#!/usr/bin/env python3
"""
Comprehensive Vulnerability Testing Framework
Performs thorough testing with validation and verification
"""

import ast
import re
import json
import subprocess
from typing import Dict, List, Optional, Tuple
from pathlib import Path
from dataclasses import dataclass, asdict
from enum import Enum
import logging
from datetime import datetime

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class Severity(Enum):
    """Vulnerability severity levels (CVSS-based)"""
    CRITICAL = "Critical"  # CVSS 9.0-10.0
    HIGH = "High"         # CVSS 7.0-8.9
    MEDIUM = "Medium"     # CVSS 4.0-6.9
    LOW = "Low"          # CVSS 0.1-3.9
    INFO = "Informational"


class VulnerabilityType(Enum):
    """Standard vulnerability classifications"""
    SQL_INJECTION = "SQL Injection"
    XSS = "Cross-Site Scripting (XSS)"
    CSRF = "Cross-Site Request Forgery (CSRF)"
    COMMAND_INJECTION = "Command Injection"
    PATH_TRAVERSAL = "Path Traversal"
    BUFFER_OVERFLOW = "Buffer Overflow"
    AUTH_BYPASS = "Authentication Bypass"
    IDOR = "Insecure Direct Object Reference (IDOR)"
    XXE = "XML External Entity (XXE)"
    SSRF = "Server-Side Request Forgery (SSRF)"
    RCE = "Remote Code Execution (RCE)"
    INFO_DISCLOSURE = "Information Disclosure"
    CRYPTO_WEAKNESS = "Cryptographic Weakness"
    INSECURE_DESERIALIZATION = "Insecure Deserialization"
    RACE_CONDITION = "Race Condition"


@dataclass
class VulnerabilityEvidence:
    """Evidence supporting a vulnerability finding"""
    description: str
    code_snippet: str
    line_numbers: List[int]
    file_path: str
    proof_of_concept: Optional[str] = None
    verification_steps: Optional[List[str]] = None
    additional_context: Optional[Dict] = None


@dataclass
class VulnerabilityFinding:
    """Complete vulnerability finding with all details"""
    id: str
    title: str
    type: VulnerabilityType
    severity: Severity
    cvss_score: float
    cwe_id: str
    description: str
    impact: str
    affected_component: str
    evidence: VulnerabilityEvidence
    remediation: str
    references: List[str]
    discovered_date: str
    verified: bool = False
    false_positive: bool = False
    verification_notes: Optional[str] = None


class ComprehensiveVulnerabilityTester:
    """
    Comprehensive testing framework for vulnerability detection
    """

    def __init__(self, project_path: str):
        self.project_path = Path(project_path)
        self.findings: List[VulnerabilityFinding] = []
        self.test_results = []

    def scan_sql_injection(self, file_path: Path) -> List[VulnerabilityFinding]:
        """
        Comprehensive SQL injection testing
        """
        findings = []

        try:
            content = file_path.read_text(errors='ignore')
            lines = content.split('\n')

            # Pattern detection
            vulnerable_patterns = [
                (r'execute\s*\([^)]*["\'].*?["\'][\s]*[\+\%]',
                 "String concatenation in SQL execute()"),
                (r'cursor\.execute\s*\([^)]*[\+\%]',
                 "String formatting in cursor.execute()"),
                (r'query\s*=\s*["\']SELECT.*?["\'][\s]*[\+\%]',
                 "SQL query with string concatenation"),
                (r'db\.query\s*\([^)]*f["\']',
                 "F-string in database query"),
                (r'\.raw\s*\([^)]*[\+\%]',
                 "String concatenation in raw SQL"),
            ]

            for line_num, line in enumerate(lines, 1):
                for pattern, description in vulnerable_patterns:
                    if re.search(pattern, line, re.IGNORECASE):
                        # Check if parameterized query is used
                        if self._is_parameterized_query(line):
                            continue

                        # Extract context
                        context_start = max(0, line_num - 3)
                        context_end = min(len(lines), line_num + 2)
                        code_snippet = '\n'.join(lines[context_start:context_end])

                        evidence = VulnerabilityEvidence(
                            description=description,
                            code_snippet=code_snippet,
                            line_numbers=[line_num],
                            file_path=str(file_path.relative_to(self.project_path)),
                            verification_steps=[
                                "1. Identify user input that flows into the SQL query",
                                "2. Attempt SQL injection payload: ' OR '1'='1",
                                "3. Verify if query logic is altered",
                                "4. Test with sqlmap for automated exploitation"
                            ]
                        )

                        finding = VulnerabilityFinding(
                            id=f"SQLi-{len(findings)+1:03d}",
                            title=f"SQL Injection in {file_path.name}",
                            type=VulnerabilityType.SQL_INJECTION,
                            severity=Severity.CRITICAL,
                            cvss_score=9.8,
                            cwe_id="CWE-89",
                            description=f"SQL injection vulnerability detected due to {description.lower()}",
                            impact="Attacker can execute arbitrary SQL queries, leading to data breach, data manipulation, or complete database compromise.",
                            affected_component=str(file_path.relative_to(self.project_path)),
                            evidence=evidence,
                            remediation="Use parameterized queries (prepared statements) instead of string concatenation. Example: cursor.execute('SELECT * FROM users WHERE id = ?', [user_id])",
                            references=[
                                "https://owasp.org/www-community/attacks/SQL_Injection",
                                "https://cwe.mitre.org/data/definitions/89.html"
                            ],
                            discovered_date=datetime.now().isoformat()
                        )

                        findings.append(finding)

        except Exception as e:
            logger.error(f"Error scanning {file_path}: {e}")

        return findings

    def scan_xss(self, file_path: Path) -> List[VulnerabilityFinding]:
        """
        Comprehensive XSS testing
        """
        findings = []

        try:
            content = file_path.read_text(errors='ignore')
            lines = content.split('\n')

            vulnerable_patterns = [
                (r'innerHTML\s*=\s*(?!.*DOMPurify)',
                 "innerHTML assignment without sanitization"),
                (r'document\.write\s*\([^)]*\)',
                 "document.write() with user data"),
                (r'eval\s*\([^)]*\)',
                 "eval() with potentially user-controlled data"),
                (r'v-html\s*=\s*["\'][^"\']*\{\{',
                 "Vue v-html with variable binding"),
                (r'dangerouslySetInnerHTML',
                 "React dangerouslySetInnerHTML"),
            ]

            for line_num, line in enumerate(lines, 1):
                for pattern, description in vulnerable_patterns:
                    if re.search(pattern, line, re.IGNORECASE):
                        # Check for sanitization
                        if self._has_sanitization(line):
                            continue

                        context_start = max(0, line_num - 3)
                        context_end = min(len(lines), line_num + 2)
                        code_snippet = '\n'.join(lines[context_start:context_end])

                        evidence = VulnerabilityEvidence(
                            description=description,
                            code_snippet=code_snippet,
                            line_numbers=[line_num],
                            file_path=str(file_path.relative_to(self.project_path)),
                            proof_of_concept="<script>alert('XSS')</script>",
                            verification_steps=[
                                "1. Inject XSS payload: <script>alert('XSS')</script>",
                                "2. Verify if JavaScript executes in browser",
                                "3. Test with various encoding: %3Cscript%3E",
                                "4. Check for CSP bypass possibilities"
                            ]
                        )

                        finding = VulnerabilityFinding(
                            id=f"XSS-{len(findings)+1:03d}",
                            title=f"Cross-Site Scripting in {file_path.name}",
                            type=VulnerabilityType.XSS,
                            severity=Severity.HIGH,
                            cvss_score=7.1,
                            cwe_id="CWE-79",
                            description=f"XSS vulnerability detected: {description}",
                            impact="Attacker can execute arbitrary JavaScript in victim's browser, steal cookies, session tokens, or perform actions on behalf of the user.",
                            affected_component=str(file_path.relative_to(self.project_path)),
                            evidence=evidence,
                            remediation="Sanitize user input before rendering. Use textContent instead of innerHTML, or use a sanitization library like DOMPurify.",
                            references=[
                                "https://owasp.org/www-community/attacks/xss/",
                                "https://cwe.mitre.org/data/definitions/79.html"
                            ],
                            discovered_date=datetime.now().isoformat()
                        )

                        findings.append(finding)

        except Exception as e:
            logger.error(f"Error scanning {file_path}: {e}")

        return findings

    def scan_command_injection(self, file_path: Path) -> List[VulnerabilityFinding]:
        """
        Comprehensive command injection testing
        """
        findings = []

        try:
            content = file_path.read_text(errors='ignore')
            lines = content.split('\n')

            vulnerable_patterns = [
                (r'os\.system\s*\([^)]*[\+\%]',
                 "os.system() with string concatenation"),
                (r'subprocess\.(?:call|run|Popen)\s*\([^)]*shell\s*=\s*True',
                 "subprocess with shell=True"),
                (r'exec\s*\([^)]*\)',
                 "exec() with user input"),
                (r'eval\s*\([^)]*\)',
                 "eval() with user input"),
                (r'system\s*\([^)]*\)',
                 "C system() call"),
            ]

            for line_num, line in enumerate(lines, 1):
                for pattern, description in vulnerable_patterns:
                    if re.search(pattern, line, re.IGNORECASE):
                        context_start = max(0, line_num - 3)
                        context_end = min(len(lines), line_num + 2)
                        code_snippet = '\n'.join(lines[context_start:context_end])

                        evidence = VulnerabilityEvidence(
                            description=description,
                            code_snippet=code_snippet,
                            line_numbers=[line_num],
                            file_path=str(file_path.relative_to(self.project_path)),
                            proof_of_concept="; cat /etc/passwd",
                            verification_steps=[
                                "1. Inject command separator: ; whoami",
                                "2. Test with command substitution: $(whoami)",
                                "3. Verify command execution in application logs",
                                "4. Test with reverse shell payload"
                            ]
                        )

                        finding = VulnerabilityFinding(
                            id=f"CMDi-{len(findings)+1:03d}",
                            title=f"Command Injection in {file_path.name}",
                            type=VulnerabilityType.COMMAND_INJECTION,
                            severity=Severity.CRITICAL,
                            cvss_score=9.8,
                            cwe_id="CWE-78",
                            description=f"Command injection vulnerability: {description}",
                            impact="Attacker can execute arbitrary system commands, potentially leading to full system compromise, data exfiltration, or denial of service.",
                            affected_component=str(file_path.relative_to(self.project_path)),
                            evidence=evidence,
                            remediation="Use subprocess with shell=False and pass arguments as a list. Avoid os.system() entirely. Validate and sanitize all user input.",
                            references=[
                                "https://owasp.org/www-community/attacks/Command_Injection",
                                "https://cwe.mitre.org/data/definitions/78.html"
                            ],
                            discovered_date=datetime.now().isoformat()
                        )

                        findings.append(finding)

        except Exception as e:
            logger.error(f"Error scanning {file_path}: {e}")

        return findings

    def scan_path_traversal(self, file_path: Path) -> List[VulnerabilityFinding]:
        """
        Comprehensive path traversal testing
        """
        findings = []

        try:
            content = file_path.read_text(errors='ignore')
            lines = content.split('\n')

            vulnerable_patterns = [
                (r'open\s*\([^)]*[\+]',
                 "File open with path concatenation"),
                (r'readFile\s*\([^)]*[\+]',
                 "readFile with path concatenation"),
                (r'File\.read\s*\([^)]*params',
                 "File.read with user parameters"),
            ]

            for line_num, line in enumerate(lines, 1):
                for pattern, description in vulnerable_patterns:
                    if re.search(pattern, line, re.IGNORECASE):
                        # Check for path validation
                        if self._has_path_validation(line):
                            continue

                        context_start = max(0, line_num - 3)
                        context_end = min(len(lines), line_num + 2)
                        code_snippet = '\n'.join(lines[context_start:context_end])

                        evidence = VulnerabilityEvidence(
                            description=description,
                            code_snippet=code_snippet,
                            line_numbers=[line_num],
                            file_path=str(file_path.relative_to(self.project_path)),
                            proof_of_concept="../../etc/passwd",
                            verification_steps=[
                                "1. Test with path traversal: ../../etc/passwd",
                                "2. Try URL encoding: %2e%2e%2f",
                                "3. Test double encoding: ..%252f",
                                "4. Verify file access in different OS contexts"
                            ]
                        )

                        finding = VulnerabilityFinding(
                            id=f"PT-{len(findings)+1:03d}",
                            title=f"Path Traversal in {file_path.name}",
                            type=VulnerabilityType.PATH_TRAVERSAL,
                            severity=Severity.HIGH,
                            cvss_score=7.5,
                            cwe_id="CWE-22",
                            description=f"Path traversal vulnerability: {description}",
                            impact="Attacker can read arbitrary files on the server, potentially accessing sensitive configuration files, credentials, or source code.",
                            affected_component=str(file_path.relative_to(self.project_path)),
                            evidence=evidence,
                            remediation="Use os.path.basename() to extract filename, validate against whitelist, or use safe_join(). Never trust user input for file paths.",
                            references=[
                                "https://owasp.org/www-community/attacks/Path_Traversal",
                                "https://cwe.mitre.org/data/definitions/22.html"
                            ],
                            discovered_date=datetime.now().isoformat()
                        )

                        findings.append(finding)

        except Exception as e:
            logger.error(f"Error scanning {file_path}: {e}")

        return findings

    def _is_parameterized_query(self, line: str) -> bool:
        """Check if query uses parameterized statements"""
        safe_indicators = ['?', 'prepare', 'bind_param', '%s', '$1', '$2', ':param']
        return any(indicator in line for indicator in safe_indicators)

    def _has_sanitization(self, line: str) -> bool:
        """Check if output has sanitization"""
        sanitizers = ['sanitize', 'escape', 'DOMPurify', 'textContent', 'encodeURIComponent']
        return any(sanitizer in line for sanitizer in sanitizers)

    def _has_path_validation(self, line: str) -> bool:
        """Check if path has validation"""
        validators = ['basename', 'safe_join', 'realpath', 'normpath', 'abspath']
        return any(validator in line for validator in validators)

    def comprehensive_scan(self, file_extensions: List[str] = None) -> List[VulnerabilityFinding]:
        """
        Run comprehensive vulnerability scan

        Args:
            file_extensions: List of file extensions to scan (e.g., ['.py', '.js'])

        Returns:
            List of all vulnerability findings
        """
        if file_extensions is None:
            file_extensions = ['.py', '.js', '.ts', '.java', '.php', '.rb', '.go']

        logger.info(f"Starting comprehensive scan of {self.project_path}")
        logger.info(f"Scanning file types: {file_extensions}")

        all_findings = []

        # Scan all files
        for ext in file_extensions:
            files = list(self.project_path.rglob(f'*{ext}'))
            logger.info(f"Found {len(files)} {ext} files")

            for file_path in files:
                # Skip certain directories
                if any(skip in str(file_path) for skip in ['node_modules', 'venv', '.git', 'test', '__pycache__']):
                    continue

                # Run all scanners
                all_findings.extend(self.scan_sql_injection(file_path))
                all_findings.extend(self.scan_xss(file_path))
                all_findings.extend(self.scan_command_injection(file_path))
                all_findings.extend(self.scan_path_traversal(file_path))

        self.findings = all_findings

        logger.info(f"\nScan complete: Found {len(all_findings)} potential vulnerabilities")
        logger.info(self._get_summary())

        return all_findings

    def _get_summary(self) -> str:
        """Get summary of findings by severity"""
        summary = "\nFindings by Severity:\n"
        for severity in Severity:
            count = sum(1 for f in self.findings if f.severity == severity)
            if count > 0:
                summary += f"  {severity.value}: {count}\n"

        summary += "\nFindings by Type:\n"
        for vuln_type in VulnerabilityType:
            count = sum(1 for f in self.findings if f.type == vuln_type)
            if count > 0:
                summary += f"  {vuln_type.value}: {count}\n"

        return summary

    def export_json(self, output_file: str):
        """Export findings to JSON"""
        findings_dict = [
            {
                **asdict(f),
                'type': f.type.value,
                'severity': f.severity.value
            }
            for f in self.findings
        ]

        with open(output_file, 'w') as f:
            json.dump(findings_dict, f, indent=2)

        logger.info(f"Findings exported to {output_file}")


if __name__ == "__main__":
    # Example usage
    logger.info("Comprehensive Vulnerability Testing Framework\n")

    # Test on current project
    tester = ComprehensiveVulnerabilityTester(".")
    findings = tester.comprehensive_scan(file_extensions=['.py'])

    if findings:
        logger.info(f"\n{'='*80}")
        logger.info(f"VULNERABILITY FINDINGS")
        logger.info(f"{'='*80}\n")

        for finding in findings[:5]:  # Show first 5
            logger.info(f"ID: {finding.id}")
            logger.info(f"Title: {finding.title}")
            logger.info(f"Severity: {finding.severity.value} (CVSS: {finding.cvss_score})")
            logger.info(f"Type: {finding.type.value}")
            logger.info(f"File: {finding.affected_component}")
            logger.info(f"Description: {finding.description}")
            logger.info(f"{'─'*80}\n")

        # Export results
        tester.export_json("vulnerability_findings.json")
    else:
        logger.info("\n✓ No vulnerabilities found")
