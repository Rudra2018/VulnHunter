#!/usr/bin/env python3
"""
🔍 VulnHunter Vulnerability Validation Framework
=============================================
Phase 1 Critical Fix: Implement validation framework to prevent fabrication
Following 1.txt Section 6.1.4 - Eval Framework

Key validations:
1. Mathematical result validation (no impossible values)
2. Code pattern verification (claimed vulnerabilities exist)
3. Security context analysis (intended vs vulnerable behavior)
4. Compilation testing (PoCs actually work)
5. Ground truth cross-validation

Addresses root causes identified in 1.txt Section 4.
"""

import os
import sys
import subprocess
import tempfile
import json
import re
from typing import Dict, List, Any, Tuple, Optional, Union
from dataclasses import dataclass
from enum import Enum
import ast

class ValidationResult(Enum):
    VALID = "valid"
    INVALID = "invalid"
    UNCERTAIN = "uncertain"

@dataclass
class ValidationReport:
    finding_id: str
    result: ValidationResult
    confidence: float
    validation_checks: Dict[str, bool]
    reasons: List[str]
    recommendations: List[str]

class MathematicalValidator:
    """Validates mathematical analysis results for impossible values"""

    def __init__(self):
        # Import the comprehensive mathematical validator
        from .mathematical_validation import MathematicalValidator as ComprehensiveValidator
        self.comprehensive_validator = ComprehensiveValidator()

    def validate_spectral_analysis(self, spectral_results: Dict[str, Any]) -> Tuple[bool, List[str]]:
        """Validate spectral graph analysis results"""
        issues = []

        # Use comprehensive validator for spectral gap validation
        if 'spectral_gap' in spectral_results:
            validation_result = self.comprehensive_validator.validate_spectral_gap(
                spectral_results['spectral_gap'],
                spectral_results.get('eigenvalues', [])
            )
            if not validation_result.is_valid:
                issues.append(validation_result.error_message)

        # Check spectral gap is non-negative (eigenvalue differences)
        if 'spectral_gap' in spectral_results:
            gap = spectral_results['spectral_gap']
            if gap < 0:
                issues.append(f"INVALID: Spectral gap cannot be negative: {gap}")

        # Check eigenvalues are mathematically valid
        if 'eigenvalues' in spectral_results:
            eigenvals = spectral_results['eigenvalues']
            if isinstance(eigenvals, list) and len(eigenvals) > 1:
                # For Laplacian matrices, smallest eigenvalue should be 0
                if abs(eigenvals[0]) > 1e-10:
                    issues.append(f"WARNING: Laplacian smallest eigenvalue not zero: {eigenvals[0]}")

                # Check if eigenvalues are sorted
                sorted_vals = sorted(eigenvals)
                if eigenvals != sorted_vals:
                    issues.append(f"WARNING: Eigenvalues not properly sorted")

        return len(issues) == 0, issues

    def validate_homology_analysis(self, homology_results: Dict[str, Any]) -> Tuple[bool, List[str]]:
        """Validate persistent homology results"""
        issues = []

        # Check if homology is being applied appropriately
        if 'topological_holes' in homology_results:
            holes = homology_results['topological_holes']
            if isinstance(holes, int) and holes < 0:
                issues.append(f"INVALID: Cannot have negative topological holes: {holes}")

        # Check if homology results have security meaning
        if 'security_interpretation' not in homology_results:
            issues.append("WARNING: Homology results lack security context interpretation")

        return len(issues) == 0, issues

    def validate_ricci_curvature(self, ricci_results: Dict[str, Any]) -> Tuple[bool, List[str]]:
        """Validate Ricci curvature analysis"""
        issues = []

        # Ricci curvature on graphs should be bounded
        if 'ricci_curvature' in ricci_results:
            curvature = ricci_results['ricci_curvature']
            if isinstance(curvature, (int, float)):
                if curvature < -10 or curvature > 10:
                    issues.append(f"WARNING: Ricci curvature seems extreme: {curvature}")

        # Check if applied appropriately to code graphs
        if 'graph_type' in ricci_results:
            if ricci_results['graph_type'] == 'ast':
                issues.append("WARNING: Ricci curvature may not be meaningful on AST graphs")

        return len(issues) == 0, issues

class CodePatternValidator:
    """Validates that claimed vulnerable code patterns actually exist"""

    def __init__(self, repository_path: str):
        self.repository_path = repository_path

    def validate_file_exists(self, file_path: str) -> Tuple[bool, str]:
        """Check if claimed vulnerable file exists"""
        full_path = os.path.join(self.repository_path, file_path)
        if os.path.exists(full_path):
            return True, f"File exists: {file_path}"
        else:
            return False, f"FILE NOT FOUND: {file_path}"

    def validate_code_pattern(self, file_path: str, claimed_pattern: str) -> Tuple[bool, str]:
        """Verify claimed vulnerable code pattern exists in file"""
        full_path = os.path.join(self.repository_path, file_path)

        if not os.path.exists(full_path):
            return False, "File does not exist"

        try:
            with open(full_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()

            # Check for exact pattern match
            if claimed_pattern in content:
                return True, "Pattern found in file"

            # Check for regex pattern match
            try:
                if re.search(claimed_pattern, content):
                    return True, "Pattern found via regex"
            except re.error:
                pass

            return False, f"Pattern not found in file: {claimed_pattern}"

        except Exception as e:
            return False, f"Error reading file: {e}"

    def validate_method_exists(self, file_path: str, method_name: str) -> Tuple[bool, str]:
        """Check if claimed vulnerable method actually exists"""
        full_path = os.path.join(self.repository_path, file_path)

        if not os.path.exists(full_path):
            return False, "File does not exist"

        try:
            with open(full_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()

            # Look for method declarations in various languages
            patterns = [
                rf'def\s+{method_name}\s*\(',  # Python
                rf'function\s+{method_name}\s*\(',  # JavaScript
                rf'public\s+.*\s+{method_name}\s*\(',  # Java
                rf'private\s+.*\s+{method_name}\s*\(',  # Java
                rf'protected\s+.*\s+{method_name}\s*\(',  # Java
                rf'{method_name}\s*\(',  # General
            ]

            for pattern in patterns:
                if re.search(pattern, content):
                    return True, f"Method found: {method_name}"

            return False, f"Method not found: {method_name}"

        except Exception as e:
            return False, f"Error reading file: {e}"

class SecurityContextAnalyzer:
    """Analyzes whether detected patterns are actually security issues"""

    def __init__(self):
        # Known safe patterns that aren't vulnerabilities
        self.safe_patterns = [
            'test', 'example', 'demo', 'mock', 'stub',
            'deprecated', 'legacy', 'backward_compatibility'
        ]

        # Indicators of intended behavior vs vulnerabilities
        self.intended_behavior_indicators = [
            'default', 'fallback', 'compatibility', 'legacy_support',
            'backwards_compatible', 'opt_in', 'explicit_enable'
        ]

    def analyze_security_impact(self, finding: Dict[str, Any]) -> Tuple[bool, str, List[str]]:
        """Determine if finding represents actual security vulnerability"""
        file_path = finding.get('file_path', '')
        description = finding.get('description', '')
        code_context = finding.get('code_context', '')

        is_vulnerable = True
        confidence_reason = "Potential security issue"
        flags = []

        # Check if this is test/example code
        if any(safe_word in file_path.lower() for safe_word in self.safe_patterns):
            is_vulnerable = False
            confidence_reason = "Test/example code - not production vulnerability"
            flags.append("test_code")

        # Check for intended behavior patterns
        if any(indicator in description.lower() for indicator in self.intended_behavior_indicators):
            is_vulnerable = False
            confidence_reason = "Appears to be intended behavior, not vulnerability"
            flags.append("intended_behavior")

        # Check for explicit configuration requirements
        if 'requires explicit configuration' in description.lower():
            is_vulnerable = False
            confidence_reason = "Requires explicit opt-in configuration"
            flags.append("explicit_configuration")

        # Check for documented behavior
        if 'documented' in description.lower() or 'specified' in description.lower():
            is_vulnerable = False
            confidence_reason = "Documented/specified behavior"
            flags.append("documented_behavior")

        return is_vulnerable, confidence_reason, flags

    def check_deep_linking_context(self, finding: Dict[str, Any]) -> Tuple[bool, str]:
        """Specific validation for deep linking 'vulnerabilities'"""
        description = finding.get('description', '')
        file_path = finding.get('file_path', '')

        # Deep linking requires explicit manifest configuration
        if 'deep' in description.lower() and 'link' in description.lower():
            if 'androidmanifest.xml' not in file_path.lower():
                return False, "Deep linking requires explicit AndroidManifest.xml configuration - not automatic vulnerability"

        # Check for Flutter deep linking context
        if 'flutter' in description.lower() and 'shouldHandleDeeplinking' in description:
            return False, "Flutter deep linking is opt-in behavior by design, not security vulnerability"

        return True, "Potential security issue"

class PoCValidator:
    """Validates proof-of-concept exploits actually work"""

    def __init__(self):
        self.temp_dir = tempfile.mkdtemp()

    def validate_java_compilation(self, poc_code: str) -> Tuple[bool, str]:
        """Test if Java PoC compiles"""
        try:
            java_file = os.path.join(self.temp_dir, "PoC.java")
            with open(java_file, 'w') as f:
                f.write(poc_code)

            result = subprocess.run(
                ['javac', java_file],
                capture_output=True,
                text=True,
                timeout=30
            )

            if result.returncode == 0:
                return True, "Java PoC compiles successfully"
            else:
                return False, f"Java compilation failed: {result.stderr}"

        except subprocess.TimeoutExpired:
            return False, "Java compilation timed out"
        except FileNotFoundError:
            return False, "Java compiler not available"
        except Exception as e:
            return False, f"Java compilation error: {e}"

    def validate_python_syntax(self, poc_code: str) -> Tuple[bool, str]:
        """Test if Python PoC has valid syntax"""
        try:
            ast.parse(poc_code)
            return True, "Python PoC has valid syntax"
        except SyntaxError as e:
            return False, f"Python syntax error: {e}"
        except Exception as e:
            return False, f"Python validation error: {e}"

    def validate_poc_realism(self, poc_code: str) -> Tuple[bool, str]:
        """Check if PoC uses realistic APIs and patterns"""
        # Check for common fabricated patterns
        fabricated_patterns = [
            'setMetaData(',  # Android - this method doesn't exist
            'flutter://malicious',  # Invalid URI scheme
            'HANDLE_DEEPLINKING_META_DATA_KEY',  # Check if constant exists
        ]

        for pattern in fabricated_patterns:
            if pattern in poc_code:
                return False, f"PoC uses non-existent API: {pattern}"

        return True, "PoC appears to use realistic APIs"

class VulnerabilityValidationFramework:
    """Main validation framework coordinating all validators"""

    def __init__(self, repository_path: str):
        self.repository_path = repository_path
        self.math_validator = MathematicalValidator()
        self.code_validator = CodePatternValidator(repository_path)
        self.security_analyzer = SecurityContextAnalyzer()
        self.poc_validator = PoCValidator()

    def validate_finding(self, finding: Dict[str, Any]) -> ValidationReport:
        """Comprehensive validation of a security finding"""
        finding_id = finding.get('id', 'unknown')
        validation_checks = {}
        issues = []
        recommendations = []

        # 1. Mathematical Validation
        if 'mathematical_proofs' in finding:
            math_proofs = finding['mathematical_proofs']

            # Validate spectral analysis
            if 'spectral_analysis' in math_proofs:
                valid, math_issues = self.math_validator.validate_spectral_analysis(
                    math_proofs['spectral_analysis']
                )
                validation_checks['spectral_math'] = valid
                issues.extend(math_issues)

            # Validate homology analysis
            if 'homology_analysis' in math_proofs:
                valid, math_issues = self.math_validator.validate_homology_analysis(
                    math_proofs['homology_analysis']
                )
                validation_checks['homology_math'] = valid
                issues.extend(math_issues)

            # Validate Ricci curvature
            if 'ricci_analysis' in math_proofs:
                valid, math_issues = self.math_validator.validate_ricci_curvature(
                    math_proofs['ricci_analysis']
                )
                validation_checks['ricci_math'] = valid
                issues.extend(math_issues)

        # 2. Code Pattern Validation
        file_path = finding.get('file_path')
        if file_path:
            # Check file exists
            exists, msg = self.code_validator.validate_file_exists(file_path)
            validation_checks['file_exists'] = exists
            if not exists:
                issues.append(msg)

            # Check claimed vulnerable pattern exists
            if 'vulnerable_pattern' in finding:
                pattern_exists, msg = self.code_validator.validate_code_pattern(
                    file_path, finding['vulnerable_pattern']
                )
                validation_checks['pattern_exists'] = pattern_exists
                if not pattern_exists:
                    issues.append(msg)

            # Check claimed method exists
            if 'method_name' in finding:
                method_exists, msg = self.code_validator.validate_method_exists(
                    file_path, finding['method_name']
                )
                validation_checks['method_exists'] = method_exists
                if not method_exists:
                    issues.append(msg)

        # 3. Security Context Analysis
        is_security_issue, security_reason, security_flags = self.security_analyzer.analyze_security_impact(finding)
        validation_checks['is_security_issue'] = is_security_issue
        if not is_security_issue:
            issues.append(f"NOT A VULNERABILITY: {security_reason}")

        # Deep linking specific validation
        if 'deep' in str(finding).lower() and 'link' in str(finding).lower():
            is_vuln, reason = self.security_analyzer.check_deep_linking_context(finding)
            validation_checks['deep_linking_valid'] = is_vuln
            if not is_vuln:
                issues.append(f"DEEP LINKING: {reason}")

        # 4. PoC Validation
        if 'proof_of_concept' in finding:
            poc_code = finding['proof_of_concept']

            # Test compilation
            if 'java' in file_path.lower() if file_path else False:
                compiles, msg = self.poc_validator.validate_java_compilation(poc_code)
                validation_checks['poc_compiles'] = compiles
                if not compiles:
                    issues.append(f"POC COMPILATION: {msg}")

            # Test API realism
            realistic, msg = self.poc_validator.validate_poc_realism(poc_code)
            validation_checks['poc_realistic'] = realistic
            if not realistic:
                issues.append(f"POC REALISM: {msg}")

        # 5. Overall Assessment
        critical_checks = ['file_exists', 'is_security_issue']
        critical_failed = any(not validation_checks.get(check, False) for check in critical_checks)

        math_checks = ['spectral_math', 'homology_math', 'ricci_math']
        math_failed = any(not validation_checks.get(check, True) for check in math_checks)

        if critical_failed:
            result = ValidationResult.INVALID
            confidence = 0.1
            recommendations.append("DO NOT SUBMIT - Critical validation failures")
        elif math_failed:
            result = ValidationResult.INVALID
            confidence = 0.2
            recommendations.append("FIX MATHEMATICAL ANALYSIS - Invalid mathematical results")
        elif len(issues) > 3:
            result = ValidationResult.UNCERTAIN
            confidence = 0.4
            recommendations.append("MANUAL REVIEW REQUIRED - Multiple validation concerns")
        else:
            result = ValidationResult.VALID
            confidence = 0.8
            recommendations.append("Finding appears valid for submission")

        return ValidationReport(
            finding_id=finding_id,
            result=result,
            confidence=confidence,
            validation_checks=validation_checks,
            reasons=issues,
            recommendations=recommendations
        )

    def validate_flutter_finding(self, finding: Dict[str, Any]) -> ValidationReport:
        """Specialized validation for Flutter findings"""
        # Add Flutter-specific validation logic
        report = self.validate_finding(finding)

        # Additional Flutter checks
        if 'flutter' in str(finding).lower():
            # Check if this involves actual Flutter security mechanisms
            description = finding.get('description', '')
            if 'shouldHandleDeeplinking' in description:
                # This is documented Flutter behavior, not vulnerability
                report.result = ValidationResult.INVALID
                report.confidence = 0.1
                report.reasons.append("FLUTTER: shouldHandleDeeplinking is documented behavior")
                report.recommendations = ["DO NOT SUBMIT - This is intended Flutter behavior"]

        return report

# Example usage and testing
if __name__ == "__main__":
    # Test the validation framework
    repo_path = "/Users/ankitthakur/VulnHunter/bug_bounty_analysis/flutter"

    # Create test finding based on our Flutter analysis
    test_finding = {
        'id': 'flutter-001',
        'file_path': 'engine/src/flutter/shell/platform/android/test/io/flutter/embedding/android/FlutterActivityTest.java',
        'description': 'Flutter shouldHandleDeeplinking returns true by default',
        'vulnerable_pattern': 'shouldHandleDeeplinking',
        'mathematical_proofs': {
            'spectral_analysis': {
                'spectral_gap': 0.5,  # Valid positive value
                'eigenvalues': [0.0, 0.5, 1.2, 2.1]
            }
        },
        'proof_of_concept': '''
        FlutterActivity activity = new FlutterActivity();
        activity.setMetaData(emptyBundle);  // This method doesn't exist
        '''
    }

    validator = VulnerabilityValidationFramework(repo_path)
    report = validator.validate_flutter_finding(test_finding)

    print(f"Validation Result: {report.result}")
    print(f"Confidence: {report.confidence}")
    print("Issues found:")
    for reason in report.reasons:
        print(f"  - {reason}")
    print("Recommendations:")
    for rec in report.recommendations:
        print(f"  - {rec}")