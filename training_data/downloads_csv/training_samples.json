[
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 298",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xa24787320ede4cc19d800bf87b41ab9539c4da9d",
    "activity_level": "MEDIUM",
    "contract_type": "standard_contract",
    "tx_count": 879535,
    "risk_score": 0.4,
    "title": "Flash Loan Reentrancy - MEDIUM",
    "description": "Vulnerability pattern inspired by MEDIUM activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 4966891,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x8fdcc30eda7e94f1c12ce0280df6cd531e8365c5",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 2229775,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x21ab6c9fac80c59d401b37cb43f81ea9dde7fe34",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1332382,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x1a2a1c938ce3ec39b6d47113c7955baa9dd454f2",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 3088378,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 220",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 157",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xc011a73ee8576fb46f5e1c5751ca3b9fe0af2a6f",
    "activity_level": "MEDIUM",
    "contract_type": "standard_contract",
    "tx_count": 974769,
    "risk_score": 0.4,
    "title": "Flash Loan Reentrancy - MEDIUM",
    "description": "Vulnerability pattern inspired by MEDIUM activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 264",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 13",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x06012c8cf97bead5deae237070f9587f8e7a266d",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 4901882,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 97",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 10",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x61935cbdd02287b511119ddb11aeb42f1593b7ef",
    "activity_level": "MEDIUM",
    "contract_type": "standard_contract",
    "tx_count": 890966,
    "risk_score": 0.4,
    "title": "Flash Loan Reentrancy - MEDIUM",
    "description": "Vulnerability pattern inspired by MEDIUM activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n                contract DAOGovernance {\n                    mapping(address => uint256) public votingPower;\n                    mapping(uint256 => Proposal) public proposals;\n                    uint256 public proposalCount;\n\n                    struct Proposal {\n                        string description;\n                        uint256 forVotes;\n                        uint256 againstVotes;\n                        bool executed;\n                        uint256 deadline;\n                    }\n\n                    function propose(string memory description) external returns (uint256) {\n                        // VULNERABLE: No minimum voting power required\n                        uint256 proposalId = proposalCount++;\n                        proposals[proposalId] = Proposal({\n                            description: description,\n                            forVotes: 0,\n                            againstVotes: 0,\n                            executed: false,\n                            deadline: block.timestamp + 7 days\n                        });\n                        return proposalId;\n                    }\n\n                    function vote(uint256 proposalId, bool support) external {\n                        Proposal storage proposal = proposals[proposalId];\n                        require(block.timestamp <= proposal.deadline, \"Voting ended\");\n\n                        // VULNERABLE: No double-voting protection\n                        uint256 power = votingPower[msg.sender];\n                        if (support) {\n                            proposal.forVotes += power;\n                        } else {\n                            proposal.againstVotes += power;\n                        }\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "governance_attack",
    "severity": "High",
    "confidence": 0.88,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
    "activity_level": "VERY_HIGH",
    "contract_type": "defi_protocol_or_dex",
    "tx_count": 20226838,
    "risk_score": 0.8,
    "title": "Governance Attack - VERY_HIGH",
    "description": "Vulnerability pattern inspired by VERY_HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.7750000000000001,
    "lines_of_code": 40,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0
    ],
    "exploit_difficulty": "medium"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x9554efa1669014c25070bc23c2df262825704228",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1021428,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 83",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DAOGovernance {\n                    mapping(address => uint256) public votingPower;\n                    mapping(uint256 => Proposal) public proposals;\n                    uint256 public proposalCount;\n\n                    struct Proposal {\n                        string description;\n                        uint256 forVotes;\n                        uint256 againstVotes;\n                        bool executed;\n                        uint256 deadline;\n                    }\n\n                    function propose(string memory description) external returns (uint256) {\n                        // VULNERABLE: No minimum voting power required\n                        uint256 proposalId = proposalCount++;\n                        proposals[proposalId] = Proposal({\n                            description: description,\n                            forVotes: 0,\n                            againstVotes: 0,\n                            executed: false,\n                            deadline: block.timestamp + 7 days\n                        });\n                        return proposalId;\n                    }\n\n                    function vote(uint256 proposalId, bool support) external {\n                        Proposal storage proposal = proposals[proposalId];\n                        require(block.timestamp <= proposal.deadline, \"Voting ended\");\n\n                        // VULNERABLE: No double-voting protection\n                        uint256 power = votingPower[msg.sender];\n                        if (support) {\n                            proposal.forVotes += power;\n                        } else {\n                            proposal.againstVotes += power;\n                        }\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "governance_attack",
    "severity": "High",
    "confidence": 0.88,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x000000000000006f6502b7f2bbac8c30a3f67e9a",
    "activity_level": "VERY_HIGH",
    "contract_type": "popular_token_or_dapp",
    "tx_count": 17250288,
    "risk_score": 0.8,
    "title": "Governance Attack - VERY_HIGH",
    "description": "Vulnerability pattern inspired by VERY_HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.7750000000000001,
    "lines_of_code": 40,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0
    ],
    "exploit_difficulty": "medium"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x00000000003b3cc22af3ae1eac0440bcee416b40",
    "activity_level": "HIGH",
    "contract_type": "popular_token_or_dapp",
    "tx_count": 5014526,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 129",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xfbddadd80fe7bda00b901fbaf73803f2238ae655",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1435628,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
    "activity_level": "HIGH",
    "contract_type": "popular_token_or_dapp",
    "tx_count": 6855477,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 41",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n        contract CrossChainToken {\n            mapping(uint256 => mapping(address => uint256)) public balances; // chainId => user => balance\n            mapping(uint256 => bool) public supportedChains;\n\n            function bridgeTokens(uint256 toChainId, uint256 amount) external {\n                require(supportedChains[toChainId], \"Chain not supported\");\n                require(balances[getCurrentChainId()][msg.sender] >= amount, \"Insufficient balance\");\n\n                // VULNERABLE: No proper chain validation\n                balances[getCurrentChainId()][msg.sender] -= amount;\n\n                // VULNERABLE: Trust external bridge without validation\n                IBridge(getBridgeAddress()).transferToChain(\n                    toChainId,\n                    msg.sender,\n                    amount\n                );\n            }\n\n            function mintFromBridge(address user, uint256 amount, uint256 fromChainId) external {\n                // VULNERABLE: No bridge authentication\n                balances[getCurrentChainId()][user] += amount;\n            }\n        }",
    "vulnerability_label": 1,
    "vulnerability_type": "bridge_vulnerability",
    "severity": "High",
    "confidence": 0.85,
    "source": "downloads_csv_multichain",
    "inspired_by_project": "1inch",
    "project_symbol": "1inch",
    "supported_chains": [
      "ethereum",
      "polygon",
      "bsc",
      "avalanche"
    ],
    "chain_count": 4,
    "title": "Multi-chain Bridge Vulnerability - 1inch",
    "description": "Bridge vulnerability inspired by 1inch multi-chain presence",
    "real_world_inspiration": true,
    "complexity_score": 0.7,
    "lines_of_code": 25,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 172",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 160",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 156",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 282",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 57",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 222",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 39",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xa15c7ebe1f07caf6bff097d8a589fb8ac49ae5b3",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1469997,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xbcf935d206ca32929e1b887a07ed240f0d8ccd22",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1193096,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 136",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x62b9f8741bf53a6986a5411c0557c30f6f11f3af",
    "activity_level": "MEDIUM",
    "contract_type": "standard_contract",
    "tx_count": 932475,
    "risk_score": 0.4,
    "title": "Dex Price Manipulation - MEDIUM",
    "description": "Vulnerability pattern inspired by MEDIUM activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x744d70fdbe2ba4cf95131626614a1763df805b9e",
    "activity_level": "MEDIUM",
    "contract_type": "standard_contract",
    "tx_count": 999184,
    "risk_score": 0.4,
    "title": "Dex Price Manipulation - MEDIUM",
    "description": "Vulnerability pattern inspired by MEDIUM activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xfa52274dd61e1643d2205169732f29114bc240b3",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 2695924,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xfa52274dd61e1643d2205169732f29114bc240b3",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 2695924,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 54",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 258",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x0d8775f648430679a709e98d2b0cb6250d2887ef",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 2895113,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 273",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 139",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x7d1afa7b718fb893db30a3abc0cfc608aacfebb0",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 3056441,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x8d1f2ebfaccf1136db76fdd1b86f1dede2d23852",
    "activity_level": "MEDIUM",
    "contract_type": "standard_contract",
    "tx_count": 844824,
    "risk_score": 0.4,
    "title": "Dex Price Manipulation - MEDIUM",
    "description": "Vulnerability pattern inspired by MEDIUM activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x860bd2dba9cd475a61e6d1b45e16c365f6d78f66",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 2163734,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 70",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 217",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 198",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 227",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 105",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 295",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 248",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x98ad263a95f1ab1abff41f4d44b07c3240251a0a",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1354177,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 120",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xf8a4d3a0b5859a24cd1320ba014ab17f623612e2",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1623975,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 11",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 7",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x86fa049857e0209aa7d9e616f7eb3b3b78ecfdb0",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 2970426,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 138",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 82",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x9e9801bace260f58407c15e6e515c45918756e0f",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1442315,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 168",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 163",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 231",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xe94b04a0fed112f3664e45adb2b8915693dd5ff3",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1653545,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 277",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 278",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x8a91c9a16cd62693649d80afa85a09dbbdcb8508",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 2329654,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xc011a73ee8576fb46f5e1c5751ca3b9fe0af2a6f",
    "activity_level": "MEDIUM",
    "contract_type": "standard_contract",
    "tx_count": 974769,
    "risk_score": 0.4,
    "title": "Dex Price Manipulation - MEDIUM",
    "description": "Vulnerability pattern inspired by MEDIUM activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xdac17f958d2ee523a2206206994597c13d831ec7",
    "activity_level": "ULTRA_HIGH",
    "contract_type": "major_exchange_or_bridge",
    "tx_count": 128326187,
    "risk_score": 0.9,
    "title": "Flash Loan Reentrancy - ULTRA_HIGH",
    "description": "Vulnerability pattern inspired by ULTRA_HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 259",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 285",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 171",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n        contract CrossChainToken {\n            mapping(uint256 => mapping(address => uint256)) public balances; // chainId => user => balance\n            mapping(uint256 => bool) public supportedChains;\n\n            function bridgeTokens(uint256 toChainId, uint256 amount) external {\n                require(supportedChains[toChainId], \"Chain not supported\");\n                require(balances[getCurrentChainId()][msg.sender] >= amount, \"Insufficient balance\");\n\n                // VULNERABLE: No proper chain validation\n                balances[getCurrentChainId()][msg.sender] -= amount;\n\n                // VULNERABLE: Trust external bridge without validation\n                IBridge(getBridgeAddress()).transferToChain(\n                    toChainId,\n                    msg.sender,\n                    amount\n                );\n            }\n\n            function mintFromBridge(address user, uint256 amount, uint256 fromChainId) external {\n                // VULNERABLE: No bridge authentication\n                balances[getCurrentChainId()][user] += amount;\n            }\n        }",
    "vulnerability_label": 1,
    "vulnerability_type": "bridge_vulnerability",
    "severity": "High",
    "confidence": 0.85,
    "source": "downloads_csv_multichain",
    "inspired_by_project": "A4 Finance",
    "project_symbol": "a4",
    "supported_chains": [
      "ethereum",
      "polygon",
      "bsc",
      "fantom",
      "avalanche"
    ],
    "chain_count": 5,
    "title": "Multi-chain Bridge Vulnerability - A4 Finance",
    "description": "Bridge vulnerability inspired by A4 Finance multi-chain presence",
    "real_world_inspiration": true,
    "complexity_score": 0.7,
    "lines_of_code": 25,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 81",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract CrossChainBridge {\n                    mapping(address => bool) public validators;\n                    mapping(bytes32 => uint256) public confirmations;\n                    uint256 public requiredConfirmations = 3;\n\n                    function addValidator(address validator) external {\n                        // VULNERABLE: No access control\n                        validators[validator] = true;\n                    }\n\n                    function confirmTransaction(bytes32 txHash) external {\n                        require(validators[msg.sender], \"Not a validator\");\n                        confirmations[txHash]++;\n                    }\n\n                    function executeTransaction(\n                        address to,\n                        uint256 amount,\n                        bytes32 txHash\n                    ) external {\n                        // VULNERABLE: Insufficient validation\n                        require(confirmations[txHash] >= requiredConfirmations, \"Not enough confirmations\");\n\n                        // VULNERABLE: No replay protection\n                        payable(to).transfer(amount);\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "bridge_validator_bypass",
    "severity": "Critical",
    "confidence": 0.92,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x0000000000007f150bd6f54c40a34d7c3d5e9f56",
    "activity_level": "ULTRA_HIGH",
    "contract_type": "major_exchange_or_bridge",
    "tx_count": 75499550,
    "risk_score": 0.9,
    "title": "Bridge Validator Bypass - ULTRA_HIGH",
    "description": "Vulnerability pattern inspired by ULTRA_HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.7142857142857143,
    "lines_of_code": 28,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "medium"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x7f268357a8c2552623316e2562d90e642bb538e5",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 2877112,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x7be8076f4ea4a4ad08075c2508e481d6c946d12b",
    "activity_level": "VERY_HIGH",
    "contract_type": "popular_token_or_dapp",
    "tx_count": 16964552,
    "risk_score": 0.8,
    "title": "Dex Price Manipulation - VERY_HIGH",
    "description": "Vulnerability pattern inspired by VERY_HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x0b95993a39a363d99280ac950f5e4536ab5c5566",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 2513630,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 194",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 234",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 291",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 134",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x74fd51a98a4a1ecbef8cc43be801cce630e260bd",
    "activity_level": "MEDIUM",
    "contract_type": "standard_contract",
    "tx_count": 867499,
    "risk_score": 0.4,
    "title": "Flash Loan Reentrancy - MEDIUM",
    "description": "Vulnerability pattern inspired by MEDIUM activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xc00e94cb662c3520282e6f5717214004a7f26888",
    "activity_level": "MEDIUM",
    "contract_type": "standard_contract",
    "tx_count": 950594,
    "risk_score": 0.4,
    "title": "Flash Loan Reentrancy - MEDIUM",
    "description": "Vulnerability pattern inspired by MEDIUM activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n        contract CrossChainToken {\n            mapping(uint256 => mapping(address => uint256)) public balances; // chainId => user => balance\n            mapping(uint256 => bool) public supportedChains;\n\n            function bridgeTokens(uint256 toChainId, uint256 amount) external {\n                require(supportedChains[toChainId], \"Chain not supported\");\n                require(balances[getCurrentChainId()][msg.sender] >= amount, \"Insufficient balance\");\n\n                // VULNERABLE: No proper chain validation\n                balances[getCurrentChainId()][msg.sender] -= amount;\n\n                // VULNERABLE: Trust external bridge without validation\n                IBridge(getBridgeAddress()).transferToChain(\n                    toChainId,\n                    msg.sender,\n                    amount\n                );\n            }\n\n            function mintFromBridge(address user, uint256 amount, uint256 fromChainId) external {\n                // VULNERABLE: No bridge authentication\n                balances[getCurrentChainId()][user] += amount;\n            }\n        }",
    "vulnerability_label": 1,
    "vulnerability_type": "bridge_vulnerability",
    "severity": "High",
    "confidence": 0.85,
    "source": "downloads_csv_multichain",
    "inspired_by_project": "0x Protocol",
    "project_symbol": "zrx",
    "supported_chains": [
      "ethereum",
      "avalanche"
    ],
    "chain_count": 2,
    "title": "Multi-chain Bridge Vulnerability - 0x Protocol",
    "description": "Bridge vulnerability inspired by 0x Protocol multi-chain presence",
    "real_world_inspiration": true,
    "complexity_score": 0.7,
    "lines_of_code": 25,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 125",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 150",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x000000005736775feb0c8568e7dee77222a26880",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 2390322,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x6b3595068778dd592e39a122f4f5a5cf09c90fe2",
    "activity_level": "MEDIUM",
    "contract_type": "standard_contract",
    "tx_count": 841812,
    "risk_score": 0.4,
    "title": "Dex Price Manipulation - MEDIUM",
    "description": "Vulnerability pattern inspired by MEDIUM activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xa74476443119a942de498590fe1f2454d7d4ac0d",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1023342,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 297",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 235",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 113",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xb64ef51c888972c908cfacf59b47c1afbc0ab8ac",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1716339,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 202",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x0f5d2fb29fb7d3cfee444a200298f468908cc942",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1540242,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 140",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x2a0c0dbecc7e4d658f48e01e3fa353f44050c208",
    "activity_level": "HIGH",
    "contract_type": "popular_token_or_dapp",
    "tx_count": 9787480,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 127",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x2b591e99afe9f32eaa6214f7b7629768c40eeb39",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1544945,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x1f9840a85d5af5bf1d1762f925bdaddc4201f984",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1941008,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x8a91c9a16cd62693649d80afa85a09dbbdcb8508",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 2329654,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xa5409ec958c83c3f309868babaca7c86dcb077c1",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1392279,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 177",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x000000000000006f6502b7f2bbac8c30a3f67e9a",
    "activity_level": "VERY_HIGH",
    "contract_type": "popular_token_or_dapp",
    "tx_count": 17250288,
    "risk_score": 0.8,
    "title": "Flash Loan Reentrancy - VERY_HIGH",
    "description": "Vulnerability pattern inspired by VERY_HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n                contract DAOGovernance {\n                    mapping(address => uint256) public votingPower;\n                    mapping(uint256 => Proposal) public proposals;\n                    uint256 public proposalCount;\n\n                    struct Proposal {\n                        string description;\n                        uint256 forVotes;\n                        uint256 againstVotes;\n                        bool executed;\n                        uint256 deadline;\n                    }\n\n                    function propose(string memory description) external returns (uint256) {\n                        // VULNERABLE: No minimum voting power required\n                        uint256 proposalId = proposalCount++;\n                        proposals[proposalId] = Proposal({\n                            description: description,\n                            forVotes: 0,\n                            againstVotes: 0,\n                            executed: false,\n                            deadline: block.timestamp + 7 days\n                        });\n                        return proposalId;\n                    }\n\n                    function vote(uint256 proposalId, bool support) external {\n                        Proposal storage proposal = proposals[proposalId];\n                        require(block.timestamp <= proposal.deadline, \"Voting ended\");\n\n                        // VULNERABLE: No double-voting protection\n                        uint256 power = votingPower[msg.sender];\n                        if (support) {\n                            proposal.forVotes += power;\n                        } else {\n                            proposal.againstVotes += power;\n                        }\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "governance_attack",
    "severity": "High",
    "confidence": 0.88,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x7be8076f4ea4a4ad08075c2508e481d6c946d12b",
    "activity_level": "VERY_HIGH",
    "contract_type": "popular_token_or_dapp",
    "tx_count": 16964552,
    "risk_score": 0.8,
    "title": "Governance Attack - VERY_HIGH",
    "description": "Vulnerability pattern inspired by VERY_HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.7750000000000001,
    "lines_of_code": 40,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0
    ],
    "exploit_difficulty": "medium"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x0d8775f648430679a709e98d2b0cb6250d2887ef",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 2895113,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 228",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x03f7724180aa6b939894b5ca4314783b0b36b329",
    "activity_level": "MEDIUM",
    "contract_type": "standard_contract",
    "tx_count": 951074,
    "risk_score": 0.4,
    "title": "Dex Price Manipulation - MEDIUM",
    "description": "Vulnerability pattern inspired by MEDIUM activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 263",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xd1ceeeeee83f8bcf3bedad437202b6154e9f5405",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 4345167,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 180",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x209c4784ab1e8183cf58ca33cb740efbf3fc18ef",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1814557,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xae9b8e05c22bae74d1e8db82c4af122b18050bd4",
    "activity_level": "MEDIUM",
    "contract_type": "standard_contract",
    "tx_count": 876593,
    "risk_score": 0.4,
    "title": "Dex Price Manipulation - MEDIUM",
    "description": "Vulnerability pattern inspired by MEDIUM activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 181",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x00000000003b3cc22af3ae1eac0440bcee416b40",
    "activity_level": "HIGH",
    "contract_type": "popular_token_or_dapp",
    "tx_count": 5014526,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xf8a4d3a0b5859a24cd1320ba014ab17f623612e2",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1623975,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 286",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 18",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 176",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 261",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x2a0c0dbecc7e4d658f48e01e3fa353f44050c208",
    "activity_level": "HIGH",
    "contract_type": "popular_token_or_dapp",
    "tx_count": 9787480,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 110",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 119",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 281",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x8e870d67f660d95d5be530380d0ec0bd388289e1",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1796004,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 63",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 137",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 3",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x86fa049857e0209aa7d9e616f7eb3b3b78ecfdb0",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 2970426,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 71",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 237",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xa0b73e1ff0b80914ab6fe0444e65848c4c34450b",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1136539,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 109",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 232",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 225",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 197",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 266",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 161",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 244",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 87",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xd26114cd6ee289accf82350c8d8487fedb8a0c07",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 2705998,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 191",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 218",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 186",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract CrossChainBridge {\n                    mapping(address => bool) public validators;\n                    mapping(bytes32 => uint256) public confirmations;\n                    uint256 public requiredConfirmations = 3;\n\n                    function addValidator(address validator) external {\n                        // VULNERABLE: No access control\n                        validators[validator] = true;\n                    }\n\n                    function confirmTransaction(bytes32 txHash) external {\n                        require(validators[msg.sender], \"Not a validator\");\n                        confirmations[txHash]++;\n                    }\n\n                    function executeTransaction(\n                        address to,\n                        uint256 amount,\n                        bytes32 txHash\n                    ) external {\n                        // VULNERABLE: Insufficient validation\n                        require(confirmations[txHash] >= requiredConfirmations, \"Not enough confirmations\");\n\n                        // VULNERABLE: No replay protection\n                        payable(to).transfer(amount);\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "bridge_validator_bypass",
    "severity": "Critical",
    "confidence": 0.92,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x000000000000006f6502b7f2bbac8c30a3f67e9a",
    "activity_level": "VERY_HIGH",
    "contract_type": "popular_token_or_dapp",
    "tx_count": 17250288,
    "risk_score": 0.8,
    "title": "Bridge Validator Bypass - VERY_HIGH",
    "description": "Vulnerability pattern inspired by VERY_HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.7142857142857143,
    "lines_of_code": 28,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "medium"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x78a55b9b3bbeffb36a43d9905f654d2769dc55e8",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1243275,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 245",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x8e766f57f7d16ca50b4a0b90b88f6468a09b0439",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1564464,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xa0b73e1ff0b80914ab6fe0444e65848c4c34450b",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1136539,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 173",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 19",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x7a250d5630b4cf539739df2c5dacb4c659f2488d",
    "activity_level": "ULTRA_HIGH",
    "contract_type": "major_exchange_or_bridge",
    "tx_count": 53642378,
    "risk_score": 0.9,
    "title": "Flash Loan Reentrancy - ULTRA_HIGH",
    "description": "Vulnerability pattern inspired by ULTRA_HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x5f65f7b609678448494de4c87521cdf6cef1e932",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1321809,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 159",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x514910771af9ca656af840dff83e8264ecf986ca",
    "activity_level": "HIGH",
    "contract_type": "popular_token_or_dapp",
    "tx_count": 5621638,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n        contract CrossChainToken {\n            mapping(uint256 => mapping(address => uint256)) public balances; // chainId => user => balance\n            mapping(uint256 => bool) public supportedChains;\n\n            function bridgeTokens(uint256 toChainId, uint256 amount) external {\n                require(supportedChains[toChainId], \"Chain not supported\");\n                require(balances[getCurrentChainId()][msg.sender] >= amount, \"Insufficient balance\");\n\n                // VULNERABLE: No proper chain validation\n                balances[getCurrentChainId()][msg.sender] -= amount;\n\n                // VULNERABLE: Trust external bridge without validation\n                IBridge(getBridgeAddress()).transferToChain(\n                    toChainId,\n                    msg.sender,\n                    amount\n                );\n            }\n\n            function mintFromBridge(address user, uint256 amount, uint256 fromChainId) external {\n                // VULNERABLE: No bridge authentication\n                balances[getCurrentChainId()][user] += amount;\n            }\n        }",
    "vulnerability_label": 1,
    "vulnerability_type": "bridge_vulnerability",
    "severity": "High",
    "confidence": 0.85,
    "source": "downloads_csv_multichain",
    "inspired_by_project": "0xMonero",
    "project_symbol": "0xmr",
    "supported_chains": [
      "ethereum",
      "polygon",
      "bsc",
      "fantom"
    ],
    "chain_count": 4,
    "title": "Multi-chain Bridge Vulnerability - 0xMonero",
    "description": "Bridge vulnerability inspired by 0xMonero multi-chain presence",
    "real_world_inspiration": true,
    "complexity_score": 0.7,
    "lines_of_code": 25,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xa57bd00134b2850b2a1c55860c9e9ea100fdd6cf",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 2850379,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n        contract CrossChainToken {\n            mapping(uint256 => mapping(address => uint256)) public balances; // chainId => user => balance\n            mapping(uint256 => bool) public supportedChains;\n\n            function bridgeTokens(uint256 toChainId, uint256 amount) external {\n                require(supportedChains[toChainId], \"Chain not supported\");\n                require(balances[getCurrentChainId()][msg.sender] >= amount, \"Insufficient balance\");\n\n                // VULNERABLE: No proper chain validation\n                balances[getCurrentChainId()][msg.sender] -= amount;\n\n                // VULNERABLE: Trust external bridge without validation\n                IBridge(getBridgeAddress()).transferToChain(\n                    toChainId,\n                    msg.sender,\n                    amount\n                );\n            }\n\n            function mintFromBridge(address user, uint256 amount, uint256 fromChainId) external {\n                // VULNERABLE: No bridge authentication\n                balances[getCurrentChainId()][user] += amount;\n            }\n        }",
    "vulnerability_label": 1,
    "vulnerability_type": "bridge_vulnerability",
    "severity": "High",
    "confidence": 0.85,
    "source": "downloads_csv_multichain",
    "inspired_by_project": "Zus",
    "project_symbol": "zcn",
    "supported_chains": [
      "ethereum",
      "polygon"
    ],
    "chain_count": 2,
    "title": "Multi-chain Bridge Vulnerability - Zus",
    "description": "Bridge vulnerability inspired by Zus multi-chain presence",
    "real_world_inspiration": true,
    "complexity_score": 0.7,
    "lines_of_code": 25,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 114",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xf230b790e05390fc8295f4d3f60332c93bed42e2",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 2085638,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 80",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 2",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 122",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 84",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 257",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 30",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x8e766f57f7d16ca50b4a0b90b88f6468a09b0439",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1564464,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 100",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 182",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 269",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 116",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 240",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xd7cc16500d0b0ac3d0ba156a584865a43b0b0050",
    "activity_level": "MEDIUM",
    "contract_type": "standard_contract",
    "tx_count": 899748,
    "risk_score": 0.4,
    "title": "Dex Price Manipulation - MEDIUM",
    "description": "Vulnerability pattern inspired by MEDIUM activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 199",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xb1690c08e213a35ed9bab7b318de14420fb57d8c",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1186058,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x9b9647431632af44be02ddd22477ed94d14aacaa",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1667685,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 135",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 272",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 189",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x9dffe202df7f82ba57a7f8d571628805eff7fed9",
    "activity_level": "MEDIUM",
    "contract_type": "standard_contract",
    "tx_count": 871943,
    "risk_score": 0.4,
    "title": "Dex Price Manipulation - MEDIUM",
    "description": "Vulnerability pattern inspired by MEDIUM activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 162",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n        contract CrossChainToken {\n            mapping(uint256 => mapping(address => uint256)) public balances; // chainId => user => balance\n            mapping(uint256 => bool) public supportedChains;\n\n            function bridgeTokens(uint256 toChainId, uint256 amount) external {\n                require(supportedChains[toChainId], \"Chain not supported\");\n                require(balances[getCurrentChainId()][msg.sender] >= amount, \"Insufficient balance\");\n\n                // VULNERABLE: No proper chain validation\n                balances[getCurrentChainId()][msg.sender] -= amount;\n\n                // VULNERABLE: Trust external bridge without validation\n                IBridge(getBridgeAddress()).transferToChain(\n                    toChainId,\n                    msg.sender,\n                    amount\n                );\n            }\n\n            function mintFromBridge(address user, uint256 amount, uint256 fromChainId) external {\n                // VULNERABLE: No bridge authentication\n                balances[getCurrentChainId()][user] += amount;\n            }\n        }",
    "vulnerability_label": 1,
    "vulnerability_type": "bridge_vulnerability",
    "severity": "High",
    "confidence": 0.85,
    "source": "downloads_csv_multichain",
    "inspired_by_project": "99Starz",
    "project_symbol": "stz",
    "supported_chains": [
      "ethereum",
      "polygon",
      "bsc"
    ],
    "chain_count": 3,
    "title": "Multi-chain Bridge Vulnerability - 99Starz",
    "description": "Bridge vulnerability inspired by 99Starz multi-chain presence",
    "real_world_inspiration": true,
    "complexity_score": 0.7,
    "lines_of_code": 25,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 20",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract CrossChainBridge {\n                    mapping(address => bool) public validators;\n                    mapping(bytes32 => uint256) public confirmations;\n                    uint256 public requiredConfirmations = 3;\n\n                    function addValidator(address validator) external {\n                        // VULNERABLE: No access control\n                        validators[validator] = true;\n                    }\n\n                    function confirmTransaction(bytes32 txHash) external {\n                        require(validators[msg.sender], \"Not a validator\");\n                        confirmations[txHash]++;\n                    }\n\n                    function executeTransaction(\n                        address to,\n                        uint256 amount,\n                        bytes32 txHash\n                    ) external {\n                        // VULNERABLE: Insufficient validation\n                        require(confirmations[txHash] >= requiredConfirmations, \"Not enough confirmations\");\n\n                        // VULNERABLE: No replay protection\n                        payable(to).transfer(amount);\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "bridge_validator_bypass",
    "severity": "Critical",
    "confidence": 0.92,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
    "activity_level": "VERY_HIGH",
    "contract_type": "defi_protocol_or_dex",
    "tx_count": 20226838,
    "risk_score": 0.8,
    "title": "Bridge Validator Bypass - VERY_HIGH",
    "description": "Vulnerability pattern inspired by VERY_HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.7142857142857143,
    "lines_of_code": 28,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "medium"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 265",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xcadb96858fe496bb6309622f9023ba2defb5d540",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1175154,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 112",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 79",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 95",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 107",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x68e54af74b22acaccffa04ccaad13be16ed14eac",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1169593,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 143",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 78",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x21ab6c9fac80c59d401b37cb43f81ea9dde7fe34",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1332382,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 296",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 121",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 93",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 62",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xa5409ec958c83c3f309868babaca7c86dcb077c1",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1392279,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 75",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 12",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 242",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 47",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 5",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 238",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 174",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xd9e1ce17f2641f24ae83637ab66a2cca9c378b9f",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 3584567,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x912656188616e0184e3181f019022990a63280b1",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1156722,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 6",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 1",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xdef1c0ded9bec7f1a1670819833240f027b25eff",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1383512,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 16",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 90",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 212",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 32",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 239",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract CrossChainBridge {\n                    mapping(address => bool) public validators;\n                    mapping(bytes32 => uint256) public confirmations;\n                    uint256 public requiredConfirmations = 3;\n\n                    function addValidator(address validator) external {\n                        // VULNERABLE: No access control\n                        validators[validator] = true;\n                    }\n\n                    function confirmTransaction(bytes32 txHash) external {\n                        require(validators[msg.sender], \"Not a validator\");\n                        confirmations[txHash]++;\n                    }\n\n                    function executeTransaction(\n                        address to,\n                        uint256 amount,\n                        bytes32 txHash\n                    ) external {\n                        // VULNERABLE: Insufficient validation\n                        require(confirmations[txHash] >= requiredConfirmations, \"Not enough confirmations\");\n\n                        // VULNERABLE: No replay protection\n                        payable(to).transfer(amount);\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "bridge_validator_bypass",
    "severity": "Critical",
    "confidence": 0.92,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x7a250d5630b4cf539739df2c5dacb4c659f2488d",
    "activity_level": "ULTRA_HIGH",
    "contract_type": "major_exchange_or_bridge",
    "tx_count": 53642378,
    "risk_score": 0.9,
    "title": "Bridge Validator Bypass - ULTRA_HIGH",
    "description": "Vulnerability pattern inspired by ULTRA_HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.7142857142857143,
    "lines_of_code": 28,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "medium"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 188",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 49",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 213",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 267",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 154",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xf629cbd94d3791c9250152bd8dfbdf380e2a3b9c",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1309197,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x5acc84a3e955bdd76467d3348077d003f00ffb97",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 3635283,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x8d1f2ebfaccf1136db76fdd1b86f1dede2d23852",
    "activity_level": "MEDIUM",
    "contract_type": "standard_contract",
    "tx_count": 844824,
    "risk_score": 0.4,
    "title": "Flash Loan Reentrancy - MEDIUM",
    "description": "Vulnerability pattern inspired by MEDIUM activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x174bfa6600bf90c885c7c01c7031389ed1461ab9",
    "activity_level": "HIGH",
    "contract_type": "popular_token_or_dapp",
    "tx_count": 9088348,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x5f65f7b609678448494de4c87521cdf6cef1e932",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1321809,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x9e9801bace260f58407c15e6e515c45918756e0f",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1442315,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 251",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xbcf935d206ca32929e1b887a07ed240f0d8ccd22",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1193096,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 230",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xa3c1e324ca1ce40db73ed6026c4a177f099b5770",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1578591,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 280",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x881d40237659c251811cec9c364ef91dc08d300c",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 4321297,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x1d6e8bac6ea3730825bde4b005ed7b2b39a2932d",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 3846654,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
    "activity_level": "VERY_HIGH",
    "contract_type": "defi_protocol_or_dex",
    "tx_count": 20226838,
    "risk_score": 0.8,
    "title": "Dex Price Manipulation - VERY_HIGH",
    "description": "Vulnerability pattern inspired by VERY_HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 108",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x283af0b28c62c092c9727f1ee09c02ca627eb7f5",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1500961,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 243",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 130",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xa74476443119a942de498590fe1f2454d7d4ac0d",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1023342,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 46",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 151",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 226",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 85",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 184",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 8",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xe592427a0aece92de3edee1f18e0157c05861564",
    "activity_level": "HIGH",
    "contract_type": "popular_token_or_dapp",
    "tx_count": 5350146,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 148",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 67",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x9b9647431632af44be02ddd22477ed94d14aacaa",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1667685,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 92",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 179",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 15",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 149",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x7d1afa7b718fb893db30a3abc0cfc608aacfebb0",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 3056441,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 246",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 33",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 196",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 145",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 37",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x000000000035b5e5ad9019092c665357240f594e",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1215927,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x39755357759ce0d7f32dc8dc45414cca409ae24e",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1059336,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xdac17f958d2ee523a2206206994597c13d831ec7",
    "activity_level": "ULTRA_HIGH",
    "contract_type": "major_exchange_or_bridge",
    "tx_count": 128326187,
    "risk_score": 0.9,
    "title": "Dex Price Manipulation - ULTRA_HIGH",
    "description": "Vulnerability pattern inspired by ULTRA_HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 22",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 284",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x653430560be843c4a3d143d0110e896c2ab8ac0d",
    "activity_level": "MEDIUM",
    "contract_type": "standard_contract",
    "tx_count": 902953,
    "risk_score": 0.4,
    "title": "Dex Price Manipulation - MEDIUM",
    "description": "Vulnerability pattern inspired by MEDIUM activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x39755357759ce0d7f32dc8dc45414cca409ae24e",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1059336,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 293",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x881d40237659c251811cec9c364ef91dc08d300c",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 4321297,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n                contract CrossChainBridge {\n                    mapping(address => bool) public validators;\n                    mapping(bytes32 => uint256) public confirmations;\n                    uint256 public requiredConfirmations = 3;\n\n                    function addValidator(address validator) external {\n                        // VULNERABLE: No access control\n                        validators[validator] = true;\n                    }\n\n                    function confirmTransaction(bytes32 txHash) external {\n                        require(validators[msg.sender], \"Not a validator\");\n                        confirmations[txHash]++;\n                    }\n\n                    function executeTransaction(\n                        address to,\n                        uint256 amount,\n                        bytes32 txHash\n                    ) external {\n                        // VULNERABLE: Insufficient validation\n                        require(confirmations[txHash] >= requiredConfirmations, \"Not enough confirmations\");\n\n                        // VULNERABLE: No replay protection\n                        payable(to).transfer(amount);\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "bridge_validator_bypass",
    "severity": "Critical",
    "confidence": 0.92,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x8d12a197cb00d4747a1fe03395095ce2a5cc6819",
    "activity_level": "VERY_HIGH",
    "contract_type": "popular_token_or_dapp",
    "tx_count": 11541781,
    "risk_score": 0.8,
    "title": "Bridge Validator Bypass - VERY_HIGH",
    "description": "Vulnerability pattern inspired by VERY_HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.7142857142857143,
    "lines_of_code": 28,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "medium"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 146",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 26",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xb1690c08e213a35ed9bab7b318de14420fb57d8c",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1186058,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x8fdcc30eda7e94f1c12ce0280df6cd531e8365c5",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 2229775,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 50",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x1d6e8bac6ea3730825bde4b005ed7b2b39a2932d",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 3846654,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 164",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 45",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 249",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 169",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 56",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 152",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x7be8076f4ea4a4ad08075c2508e481d6c946d12b",
    "activity_level": "VERY_HIGH",
    "contract_type": "popular_token_or_dapp",
    "tx_count": 16964552,
    "risk_score": 0.8,
    "title": "Flash Loan Reentrancy - VERY_HIGH",
    "description": "Vulnerability pattern inspired by VERY_HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 276",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 117",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 128",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xbc4162d53f945266684f4e5e48d545f206bc1ca5",
    "activity_level": "MEDIUM",
    "contract_type": "standard_contract",
    "tx_count": 989165,
    "risk_score": 0.4,
    "title": "Dex Price Manipulation - MEDIUM",
    "description": "Vulnerability pattern inspired by MEDIUM activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 21",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 268",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x000000005736775feb0c8568e7dee77222a26880",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 2390322,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 215",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 17",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
    "activity_level": "VERY_HIGH",
    "contract_type": "defi_protocol_or_dex",
    "tx_count": 20226838,
    "risk_score": 0.8,
    "title": "Flash Loan Reentrancy - VERY_HIGH",
    "description": "Vulnerability pattern inspired by VERY_HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x0000000000007f150bd6f54c40a34d7c3d5e9f56",
    "activity_level": "ULTRA_HIGH",
    "contract_type": "major_exchange_or_bridge",
    "tx_count": 75499550,
    "risk_score": 0.9,
    "title": "Flash Loan Reentrancy - ULTRA_HIGH",
    "description": "Vulnerability pattern inspired by ULTRA_HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 23",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 247",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 253",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 42",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 89",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xb8c77482e45f1f44de1745f52c74426c631bdd52",
    "activity_level": "MEDIUM",
    "contract_type": "standard_contract",
    "tx_count": 874219,
    "risk_score": 0.4,
    "title": "Dex Price Manipulation - MEDIUM",
    "description": "Vulnerability pattern inspired by MEDIUM activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 68",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 31",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xdef1c0ded9bec7f1a1670819833240f027b25eff",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1383512,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 69",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 201",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x9554efa1669014c25070bc23c2df262825704228",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1021428,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x61935cbdd02287b511119ddb11aeb42f1593b7ef",
    "activity_level": "MEDIUM",
    "contract_type": "standard_contract",
    "tx_count": 890966,
    "risk_score": 0.4,
    "title": "Dex Price Manipulation - MEDIUM",
    "description": "Vulnerability pattern inspired by MEDIUM activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xa57bd00134b2850b2a1c55860c9e9ea100fdd6cf",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 2850379,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x1522900b6dafac587d499a862861c0869be6e428",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1416398,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 178",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DAOGovernance {\n                    mapping(address => uint256) public votingPower;\n                    mapping(uint256 => Proposal) public proposals;\n                    uint256 public proposalCount;\n\n                    struct Proposal {\n                        string description;\n                        uint256 forVotes;\n                        uint256 againstVotes;\n                        bool executed;\n                        uint256 deadline;\n                    }\n\n                    function propose(string memory description) external returns (uint256) {\n                        // VULNERABLE: No minimum voting power required\n                        uint256 proposalId = proposalCount++;\n                        proposals[proposalId] = Proposal({\n                            description: description,\n                            forVotes: 0,\n                            againstVotes: 0,\n                            executed: false,\n                            deadline: block.timestamp + 7 days\n                        });\n                        return proposalId;\n                    }\n\n                    function vote(uint256 proposalId, bool support) external {\n                        Proposal storage proposal = proposals[proposalId];\n                        require(block.timestamp <= proposal.deadline, \"Voting ended\");\n\n                        // VULNERABLE: No double-voting protection\n                        uint256 power = votingPower[msg.sender];\n                        if (support) {\n                            proposal.forVotes += power;\n                        } else {\n                            proposal.againstVotes += power;\n                        }\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "governance_attack",
    "severity": "High",
    "confidence": 0.88,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x0000000000007f150bd6f54c40a34d7c3d5e9f56",
    "activity_level": "ULTRA_HIGH",
    "contract_type": "major_exchange_or_bridge",
    "tx_count": 75499550,
    "risk_score": 0.9,
    "title": "Governance Attack - ULTRA_HIGH",
    "description": "Vulnerability pattern inspired by ULTRA_HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.7750000000000001,
    "lines_of_code": 40,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0
    ],
    "exploit_difficulty": "medium"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 66",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x11111112542d85b3ef69ae05771c2dccff4faa26",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1737257,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x8e870d67f660d95d5be530380d0ec0bd388289e1",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1796004,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 27",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 38",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 74",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x9dffe202df7f82ba57a7f8d571628805eff7fed9",
    "activity_level": "MEDIUM",
    "contract_type": "standard_contract",
    "tx_count": 871943,
    "risk_score": 0.4,
    "title": "Flash Loan Reentrancy - MEDIUM",
    "description": "Vulnerability pattern inspired by MEDIUM activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 55",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 262",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 158",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 147",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xd26114cd6ee289accf82350c8d8487fedb8a0c07",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 2705998,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x860bd2dba9cd475a61e6d1b45e16c365f6d78f66",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 2163734,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x06012c8cf97bead5deae237070f9587f8e7a266d",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 4901882,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 190",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x1f9840a85d5af5bf1d1762f925bdaddc4201f984",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1941008,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x0000000000007f150bd6f54c40a34d7c3d5e9f56",
    "activity_level": "ULTRA_HIGH",
    "contract_type": "major_exchange_or_bridge",
    "tx_count": 75499550,
    "risk_score": 0.9,
    "title": "Dex Price Manipulation - ULTRA_HIGH",
    "description": "Vulnerability pattern inspired by ULTRA_HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 4",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 206",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x3506424f91fd33084466f402d5d97f05f8e3b4af",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1024831,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 192",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DAOGovernance {\n                    mapping(address => uint256) public votingPower;\n                    mapping(uint256 => Proposal) public proposals;\n                    uint256 public proposalCount;\n\n                    struct Proposal {\n                        string description;\n                        uint256 forVotes;\n                        uint256 againstVotes;\n                        bool executed;\n                        uint256 deadline;\n                    }\n\n                    function propose(string memory description) external returns (uint256) {\n                        // VULNERABLE: No minimum voting power required\n                        uint256 proposalId = proposalCount++;\n                        proposals[proposalId] = Proposal({\n                            description: description,\n                            forVotes: 0,\n                            againstVotes: 0,\n                            executed: false,\n                            deadline: block.timestamp + 7 days\n                        });\n                        return proposalId;\n                    }\n\n                    function vote(uint256 proposalId, bool support) external {\n                        Proposal storage proposal = proposals[proposalId];\n                        require(block.timestamp <= proposal.deadline, \"Voting ended\");\n\n                        // VULNERABLE: No double-voting protection\n                        uint256 power = votingPower[msg.sender];\n                        if (support) {\n                            proposal.forVotes += power;\n                        } else {\n                            proposal.againstVotes += power;\n                        }\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "governance_attack",
    "severity": "High",
    "confidence": 0.88,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x8d12a197cb00d4747a1fe03395095ce2a5cc6819",
    "activity_level": "VERY_HIGH",
    "contract_type": "popular_token_or_dapp",
    "tx_count": 11541781,
    "risk_score": 0.8,
    "title": "Governance Attack - VERY_HIGH",
    "description": "Vulnerability pattern inspired by VERY_HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.7750000000000001,
    "lines_of_code": 40,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0
    ],
    "exploit_difficulty": "medium"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 25",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 155",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 144",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x98ad263a95f1ab1abff41f4d44b07c3240251a0a",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1354177,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x1a2a1c938ce3ec39b6d47113c7955baa9dd454f2",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 3088378,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 118",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xd9e1ce17f2641f24ae83637ab66a2cca9c378b9f",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 3584567,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xc00e94cb662c3520282e6f5717214004a7f26888",
    "activity_level": "MEDIUM",
    "contract_type": "standard_contract",
    "tx_count": 950594,
    "risk_score": 0.4,
    "title": "Dex Price Manipulation - MEDIUM",
    "description": "Vulnerability pattern inspired by MEDIUM activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 294",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 229",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xb64ef51c888972c908cfacf59b47c1afbc0ab8ac",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1716339,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xac08809df1048b82959d6251fbc9538920bed1fa",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1051796,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 208",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 34",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract CrossChainBridge {\n                    mapping(address => bool) public validators;\n                    mapping(bytes32 => uint256) public confirmations;\n                    uint256 public requiredConfirmations = 3;\n\n                    function addValidator(address validator) external {\n                        // VULNERABLE: No access control\n                        validators[validator] = true;\n                    }\n\n                    function confirmTransaction(bytes32 txHash) external {\n                        require(validators[msg.sender], \"Not a validator\");\n                        confirmations[txHash]++;\n                    }\n\n                    function executeTransaction(\n                        address to,\n                        uint256 amount,\n                        bytes32 txHash\n                    ) external {\n                        // VULNERABLE: Insufficient validation\n                        require(confirmations[txHash] >= requiredConfirmations, \"Not enough confirmations\");\n\n                        // VULNERABLE: No replay protection\n                        payable(to).transfer(amount);\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "bridge_validator_bypass",
    "severity": "Critical",
    "confidence": 0.92,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xdac17f958d2ee523a2206206994597c13d831ec7",
    "activity_level": "ULTRA_HIGH",
    "contract_type": "major_exchange_or_bridge",
    "tx_count": 128326187,
    "risk_score": 0.9,
    "title": "Bridge Validator Bypass - ULTRA_HIGH",
    "description": "Vulnerability pattern inspired by ULTRA_HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.7142857142857143,
    "lines_of_code": 28,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "medium"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 175",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 52",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 167",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 260",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 142",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x798abda6cc246d0edba912092a2a3dbd3d11191b",
    "activity_level": "MEDIUM",
    "contract_type": "standard_contract",
    "tx_count": 875894,
    "risk_score": 0.4,
    "title": "Flash Loan Reentrancy - MEDIUM",
    "description": "Vulnerability pattern inspired by MEDIUM activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x744d70fdbe2ba4cf95131626614a1763df805b9e",
    "activity_level": "MEDIUM",
    "contract_type": "standard_contract",
    "tx_count": 999184,
    "risk_score": 0.4,
    "title": "Flash Loan Reentrancy - MEDIUM",
    "description": "Vulnerability pattern inspired by MEDIUM activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 44",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xcc8fa225d80b9c7d42f96e9570156c65d6caaa25",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1149854,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x68e54af74b22acaccffa04ccaad13be16ed14eac",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1169593,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x6090a6e47849629b7245dfa1ca21d94cd15878ef",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1517119,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 219",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 250",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xac08809df1048b82959d6251fbc9538920bed1fa",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1051796,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x0000000000085d4780b73119b644ae5ecd22b376",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1153719,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x0f5d2fb29fb7d3cfee444a200298f468908cc942",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1540242,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x000000000000084e91743124a982076c59f10084",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 2973216,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 183",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n        contract CrossChainToken {\n            mapping(uint256 => mapping(address => uint256)) public balances; // chainId => user => balance\n            mapping(uint256 => bool) public supportedChains;\n\n            function bridgeTokens(uint256 toChainId, uint256 amount) external {\n                require(supportedChains[toChainId], \"Chain not supported\");\n                require(balances[getCurrentChainId()][msg.sender] >= amount, \"Insufficient balance\");\n\n                // VULNERABLE: No proper chain validation\n                balances[getCurrentChainId()][msg.sender] -= amount;\n\n                // VULNERABLE: Trust external bridge without validation\n                IBridge(getBridgeAddress()).transferToChain(\n                    toChainId,\n                    msg.sender,\n                    amount\n                );\n            }\n\n            function mintFromBridge(address user, uint256 amount, uint256 fromChainId) external {\n                // VULNERABLE: No bridge authentication\n                balances[getCurrentChainId()][user] += amount;\n            }\n        }",
    "vulnerability_label": 1,
    "vulnerability_type": "bridge_vulnerability",
    "severity": "High",
    "confidence": 0.85,
    "source": "downloads_csv_multichain",
    "inspired_by_project": "OneArt",
    "project_symbol": "1art",
    "supported_chains": [
      "ethereum",
      "bsc",
      "fantom"
    ],
    "chain_count": 3,
    "title": "Multi-chain Bridge Vulnerability - OneArt",
    "description": "Bridge vulnerability inspired by OneArt multi-chain presence",
    "real_world_inspiration": true,
    "complexity_score": 0.7,
    "lines_of_code": 25,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 216",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 166",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x11111112542d85b3ef69ae05771c2dccff4faa26",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1737257,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x0e50e6d6bb434938d8fe670a2d7a14cd128eb50f",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1373486,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 88",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 58",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 254",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x6b175474e89094c44da98b954eedeac495271d0f",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 4239593,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 48",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 126",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xfbddadd80fe7bda00b901fbaf73803f2238ae655",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1435628,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 271",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 299",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xa3c1e324ca1ce40db73ed6026c4a177f099b5770",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1578591,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 165",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x6b3595068778dd592e39a122f4f5a5cf09c90fe2",
    "activity_level": "MEDIUM",
    "contract_type": "standard_contract",
    "tx_count": 841812,
    "risk_score": 0.4,
    "title": "Flash Loan Reentrancy - MEDIUM",
    "description": "Vulnerability pattern inspired by MEDIUM activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n                contract CrossChainBridge {\n                    mapping(address => bool) public validators;\n                    mapping(bytes32 => uint256) public confirmations;\n                    uint256 public requiredConfirmations = 3;\n\n                    function addValidator(address validator) external {\n                        // VULNERABLE: No access control\n                        validators[validator] = true;\n                    }\n\n                    function confirmTransaction(bytes32 txHash) external {\n                        require(validators[msg.sender], \"Not a validator\");\n                        confirmations[txHash]++;\n                    }\n\n                    function executeTransaction(\n                        address to,\n                        uint256 amount,\n                        bytes32 txHash\n                    ) external {\n                        // VULNERABLE: Insufficient validation\n                        require(confirmations[txHash] >= requiredConfirmations, \"Not enough confirmations\");\n\n                        // VULNERABLE: No replay protection\n                        payable(to).transfer(amount);\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "bridge_validator_bypass",
    "severity": "Critical",
    "confidence": 0.92,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x7be8076f4ea4a4ad08075c2508e481d6c946d12b",
    "activity_level": "VERY_HIGH",
    "contract_type": "popular_token_or_dapp",
    "tx_count": 16964552,
    "risk_score": 0.8,
    "title": "Bridge Validator Bypass - VERY_HIGH",
    "description": "Vulnerability pattern inspired by VERY_HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.7142857142857143,
    "lines_of_code": 28,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "medium"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 193",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x8d12a197cb00d4747a1fe03395095ce2a5cc6819",
    "activity_level": "VERY_HIGH",
    "contract_type": "popular_token_or_dapp",
    "tx_count": 11541781,
    "risk_score": 0.8,
    "title": "Flash Loan Reentrancy - VERY_HIGH",
    "description": "Vulnerability pattern inspired by VERY_HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 153",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 204",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 86",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 187",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xe592427a0aece92de3edee1f18e0157c05861564",
    "activity_level": "HIGH",
    "contract_type": "popular_token_or_dapp",
    "tx_count": 5350146,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xe41d2489571d322189246dafa5ebde1f4699f498",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1750455,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 200",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 241",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 236",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 51",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 91",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 73",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xdd974d5c2e2928dea5f71b9825b8b646686bd200",
    "activity_level": "MEDIUM",
    "contract_type": "standard_contract",
    "tx_count": 931153,
    "risk_score": 0.4,
    "title": "Flash Loan Reentrancy - MEDIUM",
    "description": "Vulnerability pattern inspired by MEDIUM activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xf6874c88757721a02f47592140905c4336dfbc61",
    "activity_level": "MEDIUM",
    "contract_type": "standard_contract",
    "tx_count": 838998,
    "risk_score": 0.4,
    "title": "Dex Price Manipulation - MEDIUM",
    "description": "Vulnerability pattern inspired by MEDIUM activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x5acc84a3e955bdd76467d3348077d003f00ffb97",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 3635283,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xcc8fa225d80b9c7d42f96e9570156c65d6caaa25",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1149854,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 123",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x000000000000084e91743124a982076c59f10084",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 2973216,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x78a55b9b3bbeffb36a43d9905f654d2769dc55e8",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1243275,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xf6874c88757721a02f47592140905c4336dfbc61",
    "activity_level": "MEDIUM",
    "contract_type": "standard_contract",
    "tx_count": 838998,
    "risk_score": 0.4,
    "title": "Flash Loan Reentrancy - MEDIUM",
    "description": "Vulnerability pattern inspired by MEDIUM activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 94",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x8d12a197cb00d4747a1fe03395095ce2a5cc6819",
    "activity_level": "VERY_HIGH",
    "contract_type": "popular_token_or_dapp",
    "tx_count": 11541781,
    "risk_score": 0.8,
    "title": "Dex Price Manipulation - VERY_HIGH",
    "description": "Vulnerability pattern inspired by VERY_HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n        contract CrossChainToken {\n            mapping(uint256 => mapping(address => uint256)) public balances; // chainId => user => balance\n            mapping(uint256 => bool) public supportedChains;\n\n            function bridgeTokens(uint256 toChainId, uint256 amount) external {\n                require(supportedChains[toChainId], \"Chain not supported\");\n                require(balances[getCurrentChainId()][msg.sender] >= amount, \"Insufficient balance\");\n\n                // VULNERABLE: No proper chain validation\n                balances[getCurrentChainId()][msg.sender] -= amount;\n\n                // VULNERABLE: Trust external bridge without validation\n                IBridge(getBridgeAddress()).transferToChain(\n                    toChainId,\n                    msg.sender,\n                    amount\n                );\n            }\n\n            function mintFromBridge(address user, uint256 amount, uint256 fromChainId) external {\n                // VULNERABLE: No bridge authentication\n                balances[getCurrentChainId()][user] += amount;\n            }\n        }",
    "vulnerability_label": 1,
    "vulnerability_type": "bridge_vulnerability",
    "severity": "High",
    "confidence": 0.85,
    "source": "downloads_csv_multichain",
    "inspired_by_project": "8Pay",
    "project_symbol": "8pay",
    "supported_chains": [
      "ethereum",
      "bsc"
    ],
    "chain_count": 2,
    "title": "Multi-chain Bridge Vulnerability - 8Pay",
    "description": "Bridge vulnerability inspired by 8Pay multi-chain presence",
    "real_world_inspiration": true,
    "complexity_score": 0.7,
    "lines_of_code": 25,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 65",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xbc4162d53f945266684f4e5e48d545f206bc1ca5",
    "activity_level": "MEDIUM",
    "contract_type": "standard_contract",
    "tx_count": 989165,
    "risk_score": 0.4,
    "title": "Flash Loan Reentrancy - MEDIUM",
    "description": "Vulnerability pattern inspired by MEDIUM activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xa0c68c638235ee32657e8f720a23cec1bfc77c77",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1980887,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 76",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x209c4784ab1e8183cf58ca33cb740efbf3fc18ef",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1814557,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 64",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x514910771af9ca656af840dff83e8264ecf986ca",
    "activity_level": "HIGH",
    "contract_type": "popular_token_or_dapp",
    "tx_count": 5621638,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 77",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 115",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 98",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 131",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x0000006daea1723962647b7e189d311d757fb793",
    "activity_level": "MEDIUM",
    "contract_type": "standard_contract",
    "tx_count": 947333,
    "risk_score": 0.4,
    "title": "Dex Price Manipulation - MEDIUM",
    "description": "Vulnerability pattern inspired by MEDIUM activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 207",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 59",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 61",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 9",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 283",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x283af0b28c62c092c9727f1ee09c02ca627eb7f5",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1500961,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x653430560be843c4a3d143d0110e896c2ab8ac0d",
    "activity_level": "MEDIUM",
    "contract_type": "standard_contract",
    "tx_count": 902953,
    "risk_score": 0.4,
    "title": "Flash Loan Reentrancy - MEDIUM",
    "description": "Vulnerability pattern inspired by MEDIUM activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 221",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
    "activity_level": "HIGH",
    "contract_type": "popular_token_or_dapp",
    "tx_count": 6855477,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xcadb96858fe496bb6309622f9023ba2defb5d540",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1175154,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 4966891,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xdd974d5c2e2928dea5f71b9825b8b646686bd200",
    "activity_level": "MEDIUM",
    "contract_type": "standard_contract",
    "tx_count": 931153,
    "risk_score": 0.4,
    "title": "Dex Price Manipulation - MEDIUM",
    "description": "Vulnerability pattern inspired by MEDIUM activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xe94b04a0fed112f3664e45adb2b8915693dd5ff3",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1653545,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x000000000000006f6502b7f2bbac8c30a3f67e9a",
    "activity_level": "VERY_HIGH",
    "contract_type": "popular_token_or_dapp",
    "tx_count": 17250288,
    "risk_score": 0.8,
    "title": "Dex Price Manipulation - VERY_HIGH",
    "description": "Vulnerability pattern inspired by VERY_HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 28",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x1522900b6dafac587d499a862861c0869be6e428",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1416398,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 233",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 255",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 96",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xf629cbd94d3791c9250152bd8dfbdf380e2a3b9c",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1309197,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x3506424f91fd33084466f402d5d97f05f8e3b4af",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1024831,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 111",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 99",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x68b3465833fb72a70ecdf485e0e4c7bd8665fc45",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 4099846,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 106",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 209",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 53",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xb8c77482e45f1f44de1745f52c74426c631bdd52",
    "activity_level": "MEDIUM",
    "contract_type": "standard_contract",
    "tx_count": 874219,
    "risk_score": 0.4,
    "title": "Flash Loan Reentrancy - MEDIUM",
    "description": "Vulnerability pattern inspired by MEDIUM activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 36",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 195",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x0b95993a39a363d99280ac950f5e4536ab5c5566",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 2513630,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 256",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 223",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 290",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 35",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 29",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x03df4c372a29376d2c8df33a1b5f001cd8d68b0e",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1452754,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x798abda6cc246d0edba912092a2a3dbd3d11191b",
    "activity_level": "MEDIUM",
    "contract_type": "standard_contract",
    "tx_count": 875894,
    "risk_score": 0.4,
    "title": "Dex Price Manipulation - MEDIUM",
    "description": "Vulnerability pattern inspired by MEDIUM activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 203",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 288",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 60",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 141",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 104",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 24",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 185",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x03df4c372a29376d2c8df33a1b5f001cd8d68b0e",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1452754,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 224",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 43",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x6b175474e89094c44da98b954eedeac495271d0f",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 4239593,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xa15c7ebe1f07caf6bff097d8a589fb8ac49ae5b3",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1469997,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 133",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 275",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x2b591e99afe9f32eaa6214f7b7629768c40eeb39",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1544945,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xae9b8e05c22bae74d1e8db82c4af122b18050bd4",
    "activity_level": "MEDIUM",
    "contract_type": "standard_contract",
    "tx_count": 876593,
    "risk_score": 0.4,
    "title": "Flash Loan Reentrancy - MEDIUM",
    "description": "Vulnerability pattern inspired by MEDIUM activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x0000000000085d4780b73119b644ae5ecd22b376",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1153719,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x7f268357a8c2552623316e2562d90e642bb538e5",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 2877112,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 252",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 103",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 101",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x7a250d5630b4cf539739df2c5dacb4c659f2488d",
    "activity_level": "ULTRA_HIGH",
    "contract_type": "major_exchange_or_bridge",
    "tx_count": 53642378,
    "risk_score": 0.9,
    "title": "Dex Price Manipulation - ULTRA_HIGH",
    "description": "Vulnerability pattern inspired by ULTRA_HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 132",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 170",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x0e50e6d6bb434938d8fe670a2d7a14cd128eb50f",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1373486,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 205",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xe41d2489571d322189246dafa5ebde1f4699f498",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1750455,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 300",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 14",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x174bfa6600bf90c885c7c01c7031389ed1461ab9",
    "activity_level": "HIGH",
    "contract_type": "popular_token_or_dapp",
    "tx_count": 9088348,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x68b3465833fb72a70ecdf485e0e4c7bd8665fc45",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 4099846,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 270",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x912656188616e0184e3181f019022990a63280b1",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1156722,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 72",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x6090a6e47849629b7245dfa1ca21d94cd15878ef",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1517119,
    "risk_score": 0.6,
    "title": "Dex Price Manipulation - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xd7cc16500d0b0ac3d0ba156a584865a43b0b0050",
    "activity_level": "MEDIUM",
    "contract_type": "standard_contract",
    "tx_count": 899748,
    "risk_score": 0.4,
    "title": "Flash Loan Reentrancy - MEDIUM",
    "description": "Vulnerability pattern inspired by MEDIUM activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 287",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 289",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 210",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 279",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xa0c68c638235ee32657e8f720a23cec1bfc77c77",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1980887,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n                contract DAOGovernance {\n                    mapping(address => uint256) public votingPower;\n                    mapping(uint256 => Proposal) public proposals;\n                    uint256 public proposalCount;\n\n                    struct Proposal {\n                        string description;\n                        uint256 forVotes;\n                        uint256 againstVotes;\n                        bool executed;\n                        uint256 deadline;\n                    }\n\n                    function propose(string memory description) external returns (uint256) {\n                        // VULNERABLE: No minimum voting power required\n                        uint256 proposalId = proposalCount++;\n                        proposals[proposalId] = Proposal({\n                            description: description,\n                            forVotes: 0,\n                            againstVotes: 0,\n                            executed: false,\n                            deadline: block.timestamp + 7 days\n                        });\n                        return proposalId;\n                    }\n\n                    function vote(uint256 proposalId, bool support) external {\n                        Proposal storage proposal = proposals[proposalId];\n                        require(block.timestamp <= proposal.deadline, \"Voting ended\");\n\n                        // VULNERABLE: No double-voting protection\n                        uint256 power = votingPower[msg.sender];\n                        if (support) {\n                            proposal.forVotes += power;\n                        } else {\n                            proposal.againstVotes += power;\n                        }\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "governance_attack",
    "severity": "High",
    "confidence": 0.88,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x7a250d5630b4cf539739df2c5dacb4c659f2488d",
    "activity_level": "ULTRA_HIGH",
    "contract_type": "major_exchange_or_bridge",
    "tx_count": 53642378,
    "risk_score": 0.9,
    "title": "Governance Attack - ULTRA_HIGH",
    "description": "Vulnerability pattern inspired by ULTRA_HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.7750000000000001,
    "lines_of_code": 40,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0
    ],
    "exploit_difficulty": "medium"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x62b9f8741bf53a6986a5411c0557c30f6f11f3af",
    "activity_level": "MEDIUM",
    "contract_type": "standard_contract",
    "tx_count": 932475,
    "risk_score": 0.4,
    "title": "Flash Loan Reentrancy - MEDIUM",
    "description": "Vulnerability pattern inspired by MEDIUM activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xa24787320ede4cc19d800bf87b41ab9539c4da9d",
    "activity_level": "MEDIUM",
    "contract_type": "standard_contract",
    "tx_count": 879535,
    "risk_score": 0.4,
    "title": "Dex Price Manipulation - MEDIUM",
    "description": "Vulnerability pattern inspired by MEDIUM activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 124",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DEXPriceOracle {\n                    struct PriceData {\n                        uint256 price;\n                        uint256 timestamp;\n                        uint256 volume;\n                    }\n\n                    mapping(address => PriceData) public prices;\n\n                    function updatePrice(address token, uint256 newPrice, uint256 volume) external {\n                        // VULNERABLE: No access control\n                        prices[token] = PriceData({\n                            price: newPrice,\n                            timestamp: block.timestamp,\n                            volume: volume\n                        });\n                    }\n\n                    function getPrice(address token) external view returns (uint256) {\n                        PriceData memory data = prices[token];\n\n                        // VULNERABLE: No staleness check\n                        return data.price;\n                    }\n\n                    function getWeightedPrice(address token) external view returns (uint256) {\n                        // VULNERABLE: Single source, manipulable\n                        return prices[token].price * prices[token].volume / 1e18;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "dex_price_manipulation",
    "severity": "High",
    "confidence": 0.9,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x74fd51a98a4a1ecbef8cc43be801cce630e260bd",
    "activity_level": "MEDIUM",
    "contract_type": "standard_contract",
    "tx_count": 867499,
    "risk_score": 0.4,
    "title": "Dex Price Manipulation - MEDIUM",
    "description": "Vulnerability pattern inspired by MEDIUM activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.5483870967741936,
    "lines_of_code": 31,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "very_high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 102",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 40",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 274",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n            contract SecureMultiChainBridge {\n                mapping(address => bool) public authorizedValidators;\n                mapping(bytes32 => bool) public processedTransactions;\n                uint256 public constant REQUIRED_SIGNATURES = 3;\n                address public admin;\n\n                modifier onlyAdmin() {\n                    require(msg.sender == admin, \"Not admin\");\n                    _;\n                }\n\n                modifier onlyValidator() {\n                    require(authorizedValidators[msg.sender], \"Not authorized validator\");\n                    _;\n                }\n\n                function addValidator(address validator) external onlyAdmin {\n                    authorizedValidators[validator] = true;\n                }\n\n                function processWithdrawal(\n                    address to,\n                    uint256 amount,\n                    bytes32 txHash,\n                    bytes[] memory signatures\n                ) external onlyValidator {\n                    require(!processedTransactions[txHash], \"Already processed\");\n                    require(signatures.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n                    require(verifySignatures(txHash, signatures), \"Invalid signatures\");\n\n                    processedTransactions[txHash] = true;\n                    safeTransfer(to, amount);\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 211",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 35,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract DAOGovernance {\n                    mapping(address => uint256) public votingPower;\n                    mapping(uint256 => Proposal) public proposals;\n                    uint256 public proposalCount;\n\n                    struct Proposal {\n                        string description;\n                        uint256 forVotes;\n                        uint256 againstVotes;\n                        bool executed;\n                        uint256 deadline;\n                    }\n\n                    function propose(string memory description) external returns (uint256) {\n                        // VULNERABLE: No minimum voting power required\n                        uint256 proposalId = proposalCount++;\n                        proposals[proposalId] = Proposal({\n                            description: description,\n                            forVotes: 0,\n                            againstVotes: 0,\n                            executed: false,\n                            deadline: block.timestamp + 7 days\n                        });\n                        return proposalId;\n                    }\n\n                    function vote(uint256 proposalId, bool support) external {\n                        Proposal storage proposal = proposals[proposalId];\n                        require(block.timestamp <= proposal.deadline, \"Voting ended\");\n\n                        // VULNERABLE: No double-voting protection\n                        uint256 power = votingPower[msg.sender];\n                        if (support) {\n                            proposal.forVotes += power;\n                        } else {\n                            proposal.againstVotes += power;\n                        }\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "governance_attack",
    "severity": "High",
    "confidence": 0.88,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xdac17f958d2ee523a2206206994597c13d831ec7",
    "activity_level": "ULTRA_HIGH",
    "contract_type": "major_exchange_or_bridge",
    "tx_count": 128326187,
    "risk_score": 0.9,
    "title": "Governance Attack - ULTRA_HIGH",
    "description": "Vulnerability pattern inspired by ULTRA_HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 0.7750000000000001,
    "lines_of_code": 40,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0
    ],
    "exploit_difficulty": "medium"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x03f7724180aa6b939894b5ca4314783b0b36b329",
    "activity_level": "MEDIUM",
    "contract_type": "standard_contract",
    "tx_count": 951074,
    "risk_score": 0.4,
    "title": "Flash Loan Reentrancy - MEDIUM",
    "description": "Vulnerability pattern inspired by MEDIUM activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n        contract CrossChainToken {\n            mapping(uint256 => mapping(address => uint256)) public balances; // chainId => user => balance\n            mapping(uint256 => bool) public supportedChains;\n\n            function bridgeTokens(uint256 toChainId, uint256 amount) external {\n                require(supportedChains[toChainId], \"Chain not supported\");\n                require(balances[getCurrentChainId()][msg.sender] >= amount, \"Insufficient balance\");\n\n                // VULNERABLE: No proper chain validation\n                balances[getCurrentChainId()][msg.sender] -= amount;\n\n                // VULNERABLE: Trust external bridge without validation\n                IBridge(getBridgeAddress()).transferToChain(\n                    toChainId,\n                    msg.sender,\n                    amount\n                );\n            }\n\n            function mintFromBridge(address user, uint256 amount, uint256 fromChainId) external {\n                // VULNERABLE: No bridge authentication\n                balances[getCurrentChainId()][user] += amount;\n            }\n        }",
    "vulnerability_label": 1,
    "vulnerability_type": "bridge_vulnerability",
    "severity": "High",
    "confidence": 0.85,
    "source": "downloads_csv_multichain",
    "inspired_by_project": "2crazyNFT",
    "project_symbol": "2crz",
    "supported_chains": [
      "ethereum",
      "bsc"
    ],
    "chain_count": 2,
    "title": "Multi-chain Bridge Vulnerability - 2crazyNFT",
    "description": "Bridge vulnerability inspired by 2crazyNFT multi-chain presence",
    "real_world_inspiration": true,
    "complexity_score": 0.7,
    "lines_of_code": 25,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 292",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x000000000035b5e5ad9019092c665357240f594e",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 1215927,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xd1ceeeeee83f8bcf3bedad437202b6154e9f5405",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 4345167,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0xf230b790e05390fc8295f4d3f60332c93bed42e2",
    "activity_level": "HIGH",
    "contract_type": "active_contract",
    "tx_count": 2085638,
    "risk_score": 0.6,
    "title": "Flash Loan Reentrancy - HIGH",
    "description": "Vulnerability pattern inspired by HIGH activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n                contract FlashLoanProtocol {\n                    mapping(address => uint256) public deposits;\n                    uint256 public totalLiquidity;\n\n                    function flashLoan(uint256 amount, address borrower) external {\n                        require(amount <= totalLiquidity, \"Insufficient liquidity\");\n\n                        uint256 balanceBefore = address(this).balance;\n\n                        // VULNERABLE: External call before state validation\n                        (bool success, ) = borrower.call{value: amount}(\"\");\n                        require(success, \"Flash loan execution failed\");\n\n                        // VULNERABLE: Insufficient validation of repayment\n                        require(address(this).balance >= balanceBefore + getFee(amount), \"Loan not repaid\");\n                    }\n\n                    function withdraw() external {\n                        uint256 amount = deposits[msg.sender];\n                        require(amount > 0, \"No deposits\");\n\n                        // VULNERABLE: Classic reentrancy\n                        (bool success, ) = msg.sender.call{value: amount}(\"\");\n                        require(success, \"Withdrawal failed\");\n\n                        deposits[msg.sender] = 0;\n                    }\n                }",
    "vulnerability_label": 1,
    "vulnerability_type": "flash_loan_reentrancy",
    "severity": "Critical",
    "confidence": 0.95,
    "source": "downloads_csv_inspired",
    "inspired_by_address": "0x0000006daea1723962647b7e189d311d757fb793",
    "activity_level": "MEDIUM",
    "contract_type": "standard_contract",
    "tx_count": 947333,
    "risk_score": 0.4,
    "title": "Flash Loan Reentrancy - MEDIUM",
    "description": "Vulnerability pattern inspired by MEDIUM activity contract",
    "real_world_inspiration": true,
    "complexity_score": 1.0,
    "lines_of_code": 29,
    "has_external_calls": true,
    "has_state_changes": true,
    "proof_required": true,
    "formal_verification_target": true,
    "vulnerability_types": [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "high"
  },
  {
    "code": "\n            contract SecureFlashLoanProtocol {\n                using SafeMath for uint256;\n                mapping(address => uint256) public balances;\n                bool private locked;\n\n                modifier noReentrancy() {\n                    require(!locked, \"Reentrancy guard\");\n                    locked = true;\n                    _;\n                    locked = false;\n                }\n\n                function flashLoan(uint256 amount, address borrower) external noReentrancy {\n                    require(amount <= getAvailableLiquidity(), \"Insufficient liquidity\");\n                    require(isAuthorizedBorrower(borrower), \"Unauthorized borrower\");\n\n                    uint256 fee = calculateFee(amount);\n                    uint256 balanceBefore = address(this).balance;\n\n                    // Execute flash loan\n                    IFlashLoanReceiver(borrower).executeOperation(amount, fee);\n\n                    // Verify repayment\n                    require(\n                        address(this).balance >= balanceBefore.add(fee),\n                        \"Flash loan not properly repaid\"\n                    );\n                }\n            }",
    "vulnerability_label": 0,
    "vulnerability_type": "none",
    "severity": "Safe",
    "confidence": 0.95,
    "source": "downloads_csv_safe",
    "title": "Secure Contract Pattern 214",
    "description": "Safe contract with proper security patterns",
    "real_world_inspiration": true,
    "complexity_score": 0.4,
    "lines_of_code": 30,
    "has_external_calls": false,
    "has_state_changes": true,
    "proof_required": false,
    "formal_verification_target": false,
    "vulnerability_types": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    "exploit_difficulty": "none"
  }
]