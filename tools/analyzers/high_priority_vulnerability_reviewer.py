#!/usr/bin/env python3
"""
High-Priority Vulnerability Reviewer for Oort Protocol

This tool analyzes the high-priority findings from our comprehensive security assessment
and provides detailed technical review, impact analysis, and immediate remediation guidance.

Focus: Critical and High severity vulnerabilities requiring immediate attention
"""

import json
import sys
from pathlib import Path
from typing import Dict, List, Any, Tuple
from collections import defaultdict, Counter
from datetime import datetime

class HighPriorityVulnerabilityReviewer:
    """
    Detailed reviewer for high-priority vulnerabilities found in Oort Protocol.

    Provides:
    - Technical analysis of vulnerability patterns
    - Exploitability assessment
    - Immediate remediation guidance
    - Risk prioritization
    """

    def __init__(self, report_path: str):
        self.report_path = Path(report_path)
        self.vulnerability_data = self._load_report()
        self.high_priority_vulns = []
        self.analysis_results = {}

    def _load_report(self) -> Dict:
        """Load the security analysis report."""
        try:
            with open(self.report_path, 'r') as f:
                return json.load(f)
        except Exception as e:
            print(f"Error loading report: {e}")
            return {}

    def extract_high_priority_vulnerabilities(self) -> List[Dict]:
        """Extract critical and high severity vulnerabilities."""
        print("🔍 Extracting High-Priority Vulnerabilities...")

        # Get critical and high severity vulnerabilities
        critical_vulns = self.vulnerability_data.get("vulnerabilities", {}).get("critical", [])
        high_vulns = self.vulnerability_data.get("vulnerabilities", {}).get("high", [])

        # Combine and sort by confidence/severity
        self.high_priority_vulns = critical_vulns + high_vulns

        # Sort by confidence and component criticality
        self.high_priority_vulns.sort(
            key=lambda x: (
                x.get("severity") == "critical",  # Critical first
                x.get("confidence", 0),  # Then by confidence
                x.get("component") in ["consensus_layer", "vm_interpreter", "evm_implementation"]  # Critical components
            ),
            reverse=True
        )

        print(f"📊 Found {len(self.high_priority_vulns)} high-priority vulnerabilities")
        return self.high_priority_vulns

    def analyze_vulnerability_patterns(self) -> Dict:
        """Analyze patterns in high-priority vulnerabilities."""
        print("📈 Analyzing Vulnerability Patterns...")

        patterns = {
            "by_component": Counter(),
            "by_category": Counter(),
            "by_file_type": Counter(),
            "critical_components_affected": set(),
            "exploitability_distribution": Counter(),
            "unique_files_affected": set()
        }

        for vuln in self.high_priority_vulns:
            component = vuln.get("component", "unknown")
            category = vuln.get("category", "unknown")
            file_path = vuln.get("file", "")
            confidence = vuln.get("confidence", 0)

            patterns["by_component"][component] += 1
            patterns["by_category"][category] += 1
            patterns["unique_files_affected"].add(file_path)

            # Determine file type
            if file_path.endswith('.sol'):
                patterns["by_file_type"]["Solidity"] += 1
            elif file_path.endswith(('.cpp', '.hpp', '.h')):
                patterns["by_file_type"]["C++"] += 1
            elif file_path.endswith('.js'):
                patterns["by_file_type"]["JavaScript"] += 1

            # Track critical components
            if component in ["consensus_layer", "vm_interpreter", "evm_implementation"]:
                patterns["critical_components_affected"].add(component)

            # Assess exploitability
            if confidence > 0.8:
                patterns["exploitability_distribution"]["High"] += 1
            elif confidence > 0.6:
                patterns["exploitability_distribution"]["Medium"] += 1
            else:
                patterns["exploitability_distribution"]["Low"] += 1

        return patterns

    def prioritize_vulnerabilities(self) -> List[Dict]:
        """Prioritize vulnerabilities based on multiple factors."""
        print("🎯 Prioritizing Vulnerabilities by Risk...")

        prioritized_vulns = []

        for vuln in self.high_priority_vulns:
            risk_score = self._calculate_risk_score(vuln)
            exploitability = self._assess_exploitability(vuln)
            business_impact = self._assess_business_impact(vuln)

            prioritized_vuln = {
                **vuln,
                "risk_score": risk_score,
                "exploitability": exploitability,
                "business_impact": business_impact,
                "priority_rank": self._determine_priority_rank(risk_score, exploitability, business_impact)
            }

            prioritized_vulns.append(prioritized_vuln)

        # Sort by priority rank
        prioritized_vulns.sort(key=lambda x: x["priority_rank"], reverse=True)

        return prioritized_vulns

    def _calculate_risk_score(self, vuln: Dict) -> float:
        """Calculate comprehensive risk score for vulnerability."""
        score = 0.0

        # Base severity score
        severity_scores = {
            "critical": 10.0,
            "high": 7.0,
            "medium": 4.0,
            "low": 1.0
        }
        score += severity_scores.get(vuln.get("severity", "low"), 1.0)

        # Confidence multiplier
        confidence = vuln.get("confidence", 0.5)
        score *= confidence

        # Component criticality multiplier
        component = vuln.get("component", "")
        if component in ["consensus_layer", "vm_interpreter"]:
            score *= 1.5
        elif component == "evm_implementation":
            score *= 1.8
        elif component in ["p2p_network", "smart_contracts"]:
            score *= 1.2

        # Category-specific adjustments
        category = vuln.get("category", "")
        if category in ["economic", "cryptographic"]:
            score *= 1.3
        elif category in ["consensus", "smart_contracts"]:
            score *= 1.4

        return round(score, 2)

    def _assess_exploitability(self, vuln: Dict) -> Dict:
        """Assess exploitability characteristics."""
        component = vuln.get("component", "")
        category = vuln.get("category", "")
        confidence = vuln.get("confidence", 0.5)

        # Attack complexity
        if component in ["p2p_network"] and "network" in vuln.get("name", "").lower():
            complexity = "Medium"  # Network access required
        elif component == "smart_contracts":
            complexity = "Low"     # Transaction-based attacks
        elif component in ["consensus_layer", "vm_interpreter"]:
            complexity = "High"    # Deep protocol knowledge required
        else:
            complexity = "Medium"

        # Required privileges
        if component == "consensus_layer":
            privileges = "High"    # Validator access needed
        elif component in ["smart_contracts", "rpc_interface"]:
            privileges = "Low"     # Public interfaces
        else:
            privileges = "Medium"

        # Exploit availability
        if confidence > 0.8:
            availability = "Proof-of-concept readily available"
        elif confidence > 0.6:
            availability = "Exploit development feasible"
        else:
            availability = "Significant research required"

        return {
            "complexity": complexity,
            "required_privileges": privileges,
            "exploit_availability": availability,
            "remote_exploitable": component in ["p2p_network", "rpc_interface", "smart_contracts"]
        }

    def _assess_business_impact(self, vuln: Dict) -> Dict:
        """Assess business impact of vulnerability."""
        component = vuln.get("component", "")
        category = vuln.get("category", "")
        severity = vuln.get("severity", "medium")

        # Financial impact
        if category == "economic" or "oracle" in vuln.get("name", "").lower():
            financial_impact = "Direct fund loss possible"
        elif component == "smart_contracts":
            financial_impact = "User fund exposure"
        elif component in ["consensus_layer", "vm_interpreter"]:
            financial_impact = "Network-wide economic disruption"
        else:
            financial_impact = "Indirect financial impact"

        # Operational impact
        if component in ["consensus_layer", "p2p_network"]:
            operational_impact = "Network disruption/downtime"
        elif component == "vm_interpreter":
            operational_impact = "Transaction processing failure"
        else:
            operational_impact = "Service degradation"

        # Reputation impact
        reputation_impact = {
            "critical": "Severe long-term reputation damage",
            "high": "Significant short-term reputation impact",
            "medium": "Moderate reputation concerns"
        }.get(severity, "Limited reputation impact")

        # Recovery complexity
        if component in ["consensus_layer", "vm_interpreter"]:
            recovery = "Complex network upgrade required"
        elif component == "smart_contracts":
            recovery = "Contract redeployment needed"
        else:
            recovery = "Standard patching process"

        return {
            "financial_impact": financial_impact,
            "operational_impact": operational_impact,
            "reputation_impact": reputation_impact,
            "recovery_complexity": recovery
        }

    def _determine_priority_rank(self, risk_score: float, exploitability: Dict, business_impact: Dict) -> int:
        """Determine overall priority ranking (higher = more urgent)."""
        rank = int(risk_score * 10)  # Base ranking from risk score

        # Exploitability adjustments
        if exploitability["complexity"] == "Low":
            rank += 20
        elif exploitability["complexity"] == "Medium":
            rank += 10

        if exploitability["required_privileges"] == "Low":
            rank += 15

        if exploitability["remote_exploitable"]:
            rank += 25

        # Business impact adjustments
        if "Direct fund loss" in business_impact["financial_impact"]:
            rank += 30

        if "Network disruption" in business_impact["operational_impact"]:
            rank += 20

        return rank

    def generate_immediate_action_plan(self, top_n: int = 10) -> List[Dict]:
        """Generate immediate action plan for top vulnerabilities."""
        print(f"🚨 Generating Immediate Action Plan for Top {top_n} Vulnerabilities...")

        prioritized_vulns = self.prioritize_vulnerabilities()
        top_vulns = prioritized_vulns[:top_n]

        action_plan = []

        for i, vuln in enumerate(top_vulns, 1):
            action_item = {
                "priority": i,
                "vulnerability": {
                    "name": vuln.get("name", "Unknown"),
                    "component": vuln.get("component", "unknown"),
                    "file": vuln.get("file", ""),
                    "line": vuln.get("line", ""),
                    "risk_score": vuln.get("risk_score", 0)
                },
                "immediate_actions": self._generate_immediate_actions(vuln),
                "timeline": self._determine_timeline(vuln),
                "assigned_team": self._determine_assigned_team(vuln),
                "success_criteria": self._define_success_criteria(vuln),
                "testing_requirements": self._define_testing_requirements(vuln)
            }

            action_plan.append(action_item)

        return action_plan

    def _generate_immediate_actions(self, vuln: Dict) -> List[str]:
        """Generate specific immediate actions for vulnerability."""
        component = vuln.get("component", "")
        category = vuln.get("category", "")
        vuln_name = vuln.get("name", "")

        actions = []

        # Component-specific actions
        if component == "p2p_network":
            actions.extend([
                "Implement network traffic monitoring for anomalous patterns",
                "Deploy temporary rate limiting on peer connections",
                "Review and harden message parsing code",
                "Add input validation for all network messages"
            ])

        elif component == "smart_contracts":
            actions.extend([
                "Pause affected smart contract functions if possible",
                "Deploy monitoring for unusual transaction patterns",
                "Implement emergency circuit breakers",
                "Review and test contract upgrade mechanisms"
            ])

        elif component in ["consensus_layer", "vm_interpreter"]:
            actions.extend([
                "Coordinate with major validators immediately",
                "Prepare emergency network upgrade if needed",
                "Implement additional consensus validation checks",
                "Monitor for any consensus attack attempts"
            ])

        elif component == "rpc_interface":
            actions.extend([
                "Implement stricter RPC rate limiting",
                "Add additional input validation",
                "Deploy API monitoring and alerting",
                "Review authentication mechanisms"
            ])

        # Category-specific actions
        if "oracle" in vuln_name.lower():
            actions.extend([
                "Implement multi-oracle price feeds immediately",
                "Add price deviation monitoring and alerts",
                "Deploy emergency price feed circuit breakers",
                "Coordinate with oracle service providers"
            ])

        if "random" in vuln_name.lower():
            actions.extend([
                "Replace weak RNG with cryptographically secure version",
                "Audit all usages of random number generation",
                "Implement entropy source validation",
                "Test randomness quality with statistical tests"
            ])

        # General security actions
        actions.extend([
            "Document the vulnerability and create tracking ticket",
            "Notify relevant team members and stakeholders",
            "Begin development of comprehensive fix",
            "Prepare communication plan for stakeholders"
        ])

        return actions

    def _determine_timeline(self, vuln: Dict) -> Dict:
        """Determine remediation timeline based on severity and complexity."""
        severity = vuln.get("severity", "medium")
        component = vuln.get("component", "")
        risk_score = vuln.get("risk_score", 0)

        if severity == "critical" or risk_score > 12:
            return {
                "immediate": "0-24 hours",
                "short_term": "1-3 days",
                "complete_fix": "1 week",
                "verification": "2 weeks"
            }
        elif severity == "high" or risk_score > 8:
            return {
                "immediate": "0-48 hours",
                "short_term": "3-7 days",
                "complete_fix": "2 weeks",
                "verification": "1 month"
            }
        else:
            return {
                "immediate": "0-72 hours",
                "short_term": "1-2 weeks",
                "complete_fix": "1 month",
                "verification": "6 weeks"
            }

    def _determine_assigned_team(self, vuln: Dict) -> Dict:
        """Determine which teams should handle the vulnerability."""
        component = vuln.get("component", "")

        team_mapping = {
            "consensus_layer": {
                "primary": "Core Blockchain Team",
                "secondary": ["Security Team", "Validator Relations"],
                "escalation": "CTO/Technical Leadership"
            },
            "vm_interpreter": {
                "primary": "EVM/VM Team",
                "secondary": ["Core Blockchain Team", "Security Team"],
                "escalation": "CTO/Technical Leadership"
            },
            "p2p_network": {
                "primary": "Network/Infrastructure Team",
                "secondary": ["Security Team", "DevOps"],
                "escalation": "Infrastructure Lead"
            },
            "smart_contracts": {
                "primary": "Smart Contract Team",
                "secondary": ["Security Team", "DeFi Team"],
                "escalation": "Product/Security Lead"
            },
            "rpc_interface": {
                "primary": "API/Backend Team",
                "secondary": ["Security Team"],
                "escalation": "Backend Lead"
            }
        }

        return team_mapping.get(component, {
            "primary": "Security Team",
            "secondary": ["Development Team"],
            "escalation": "Security Lead"
        })

    def _define_success_criteria(self, vuln: Dict) -> List[str]:
        """Define success criteria for vulnerability remediation."""
        return [
            "Vulnerability no longer detectable by security scanning tools",
            "Proof-of-concept exploit no longer functional",
            "Security team sign-off on fix implementation",
            "Code review completed and approved",
            "Comprehensive testing completed (unit, integration, security)",
            "Monitoring deployed to prevent similar issues",
            "Documentation updated with security considerations"
        ]

    def _define_testing_requirements(self, vuln: Dict) -> List[str]:
        """Define testing requirements for vulnerability fix."""
        component = vuln.get("component", "")

        base_requirements = [
            "Unit tests covering the vulnerability scenario",
            "Integration tests with related components",
            "Security-focused penetration testing",
            "Regression testing to ensure no new issues introduced"
        ]

        if component == "smart_contracts":
            base_requirements.extend([
                "Formal verification of contract logic",
                "Gas usage optimization testing",
                "Multi-scenario transaction testing"
            ])
        elif component == "p2p_network":
            base_requirements.extend([
                "Network stress testing",
                "Malformed packet testing",
                "Performance impact assessment"
            ])
        elif component in ["consensus_layer", "vm_interpreter"]:
            base_requirements.extend([
                "Consensus algorithm validation",
                "Network upgrade testing",
                "Backward compatibility verification"
            ])

        return base_requirements

    def generate_technical_deep_dive(self, vuln: Dict) -> Dict:
        """Generate detailed technical analysis for a specific vulnerability."""
        return {
            "vulnerability_analysis": {
                "description": vuln.get("description", ""),
                "technical_details": self._extract_technical_details(vuln),
                "attack_vectors": self._identify_attack_vectors(vuln),
                "code_analysis": self._analyze_vulnerable_code(vuln)
            },
            "exploitation_analysis": {
                "exploitability_factors": self._analyze_exploitability_factors(vuln),
                "attack_scenarios": self._generate_attack_scenarios(vuln),
                "proof_of_concept": self._generate_poc_outline(vuln)
            },
            "impact_analysis": {
                "direct_impacts": self._analyze_direct_impacts(vuln),
                "cascading_effects": self._analyze_cascading_effects(vuln),
                "business_consequences": self._analyze_business_consequences(vuln)
            },
            "remediation_analysis": {
                "root_cause": self._identify_root_cause(vuln),
                "fix_strategies": self._identify_fix_strategies(vuln),
                "implementation_considerations": self._analyze_implementation_considerations(vuln)
            }
        }

    def _extract_technical_details(self, vuln: Dict) -> Dict:
        """Extract detailed technical information about vulnerability."""
        return {
            "location": {
                "file": vuln.get("file", ""),
                "line": vuln.get("line", ""),
                "function": "Analysis pending - requires code review",
                "component": vuln.get("component", "")
            },
            "vulnerability_type": vuln.get("category", ""),
            "pattern_matched": vuln.get("match", ""),
            "code_snippet": vuln.get("code_snippet", ""),
            "confidence_level": vuln.get("confidence", 0),
            "detection_method": "Static analysis pattern matching"
        }

    def _identify_attack_vectors(self, vuln: Dict) -> List[str]:
        """Identify possible attack vectors for vulnerability."""
        component = vuln.get("component", "")
        category = vuln.get("category", "")

        vectors = []

        if component == "p2p_network":
            vectors.extend([
                "Malformed network messages",
                "Resource exhaustion attacks",
                "Protocol-level DoS",
                "Network partition attacks"
            ])

        if component == "smart_contracts":
            vectors.extend([
                "Malicious transaction crafting",
                "Contract interaction manipulation",
                "Economic attack exploitation",
                "Cross-contract call abuse"
            ])

        if "oracle" in vuln.get("name", "").lower():
            vectors.extend([
                "Price feed manipulation",
                "Oracle data corruption",
                "Flash loan price attacks",
                "MEV extraction"
            ])

        return vectors

    def _analyze_vulnerable_code(self, vuln: Dict) -> Dict:
        """Analyze the vulnerable code pattern."""
        code_snippet = vuln.get("code_snippet", "")
        match = vuln.get("match", "")

        return {
            "vulnerable_pattern": match,
            "code_context": code_snippet,
            "potential_issues": [
                "Input validation missing",
                "Boundary checks absent",
                "Error handling insufficient",
                "Security controls bypassed"
            ],
            "code_quality_concerns": [
                "Unsafe operations detected",
                "Security assumptions violated",
                "Best practices not followed"
            ]
        }

    # Additional analysis methods (simplified for brevity)
    def _analyze_exploitability_factors(self, vuln: Dict) -> Dict:
        return {"complexity": "Medium", "reliability": "High", "stealth": "Medium"}

    def _generate_attack_scenarios(self, vuln: Dict) -> List[str]:
        return ["Scenario 1: Direct exploitation", "Scenario 2: Chained attack", "Scenario 3: Advanced persistent threat"]

    def _generate_poc_outline(self, vuln: Dict) -> Dict:
        return {"approach": "Static analysis based", "tools_needed": ["Custom scripts"], "estimated_effort": "1-2 days"}

    def _analyze_direct_impacts(self, vuln: Dict) -> List[str]:
        return ["Security control bypass", "Data exposure", "Service disruption"]

    def _analyze_cascading_effects(self, vuln: Dict) -> List[str]:
        return ["Network instability", "User confidence loss", "Regulatory scrutiny"]

    def _analyze_business_consequences(self, vuln: Dict) -> List[str]:
        return ["Financial losses", "Reputation damage", "Market confidence impact"]

    def _identify_root_cause(self, vuln: Dict) -> str:
        return "Insufficient input validation and security controls"

    def _identify_fix_strategies(self, vuln: Dict) -> List[str]:
        return ["Input validation", "Error handling", "Security controls", "Code review"]

    def _analyze_implementation_considerations(self, vuln: Dict) -> List[str]:
        return ["Backward compatibility", "Performance impact", "Testing requirements"]

    def generate_comprehensive_review(self) -> Dict:
        """Generate comprehensive review of all high-priority vulnerabilities."""
        print("📋 Generating Comprehensive High-Priority Vulnerability Review...")

        # Extract and analyze vulnerabilities
        self.extract_high_priority_vulnerabilities()
        patterns = self.analyze_vulnerability_patterns()
        prioritized_vulns = self.prioritize_vulnerabilities()
        action_plan = self.generate_immediate_action_plan(10)

        # Top 5 most critical vulnerabilities for detailed analysis
        top_critical = prioritized_vulns[:5]
        detailed_analyses = []

        for vuln in top_critical:
            detailed_analysis = self.generate_technical_deep_dive(vuln)
            detailed_analyses.append({
                "vulnerability": vuln,
                "detailed_analysis": detailed_analysis
            })

        review_results = {
            "metadata": {
                "review_date": datetime.now().isoformat(),
                "total_high_priority_vulns": len(self.high_priority_vulns),
                "reviewer": "VulnHunter AI High-Priority Reviewer",
                "report_source": str(self.report_path)
            },
            "executive_summary": {
                "critical_findings": len([v for v in self.high_priority_vulns if v.get("severity") == "critical"]),
                "high_severity_findings": len([v for v in self.high_priority_vulns if v.get("severity") == "high"]),
                "most_affected_component": patterns["by_component"].most_common(1)[0] if patterns["by_component"] else ("unknown", 0),
                "top_vulnerability_category": patterns["by_category"].most_common(1)[0] if patterns["by_category"] else ("unknown", 0),
                "immediate_action_required": len(action_plan),
                "unique_files_affected": len(patterns["unique_files_affected"])
            },
            "vulnerability_patterns": {
                "by_component": dict(patterns["by_component"]),
                "by_category": dict(patterns["by_category"]),
                "by_file_type": dict(patterns["by_file_type"]),
                "exploitability_distribution": dict(patterns["exploitability_distribution"]),
                "critical_components_affected": list(patterns["critical_components_affected"])
            },
            "immediate_action_plan": action_plan,
            "detailed_vulnerability_analyses": detailed_analyses,
            "risk_assessment": {
                "overall_risk_level": self._calculate_overall_risk_level(prioritized_vulns),
                "business_impact_assessment": self._calculate_business_impact_level(prioritized_vulns),
                "remediation_complexity": self._assess_remediation_complexity(prioritized_vulns)
            },
            "recommendations": {
                "immediate_priorities": self._generate_immediate_priorities(),
                "resource_allocation": self._recommend_resource_allocation(patterns),
                "timeline_recommendations": self._generate_timeline_recommendations()
            }
        }

        return review_results

    def _calculate_overall_risk_level(self, prioritized_vulns: List[Dict]) -> str:
        """Calculate overall risk level based on vulnerability portfolio."""
        if not prioritized_vulns:
            return "LOW"

        avg_risk_score = sum(v.get("risk_score", 0) for v in prioritized_vulns) / len(prioritized_vulns)

        if avg_risk_score > 10:
            return "CRITICAL"
        elif avg_risk_score > 7:
            return "HIGH"
        elif avg_risk_score > 4:
            return "MEDIUM"
        else:
            return "LOW"

    def _calculate_business_impact_level(self, prioritized_vulns: List[Dict]) -> str:
        """Calculate business impact level."""
        critical_components = sum(1 for v in prioritized_vulns
                                if v.get("component") in ["consensus_layer", "vm_interpreter", "evm_implementation"])

        economic_vulns = sum(1 for v in prioritized_vulns
                           if v.get("category") == "economic")

        if critical_components > 5 or economic_vulns > 10:
            return "SEVERE"
        elif critical_components > 2 or economic_vulns > 5:
            return "HIGH"
        else:
            return "MODERATE"

    def _assess_remediation_complexity(self, prioritized_vulns: List[Dict]) -> str:
        """Assess overall remediation complexity."""
        consensus_vulns = sum(1 for v in prioritized_vulns if v.get("component") == "consensus_layer")
        vm_vulns = sum(1 for v in prioritized_vulns if v.get("component") == "vm_interpreter")

        if consensus_vulns > 0 or vm_vulns > 0:
            return "VERY HIGH - Core protocol changes required"
        elif len(prioritized_vulns) > 50:
            return "HIGH - Extensive code changes needed"
        else:
            return "MEDIUM - Standard security patching"

    def _generate_immediate_priorities(self) -> List[str]:
        """Generate immediate priority recommendations."""
        return [
            "Address all P2P network input validation issues within 48 hours",
            "Implement emergency monitoring for oracle price manipulation",
            "Deploy circuit breakers for high-risk smart contract functions",
            "Coordinate with validators for potential emergency network measures",
            "Establish 24/7 security monitoring and incident response",
            "Prepare public communication strategy for vulnerability disclosure"
        ]

    def _recommend_resource_allocation(self, patterns: Dict) -> Dict:
        """Recommend resource allocation based on vulnerability patterns."""
        return {
            "security_team": "Immediate scale-up required - 3x current capacity",
            "development_teams": {
                "p2p_network": "2-3 senior developers, 1-2 weeks full-time",
                "smart_contracts": "2-3 smart contract experts, 2-3 weeks",
                "consensus_layer": "1-2 consensus experts, ongoing support",
                "general": "All teams need security training immediately"
            },
            "external_resources": [
                "Emergency security audit firm engagement",
                "Smart contract formal verification specialists",
                "Network security penetration testing team"
            ]
        }

    def _generate_timeline_recommendations(self) -> Dict:
        """Generate timeline recommendations."""
        return {
            "immediate": "0-48 hours - Critical P2P and oracle vulnerabilities",
            "short_term": "1-2 weeks - High-severity smart contract issues",
            "medium_term": "2-4 weeks - Comprehensive security overhaul",
            "long_term": "1-3 months - Security architecture improvements",
            "ongoing": "Continuous security monitoring and improvement"
        }

    def save_review_results(self, output_path: str = None) -> str:
        """Save comprehensive review results."""
        if not output_path:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            output_path = f"/Users/ankitthakur/vuln_ml_research/data/results/oort_high_priority_review_{timestamp}.json"

        review_results = self.generate_comprehensive_review()

        with open(output_path, 'w') as f:
            json.dump(review_results, f, indent=2, default=str)

        print(f"📄 High-priority vulnerability review saved to: {output_path}")
        return output_path

def main():
    """Main execution function."""
    if len(sys.argv) != 2:
        print("Usage: python high_priority_vulnerability_reviewer.py <security_report.json>")
        sys.exit(1)

    report_path = sys.argv[1]

    print("🔍 VulnHunter AI - High-Priority Vulnerability Reviewer")
    print("=" * 60)

    reviewer = HighPriorityVulnerabilityReviewer(report_path)
    output_path = reviewer.save_review_results()

    # Generate summary
    review_results = reviewer.generate_comprehensive_review()

    print(f"\n📊 High-Priority Vulnerability Review Summary:")
    print(f"Total High-Priority Vulnerabilities: {review_results['metadata']['total_high_priority_vulns']}")
    print(f"Critical Findings: {review_results['executive_summary']['critical_findings']}")
    print(f"High Severity Findings: {review_results['executive_summary']['high_severity_findings']}")
    print(f"Immediate Actions Required: {review_results['executive_summary']['immediate_action_required']}")
    print(f"Overall Risk Level: {review_results['risk_assessment']['overall_risk_level']}")

    print(f"\n🎯 Top Immediate Priorities:")
    for i, priority in enumerate(review_results['recommendations']['immediate_priorities'][:3], 1):
        print(f"  {i}. {priority}")

if __name__ == "__main__":
    main()