
#!/usr/bin/env python3
"""
OPTIMIZED VULNERABILITY PREDICTOR
Fixed feature names and improved predictions
"""

import joblib
import pandas as pd
import numpy as np
import re

class OptimizedVulnPredictor:
    """Optimized predictor with proper feature handling."""
    
    def __init__(self, model_dir="."):
        self.model_dir = model_dir
        self.load_optimized_models()
    
    def load_optimized_models(self):
        """Load optimized models with proper feature handling."""
        try:
            self.severity_model = joblib.load(f"{self.model_dir}/optimized_severity_model.pkl")
            self.scaler = joblib.load(f"{self.model_dir}/optimized_scaler.pkl")
            self.feature_names = joblib.load(f"{self.model_dir}/optimized_features.pkl")
            print("âœ… Optimized ML models loaded successfully!")
            self.ml_loaded = True
        except Exception as e:
            print(f"âš ï¸ Optimized models not available: {e}")
            self.ml_loaded = False
        
        # Fallback to original models
        try:
            self.fallback_model = joblib.load(f"{self.model_dir}/proper_severity_model.pkl")
            self.fallback_loaded = True
        except:
            self.fallback_loaded = False
    
    def extract_optimized_features(self, description):
        """Extract features that match the training data structure."""
        features = {}
        desc_lower = description.lower()
        
        # Basic features
        features['desc_length'] = len(description)
        features['word_count'] = len(description.split())
        
        # Security keyword features
        security_terms = {
            'rce': ['remote code execution', 'arbitrary code', 'execute commands'],
            'sqli': ['sql injection', 'sqli'],
            'xss': ['cross site scripting', 'xss'],
            'buffer_overflow': ['buffer overflow', 'stack overflow'],
            'privilege_escalation': ['privilege escalation', 'root access', 'gain privileges'],
            'dos': ['denial of service', 'dos', 'crash']
        }
        
        for feature, terms in security_terms.items():
            features[f'has_{feature}'] = 1 if any(term in desc_lower for term in terms) else 0
        
        # Count security keywords
        features['security_keyword_count'] = sum(
            features.get(f'has_{feature}', 0) for feature in security_terms.keys()
        )
        
        # Source features (default to 0)
        for source in ['NVD', 'AppThreat', 'HackerOne', 'PentesterLand']:
            features[f'source_{source}'] = 0
        
        # CVSS and severity estimation
        features['cve_score'] = self.estimate_cvss(description)
        features['severity_numeric'] = self.estimate_severity(description)
        
        return features
    
    def estimate_cvss(self, description):
        """Estimate CVSS score with improved logic."""
        desc_lower = description.lower()
        score = 5.0  # Base
        
        # High impact indicators
        high_impact_terms = [
            'remote code execution', 'arbitrary code execution', 'root access',
            'privilege escalation', 'gain privileges', 'administrator access'
        ]
        
        medium_impact_terms = [
            'code execution', 'execute commands', 'buffer overflow',
            'denial of service', 'information disclosure'
        ]
        
        # Check for high impact terms
        high_impact_count = sum(1 for term in high_impact_terms if term in desc_lower)
        medium_impact_count = sum(1 for term in medium_impact_terms if term in desc_lower)
        
        if high_impact_count >= 2:
            score += 4.0
        elif high_impact_count >= 1:
            score += 3.0
        elif medium_impact_count >= 2:
            score += 2.0
        elif medium_impact_count >= 1:
            score += 1.0
        
        # Additional bonuses
        if 'remote' in desc_lower and any(term in desc_lower for term in ['code execution', 'arbitrary code']):
            score += 1.0
        
        return min(max(score, 1.0), 10.0)
    
    def estimate_severity(self, description):
        """Convert CVSS to severity with better thresholds."""
        cvss = self.estimate_cvss(description)
        if cvss >= 9.0: return 4
        elif cvss >= 7.0: return 3
        elif cvss >= 5.0: return 2
        else: return 1
    
    def create_feature_dataframe(self, features):
        """Create a properly structured DataFrame for prediction."""
        # Ensure all expected features are present
        feature_dict = {}
        for feature_name in self.feature_names:
            feature_dict[feature_name] = features.get(feature_name, 0)
        
        return pd.DataFrame([feature_dict])
    
    def predict(self, description):
        """Optimized prediction with proper feature handling."""
        if not self.ml_loaded:
            return self.fallback_predict(description)
        
        try:
            # Extract features
            features = self.extract_optimized_features(description)
            
            # Create properly structured DataFrame
            X = self.create_feature_dataframe(features)
            
            # Scale features
            X_scaled = self.scaler.transform(X)
            
            # Predict
            prediction = self.severity_model.predict(X_scaled)[0]
            confidence = self.severity_model.predict_proba(X_scaled)[0][1]
            
            # Post-process to be less conservative
            adjusted_confidence = self.adjust_confidence(confidence, features)
            final_prediction = 1 if adjusted_confidence >= 0.3 else 0  # Lower threshold
            
            return {
                'severity': 'High/Critical' if final_prediction == 1 else 'Low/Medium',
                'confidence': float(adjusted_confidence),
                'raw_confidence': float(confidence),
                'estimated_cvss': features.get('cve_score', 0),
                'risk_level': self.get_risk_level(adjusted_confidence, final_prediction),
                'method': 'Optimized ML Model',
                'feature_count': len(features),
                'high_impact_indicators': self.count_high_impact_indicators(description)
            }
            
        except Exception as e:
            print(f"Prediction error: {e}")
            return self.fallback_predict(description)
    
    def adjust_confidence(self, confidence, features):
        """Adjust confidence based on high-impact indicators."""
        adjusted = confidence
        
        # Boost confidence for high-impact features
        if features.get('has_rce', 0):
            adjusted += 0.2
        if features.get('has_privilege_escalation', 0):
            adjusted += 0.15
        if features.get('has_buffer_overflow', 0):
            adjusted += 0.1
        
        # Boost for high CVSS scores
        if features.get('cve_score', 0) >= 8.0:
            adjusted += 0.2
        elif features.get('cve_score', 0) >= 6.0:
            adjusted += 0.1
        
        return min(adjusted, 1.0)
    
    def count_high_impact_indicators(self, description):
        """Count high-impact security indicators."""
        desc_lower = description.lower()
        indicators = []
        
        high_impact_terms = {
            'Remote Code Execution': ['remote code execution', 'arbitrary code execution'],
            'Privilege Escalation': ['privilege escalation', 'root access', 'gain privileges'],
            'Buffer Overflow': ['buffer overflow', 'stack overflow'],
            'SQL Injection': ['sql injection', 'sqli'],
            'Command Execution': ['execute commands', 'command execution']
        }
        
        for indicator, terms in high_impact_terms.items():
            if any(term in desc_lower for term in terms):
                indicators.append(indicator)
        
        return indicators
    
    def get_risk_level(self, confidence, prediction):
        """Calculate risk level with better thresholds."""
        if prediction == 1 and confidence >= 0.6:
            return 'CRITICAL'
        elif prediction == 1:
            return 'HIGH'
        elif confidence >= 0.5:
            return 'MEDIUM'
        else:
            return 'LOW'
    
    def fallback_predict(self, description):
        """Fallback prediction using rule-based approach."""
        features = self.extract_optimized_features(description)
        
        # Simple rule-based approach
        score = 0
        if features.get('cve_score', 0) >= 7.0:
            score += 1
        if features.get('has_rce', 0) or features.get('has_privilege_escalation', 0):
            score += 1
        if features.get('security_keyword_count', 0) >= 2:
            score += 1
        
        confidence = score / 3
        prediction = 1 if confidence >= 0.5 else 0
        
        return {
            'severity': 'High/Critical' if prediction == 1 else 'Low/Medium',
            'confidence': float(confidence),
            'estimated_cvss': features.get('cve_score', 0),
            'risk_level': self.get_risk_level(confidence, prediction),
            'method': 'Rule-Based Fallback',
            'feature_count': len(features),
            'high_impact_indicators': self.count_high_impact_indicators(description)
        }

# Factory function for easy integration
def create_predictor(model_path="."):
    """Create and return an optimized predictor instance."""
    return OptimizedVulnPredictor(model_path)

if __name__ == "__main__":
    # Test the optimized predictor
    predictor = OptimizedVulnPredictor()
    
    test_cases = [
        "Remote code execution vulnerability allowing arbitrary code execution with high impact",
        "Cross-site scripting in login form with limited impact",
        "Buffer overflow in network service leading to denial of service and potential code execution",
        "Privilege escalation vulnerability allowing local users to gain root access",
        "SQL injection in user login form exposing database credentials"
    ]
    
    print("ðŸ”’ OPTIMIZED PREDICTOR TEST")
    print("=" * 60)
    
    for i, desc in enumerate(test_cases, 1):
        result = predictor.predict(desc)
        print(f"\n{i}. {desc[:70]}...")
        print(f"   ðŸ”¥ Severity: {result['severity']}")
        print(f"   ðŸŽ¯ Confidence: {result['confidence']:.2f} (raw: {result['raw_confidence']:.2f})")
        print(f"   âš¡ Risk: {result['risk_level']}")
        print(f"   ðŸ¤– Method: {result['method']}")
        print(f"   ðŸ“Š CVSS: {result['estimated_cvss']:.1f}")
        if result['high_impact_indicators']:
            print(f"   ðŸš¨ Indicators: {', '.join(result['high_impact_indicators'])}")
