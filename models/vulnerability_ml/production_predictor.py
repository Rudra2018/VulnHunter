
#!/usr/bin/env python3
"""
UNIFIED VULNERABILITY PREDICTOR
Combines Rule-Based System + ML Models for Production Use
"""

import joblib
import pandas as pd
import numpy as np
import json
import re

class ProductionVulnPredictor:
    """Production-ready vulnerability predictor for integration."""
    
    def __init__(self, model_dir="."):
        self.model_dir = model_dir
        self.load_all_models()
    
    def load_all_models(self):
        """Load all available models."""
        self.models_loaded = {}
        
        try:
            # Try to load proper ML models first
            self.severity_model = joblib.load(f"{self.model_dir}/proper_severity_model.pkl")
            self.scaler = joblib.load(f"{self.model_dir}/proper_scaler.pkl")
            self.feature_columns = joblib.load(f"{self.model_dir}/feature_columns.pkl")
            self.models_loaded['ml'] = True
            print("âœ… Proper ML models loaded")
        except:
            print("âš ï¸ Proper ML models not available")
            self.models_loaded['ml'] = False
        
        try:
            # Load bounty model
            self.bounty_model = joblib.load(f"{self.model_dir}/bounty_model.pkl")
            self.models_loaded['bounty'] = True
            print("âœ… Bounty model loaded")
        except:
            print("âš ï¸ Bounty model not available")
            self.models_loaded['bounty'] = False
        
        try:
            # Load rules
            with open(f"{self.model_dir}/predictor_config.json", 'r') as f:
                self.rules_config = json.load(f)
            self.models_loaded['rules'] = True
            print("âœ… Rule system loaded")
        except:
            print("âš ï¸ Rules config not available")
            self.models_loaded['rules'] = False
    
    def extract_features(self, description):
        """Extract features from vulnerability description."""
        features = {}
        desc_lower = description.lower()
        
        # Basic text features
        features['desc_length'] = len(description)
        features['word_count'] = len(description.split())
        
        # Security keywords
        security_keywords = {
            'rce': ['remote code execution', 'arbitrary code', 'execute commands'],
            'sqli': ['sql injection', 'sqli'],
            'xss': ['cross site scripting', 'xss'],
            'buffer_overflow': ['buffer overflow', 'stack overflow'],
            'privilege_escalation': ['privilege escalation', 'root access', 'gain privileges'],
            'dos': ['denial of service', 'dos', 'crash']
        }
        
        for feature, terms in security_keywords.items():
            features[f'has_{feature}'] = 1 if any(term in desc_lower for term in terms) else 0
        
        # Count security keywords
        features['security_keyword_count'] = sum(
            features.get(f'has_{feature}', 0) for feature in security_keywords.keys()
        )
        
        # CVSS estimation
        features['cve_score'] = self.estimate_cvss(description)
        features['severity_numeric'] = self.estimate_severity(description)
        
        return features
    
    def estimate_cvss(self, description):
        """Estimate CVSS score from description."""
        desc_lower = description.lower()
        score = 5.0
        
        if any(kw in desc_lower for kw in ['remote code execution', 'arbitrary code']):
            score += 3.0
        elif any(kw in desc_lower for kw in ['code execution', 'execute commands']):
            score += 2.0
            
        if any(kw in desc_lower for kw in ['privilege escalation', 'root access']):
            score += 2.5
            
        if 'buffer overflow' in desc_lower:
            score += 2.0
            
        return min(score, 10.0)
    
    def estimate_severity(self, description):
        """Convert CVSS to severity numeric."""
        cvss = self.estimate_cvss(description)
        if cvss >= 9.0: return 4
        elif cvss >= 7.0: return 3
        elif cvss >= 4.0: return 2
        else: return 1
    
    def predict_severity(self, description):
        """Predict vulnerability severity."""
        features = self.extract_features(description)
        
        # Try ML prediction first
        if self.models_loaded.get('ml'):
            try:
                # Create feature vector for ML model
                feature_vector = []
                for col in self.feature_columns:
                    feature_vector.append(features.get(col, 0))
                
                # Scale and predict
                feature_vector_scaled = self.scaler.transform([feature_vector])
                ml_prediction = self.severity_model.predict(feature_vector_scaled)[0]
                ml_confidence = self.severity_model.predict_proba(feature_vector_scaled)[0][1]
                
                return {
                    'severity': 'High/Critical' if ml_prediction == 1 else 'Low/Medium',
                    'confidence': float(ml_confidence),
                    'method': 'ML Model',
                    'estimated_cvss': features.get('cve_score', 0)
                }
            except Exception as e:
                print(f"ML prediction failed: {e}")
        
        # Fallback to rule-based system
        if self.models_loaded.get('rules'):
            score = 0
            max_score = 3
            
            if features.get('cve_score', 0) >= 7.0:
                score += 1
                
            critical_keywords = features.get('has_rce', 0) + features.get('has_privilege_escalation', 0) + features.get('has_buffer_overflow', 0)
            if critical_keywords >= 1:
                score += 1
                
            if features.get('desc_length', 0) >= 82:
                score += 1
                
            confidence = score / max_score
            prediction = 1 if confidence >= 0.6 else 0
            
            return {
                'severity': 'High/Critical' if prediction == 1 else 'Low/Medium',
                'confidence': float(confidence),
                'method': 'Rule-Based System',
                'estimated_cvss': features.get('cve_score', 0)
            }
        
        # Final fallback
        return {
            'severity': 'Unknown',
            'confidence': 0.0,
            'method': 'Fallback',
            'estimated_cvss': features.get('cve_score', 0)
        }
    
    def predict_bounty(self, description):
        """Predict potential bounty amount."""
        if not self.models_loaded.get('bounty'):
            return {'bounty': 0, 'confidence': 0.0}
        
        features = self.extract_features(description)
        
        # Simple bounty estimation based on severity
        severity_result = self.predict_severity(description)
        base_bounty = 1000 if severity_result['severity'] == 'High/Critical' else 100
        
        # Adjust based on features
        if features.get('has_rce', 0):
            base_bounty *= 2
        if features.get('has_privilege_escalation', 0):
            base_bounty *= 1.5
            
        return {
            'bounty': int(base_bounty),
            'confidence': severity_result['confidence'],
            'currency': 'USD'
        }
    
    def predict(self, description):
        """Complete vulnerability assessment."""
        severity_result = self.predict_severity(description)
        bounty_result = self.predict_bounty(description)
        
        return {
            'description': description,
            'severity': severity_result['severity'],
            'severity_confidence': severity_result['confidence'],
            'prediction_method': severity_result['method'],
            'estimated_cvss': severity_result['estimated_cvss'],
            'estimated_bounty': bounty_result['bounty'],
            'bounty_currency': bounty_result['currency'],
            'bounty_confidence': bounty_result['confidence'],
            'risk_level': self.get_risk_level(severity_result['confidence'], severity_result['severity'])
        }
    
    def get_risk_level(self, confidence, severity):
        """Calculate risk level."""
        if severity == 'High/Critical' and confidence >= 0.7:
            return 'CRITICAL'
        elif severity == 'High/Critical':
            return 'HIGH'
        elif severity == 'Low/Medium' and confidence >= 0.7:
            return 'MEDIUM'
        else:
            return 'LOW'

# Example usage for integration
def create_predictor():
    """Factory function for easy integration."""
    return ProductionVulnPredictor()

if __name__ == "__main__":
    # Test the predictor
    predictor = ProductionVulnPredictor()
    
    test_cases = [
        "Remote code execution vulnerability in web server",
        "Cross-site scripting in login form",
        "Buffer overflow leading to denial of service"
    ]
    
    print("ğŸ”’ PRODUCTION PREDICTOR TEST")
    print("=" * 50)
    
    for desc in test_cases:
        result = predictor.predict(desc)
        print(f"\nğŸ“: {desc}")
        print(f"   ğŸ”¥ Severity: {result['severity']} (Confidence: {result['severity_confidence']:.2f})")
        print(f"   ğŸ’° Bounty: {result['estimated_bounty']} {result['bounty_currency']}")
        print(f"   ğŸ¯ Method: {result['prediction_method']}")
        print(f"   âš¡ Risk: {result['risk_level']}")
