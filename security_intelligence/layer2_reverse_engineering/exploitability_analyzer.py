"""
Exploitability Analysis Engine

This module provides advanced exploitability analysis capabilities including:
- Constraint solving for path exploration
- Taint analysis for input propagation tracking
- Exploit chain construction and validation
- ASLR/DEP/Stack Canary bypass analysis
"""

import numpy as np
import torch
import torch.nn as nn
from typing import Dict, List, Tuple, Optional, Any, Set, Union
from dataclasses import dataclass, field
from enum import Enum
import logging
from pathlib import Path
import json
import hashlib
from collections import defaultdict, deque
import re
import struct

try:
    import angr
    import claripy
    import pyvex
    ANGR_AVAILABLE = True
except ImportError:
    ANGR_AVAILABLE = False
    logging.warning("Angr not available. Advanced exploitability analysis will be limited.")

class ExploitType(Enum):
    """Types of exploits"""
    BUFFER_OVERFLOW = "buffer_overflow"
    USE_AFTER_FREE = "use_after_free"
    FORMAT_STRING = "format_string"
    INTEGER_OVERFLOW = "integer_overflow"
    RACE_CONDITION = "race_condition"
    PRIVILEGE_ESCALATION = "privilege_escalation"
    CODE_INJECTION = "code_injection"
    RETURN_ORIENTED_PROGRAMMING = "rop"
    JUMP_ORIENTED_PROGRAMMING = "jop"

class ExploitDifficulty(Enum):
    """Exploit difficulty levels"""
    TRIVIAL = "trivial"
    EASY = "easy"
    MODERATE = "moderate"
    HARD = "hard"
    EXPERT = "expert"

class Mitigation(Enum):
    """Security mitigations"""
    ASLR = "aslr"
    DEP_NX = "dep_nx"
    STACK_CANARY = "stack_canary"
    FORTIFY_SOURCE = "fortify_source"
    PIE = "pie"
    RELRO = "relro"
    CFI = "cfi"
    CET = "cet"

@dataclass
class TaintSource:
    """Represents a taint source (user input)"""
    source_id: str
    location: str
    input_type: str
    size_limit: Optional[int]
    validation_present: bool
    metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass
class TaintSink:
    """Represents a taint sink (dangerous function)"""
    sink_id: str
    location: str
    function_name: str
    parameter_index: int
    vulnerability_type: str
    severity: str
    metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass
class TaintPath:
    """Represents a taint propagation path"""
    path_id: str
    source: TaintSource
    sink: TaintSink
    path_length: int
    transformations: List[str]
    constraints: List[str]
    exploitable: bool
    confidence: float

@dataclass
class ExploitChain:
    """Represents a complete exploit chain"""
    chain_id: str
    exploit_type: ExploitType
    target_function: str
    entry_point: str
    taint_paths: List[TaintPath]
    required_conditions: List[str]
    bypass_techniques: List[str]
    payload_constraints: Dict[str, Any]
    success_probability: float
    difficulty: ExploitDifficulty

@dataclass
class ExploitabilityResult:
    """Result of exploitability analysis"""
    target_path: str
    exploitable: bool
    exploit_chains: List[ExploitChain]
    active_mitigations: List[Mitigation]
    bypass_possibilities: Dict[Mitigation, float]
    overall_exploitability_score: float
    recommended_exploits: List[ExploitType]
    analysis_metadata: Dict[str, Any]

class ConstraintSolver:
    """Advanced constraint solving for path exploration"""

    def __init__(self):
        self.solver_timeout = 30
        self.max_path_length = 1000
        self.constraint_cache = {}

    def solve_path_constraints(self, constraints: List[str], target_condition: str) -> Optional[Dict[str, Any]]:
        """Solve path constraints to reach target condition"""
        if not ANGR_AVAILABLE:
            return self._basic_constraint_solving(constraints, target_condition)

        try:
            solver = claripy.Solver()

            symbolic_vars = {}
            for i, constraint in enumerate(constraints):
                var_name = f"input_{i}"
                symbolic_vars[var_name] = claripy.BVS(var_name, 64)

                parsed_constraint = self._parse_constraint(constraint, symbolic_vars)
                if parsed_constraint is not None:
                    solver.add(parsed_constraint)

            target_parsed = self._parse_constraint(target_condition, symbolic_vars)
            if target_parsed is not None:
                solver.add(target_parsed)

            if solver.satisfiable():
                solution = {}
                for var_name, var in symbolic_vars.items():
                    try:
                        solution[var_name] = solver.eval(var, 1)[0]
                    except:
                        solution[var_name] = 0
                return solution
            else:
                return None

        except Exception as e:
            logging.error(f"Constraint solving failed: {e}")
            return None

    def _basic_constraint_solving(self, constraints: List[str], target_condition: str) -> Optional[Dict[str, Any]]:
        """Basic constraint solving without Angr"""
        try:
            solution = {}

            for i, constraint in enumerate(constraints):
                if 'input' in constraint and '=' in constraint:
                    parts = constraint.split('=')
                    if len(parts) == 2:
                        var_part = parts[0].strip()
                        value_part = parts[1].strip()

                        if var_part.startswith('input'):
                            try:
                                solution[var_part] = int(value_part)
                            except ValueError:
                                solution[var_part] = 0

            return solution if solution else None

        except Exception as e:
            logging.error(f"Basic constraint solving failed: {e}")
            return None

    def _parse_constraint(self, constraint: str, symbolic_vars: Dict[str, Any]) -> Optional[Any]:
        """Parse constraint string into symbolic expression"""
        try:
            if not ANGR_AVAILABLE:
                return None

            constraint = constraint.strip()

            for var_name in symbolic_vars:
                constraint = constraint.replace(var_name, f"symbolic_vars['{var_name}']")

            if '>' in constraint:
                left, right = constraint.split('>', 1)
                left_expr = eval(left.strip(), {"symbolic_vars": symbolic_vars, "claripy": claripy})
                right_expr = eval(right.strip(), {"symbolic_vars": symbolic_vars, "claripy": claripy})
                return left_expr > right_expr

            elif '<' in constraint:
                left, right = constraint.split('<', 1)
                left_expr = eval(left.strip(), {"symbolic_vars": symbolic_vars, "claripy": claripy})
                right_expr = eval(right.strip(), {"symbolic_vars": symbolic_vars, "claripy": claripy})
                return left_expr < right_expr

            elif '==' in constraint:
                left, right = constraint.split('==', 1)
                left_expr = eval(left.strip(), {"symbolic_vars": symbolic_vars, "claripy": claripy})
                right_expr = eval(right.strip(), {"symbolic_vars": symbolic_vars, "claripy": claripy})
                return left_expr == right_expr

            return None

        except Exception as e:
            logging.debug(f"Failed to parse constraint '{constraint}': {e}")
            return None

class TaintAnalyzer:
    """Advanced taint analysis for input propagation tracking"""

    def __init__(self):
        self.taint_sources = []
        self.taint_sinks = []
        self.taint_paths = []
        self.dangerous_functions = {
            'strcpy', 'sprintf', 'gets', 'scanf', 'strcat',
            'memcpy', 'memmove', 'system', 'exec', 'eval'
        }

    def identify_taint_sources(self, binary_path: str) -> List[TaintSource]:
        """Identify potential taint sources in binary"""
        sources = []

        if ANGR_AVAILABLE:
            sources.extend(self._angr_identify_sources(binary_path))
        else:
            sources.extend(self._basic_identify_sources(binary_path))

        self.taint_sources = sources
        return sources

    def identify_taint_sinks(self, binary_path: str) -> List[TaintSink]:
        """Identify potential taint sinks in binary"""
        sinks = []

        if ANGR_AVAILABLE:
            sinks.extend(self._angr_identify_sinks(binary_path))
        else:
            sinks.extend(self._basic_identify_sinks(binary_path))

        self.taint_sinks = sinks
        return sinks

    def _angr_identify_sources(self, binary_path: str) -> List[TaintSource]:
        """Use Angr to identify taint sources"""
        sources = []

        try:
            project = angr.Project(binary_path, auto_load_libs=False)

            for func_addr in project.kb.functions:
                func = project.kb.functions[func_addr]

                if any(input_func in func.name for input_func in ['read', 'recv', 'scanf', 'gets', 'fgets']):
                    source = TaintSource(
                        source_id=f"source_{func_addr:x}",
                        location=f"0x{func_addr:x}",
                        input_type="user_input",
                        size_limit=None,
                        validation_present=False,
                        metadata={"function_name": func.name}
                    )
                    sources.append(source)

        except Exception as e:
            logging.error(f"Angr source identification failed: {e}")

        return sources

    def _basic_identify_sources(self, binary_path: str) -> List[TaintSource]:
        """Basic taint source identification"""
        sources = []

        try:
            with open(binary_path, 'rb') as f:
                content = f.read()

            input_functions = [b'read', b'recv', b'scanf', b'gets', b'fgets']

            for i, func_name in enumerate(input_functions):
                if func_name in content:
                    source = TaintSource(
                        source_id=f"basic_source_{i}",
                        location="unknown",
                        input_type="user_input",
                        size_limit=None,
                        validation_present=False,
                        metadata={"function_name": func_name.decode()}
                    )
                    sources.append(source)

        except Exception as e:
            logging.error(f"Basic source identification failed: {e}")

        return sources

    def _angr_identify_sinks(self, binary_path: str) -> List[TaintSink]:
        """Use Angr to identify taint sinks"""
        sinks = []

        try:
            project = angr.Project(binary_path, auto_load_libs=False)

            for func_addr in project.kb.functions:
                func = project.kb.functions[func_addr]

                for dangerous_func in self.dangerous_functions:
                    if dangerous_func in func.name:
                        sink = TaintSink(
                            sink_id=f"sink_{func_addr:x}",
                            location=f"0x{func_addr:x}",
                            function_name=func.name,
                            parameter_index=0,
                            vulnerability_type=self._get_vuln_type(dangerous_func),
                            severity="high",
                            metadata={"address": func_addr}
                        )
                        sinks.append(sink)

        except Exception as e:
            logging.error(f"Angr sink identification failed: {e}")

        return sinks

    def _basic_identify_sinks(self, binary_path: str) -> List[TaintSink]:
        """Basic taint sink identification"""
        sinks = []

        try:
            with open(binary_path, 'rb') as f:
                content = f.read()

            for i, func_name in enumerate(self.dangerous_functions):
                func_bytes = func_name.encode()
                if func_bytes in content:
                    sink = TaintSink(
                        sink_id=f"basic_sink_{i}",
                        location="unknown",
                        function_name=func_name,
                        parameter_index=0,
                        vulnerability_type=self._get_vuln_type(func_name),
                        severity="high",
                        metadata={"detected_bytes": func_bytes}
                    )
                    sinks.append(sink)

        except Exception as e:
            logging.error(f"Basic sink identification failed: {e}")

        return sinks

    def _get_vuln_type(self, function_name: str) -> str:
        """Get vulnerability type for function"""
        vuln_mapping = {
            'strcpy': 'buffer_overflow',
            'sprintf': 'buffer_overflow',
            'gets': 'buffer_overflow',
            'scanf': 'buffer_overflow',
            'strcat': 'buffer_overflow',
            'memcpy': 'buffer_overflow',
            'system': 'command_injection',
            'exec': 'command_injection',
            'eval': 'code_injection'
        }
        return vuln_mapping.get(function_name, 'unknown')

    def trace_taint_propagation(self, binary_path: str) -> List[TaintPath]:
        """Trace taint propagation from sources to sinks"""
        paths = []

        sources = self.identify_taint_sources(binary_path)
        sinks = self.identify_taint_sinks(binary_path)

        for source in sources:
            for sink in sinks:
                path = self._find_taint_path(source, sink, binary_path)
                if path:
                    paths.append(path)

        self.taint_paths = paths
        return paths

    def _find_taint_path(self, source: TaintSource, sink: TaintSink, binary_path: str) -> Optional[TaintPath]:
        """Find taint propagation path between source and sink"""
        try:
            path = TaintPath(
                path_id=f"{source.source_id}_{sink.sink_id}",
                source=source,
                sink=sink,
                path_length=1,
                transformations=["direct"],
                constraints=["reachable"],
                exploitable=True,
                confidence=0.7
            )

            if source.input_type == "user_input" and sink.vulnerability_type in ["buffer_overflow", "command_injection"]:
                path.exploitable = True
                path.confidence = 0.8
            else:
                path.exploitable = False
                path.confidence = 0.5

            return path

        except Exception as e:
            logging.error(f"Taint path finding failed: {e}")
            return None

class MitigationBypassAnalyzer:
    """Analyzes security mitigations and bypass possibilities"""

    def __init__(self):
        self.mitigation_detectors = {
            Mitigation.ASLR: self._detect_aslr,
            Mitigation.DEP_NX: self._detect_dep_nx,
            Mitigation.STACK_CANARY: self._detect_stack_canary,
            Mitigation.PIE: self._detect_pie,
            Mitigation.RELRO: self._detect_relro,
            Mitigation.FORTIFY_SOURCE: self._detect_fortify_source
        }

        self.bypass_analyzers = {
            Mitigation.ASLR: self._analyze_aslr_bypass,
            Mitigation.DEP_NX: self._analyze_dep_bypass,
            Mitigation.STACK_CANARY: self._analyze_canary_bypass,
            Mitigation.PIE: self._analyze_pie_bypass,
            Mitigation.RELRO: self._analyze_relro_bypass
        }

    def detect_active_mitigations(self, binary_path: str) -> List[Mitigation]:
        """Detect active security mitigations"""
        active_mitigations = []

        for mitigation, detector in self.mitigation_detectors.items():
            try:
                if detector(binary_path):
                    active_mitigations.append(mitigation)
            except Exception as e:
                logging.warning(f"Failed to detect {mitigation.value}: {e}")

        return active_mitigations

    def analyze_bypass_possibilities(self, binary_path: str,
                                   active_mitigations: List[Mitigation]) -> Dict[Mitigation, float]:
        """Analyze bypass possibilities for active mitigations"""
        bypass_scores = {}

        for mitigation in active_mitigations:
            if mitigation in self.bypass_analyzers:
                try:
                    score = self.bypass_analyzers[mitigation](binary_path)
                    bypass_scores[mitigation] = score
                except Exception as e:
                    logging.warning(f"Failed to analyze bypass for {mitigation.value}: {e}")
                    bypass_scores[mitigation] = 0.0

        return bypass_scores

    def _detect_aslr(self, binary_path: str) -> bool:
        """Detect ASLR support"""
        try:
            with open(binary_path, 'rb') as f:
                header = f.read(64)

            if header[:4] == b'\x7fELF':
                f.seek(16)
                e_type = struct.unpack('<H', f.read(2))[0]
                return e_type == 3
            elif header[:2] == b'MZ':
                return True

            return False
        except:
            return False

    def _detect_dep_nx(self, binary_path: str) -> bool:
        """Detect DEP/NX bit"""
        try:
            with open(binary_path, 'rb') as f:
                content = f.read(1024)

            return b'GNU_STACK' in content or b'NX' in content
        except:
            return False

    def _detect_stack_canary(self, binary_path: str) -> bool:
        """Detect stack canaries"""
        try:
            with open(binary_path, 'rb') as f:
                content = f.read()

            canary_indicators = [b'__stack_chk_fail', b'__stack_chk_guard', b'stack_canary']
            return any(indicator in content for indicator in canary_indicators)
        except:
            return False

    def _detect_pie(self, binary_path: str) -> bool:
        """Detect Position Independent Executable"""
        try:
            with open(binary_path, 'rb') as f:
                header = f.read(64)

            if header[:4] == b'\x7fELF':
                f.seek(16)
                e_type = struct.unpack('<H', f.read(2))[0]
                return e_type == 3

            return False
        except:
            return False

    def _detect_relro(self, binary_path: str) -> bool:
        """Detect RELRO (RELocation Read-Only)"""
        try:
            with open(binary_path, 'rb') as f:
                content = f.read(2048)

            return b'GNU_RELRO' in content
        except:
            return False

    def _detect_fortify_source(self, binary_path: str) -> bool:
        """Detect FORTIFY_SOURCE"""
        try:
            with open(binary_path, 'rb') as f:
                content = f.read()

            fortify_functions = [b'__strcpy_chk', b'__sprintf_chk', b'__memcpy_chk']
            return any(func in content for func in fortify_functions)
        except:
            return False

    def _analyze_aslr_bypass(self, binary_path: str) -> float:
        """Analyze ASLR bypass possibilities"""
        bypass_score = 0.0

        try:
            with open(binary_path, 'rb') as f:
                content = f.read()

            if b'format' in content or b'printf' in content:
                bypass_score += 0.3

            if b'read' in content and b'write' in content:
                bypass_score += 0.2

            if b'/proc/self/maps' in content:
                bypass_score += 0.4

            return min(bypass_score, 1.0)
        except:
            return 0.0

    def _analyze_dep_bypass(self, binary_path: str) -> float:
        """Analyze DEP bypass possibilities"""
        bypass_score = 0.0

        try:
            with open(binary_path, 'rb') as f:
                content = f.read()

            rop_gadgets = [b'pop', b'ret', b'jmp', b'call']
            gadget_count = sum(1 for gadget in rop_gadgets if gadget in content)
            bypass_score += min(gadget_count * 0.1, 0.5)

            if b'mprotect' in content or b'VirtualProtect' in content:
                bypass_score += 0.4

            return min(bypass_score, 1.0)
        except:
            return 0.0

    def _analyze_canary_bypass(self, binary_path: str) -> float:
        """Analyze stack canary bypass possibilities"""
        bypass_score = 0.0

        try:
            with open(binary_path, 'rb') as f:
                content = f.read()

            if b'format' in content or b'printf' in content:
                bypass_score += 0.4

            if b'fork' in content:
                bypass_score += 0.3

            if any(func in content for func in [b'gets', b'strcpy', b'sprintf']):
                bypass_score += 0.2

            return min(bypass_score, 1.0)
        except:
            return 0.0

    def _analyze_pie_bypass(self, binary_path: str) -> float:
        """Analyze PIE bypass possibilities"""
        return self._analyze_aslr_bypass(binary_path) * 0.8

    def _analyze_relro_bypass(self, binary_path: str) -> float:
        """Analyze RELRO bypass possibilities"""
        bypass_score = 0.0

        try:
            with open(binary_path, 'rb') as f:
                content = f.read()

            if b'dlopen' in content or b'dlsym' in content:
                bypass_score += 0.3

            if b'LD_PRELOAD' in content:
                bypass_score += 0.4

            return min(bypass_score, 1.0)
        except:
            return 0.0

class ExploitabilityAnalyzer:
    """Main exploitability analysis engine"""

    def __init__(self):
        self.constraint_solver = ConstraintSolver()
        self.taint_analyzer = TaintAnalyzer()
        self.mitigation_analyzer = MitigationBypassAnalyzer()
        self.exploit_patterns = self._load_exploit_patterns()

    def _load_exploit_patterns(self) -> Dict[ExploitType, Dict[str, Any]]:
        """Load exploit patterns and techniques"""
        return {
            ExploitType.BUFFER_OVERFLOW: {
                'required_conditions': ['vulnerable_function', 'controllable_input', 'no_bounds_check'],
                'bypass_techniques': ['rop_chain', 'ret2libc', 'shellcode_injection'],
                'difficulty_factors': ['aslr', 'dep', 'stack_canary', 'fortify_source']
            },
            ExploitType.USE_AFTER_FREE: {
                'required_conditions': ['free_call', 'use_after_free', 'heap_manipulation'],
                'bypass_techniques': ['heap_feng_shui', 'fake_object', 'vtable_hijack'],
                'difficulty_factors': ['heap_protections', 'cfi', 'aslr']
            },
            ExploitType.FORMAT_STRING: {
                'required_conditions': ['format_function', 'user_controlled_format'],
                'bypass_techniques': ['arbitrary_write', 'return_address_overwrite', 'got_overwrite'],
                'difficulty_factors': ['fortify_source', 'aslr', 'relro']
            }
        }

    def analyze_exploitability(self, binary_path: str, analysis_depth: str = "standard") -> ExploitabilityResult:
        """Comprehensive exploitability analysis"""
        logging.info(f"Starting exploitability analysis for {binary_path}")

        active_mitigations = self.mitigation_analyzer.detect_active_mitigations(binary_path)
        bypass_possibilities = self.mitigation_analyzer.analyze_bypass_possibilities(binary_path, active_mitigations)

        taint_paths = self.taint_analyzer.trace_taint_propagation(binary_path)

        exploit_chains = self._construct_exploit_chains(binary_path, taint_paths, active_mitigations)

        exploitability_score = self._calculate_exploitability_score(exploit_chains, bypass_possibilities)

        recommended_exploits = self._recommend_exploit_types(exploit_chains, active_mitigations)

        result = ExploitabilityResult(
            target_path=binary_path,
            exploitable=exploitability_score > 0.3,
            exploit_chains=exploit_chains,
            active_mitigations=active_mitigations,
            bypass_possibilities=bypass_possibilities,
            overall_exploitability_score=exploitability_score,
            recommended_exploits=recommended_exploits,
            analysis_metadata={
                'analysis_depth': analysis_depth,
                'taint_paths_found': len(taint_paths),
                'mitigations_detected': len(active_mitigations)
            }
        )

        logging.info(f"Exploitability analysis complete. Score: {exploitability_score:.3f}")
        return result

    def _construct_exploit_chains(self, binary_path: str, taint_paths: List[TaintPath],
                                active_mitigations: List[Mitigation]) -> List[ExploitChain]:
        """Construct potential exploit chains"""
        exploit_chains = []

        for path in taint_paths:
            if not path.exploitable:
                continue

            vuln_type = self._determine_exploit_type(path.sink.vulnerability_type)
            if vuln_type not in self.exploit_patterns:
                continue

            pattern = self.exploit_patterns[vuln_type]

            chain = ExploitChain(
                chain_id=f"chain_{len(exploit_chains)}",
                exploit_type=vuln_type,
                target_function=path.sink.function_name,
                entry_point=path.source.location,
                taint_paths=[path],
                required_conditions=pattern['required_conditions'],
                bypass_techniques=self._select_bypass_techniques(pattern, active_mitigations),
                payload_constraints=self._analyze_payload_constraints(path),
                success_probability=self._estimate_success_probability(path, active_mitigations),
                difficulty=self._assess_exploit_difficulty(pattern, active_mitigations)
            )

            exploit_chains.append(chain)

        return exploit_chains

    def _determine_exploit_type(self, vuln_type: str) -> ExploitType:
        """Determine exploit type from vulnerability type"""
        mapping = {
            'buffer_overflow': ExploitType.BUFFER_OVERFLOW,
            'use_after_free': ExploitType.USE_AFTER_FREE,
            'format_string': ExploitType.FORMAT_STRING,
            'integer_overflow': ExploitType.INTEGER_OVERFLOW,
            'command_injection': ExploitType.CODE_INJECTION
        }
        return mapping.get(vuln_type, ExploitType.BUFFER_OVERFLOW)

    def _select_bypass_techniques(self, pattern: Dict[str, Any],
                                active_mitigations: List[Mitigation]) -> List[str]:
        """Select appropriate bypass techniques"""
        techniques = []

        available_techniques = pattern['bypass_techniques']

        if Mitigation.DEP_NX in active_mitigations:
            if 'rop_chain' in available_techniques:
                techniques.append('rop_chain')
            elif 'ret2libc' in available_techniques:
                techniques.append('ret2libc')

        if Mitigation.ASLR in active_mitigations:
            techniques.append('information_leak')

        if Mitigation.STACK_CANARY in active_mitigations:
            techniques.append('canary_bypass')

        if not techniques:
            techniques = available_techniques[:1]

        return techniques

    def _analyze_payload_constraints(self, path: TaintPath) -> Dict[str, Any]:
        """Analyze payload constraints for exploit"""
        constraints = {
            'max_size': 1024,
            'bad_chars': [0x00, 0x0a, 0x0d],
            'encoding_required': False,
            'alignment': 1
        }

        if 'size_limit' in path.source.metadata:
            constraints['max_size'] = path.source.metadata['size_limit']

        if path.sink.function_name in ['strcpy', 'sprintf']:
            constraints['bad_chars'].extend([0x20])

        return constraints

    def _estimate_success_probability(self, path: TaintPath,
                                    active_mitigations: List[Mitigation]) -> float:
        """Estimate exploit success probability"""
        base_probability = path.confidence

        mitigation_penalty = len(active_mitigations) * 0.1
        final_probability = max(base_probability - mitigation_penalty, 0.1)

        return min(final_probability, 1.0)

    def _assess_exploit_difficulty(self, pattern: Dict[str, Any],
                                 active_mitigations: List[Mitigation]) -> ExploitDifficulty:
        """Assess exploit difficulty"""
        difficulty_score = 0

        for mitigation in active_mitigations:
            if mitigation.value in pattern['difficulty_factors']:
                difficulty_score += 1

        if difficulty_score == 0:
            return ExploitDifficulty.TRIVIAL
        elif difficulty_score <= 1:
            return ExploitDifficulty.EASY
        elif difficulty_score <= 2:
            return ExploitDifficulty.MODERATE
        elif difficulty_score <= 3:
            return ExploitDifficulty.HARD
        else:
            return ExploitDifficulty.EXPERT

    def _calculate_exploitability_score(self, exploit_chains: List[ExploitChain],
                                      bypass_possibilities: Dict[Mitigation, float]) -> float:
        """Calculate overall exploitability score"""
        if not exploit_chains:
            return 0.0

        chain_scores = [chain.success_probability for chain in exploit_chains]
        max_chain_score = max(chain_scores)

        bypass_factor = 1.0
        if bypass_possibilities:
            avg_bypass = sum(bypass_possibilities.values()) / len(bypass_possibilities)
            bypass_factor = avg_bypass

        return min(max_chain_score * bypass_factor, 1.0)

    def _recommend_exploit_types(self, exploit_chains: List[ExploitChain],
                               active_mitigations: List[Mitigation]) -> List[ExploitType]:
        """Recommend best exploit types"""
        if not exploit_chains:
            return []

        chain_scores = [(chain.exploit_type, chain.success_probability) for chain in exploit_chains]
        chain_scores.sort(key=lambda x: x[1], reverse=True)

        return [exploit_type for exploit_type, _ in chain_scores[:3]]

    def generate_exploitability_report(self, result: ExploitabilityResult) -> str:
        """Generate comprehensive exploitability report"""
        report = []
        report.append("Exploitability Analysis Report")
        report.append("=" * 40)
        report.append(f"Target: {result.target_path}")
        report.append(f"Exploitable: {'Yes' if result.exploitable else 'No'}")
        report.append(f"Overall Score: {result.overall_exploitability_score:.3f}")
        report.append("")

        if result.active_mitigations:
            report.append("Active Security Mitigations:")
            for mitigation in result.active_mitigations:
                bypass_score = result.bypass_possibilities.get(mitigation, 0.0)
                report.append(f"• {mitigation.value} (Bypass Probability: {bypass_score:.2f})")
            report.append("")

        if result.exploit_chains:
            report.append("Potential Exploit Chains:")
            for chain in result.exploit_chains:
                report.append(f"• {chain.exploit_type.value}")
                report.append(f"  Target Function: {chain.target_function}")
                report.append(f"  Success Probability: {chain.success_probability:.2f}")
                report.append(f"  Difficulty: {chain.difficulty.value}")
                report.append(f"  Bypass Techniques: {', '.join(chain.bypass_techniques)}")
                report.append("")

        if result.recommended_exploits:
            report.append("Recommended Exploit Types:")
            for exploit_type in result.recommended_exploits:
                report.append(f"• {exploit_type.value}")

        return "\n".join(report)