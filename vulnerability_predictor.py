#!/usr/bin/env python3
"""
ML-Powered Vulnerability Predictor
Uses trained ensemble models to predict vulnerability likelihood
"""

import joblib
import json
import pandas as pd
import re
from pathlib import Path

class VulnerabilityPredictor:
    """
    Predict vulnerability likelihood using trained ML models
    """

    def __init__(self, model_dir='.'):
        self.model_dir = Path(model_dir)

        # Load models
        print("Loading trained models...")
        self.rf_model = joblib.load(self.model_dir / 'model_random_forest.joblib')
        self.xgb_model = joblib.load(self.model_dir / 'model_xgboost.joblib')
        self.nn_model = joblib.load(self.model_dir / 'model_neural_network.joblib')
        self.svm_model = joblib.load(self.model_dir / 'model_svm.joblib')
        self.scaler = joblib.load(self.model_dir / 'scaler.joblib')

        # Load feature names
        with open(self.model_dir / 'model_features.json', 'r') as f:
            self.feature_names = json.load(f)

        print(f"‚úì Loaded 4 models with {len(self.feature_names)} features")

    def extract_features(self, code, file_path="unknown", context="", language="Unknown"):
        """
        Extract features from code snippet
        """
        features = {}

        # Basic features
        features['confidence'] = 0.8  # Default confidence
        features['code_length'] = len(code)
        features['has_exec'] = int(bool(re.search(r'exec|eval', code, re.I)))
        features['has_sql'] = int(bool(re.search(r'select|insert|update|delete', code, re.I)))
        features['has_memcpy'] = int(bool(re.search(r'memcpy|strcpy|sprintf', code, re.I)))
        features['has_password'] = int(bool(re.search(r'password|secret|key', code, re.I)))
        features['has_verify_false'] = int(bool(re.search(r'verify.*false|ssl.*false', code, re.I)))

        # File features
        features['is_test_file'] = int(bool(re.search(r'test|spec|example', file_path, re.I)))
        features['is_config_file'] = int(bool(re.search(r'config|settings', file_path, re.I)))

        # Context features
        features['context_length'] = len(context)
        features['context_has_bounds_check'] = int(bool(re.search(r'if.*<|if.*>|assert|check', context, re.I)))

        # Severity (default MEDIUM)
        features['severity_encoded'] = 1

        # Language one-hot encoding
        for lang in ['C/C++', 'Go', 'JavaScript', 'Python']:
            features[f'lang_{lang}'] = int(language == lang)

        # Category one-hot encoding (default all False, will detect from patterns)
        categories = [
            'Buffer Overflow', 'Command Injection', 'Hardcoded Credentials',
            'Information Disclosure', 'Insecure Data Transmission',
            'Integer Overflow', 'Path Traversal', 'Private Key Exposure',
            'Race Condition', 'SQL Injection', 'Use After Free',
            'Weak Cryptography', 'XXE Vulnerability'
        ]

        for cat in categories:
            features[f'cat_{cat}'] = 0

        # Detect likely category
        if features['has_memcpy']:
            features['cat_Buffer Overflow'] = 1
        if features['has_exec']:
            features['cat_Command Injection'] = 1
        if features['has_sql']:
            features['cat_SQL Injection'] = 1
        if features['has_password']:
            features['cat_Hardcoded Credentials'] = 1
        if features['has_verify_false']:
            features['cat_Insecure Data Transmission'] = 1

        return features

    def predict(self, code, file_path="unknown", context="", language="Unknown"):
        """
        Predict vulnerability using ensemble
        """
        # Extract features
        features = self.extract_features(code, file_path, context, language)

        # Create DataFrame with correct column order
        feature_df = pd.DataFrame([features])

        # Ensure all expected features exist
        for feat in self.feature_names:
            if feat not in feature_df.columns:
                feature_df[feat] = 0

        # Reorder columns to match training
        feature_df = feature_df[self.feature_names]

        # Get predictions from all models
        rf_prob = self.rf_model.predict_proba(feature_df)[0][1]
        xgb_prob = self.xgb_model.predict_proba(feature_df)[0][1]

        # Scale for NN and SVM
        feature_scaled = self.scaler.transform(feature_df)
        nn_prob = self.nn_model.predict_proba(feature_scaled)[0][1]
        svm_prob = self.svm_model.predict_proba(feature_scaled)[0][1]

        # Ensemble (weighted average)
        ensemble_prob = (
            0.3 * rf_prob +
            0.3 * xgb_prob +
            0.2 * nn_prob +
            0.2 * svm_prob
        )

        is_vulnerable = ensemble_prob >= 0.5

        return {
            'is_vulnerable': bool(is_vulnerable),
            'confidence': float(ensemble_prob),
            'model_predictions': {
                'random_forest': float(rf_prob),
                'xgboost': float(xgb_prob),
                'neural_network': float(nn_prob),
                'svm': float(svm_prob),
                'ensemble': float(ensemble_prob)
            },
            'risk_level': self.get_risk_level(ensemble_prob)
        }

    def get_risk_level(self, prob):
        """Get risk level from probability"""
        if prob >= 0.9:
            return "CRITICAL"
        elif prob >= 0.7:
            return "HIGH"
        elif prob >= 0.5:
            return "MEDIUM"
        elif prob >= 0.3:
            return "LOW"
        else:
            return "SAFE"

def demo():
    """Demo the predictor with examples"""
    print("="*80)
    print("ML-Powered Vulnerability Predictor Demo")
    print("="*80)

    predictor = VulnerabilityPredictor()

    # Test cases
    test_cases = [
        {
            'name': 'Buffer Overflow (strcpy)',
            'code': 'strcpy(dest, source);',
            'file_path': 'src/utils.c',
            'context': 'char dest[10]; strcpy(dest, source);',
            'language': 'C/C++'
        },
        {
            'name': 'SQL Injection',
            'code': 'query = "SELECT * FROM users WHERE id = " + user_id',
            'file_path': 'app/database.py',
            'context': 'cursor.execute(query)',
            'language': 'Python'
        },
        {
            'name': 'Command Injection',
            'code': 'exec(user_input)',
            'file_path': 'lib/processor.js',
            'context': 'const result = exec(user_input);',
            'language': 'JavaScript'
        },
        {
            'name': 'Safe Code',
            'code': 'result = calculate_sum(a, b)',
            'file_path': 'math/operations.py',
            'context': 'def calculate_sum(a, b): return a + b',
            'language': 'Python'
        },
        {
            'name': 'Hardcoded Password',
            'code': 'password = "SecretPass123"',
            'file_path': 'config/settings.py',
            'context': 'DATABASE_PASSWORD = "SecretPass123"',
            'language': 'Python'
        }
    ]

    print(f"\n{'='*80}")
    print("Testing Vulnerability Detection")
    print(f"{'='*80}\n")

    for test in test_cases:
        print(f"üìù Test: {test['name']}")
        print(f"   Code: {test['code']}")
        print(f"   File: {test['file_path']}")
        print(f"   Language: {test['language']}")

        result = predictor.predict(
            test['code'],
            test['file_path'],
            test['context'],
            test['language']
        )

        vuln_icon = "üî¥" if result['is_vulnerable'] else "‚úÖ"
        print(f"\n   {vuln_icon} Prediction: {'VULNERABLE' if result['is_vulnerable'] else 'SAFE'}")
        print(f"   üìä Confidence: {result['confidence']*100:.1f}%")
        print(f"   ‚ö†Ô∏è  Risk Level: {result['risk_level']}")
        print(f"\n   Model Breakdown:")
        for model, prob in result['model_predictions'].items():
            if model != 'ensemble':
                print(f"     - {model}: {prob*100:.1f}%")
        print(f"\n{'-'*80}\n")

    print(f"\n{'='*80}")
    print("‚úÖ Demo Complete!")
    print(f"{'='*80}")

if __name__ == '__main__':
    demo()
