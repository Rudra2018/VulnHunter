#!/usr/bin/env python3
"""
Core vulnerability data structures for VulnHunter Professional
"""

from enum import Enum
from dataclasses import dataclass, field
from typing import Dict, List, Any, Optional
from datetime import datetime
import uuid


class VulnSeverity(Enum):
    """Vulnerability severity levels following CVSS standards"""
    NONE = "none"
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class VulnType(Enum):
    """Comprehensive vulnerability classification"""
    # Injection Attacks
    SQL_INJECTION = "sql_injection"
    COMMAND_INJECTION = "command_injection"
    LDAP_INJECTION = "ldap_injection"
    XPATH_INJECTION = "xpath_injection"
    NOSQL_INJECTION = "nosql_injection"

    # Cross-Site Scripting
    REFLECTED_XSS = "reflected_xss"
    STORED_XSS = "stored_xss"
    DOM_XSS = "dom_xss"

    # Memory Corruption
    BUFFER_OVERFLOW = "buffer_overflow"
    HEAP_OVERFLOW = "heap_overflow"
    STACK_OVERFLOW = "stack_overflow"
    USE_AFTER_FREE = "use_after_free"
    DOUBLE_FREE = "double_free"

    # Authentication & Authorization
    BROKEN_AUTHENTICATION = "broken_authentication"
    PRIVILEGE_ESCALATION = "privilege_escalation"
    SESSION_FIXATION = "session_fixation"
    BROKEN_ACCESS_CONTROL = "broken_access_control"

    # Cryptographic Issues
    WEAK_CRYPTOGRAPHY = "weak_cryptography"
    HARDCODED_CREDENTIALS = "hardcoded_credentials"
    INSUFFICIENT_ENTROPY = "insufficient_entropy"

    # File/Path Security
    PATH_TRAVERSAL = "path_traversal"
    DIRECTORY_TRAVERSAL = "directory_traversal"
    FILE_INCLUSION = "file_inclusion"

    # Web Security
    CSRF = "csrf"
    SSRF = "ssrf"
    OPEN_REDIRECT = "open_redirect"

    # Data Security
    INFORMATION_DISCLOSURE = "information_disclosure"
    SENSITIVE_DATA_EXPOSURE = "sensitive_data_exposure"

    # XML Security
    XXE = "xxe"
    XML_BOMB = "xml_bomb"

    # Logic Flaws
    BUSINESS_LOGIC = "business_logic"
    INTEGER_OVERFLOW = "integer_overflow"
    RACE_CONDITION = "race_condition"
    TOCTOU = "toctou"

    # Deserialization
    UNSAFE_DESERIALIZATION = "unsafe_deserialization"

    # Mobile Security
    INSECURE_STORAGE = "insecure_storage"
    INSECURE_COMMUNICATION = "insecure_communication"

    # Cloud Security
    CLOUD_MISCONFIGURATION = "cloud_misconfiguration"

    # API Security
    API_ABUSE = "api_abuse"
    BROKEN_OBJECT_AUTHORIZATION = "broken_object_authorization"

    # Unknown/Other
    UNKNOWN = "unknown"


@dataclass
class Location:
    """Precise location information for vulnerabilities"""
    file_path: str
    line_number: int
    column_number: int = 0
    function_name: Optional[str] = None
    class_name: Optional[str] = None
    module_name: Optional[str] = None

    def __str__(self) -> str:
        return f"{self.file_path}:{self.line_number}"


@dataclass
class ProofOfConcept:
    """Proof of concept exploit information"""
    exploit_code: str
    description: str
    payload: Optional[str] = None
    steps: List[str] = field(default_factory=list)
    prerequisites: List[str] = field(default_factory=list)
    impact: str = ""


@dataclass
class MathematicalProof:
    """Mathematical proof of vulnerability existence or absence"""
    proof_type: str  # "formal", "symbolic", "topological"
    assertion: str
    proof_steps: List[str]
    verification_tool: str  # "z3", "coq", "lean"
    confidence: float


@dataclass
class Vulnerability:
    """Comprehensive vulnerability representation"""

    # Core identification
    vuln_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    vuln_type: VulnType = VulnType.UNKNOWN
    severity: VulnSeverity = VulnSeverity.NONE

    # Classification
    cwe_id: str = ""
    cve_id: Optional[str] = None
    cvss_score: float = 0.0

    # Location information
    location: Location = field(default_factory=lambda: Location("", 0))
    additional_locations: List[Location] = field(default_factory=list)

    # Description and analysis
    title: str = ""
    description: str = ""
    technical_details: str = ""
    root_cause: str = ""

    # Impact assessment
    impact: str = ""
    exploitability: str = ""
    business_impact: str = ""

    # Remediation
    remediation: str = ""
    fix_suggestions: List[str] = field(default_factory=list)
    secure_coding_practices: List[str] = field(default_factory=list)

    # Evidence and proofs
    proof_of_concept: Optional[ProofOfConcept] = None
    mathematical_proof: Optional[MathematicalProof] = None

    # Analysis metadata
    confidence: float = 0.0
    false_positive_probability: float = 0.0
    detection_method: str = ""
    analysis_engine: str = ""

    # Timestamps
    discovered_at: datetime = field(default_factory=datetime.utcnow)
    last_updated: datetime = field(default_factory=datetime.utcnow)

    # Additional metadata
    tags: List[str] = field(default_factory=list)
    references: List[str] = field(default_factory=list)
    custom_fields: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        """Convert vulnerability to dictionary for serialization"""
        return {
            'vuln_id': self.vuln_id,
            'vuln_type': self.vuln_type.value,
            'severity': self.severity.value,
            'cwe_id': self.cwe_id,
            'cve_id': self.cve_id,
            'cvss_score': self.cvss_score,
            'location': {
                'file_path': self.location.file_path,
                'line_number': self.location.line_number,
                'column_number': self.location.column_number,
                'function_name': self.location.function_name,
                'class_name': self.location.class_name,
                'module_name': self.location.module_name
            },
            'title': self.title,
            'description': self.description,
            'technical_details': self.technical_details,
            'impact': self.impact,
            'remediation': self.remediation,
            'confidence': self.confidence,
            'detection_method': self.detection_method,
            'discovered_at': self.discovered_at.isoformat(),
            'tags': self.tags,
            'references': self.references
        }

    def get_risk_score(self) -> float:
        """Calculate overall risk score based on severity, exploitability, and confidence"""
        severity_weights = {
            VulnSeverity.NONE: 0.0,
            VulnSeverity.LOW: 2.0,
            VulnSeverity.MEDIUM: 5.0,
            VulnSeverity.HIGH: 8.0,
            VulnSeverity.CRITICAL: 10.0
        }

        base_score = severity_weights.get(self.severity, 0.0)
        confidence_factor = max(0.1, self.confidence)  # Minimum 10% confidence
        false_positive_penalty = 1.0 - self.false_positive_probability

        return base_score * confidence_factor * false_positive_penalty